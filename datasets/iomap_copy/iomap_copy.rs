/* automatically generated by rust-bindgen 0.56.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const CONFIG_RING_BUFFER: u32 = 1;
pub const CONFIG_HAVE_ARCH_SECCOMP_FILTER: u32 = 1;
pub const CONFIG_SND_PROC_FS: u32 = 1;
pub const CONFIG_SCSI_DMA: u32 = 1;
pub const CONFIG_TCP_MD5SIG: u32 = 1;
pub const CONFIG_KERNEL_GZIP: u32 = 1;
pub const CONFIG_CC_HAS_SANCOV_TRACE_PC: u32 = 1;
pub const CONFIG_DEFAULT_INIT: &'static [u8; 1usize] = b"\0";
pub const CONFIG_MICROCODE: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_VM_PGTABLE: u32 = 1;
pub const CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK: u32 = 1;
pub const CONFIG_INPUT_KEYBOARD: u32 = 1;
pub const CONFIG_INET_TABLE_PERTURB_ORDER: u32 = 16;
pub const CONFIG_ARCH_SUPPORTS_INT128: u32 = 1;
pub const CONFIG_SLUB_CPU_PARTIAL: u32 = 1;
pub const CONFIG_RFS_ACCEL: u32 = 1;
pub const CONFIG_ARCH_WANTS_THP_SWAP: u32 = 1;
pub const CONFIG_CRC32: u32 = 1;
pub const CONFIG_I2C_BOARDINFO: u32 = 1;
pub const CONFIG_X86_MCE: u32 = 1;
pub const CONFIG_SECCOMP: u32 = 1;
pub const CONFIG_HIGH_RES_TIMERS: u32 = 1;
pub const CONFIG_ARCH_HAS_SET_MEMORY: u32 = 1;
pub const CONFIG_BLK_DEV_DM: u32 = 1;
pub const CONFIG_IP_MULTIPLE_TABLES: u32 = 1;
pub const CONFIG_ACPI_BGRT: u32 = 1;
pub const CONFIG_FIRMWARE_MEMMAP: u32 = 1;
pub const CONFIG_FIX_EARLYCON_MEM: u32 = 1;
pub const CONFIG_XZ_DEC_IA64: u32 = 1;
pub const CONFIG_INOTIFY_USER: u32 = 1;
pub const CONFIG_HDMI: u32 = 1;
pub const CONFIG_SAMPLES: u32 = 1;
pub const CONFIG_NETWORK_FILESYSTEMS: u32 = 1;
pub const CONFIG_MODULE_FORCE_UNLOAD: u32 = 1;
pub const CONFIG_X86_MINIMUM_CPU_FAMILY: u32 = 64;
pub const CONFIG_CPU_FREQ_GOV_ONDEMAND: u32 = 1;
pub const CONFIG_GLOB: u32 = 1;
pub const CONFIG_ARCH_WANT_LD_ORPHAN_WARN: u32 = 1;
pub const CONFIG_SND_INTEL_SOUNDWIRE_ACPI: u32 = 1;
pub const CONFIG_CGROUP_DEVICE: u32 = 1;
pub const CONFIG_X86_TSC: u32 = 1;
pub const CONFIG_ARCH_SUSPEND_POSSIBLE: u32 = 1;
pub const CONFIG_MAC80211_STA_HASH_MAX_SIZE: u32 = 0;
pub const CONFIG_HAVE_ARCH_MMAP_RND_BITS: u32 = 1;
pub const CONFIG_HIBERNATION: u32 = 1;
pub const CONFIG_PNPACPI: u32 = 1;
pub const CONFIG_KASAN_STACK: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_ATTR_SET: u32 = 1;
pub const CONFIG_EXT4_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_ZSTD_COMPRESS: u32 = 1;
pub const CONFIG_DRM_I915: u32 = 1;
pub const CONFIG_BINFMT_MISC: u32 = 1;
pub const CONFIG_SSB_POSSIBLE: u32 = 1;
pub const CONFIG_NF_NAT_SIP: u32 = 1;
pub const CONFIG_HAVE_OBJTOOL: u32 = 1;
pub const CONFIG_MMU_NOTIFIER: u32 = 1;
pub const CONFIG_ASYMMETRIC_KEY_TYPE: u32 = 1;
pub const CONFIG_ACPI_PRMT: u32 = 1;
pub const CONFIG_ARCH_CORRECT_STACKTRACE_ON_KRETPROBE: u32 = 1;
pub const CONFIG_IP_NF_NAT_MODULE: u32 = 1;
pub const CONFIG_USB_OHCI_LITTLE_ENDIAN: u32 = 1;
pub const CONFIG_NET_SCH_FIFO: u32 = 1;
pub const CONFIG_SWPHY: u32 = 1;
pub const CONFIG_FSNOTIFY: u32 = 1;
pub const CONFIG_BLK_DEV_LOOP_MIN_COUNT: u32 = 8;
pub const CONFIG_NF_CONNTRACK_SIP: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER_DISABLE_TESTS: u32 = 1;
pub const CONFIG_HIDRAW: u32 = 1;
pub const CONFIG_HAVE_KERNEL_LZMA: u32 = 1;
pub const CONFIG_NET_PTP_CLASSIFY: u32 = 1;
pub const CONFIG_GENERIC_SMP_IDLE_THREAD: u32 = 1;
pub const CONFIG_NET_VENDOR_QUALCOMM: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_NUMA_BALANCING: u32 = 1;
pub const CONFIG_DYNAMIC_DEBUG: u32 = 1;
pub const CONFIG_NET_VENDOR_EZCHIP: u32 = 1;
pub const CONFIG_LDISC_AUTOLOAD: u32 = 1;
pub const CONFIG_SERIAL_8250_RSA: u32 = 1;
pub const CONFIG_FIB_RULES: u32 = 1;
pub const CONFIG_USB_AUTOSUSPEND_DELAY: u32 = 2;
pub const CONFIG_IP6_NF_MANGLE: u32 = 1;
pub const CONFIG_SCSI_CONSTANTS: u32 = 1;
pub const CONFIG_HAVE_IRQ_TIME_ACCOUNTING: u32 = 1;
pub const CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED: u32 = 1;
pub const CONFIG_IPV6: u32 = 1;
pub const CONFIG_HAVE_STACKPROTECTOR: u32 = 1;
pub const CONFIG_NET_9P: u32 = 1;
pub const CONFIG_CRYPTO_AEAD: u32 = 1;
pub const CONFIG_AUDIT_ARCH: u32 = 1;
pub const CONFIG_COMPAT: u32 = 1;
pub const CONFIG_MAGIC_SYSRQ_SERIAL: u32 = 1;
pub const CONFIG_BQL: u32 = 1;
pub const CONFIG_HAVE_KERNEL_BZIP2: u32 = 1;
pub const CONFIG_DEFAULT_TCP_CONG: &'static [u8; 6usize] = b"cubic\0";
pub const CONFIG_DEVTMPFS: u32 = 1;
pub const CONFIG_X86_INTEL_TSX_MODE_OFF: u32 = 1;
pub const CONFIG_TIGON3_HWMON: u32 = 1;
pub const CONFIG_BLK_CGROUP_IOLATENCY: u32 = 1;
pub const CONFIG_HSU_DMA: u32 = 1;
pub const CONFIG_YENTA_RICOH: u32 = 1;
pub const CONFIG_MOUSE_PS2_SMBUS: u32 = 1;
pub const CONFIG_IP6_NF_TARGET_REJECT: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX: u32 = 16;
pub const CONFIG_UPROBES: u32 = 1;
pub const CONFIG_ARCH_SPARSEMEM_ENABLE: u32 = 1;
pub const CONFIG_SAMPLE_TRACE_CUSTOM_EVENTS_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_CPU: u32 = 1;
pub const CONFIG_PM_SLEEP_DEBUG: u32 = 1;
pub const CONFIG_WLAN: u32 = 1;
pub const CONFIG_NAMESPACES: u32 = 1;
pub const CONFIG_BLK_RQ_ALLOC_TIME: u32 = 1;
pub const CONFIG_HAVE_CMPXCHG_DOUBLE: u32 = 1;
pub const CONFIG_ARCH_USE_MEMREMAP_PROT: u32 = 1;
pub const CONFIG_HAVE_ARCH_HUGE_VMAP: u32 = 1;
pub const CONFIG_IA32_EMULATION: u32 = 1;
pub const CONFIG_BLK_DEV_BSG: u32 = 1;
pub const CONFIG_CONNECTOR: u32 = 1;
pub const CONFIG_INTEGRITY: u32 = 1;
pub const CONFIG_EISA_PCI_EISA: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_MENU: u32 = 1;
pub const CONFIG_CRYPTO_RNG2: u32 = 1;
pub const CONFIG_THERMAL_WRITABLE_TRIPS: u32 = 1;
pub const CONFIG_MSDOS_FS: u32 = 1;
pub const CONFIG_NET_CLS_CGROUP: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MICROCHIP: u32 = 1;
pub const CONFIG_NET_VENDOR_DAVICOM: u32 = 1;
pub const CONFIG_SOFTIRQ_ON_OWN_STACK: u32 = 1;
pub const CONFIG_CFG80211: u32 = 1;
pub const CONFIG_PAGE_SIZE_LESS_THAN_256KB: u32 = 1;
pub const CONFIG_SAMPLE_TRACE_PRINTK_MODULE: u32 = 1;
pub const CONFIG_CPU_IBPB_ENTRY: u32 = 1;
pub const CONFIG_SERIAL_8250: u32 = 1;
pub const CONFIG_RANDOM_TRUST_CPU: u32 = 1;
pub const CONFIG_LZO_DECOMPRESS: u32 = 1;
pub const CONFIG_IOMMU_SUPPORT: u32 = 1;
pub const CONFIG_HID_BELKIN: u32 = 1;
pub const CONFIG_WLAN_VENDOR_CISCO: u32 = 1;
pub const CONFIG_COMPAT_BINFMT_ELF: u32 = 1;
pub const CONFIG_X86_DIRECT_GBPAGES: u32 = 1;
pub const CONFIG_RD_LZMA: u32 = 1;
pub const CONFIG_USB: u32 = 1;
pub const CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK: u32 = 1;
pub const CONFIG_PRINTK_CALLER: u32 = 1;
pub const CONFIG_MODULES_USE_ELF_RELA: u32 = 1;
pub const CONFIG_CRYPTO_HMAC: u32 = 1;
pub const CONFIG_WLAN_VENDOR_REALTEK: u32 = 1;
pub const CONFIG_ETHERNET: u32 = 1;
pub const CONFIG_SCHED_OMIT_FRAME_POINTER: u32 = 1;
pub const CONFIG_BRANCH_PROFILE_NONE: u32 = 1;
pub const CONFIG_X86_IOPL_IOPERM: u32 = 1;
pub const CONFIG_SND_HRTIMER: u32 = 1;
pub const CONFIG_HAVE_DMA_CONTIGUOUS: u32 = 1;
pub const CONFIG_DQL: u32 = 1;
pub const CONFIG_DM_ZERO: u32 = 1;
pub const CONFIG_X86_SUPPORTS_MEMORY_FAILURE: u32 = 1;
pub const CONFIG_SND_SEQUENCER: u32 = 1;
pub const CONFIG_SOCK_CGROUP_DATA: u32 = 1;
pub const CONFIG_COREDUMP: u32 = 1;
pub const CONFIG_EXT4_DEBUG: u32 = 1;
pub const CONFIG_HID_CHERRY: u32 = 1;
pub const CONFIG_USE_PERCPU_NUMA_NODE_ID: u32 = 1;
pub const CONFIG_HID_SUNPLUS: u32 = 1;
pub const CONFIG_PREEMPT_DYNAMIC: u32 = 1;
pub const CONFIG_BCMA_POSSIBLE: u32 = 1;
pub const CONFIG_NF_LOG_IPV4_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_CIRRUS: u32 = 1;
pub const CONFIG_VGA_ARB: u32 = 1;
pub const CONFIG_SATA_HOST: u32 = 1;
pub const CONFIG_SCSI_COMMON: u32 = 1;
pub const CONFIG_SURFACE_PLATFORMS: u32 = 1;
pub const CONFIG_DRM_NOMODESET: u32 = 1;
pub const CONFIG_NET_POLL_CONTROLLER: u32 = 1;
pub const CONFIG_PRINTK: u32 = 1;
pub const CONFIG_FORCEDETH: u32 = 1;
pub const CONFIG_ACPI_LPIT: u32 = 1;
pub const CONFIG_TIMERFD: u32 = 1;
pub const CONFIG_DNS_RESOLVER: u32 = 1;
pub const CONFIG_TRACEPOINTS: u32 = 1;
pub const CONFIG_MTD_CFI_I2: u32 = 1;
pub const CONFIG_CRYPTO_AUTHENC: u32 = 1;
pub const CONFIG_YENTA: u32 = 1;
pub const CONFIG_NET_EMATCH_STACK: u32 = 32;
pub const CONFIG_DRM_I915_PREEMPT_TIMEOUT: u32 = 640;
pub const CONFIG_ARCH_HAS_SYSCALL_WRAPPER: u32 = 1;
pub const CONFIG_COMPAT_32BIT_TIME: u32 = 1;
pub const CONFIG_SHMEM: u32 = 1;
pub const CONFIG_MTD: u32 = 1;
pub const CONFIG_MIGRATION: u32 = 1;
pub const CONFIG_HAVE_ARCH_JUMP_LABEL: u32 = 1;
pub const CONFIG_BUILD_SALT: &'static [u8; 1usize] = b"\0";
pub const CONFIG_HAVE_ARCH_PREL32_RELOCATIONS: u32 = 1;
pub const CONFIG_DECOMPRESS_LZMA: u32 = 1;
pub const CONFIG_DEVTMPFS_MOUNT: u32 = 1;
pub const CONFIG_EXCLUSIVE_SYSTEM_RAM: u32 = 1;
pub const CONFIG_HAVE_PREEMPT_DYNAMIC: u32 = 1;
pub const CONFIG_DNOTIFY: u32 = 1;
pub const CONFIG_X86_VMX_FEATURE_NAMES: u32 = 1;
pub const CONFIG_EFI_CUSTOM_SSDT_OVERLAYS: u32 = 1;
pub const CONFIG_GENERIC_NET_UTILS: u32 = 1;
pub const CONFIG_ATA: u32 = 1;
pub const CONFIG_HAVE_ARCH_KMSAN: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_437: u32 = 1;
pub const CONFIG_HAVE_ARCH_SOFT_DIRTY: u32 = 1;
pub const CONFIG_PATA_TIMINGS: u32 = 1;
pub const CONFIG_ARCH_PROC_KCORE_TEXT: u32 = 1;
pub const CONFIG_EXPORTFS: u32 = 1;
pub const CONFIG_I2C_SLAVE_EEPROM: u32 = 1;
pub const CONFIG_IP_MROUTE_COMMON: u32 = 1;
pub const CONFIG_NET_INGRESS: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_ERROR_INJECTION: u32 = 1;
pub const CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT: u32 = 1;
pub const CONFIG_OLD_SIGSUSPEND3: u32 = 1;
pub const CONFIG_SERIO: u32 = 1;
pub const CONFIG_SCHEDSTATS: u32 = 1;
pub const CONFIG_INPUT_MOUSE: u32 = 1;
pub const CONFIG_HOTPLUG_SMT: u32 = 1;
pub const CONFIG_X86: u32 = 1;
pub const CONFIG_SUNRPC_GSS: u32 = 1;
pub const CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS: u32 = 1;
pub const CONFIG_TIGON3: u32 = 1;
pub const CONFIG_KCMP: u32 = 1;
pub const CONFIG_NETCONSOLE: u32 = 1;
pub const CONFIG_RTC_INTF_SYSFS: u32 = 1;
pub const CONFIG_I2C_SLAVE_TESTUNIT: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_COMMON: u32 = 1;
pub const CONFIG_BLK_DEV_INITRD: u32 = 1;
pub const CONFIG_X86_MCE_AMD: u32 = 1;
pub const CONFIG_PCPU_DEV_REFCNT: u32 = 1;
pub const CONFIG_DRM_VIRTIO_GPU: u32 = 1;
pub const CONFIG_EFI_DXE_MEM_ATTRIBUTES: u32 = 1;
pub const CONFIG_GDB_SCRIPTS: u32 = 1;
pub const CONFIG_ZLIB_INFLATE: u32 = 1;
pub const CONFIG_NET_VENDOR_SYNOPSYS: u32 = 1;
pub const CONFIG_HWMON: u32 = 1;
pub const CONFIG_INTEL_GTT: u32 = 1;
pub const CONFIG_NET_VENDOR_DLINK: u32 = 1;
pub const CONFIG_AUDITSYSCALL: u32 = 1;
pub const CONFIG_X86_ACPI_CPUFREQ_CPB: u32 = 1;
pub const CONFIG_IP_PNP: u32 = 1;
pub const CONFIG_CLKBLD_I8253: u32 = 1;
pub const CONFIG_RTC_INTF_PROC: u32 = 1;
pub const CONFIG_DRM_DISPLAY_HDCP_HELPER: u32 = 1;
pub const CONFIG_DYNAMIC_DEBUG_CORE: u32 = 1;
pub const CONFIG_ARCH_USE_BUILTIN_BSWAP: u32 = 1;
pub const CONFIG_PERF_EVENTS_INTEL_RAPL: u32 = 1;
pub const CONFIG_CC_IMPLICIT_FALLTHROUGH: &'static [u8; 25usize] = b"-Wimplicit-fallthrough=5\0";
pub const CONFIG_CPU_IDLE_GOV_MENU: u32 = 1;
pub const CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL: u32 = 1;
pub const CONFIG_SERIAL_8250_LPSS: u32 = 1;
pub const CONFIG_ACPI_FAN: u32 = 1;
pub const CONFIG_STACKTRACE_SUPPORT: u32 = 1;
pub const CONFIG_RCU_TRACE: u32 = 1;
pub const CONFIG_OUTPUT_FORMAT: &'static [u8; 13usize] = b"elf64-x86-64\0";
pub const CONFIG_ACPI: u32 = 1;
pub const CONFIG_USB_UHCI_HCD: u32 = 1;
pub const CONFIG_NVRAM: u32 = 1;
pub const CONFIG_LOCKD: u32 = 1;
pub const CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC: u32 = 1;
pub const CONFIG_CRYPTO_LIB_ARC4: u32 = 1;
pub const CONFIG_CRYPTO_LIB_AES: u32 = 1;
pub const CONFIG_WLAN_VENDOR_RALINK: u32 = 1;
pub const CONFIG_CRYPTO_KPP2: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROCHIP: u32 = 1;
pub const CONFIG_HAVE_UACCESS_VALIDATION: u32 = 1;
pub const CONFIG_MTRR: u32 = 1;
pub const CONFIG_NO_HZ_IDLE: u32 = 1;
pub const CONFIG_NET_VENDOR_ADAPTEC: u32 = 1;
pub const CONFIG_CFG80211_REQUIRE_SIGNED_REGDB: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_NO_PATCHABLE: u32 = 1;
pub const CONFIG_MOUSE_PS2_BYD: u32 = 1;
pub const CONFIG_BSD_PROCESS_ACCT: u32 = 1;
pub const CONFIG_INPUT_TABLET: u32 = 1;
pub const CONFIG_SOCK_RX_QUEUE_MAPPING: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_HMAC: u32 = 1;
pub const CONFIG_DRM_BRIDGE: u32 = 1;
pub const CONFIG_HPET_EMULATE_RTC: u32 = 1;
pub const CONFIG_X86_MPPARSE: u32 = 1;
pub const CONFIG_NET_VENDOR_SILAN: u32 = 1;
pub const CONFIG_EEEPC_LAPTOP: u32 = 1;
pub const CONFIG_USB_STORAGE: u32 = 1;
pub const CONFIG_NET_VENDOR_BROADCOM: u32 = 1;
pub const CONFIG_NETFILTER_SKIP_EGRESS: u32 = 1;
pub const CONFIG_GENERIC_CPU_AUTOPROBE: u32 = 1;
pub const CONFIG_STANDALONE: u32 = 1;
pub const CONFIG_SCHED_MC: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_PERFORMANCE: u32 = 1;
pub const CONFIG_EFI: u32 = 1;
pub const CONFIG_RATIONAL: u32 = 1;
pub const CONFIG_I2C_MUX: u32 = 1;
pub const CONFIG_AGP_AMD64: u32 = 1;
pub const CONFIG_WLAN_VENDOR_INTEL: u32 = 1;
pub const CONFIG_HAVE_SETUP_PER_CPU_AREA: u32 = 1;
pub const CONFIG_DRM_I915_USERPTR: u32 = 1;
pub const CONFIG_SYSTEM_TRUSTED_KEYRING: u32 = 1;
pub const CONFIG_GENERIC_EARLY_IOREMAP: u32 = 1;
pub const CONFIG_NET_VENDOR_WANGXUN: u32 = 1;
pub const CONFIG_BLOCK: u32 = 1;
pub const CONFIG_ARCH_STACKWALK: u32 = 1;
pub const CONFIG_HID_APPLE: u32 = 1;
pub const CONFIG_INIT_ENV_ARG_LIMIT: u32 = 32;
pub const CONFIG_SAMPLE_TRACE_ARRAY_MODULE: u32 = 1;
pub const CONFIG_ROOT_NFS: u32 = 1;
pub const CONFIG_SAMPLE_KPROBES_MODULE: u32 = 1;
pub const CONFIG_AF_UNIX_OOB: u32 = 1;
pub const CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH: u32 = 1;
pub const CONFIG_CPU_SUP_INTEL: u32 = 1;
pub const CONFIG_TMPFS_POSIX_ACL: u32 = 1;
pub const CONFIG_STRICT_KERNEL_RWX: u32 = 1;
pub const CONFIG_HAVE_ARCH_KCSAN: u32 = 1;
pub const CONFIG_PROVIDE_OHCI1394_DMA_INIT: u32 = 1;
pub const CONFIG_BUG: u32 = 1;
pub const CONFIG_CONTEXT_SWITCH_TRACER: u32 = 1;
pub const CONFIG_MAC80211_HAS_RC: u32 = 1;
pub const CONFIG_LOGIWHEELS_FF: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_WX: u32 = 1;
pub const CONFIG_PANTHERLORD_FF: u32 = 1;
pub const CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE: u32 = 1;
pub const CONFIG_PM: u32 = 1;
pub const CONFIG_PPS: u32 = 1;
pub const CONFIG_NETFILTER_XTABLES_COMPAT: u32 = 1;
pub const CONFIG_GENERIC_ISA_DMA: u32 = 1;
pub const CONFIG_RTC_SYSTOHC_DEVICE: &'static [u8; 5usize] = b"rtc0\0";
pub const CONFIG_NF_CONNTRACK_IRC: u32 = 1;
pub const CONFIG_NET_FAILOVER: u32 = 1;
pub const CONFIG_WLAN_VENDOR_PURELIFI: u32 = 1;
pub const CONFIG_PSAMPLE: u32 = 1;
pub const CONFIG_IO_URING: u32 = 1;
pub const CONFIG_VT: u32 = 1;
pub const CONFIG_HAVE_KERNEL_ZSTD: u32 = 1;
pub const CONFIG_VMAP_PFN: u32 = 1;
pub const CONFIG_HID_REDRAGON: u32 = 1;
pub const CONFIG_SECRETMEM: u32 = 1;
pub const CONFIG_PCI_ATS: u32 = 1;
pub const CONFIG_DMA_ACPI: u32 = 1;
pub const CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED: u32 = 1;
pub const CONFIG_SPLIT_PTLOCK_CPUS: u32 = 4;
pub const CONFIG_SBITMAP: u32 = 1;
pub const CONFIG_POWER_SUPPLY: u32 = 1;
pub const CONFIG_CRYPTO_ZSTD: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_BOOTPARAM: u32 = 1;
pub const CONFIG_ARCH_HAS_UACCESS_FLUSHCACHE: u32 = 1;
pub const CONFIG_CRYPTO_SKCIPHER2: u32 = 1;
pub const CONFIG_NETLABEL: u32 = 1;
pub const CONFIG_NLS: u32 = 1;
pub const CONFIG_ARCH_WANTS_NO_INSTR: u32 = 1;
pub const CONFIG_AS_IS_GNU: u32 = 1;
pub const CONFIG_KASAN_GENERIC: u32 = 1;
pub const CONFIG_SAMPLE_WATCHDOG: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_SECMARK: u32 = 1;
pub const CONFIG_X86_INTEL_PSTATE: u32 = 1;
pub const CONFIG_ZONE_DMA: u32 = 1;
pub const CONFIG_ACPI_I2C_OPREGION: u32 = 1;
pub const CONFIG_SAMPLE_KFIFO_MODULE: u32 = 1;
pub const CONFIG_SND_SEQ_DEVICE: u32 = 1;
pub const CONFIG_SYN_COOKIES: u32 = 1;
pub const CONFIG_HAVE_NOINSTR_VALIDATION: u32 = 1;
pub const CONFIG_IRQ_WORK: u32 = 1;
pub const CONFIG_PCI_MSI: u32 = 1;
pub const CONFIG_IP_ADVANCED_ROUTER: u32 = 1;
pub const CONFIG_HAVE_ARCH_RANDOMIZE_KSTACK_OFFSET: u32 = 1;
pub const CONFIG_X86_64_SMP: u32 = 1;
pub const CONFIG_USB_EHCI_PCI: u32 = 1;
pub const CONFIG_NET_VENDOR_FUJITSU: u32 = 1;
pub const CONFIG_SPARSEMEM_EXTREME: u32 = 1;
pub const CONFIG_USB_COMMON: u32 = 1;
pub const CONFIG_TASK_XACCT: u32 = 1;
pub const CONFIG_DRM_DISPLAY_HDMI_HELPER: u32 = 1;
pub const CONFIG_IP6_NF_IPTABLES: u32 = 1;
pub const CONFIG_LZ4_COMPRESS: u32 = 1;
pub const CONFIG_VIRTIO_ANCHOR: u32 = 1;
pub const CONFIG_SAMPLE_AUXDISPLAY: u32 = 1;
pub const CONFIG_FIXED_PHY: u32 = 1;
pub const CONFIG_ARCH_HAS_SYNC_CORE_BEFORE_USERMODE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_USERSPACE: u32 = 1;
pub const CONFIG_AS_TPAUSE: u32 = 1;
pub const CONFIG_LOG_CPU_MAX_BUF_SHIFT: u32 = 12;
pub const CONFIG_BLK_DEV_DM_BUILTIN: u32 = 1;
pub const CONFIG_TASKS_RCU: u32 = 1;
pub const CONFIG_VGA_ARB_MAX_GPUS: u32 = 16;
pub const CONFIG_PCMCIA: u32 = 1;
pub const CONFIG_EVENT_TRACING: u32 = 1;
pub const CONFIG_PAGE_TABLE_ISOLATION: u32 = 1;
pub const CONFIG_AS_SHA1_NI: u32 = 1;
pub const CONFIG_HID_CYPRESS: u32 = 1;
pub const CONFIG_SG_POOL: u32 = 1;
pub const CONFIG_DRM_KMS_HELPER: u32 = 1;
pub const CONFIG_NET_VENDOR_PACKET_ENGINES: u32 = 1;
pub const CONFIG_BLK_MQ_PCI: u32 = 1;
pub const CONFIG_PREEMPT_VOLUNTARY: u32 = 1;
pub const CONFIG_NLS_ISO8859_1: u32 = 1;
pub const CONFIG_MACINTOSH_DRIVERS: u32 = 1;
pub const CONFIG_R8169: u32 = 1;
pub const CONFIG_HID_KENSINGTON: u32 = 1;
pub const CONFIG_USB_EHCI_HCD: u32 = 1;
pub const CONFIG_FS_IOMAP: u32 = 1;
pub const CONFIG_8139TOO: u32 = 1;
pub const CONFIG_HAVE_EISA: u32 = 1;
pub const CONFIG_COMPACT_UNEVICTABLE_DEFAULT: u32 = 1;
pub const CONFIG_RD_ZSTD: u32 = 1;
pub const CONFIG_RFKILL: u32 = 1;
pub const CONFIG_NETDEVICES: u32 = 1;
pub const CONFIG_ARCH_HAS_KCOV: u32 = 1;
pub const CONFIG_CGROUP_FREEZER: u32 = 1;
pub const CONFIG_HAVE_ARCH_STACKLEAK: u32 = 1;
pub const CONFIG_EVENTFD: u32 = 1;
pub const CONFIG_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_IPV6_SIT: u32 = 1;
pub const CONFIG_XFRM: u32 = 1;
pub const CONFIG_ARCH_HAS_PMEM_API: u32 = 1;
pub const CONFIG_HAVE_KPROBES_ON_FTRACE: u32 = 1;
pub const CONFIG_YENTA_TOSHIBA: u32 = 1;
pub const CONFIG_SERIAL_8250_CONSOLE: u32 = 1;
pub const CONFIG_DRM_BUDDY: u32 = 1;
pub const CONFIG_USB_ANNOUNCE_NEW_DEVICES: u32 = 1;
pub const CONFIG_JUMP_LABEL: u32 = 1;
pub const CONFIG_IP_NF_TARGET_MASQUERADE_MODULE: u32 = 1;
pub const CONFIG_USERMODE_DRIVER: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_DISABLE: u32 = 1;
pub const CONFIG_HAVE_EBPF_JIT: u32 = 1;
pub const CONFIG_CRYPTO_LZ4: u32 = 1;
pub const CONFIG_PROC_PAGE_MONITOR: u32 = 1;
pub const CONFIG_SERIAL_8250_EXTENDED: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_MASQUERADE_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_DETECT_IRQ: u32 = 1;
pub const CONFIG_IGB_HWMON: u32 = 1;
pub const CONFIG_BPF: u32 = 1;
pub const CONFIG_DRM_USE_DYNAMIC_DEBUG: u32 = 1;
pub const CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK: u32 = 1;
pub const CONFIG_X86_CMOV: u32 = 1;
pub const CONFIG_ACPI_HOTPLUG_CPU: u32 = 1;
pub const CONFIG_PM_TRACE_RTC: u32 = 1;
pub const CONFIG_RD_LZO: u32 = 1;
pub const CONFIG_KPROBE_EVENTS: u32 = 1;
pub const CONFIG_SCSI_SPI_ATTRS: u32 = 1;
pub const CONFIG_ARCH_HAS_COPY_MC: u32 = 1;
pub const CONFIG_MICROCODE_AMD: u32 = 1;
pub const CONFIG_NF_CONNTRACK_SECMARK: u32 = 1;
pub const CONFIG_INSTRUCTION_DECODER: u32 = 1;
pub const CONFIG_CRYPTO_SHA512: u32 = 1;
pub const CONFIG_BACKLIGHT_CLASS_DEVICE: u32 = 1;
pub const CONFIG_CC_HAS_ASM_INLINE: u32 = 1;
pub const CONFIG_CRYPTO_NULL: u32 = 1;
pub const CONFIG_NET_VENDOR_SEEQ: u32 = 1;
pub const CONFIG_NF_DEFRAG_IPV4: u32 = 1;
pub const CONFIG_INTEL_IOMMU_FLOPPY_WA: u32 = 1;
pub const CONFIG_VIRTIO_CONSOLE: u32 = 1;
pub const CONFIG_ARCH_CLOCKSOURCE_INIT: u32 = 1;
pub const CONFIG_BFS_FS: u32 = 1;
pub const CONFIG_PM_DEBUG: u32 = 1;
pub const CONFIG_CRYPTO_DEFLATE: u32 = 1;
pub const CONFIG_GENERIC_STRNLEN_USER: u32 = 1;
pub const CONFIG_IGB: u32 = 1;
pub const CONFIG_WLAN_VENDOR_RSI: u32 = 1;
pub const CONFIG_CRYPTO_JITTERENTROPY: u32 = 1;
pub const CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION: u32 = 1;
pub const CONFIG_CRYPTO_GCM: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK_LOG: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE: u32 = 1;
pub const CONFIG_CDROM: u32 = 1;
pub const CONFIG_MAGIC_SYSRQ: u32 = 1;
pub const CONFIG_E100: u32 = 1;
pub const CONFIG_IO_DELAY_0X80: u32 = 1;
pub const CONFIG_DMI: u32 = 1;
pub const CONFIG_NET_VENDOR_RDC: u32 = 1;
pub const CONFIG_PGTABLE_LEVELS: u32 = 5;
pub const CONFIG_CPUSETS: u32 = 1;
pub const CONFIG_MAC80211_RC_DEFAULT_MINSTREL: u32 = 1;
pub const CONFIG_SPARSE_IRQ: u32 = 1;
pub const CONFIG_IP_NF_MANGLE: u32 = 1;
pub const CONFIG_RCU_STALL_COMMON: u32 = 1;
pub const CONFIG_CPU_SUP_AMD: u32 = 1;
pub const CONFIG_PCIEPORTBUS: u32 = 1;
pub const CONFIG_DEBUG_BUGVERBOSE: u32 = 1;
pub const CONFIG_I2C_DEBUG_BUS: u32 = 1;
pub const CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK: u32 = 1;
pub const CONFIG_IP_NF_FILTER: u32 = 1;
pub const CONFIG_DYNAMIC_MEMORY_LAYOUT: u32 = 1;
pub const CONFIG_HAVE_BUILDTIME_MCOUNT_SORT: u32 = 1;
pub const CONFIG_MODULES_TREE_LOOKUP: u32 = 1;
pub const CONFIG_FAT_FS: u32 = 1;
pub const CONFIG_SND_HDA_INTEL: u32 = 1;
pub const CONFIG_BUILDTIME_TABLE_SORT: u32 = 1;
pub const CONFIG_NVMEM: u32 = 1;
pub const CONFIG_INET_TUNNEL: u32 = 1;
pub const CONFIG_X86_INTERNODE_CACHE_SHIFT: u32 = 6;
pub const CONFIG_NF_LOG_ARP_MODULE: u32 = 1;
pub const CONFIG_NET_9P_VIRTIO: u32 = 1;
pub const CONFIG_X86_CHECK_BIOS_CORRUPTION: u32 = 1;
pub const CONFIG_BLOCK_HOLDER_DEPRECATED: u32 = 1;
pub const CONFIG_RETHUNK: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS: u32 = 1;
pub const CONFIG_OID_REGISTRY: u32 = 1;
pub const CONFIG_AS_SHA256_NI: u32 = 1;
pub const CONFIG_HAVE_KERNEL_XZ: u32 = 1;
pub const CONFIG_GCC12_NO_ARRAY_BOUNDS: u32 = 1;
pub const CONFIG_X86_PKG_TEMP_THERMAL_MODULE: u32 = 1;
pub const CONFIG_RFKILL_LEDS: u32 = 1;
pub const CONFIG_CONSOLE_TRANSLATIONS: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_ATOMIC_RMW: u32 = 1;
pub const CONFIG_STACKTRACE_BUILD_ID: u32 = 1;
pub const CONFIG_SND_X86: u32 = 1;
pub const CONFIG_PCMCIA_LOAD_CIS: u32 = 1;
pub const CONFIG_SERIAL_EARLYCON: u32 = 1;
pub const CONFIG_NET_VENDOR_NI: u32 = 1;
pub const CONFIG_DEBUG_DEVRES: u32 = 1;
pub const CONFIG_CRYPTO_AKCIPHER: u32 = 1;
pub const CONFIG_ETHTOOL_NETLINK: u32 = 1;
pub const CONFIG_ACPI_CPU_FREQ_PSS: u32 = 1;
pub const CONFIG_CPU_FREQ: u32 = 1;
pub const CONFIG_USB_OHCI_HCD: u32 = 1;
pub const CONFIG_NR_CPUS_DEFAULT: u32 = 64;
pub const CONFIG_DM_MIRROR: u32 = 1;
pub const CONFIG_ARCH_CPUIDLE_HALTPOLL: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE: u32 = 1;
pub const CONFIG_MMU_GATHER_MERGE_VMAS: u32 = 1;
pub const CONFIG_USB_PCI: u32 = 1;
pub const CONFIG_NLS_ASCII: u32 = 1;
pub const CONFIG_NF_REJECT_IPV4: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS_MAX: u32 = 32;
pub const CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE: u32 = 1;
pub const CONFIG_TRACE_IRQFLAGS_SUPPORT: u32 = 1;
pub const CONFIG_NFS_V3_ACL: u32 = 1;
pub const CONFIG_CRYPTO_CCM: u32 = 1;
pub const CONFIG_TCP_CONG_ADVANCED: u32 = 1;
pub const CONFIG_KASAN_SHADOW_OFFSET: i64 = -2305847407260205056;
pub const CONFIG_KVM_GUEST: u32 = 1;
pub const CONFIG_FONT_AUTOSELECT: u32 = 1;
pub const CONFIG_QFMT_V2: u32 = 1;
pub const CONFIG_BLK_CGROUP: u32 = 1;
pub const CONFIG_LEDS_TRIGGERS: u32 = 1;
pub const CONFIG_CRYPTO_RNG: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN: u32 = 8;
pub const CONFIG_CRYPTO_LIB_UTILS: u32 = 1;
pub const CONFIG_SND_USB: u32 = 1;
pub const CONFIG_RD_GZIP: u32 = 1;
pub const CONFIG_ARCH_HAS_CPU_RELAX: u32 = 1;
pub const CONFIG_HAVE_REGS_AND_STACK_ACCESS_API: u32 = 1;
pub const CONFIG_BLK_PM: u32 = 1;
pub const CONFIG_BLK_CGROUP_IOPRIO: u32 = 1;
pub const CONFIG_MDIO_BUS: u32 = 1;
pub const CONFIG_TREE_RCU: u32 = 1;
pub const CONFIG_ALLOW_DEV_COREDUMP: u32 = 1;
pub const CONFIG_SWIOTLB: u32 = 1;
pub const CONFIG_EXT4_FS_SECURITY: u32 = 1;
pub const CONFIG_GRO_CELLS: u32 = 1;
pub const CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN: u32 = 1;
pub const CONFIG_PCI_MSI_IRQ_DOMAIN: u32 = 1;
pub const CONFIG_CRYPTO_MD5: u32 = 1;
pub const CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE: u32 = 1;
pub const CONFIG_ATA_ACPI: u32 = 1;
pub const CONFIG_X86_EXTENDED_PLATFORM: u32 = 1;
pub const CONFIG_P2SB: u32 = 1;
pub const CONFIG_NET_VENDOR_CORTINA: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR: u32 = 1;
pub const CONFIG_ELFCORE: u32 = 1;
pub const CONFIG_HIBERNATION_SNAPSHOT_DEV: u32 = 1;
pub const CONFIG_HAVE_KVM: u32 = 1;
pub const CONFIG_PCCARD: u32 = 1;
pub const CONFIG_INIT_STACK_NONE: u32 = 1;
pub const CONFIG_BINFMT_ELF: u32 = 1;
pub const CONFIG_SCSI_PROC_FS: u32 = 1;
pub const CONFIG_HAVE_PERF_REGS: u32 = 1;
pub const CONFIG_DRM_I915_USERFAULT_AUTOSUSPEND: u32 = 250;
pub const CONFIG_IP_PIMSM_V1: u32 = 1;
pub const CONFIG_INET6_AH: u32 = 1;
pub const CONFIG_NET_VENDOR_ALTEON: u32 = 1;
pub const CONFIG_USB_MON: u32 = 1;
pub const CONFIG_NET_VENDOR_RENESAS: u32 = 1;
pub const CONFIG_KEYS: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR_CSTATE: u32 = 1;
pub const CONFIG_SND_VMASTER: u32 = 1;
pub const CONFIG_NETFILTER_XT_MARK_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XTABLES: u32 = 1;
pub const CONFIG_DRM_PANEL_ORIENTATION_QUIRKS: u32 = 1;
pub const CONFIG_CRYPTO_ECHAINIV: u32 = 1;
pub const CONFIG_HAVE_ARCH_AUDITSYSCALL: u32 = 1;
pub const CONFIG_BOOT_PRINTK_DELAY: u32 = 1;
pub const CONFIG_PM_SLEEP_SMP: u32 = 1;
pub const CONFIG_X86_16BIT: u32 = 1;
pub const CONFIG_CRYPTO_HW: u32 = 1;
pub const CONFIG_X86_VERBOSE_BOOTUP: u32 = 1;
pub const CONFIG_PCSPKR_PLATFORM: u32 = 1;
pub const CONFIG_HAVE_LIVEPATCH: u32 = 1;
pub const CONFIG_CARDBUS: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_WITH_ARGS: u32 = 1;
pub const CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE: u32 = 1;
pub const CONFIG_KALLSYMS_ABSOLUTE_PERCPU: u32 = 1;
pub const CONFIG_CPU_IBRS_ENTRY: u32 = 1;
pub const CONFIG_ACPI_AC: u32 = 1;
pub const CONFIG_HARDIRQS_SW_RESEND: u32 = 1;
pub const CONFIG_ACPI_HOTPLUG_IOAPIC: u32 = 1;
pub const CONFIG_HID_GYRATION: u32 = 1;
pub const CONFIG_THERMAL_HWMON: u32 = 1;
pub const CONFIG_CRYPTO_SKCIPHER: u32 = 1;
pub const CONFIG_XZ_DEC_X86: u32 = 1;
pub const CONFIG_MAC80211_LEDS: u32 = 1;
pub const CONFIG_HIBERNATE_CALLBACKS: u32 = 1;
pub const CONFIG_EISA: u32 = 1;
pub const CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS: u32 = 0;
pub const CONFIG_CONSOLE_LOGLEVEL_QUIET: u32 = 4;
pub const CONFIG_CRC16: u32 = 1;
pub const CONFIG_GENERIC_CALIBRATE_DELAY: u32 = 1;
pub const CONFIG_CRYPTO_GF128MUL: u32 = 1;
pub const CONFIG_UPROBE_EVENTS: u32 = 1;
pub const CONFIG_NET_CLS: u32 = 1;
pub const CONFIG_TMPFS: u32 = 1;
pub const CONFIG_NET_VENDOR_NETERION: u32 = 1;
pub const CONFIG_RANDSTRUCT_NONE: u32 = 1;
pub const CONFIG_FUTEX: u32 = 1;
pub const CONFIG_IP_PNP_DHCP: u32 = 1;
pub const CONFIG_VIRTIO_PCI: u32 = 1;
pub const CONFIG_UNIX_SCM: u32 = 1;
pub const CONFIG_CONSOLE_LOGLEVEL_DEFAULT: u32 = 7;
pub const CONFIG_ARCH_HAS_FAST_MULTIPLIER: u32 = 1;
pub const CONFIG_NET_VENDOR_REALTEK: u32 = 1;
pub const CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG: u32 = 1;
pub const CONFIG_DRM_I915_CAPTURE_ERROR: u32 = 1;
pub const CONFIG_SECURITY_NETWORK: u32 = 1;
pub const CONFIG_SERIAL_CORE_CONSOLE: u32 = 1;
pub const CONFIG_ACPI_CPPC_LIB: u32 = 1;
pub const CONFIG_HUGETLB_PAGE: u32 = 1;
pub const CONFIG_NET_VENDOR_EMULEX: u32 = 1;
pub const CONFIG_USB_HID: u32 = 1;
pub const CONFIG_USER_STACKTRACE_SUPPORT: u32 = 1;
pub const CONFIG_SLUB_DEBUG: u32 = 1;
pub const CONFIG_BLK_DEV_MD: u32 = 1;
pub const CONFIG_UCS2_STRING: u32 = 1;
pub const CONFIG_MAC_EMUMOUSEBTN: u32 = 1;
pub const CONFIG_DMADEVICES: u32 = 1;
pub const CONFIG_PAHOLE_VERSION: u32 = 0;
pub const CONFIG_ARCH_SUPPORTS_CFI_CLANG: u32 = 1;
pub const CONFIG_IPV6_NDISC_NODETYPE: u32 = 1;
pub const CONFIG_PCI_LABEL: u32 = 1;
pub const CONFIG_HAVE_OBJTOOL_MCOUNT: u32 = 1;
pub const CONFIG_ARCH_WANT_DEFAULT_BPF_JIT: u32 = 1;
pub const CONFIG_SGETMASK_SYSCALL: u32 = 1;
pub const CONFIG_CGROUP_SCHED: u32 = 1;
pub const CONFIG_QUEUED_RWLOCKS: u32 = 1;
pub const CONFIG_SYSVIPC: u32 = 1;
pub const CONFIG_ARCH_HAS_GIGANTIC_PAGE: u32 = 1;
pub const CONFIG_HAVE_DEBUG_KMEMLEAK: u32 = 1;
pub const CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT: u32 = 13;
pub const CONFIG_NF_CONNTRACK_FTP: u32 = 1;
pub const CONFIG_PAGE_SIZE_LESS_THAN_64KB: u32 = 1;
pub const CONFIG_MODULES: u32 = 1;
pub const CONFIG_CONTEXT_TRACKING: u32 = 1;
pub const CONFIG_MQ_IOSCHED_DEADLINE: u32 = 1;
pub const CONFIG_USB_HIDDEV: u32 = 1;
pub const CONFIG_IOMMU_IOVA: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE_COLUMNS: u32 = 80;
pub const CONFIG_XXHASH: u32 = 1;
pub const CONFIG_SOUND: u32 = 1;
pub const CONFIG_JOLIET: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE: u32 = 1;
pub const CONFIG_ARCH_HIBERNATION_POSSIBLE: u32 = 1;
pub const CONFIG_ARCH_USE_SYM_ANNOTATIONS: u32 = 1;
pub const CONFIG_IA32_FEAT_CTL: u32 = 1;
pub const CONFIG_UNIX: u32 = 1;
pub const CONFIG_USB_NET_DRIVERS: u32 = 1;
pub const CONFIG_CC_CAN_LINK: u32 = 1;
pub const CONFIG_QNX6FS_FS: u32 = 1;
pub const CONFIG_LD_IS_BFD: u32 = 1;
pub const CONFIG_NO_HZ_COMMON: u32 = 1;
pub const CONFIG_DRM_MIPI_DSI: u32 = 1;
pub const CONFIG_CRYPTO_HASH2: u32 = 1;
pub const CONFIG_NET_VENDOR_VERTEXCOM: u32 = 1;
pub const CONFIG_CRYPTO_LZ4HC: u32 = 1;
pub const CONFIG_THERMAL_GOV_STEP_WISE: u32 = 1;
pub const CONFIG_DEFAULT_HOSTNAME: &'static [u8; 7usize] = b"(none)\0";
pub const CONFIG_SRCU: u32 = 1;
pub const CONFIG_CC_HAS_NO_PROFILE_FN_ATTR: u32 = 1;
pub const CONFIG_NFS_FS: u32 = 1;
pub const CONFIG_CRASH_DUMP: u32 = 1;
pub const CONFIG_MEMBARRIER: u32 = 1;
pub const CONFIG_BLK_DEV_IO_TRACE: u32 = 1;
pub const CONFIG_XPS: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_DEVELOP: u32 = 1;
pub const CONFIG_SGL_ALLOC: u32 = 1;
pub const CONFIG_HPET_TIMER: u32 = 1;
pub const CONFIG_LZ4_DECOMPRESS: u32 = 1;
pub const CONFIG_HSI: u32 = 1;
pub const CONFIG_EFI_RUNTIME_MAP: u32 = 1;
pub const CONFIG_FONT_SUPPORT: u32 = 1;
pub const CONFIG_ADVISE_SYSCALLS: u32 = 1;
pub const CONFIG_MD: u32 = 1;
pub const CONFIG_CRYPTO_ALGAPI: u32 = 1;
pub const CONFIG_DRM_I915_MAX_REQUEST_BUSYWAIT: u32 = 8000;
pub const CONFIG_NET_VENDOR_WIZNET: u32 = 1;
pub const CONFIG_SERIAL_8250_MID: u32 = 1;
pub const CONFIG_RD_BZIP2: u32 = 1;
pub const CONFIG_SKB_EXTENSIONS: u32 = 1;
pub const CONFIG_CC_VERSION_TEXT: &'static [u8; 42usize] =
    b"gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0\0";
pub const CONFIG_KEYBOARD_ATKBD: u32 = 1;
pub const CONFIG_X86_PLATFORM_DEVICES: u32 = 1;
pub const CONFIG_NET_IP_TUNNEL: u32 = 1;
pub const CONFIG_MTD_CFI_I1: u32 = 1;
pub const CONFIG_NF_NAT: u32 = 1;
pub const CONFIG_BLOCK_LEGACY_AUTOLOAD: u32 = 1;
pub const CONFIG_NET_VENDOR_OKI: u32 = 1;
pub const CONFIG_CPU_IDLE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_INTERSIL: u32 = 1;
pub const CONFIG_NFS_COMMON: u32 = 1;
pub const CONFIG_FAIR_GROUP_SCHED: u32 = 1;
pub const CONFIG_CRYPTO_HASH: u32 = 1;
pub const CONFIG_HAVE_STACK_VALIDATION: u32 = 1;
pub const CONFIG_EFI_PARTITION: u32 = 1;
pub const CONFIG_PROBE_EVENTS: u32 = 1;
pub const CONFIG_TRACE_CLOCK: u32 = 1;
pub const CONFIG_LOG_BUF_SHIFT: u32 = 18;
pub const CONFIG_WLAN_VENDOR_ATH: u32 = 1;
pub const CONFIG_HZ_1000: u32 = 1;
pub const CONFIG_HPET: u32 = 1;
pub const CONFIG_ACPI_WMI: u32 = 1;
pub const CONFIG_EXTRA_FIRMWARE: &'static [u8; 1usize] = b"\0";
pub const CONFIG_NET_VENDOR_8390: u32 = 1;
pub const CONFIG_PROC_EVENTS: u32 = 1;
pub const CONFIG_ACPI_VIDEO: u32 = 1;
pub const CONFIG_HAVE_KCSAN_COMPILER: u32 = 1;
pub const CONFIG_VFAT_FS: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE: u32 = 0;
pub const CONFIG_ARCH_SUPPORTS_ACPI: u32 = 1;
pub const CONFIG_PID_NS: u32 = 1;
pub const CONFIG_BLK_CGROUP_IOCOST: u32 = 1;
pub const CONFIG_KEXEC: u32 = 1;
pub const CONFIG_CRC32_SLICEBY8: u32 = 1;
pub const CONFIG_BLK_DEV_SR: u32 = 1;
pub const CONFIG_CPU_RMAP: u32 = 1;
pub const CONFIG_SND_HWDEP: u32 = 1;
pub const CONFIG_GENERIC_CPU: u32 = 1;
pub const CONFIG_GENERIC_IRQ_MATRIX_ALLOCATOR: u32 = 1;
pub const CONFIG_BLK_DEV_LOOP: u32 = 1;
pub const CONFIG_VIRTIO_PCI_LEGACY: u32 = 1;
pub const CONFIG_ARCH_HIBERNATION_HEADER: u32 = 1;
pub const CONFIG_HAVE_OPTPROBES: u32 = 1;
pub const CONFIG_HAVE_FENTRY: u32 = 1;
pub const CONFIG_RUST_IS_AVAILABLE: u32 = 1;
pub const CONFIG_DRM_I915_HEARTBEAT_INTERVAL: u32 = 2500;
pub const CONFIG_NF_NAT_IRC: u32 = 1;
pub const CONFIG_INPUT_MISC: u32 = 1;
pub const CONFIG_E1000E: u32 = 1;
pub const CONFIG_INPUT_VIVALDIFMAP: u32 = 1;
pub const CONFIG_MULTIUSER: u32 = 1;
pub const CONFIG_SUSPEND: u32 = 1;
pub const CONFIG_GENERIC_VDSO_TIME_NS: u32 = 1;
pub const CONFIG_CROSS_MEMORY_ATTACH: u32 = 1;
pub const CONFIG_CRYPTO_CBC: u32 = 1;
pub const CONFIG_I8253_LOCK: u32 = 1;
pub const CONFIG_SERIAL_8250_RUNTIME_UARTS: u32 = 4;
pub const CONFIG_PREEMPT_BUILD: u32 = 1;
pub const CONFIG_ARCH_HAS_NONLEAF_PMD_YOUNG: u32 = 1;
pub const CONFIG_CLANG_VERSION: u32 = 0;
pub const CONFIG_KPROBES: u32 = 1;
pub const CONFIG_FS_MBCACHE: u32 = 1;
pub const CONFIG_RTC_CLASS: u32 = 1;
pub const CONFIG_CRYPTO_RNG_DEFAULT: u32 = 1;
pub const CONFIG_TMPFS_XATTR: u32 = 1;
pub const CONFIG_EXT4_USE_FOR_EXT2: u32 = 1;
pub const CONFIG_I2C_I801: u32 = 1;
pub const CONFIG_DRM_I915_STOP_TIMEOUT: u32 = 100;
pub const CONFIG_GENERIC_TRACER: u32 = 1;
pub const CONFIG_CFG80211_USE_KERNEL_REGDB_KEYS: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_TRACER: u32 = 1;
pub const CONFIG_CPU_ISOLATION: u32 = 1;
pub const CONFIG_NR_CPUS_RANGE_END: u32 = 512;
pub const CONFIG_DRM_DISPLAY_DP_HELPER: u32 = 1;
pub const CONFIG_EFI_MIXED: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER2: u32 = 1;
pub const CONFIG_SERIAL_8250_DEPRECATED_OPTIONS: u32 = 1;
pub const CONFIG_ARCH_HAS_PTE_SPECIAL: u32 = 1;
pub const CONFIG_NET_VENDOR_MYRI: u32 = 1;
pub const CONFIG_NF_NAT_MASQUERADE: u32 = 1;
pub const CONFIG_CLZ_TAB: u32 = 1;
pub const CONFIG_GENERIC_PCI_IOMAP: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_LOG_MODULE: u32 = 1;
pub const CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS: u32 = 1;
pub const CONFIG_SLUB: u32 = 1;
pub const CONFIG_XZ_DEC_BCJ: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_LTO_CLANG_THIN: u32 = 1;
pub const CONFIG_PM_SLEEP: u32 = 1;
pub const CONFIG_I2C: u32 = 1;
pub const CONFIG_MMU_GATHER_TABLE_FREE: u32 = 1;
pub const CONFIG_BINFMT_SCRIPT: u32 = 1;
pub const CONFIG_EFI_STUB: u32 = 1;
pub const CONFIG_EISA_NAMES: u32 = 1;
pub const CONFIG_MOUSE_PS2_CYPRESS: u32 = 1;
pub const CONFIG_GENERIC_PENDING_IRQ: u32 = 1;
pub const CONFIG_DRM_I915_FENCE_TIMEOUT: u32 = 10000;
pub const CONFIG_EARLY_PRINTK_DBGP: u32 = 1;
pub const CONFIG_CC_HAS_RETURN_THUNK: u32 = 1;
pub const CONFIG_MOUSE_PS2_LOGIPS2PP: u32 = 1;
pub const CONFIG_TICK_CPU_ACCOUNTING: u32 = 1;
pub const CONFIG_VM_EVENT_COUNTERS: u32 = 1;
pub const CONFIG_RELAY: u32 = 1;
pub const CONFIG_HAVE_MMIOTRACE_SUPPORT: u32 = 1;
pub const CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT: u32 = 1;
pub const CONFIG_WLAN_VENDOR_BROADCOM: u32 = 1;
pub const CONFIG_PM_STD_PARTITION: &'static [u8; 1usize] = b"\0";
pub const CONFIG_NET_VENDOR_XIRCOM: u32 = 1;
pub const CONFIG_I2C_SLAVE: u32 = 1;
pub const CONFIG_DEBUG_FS: u32 = 1;
pub const CONFIG_NET_VENDOR_AMD: u32 = 1;
pub const CONFIG_HAVE_KERNEL_LZ4: u32 = 1;
pub const CONFIG_DRM_TTM: u32 = 1;
pub const CONFIG_BASE_FULL: u32 = 1;
pub const CONFIG_ZLIB_DEFLATE: u32 = 1;
pub const CONFIG_SUNRPC: u32 = 1;
pub const CONFIG_ACPI_TABLE_UPGRADE: u32 = 1;
pub const CONFIG_ARCH_USES_HIGH_VMA_FLAGS: u32 = 1;
pub const CONFIG_RSEQ: u32 = 1;
pub const CONFIG_FW_LOADER: u32 = 1;
pub const CONFIG_SECURITY_WRITABLE_HOOKS: u32 = 1;
pub const CONFIG_KALLSYMS: u32 = 1;
pub const CONFIG_STACKPROTECTOR_STRONG: u32 = 1;
pub const CONFIG_PCI: u32 = 1;
pub const CONFIG_NET_VENDOR_FUNGIBLE: u32 = 1;
pub const CONFIG_DEBUG_INFO_COMPRESSED: u32 = 1;
pub const CONFIG_NET_VENDOR_ASIX: u32 = 1;
pub const CONFIG_DECOMPRESS_XZ: u32 = 1;
pub const CONFIG_PCI_QUIRKS: u32 = 1;
pub const CONFIG_MII: u32 = 1;
pub const CONFIG_SIGNALFD: u32 = 1;
pub const CONFIG_NET_CORE: u32 = 1;
pub const CONFIG_MOUSE_PS2_ALPS: u32 = 1;
pub const CONFIG_KEXEC_CORE: u32 = 1;
pub const CONFIG_HAVE_UNSTABLE_SCHED_CLOCK: u32 = 1;
pub const CONFIG_EXT4_FS: u32 = 1;
pub const CONFIG_UNINLINE_SPIN_UNLOCK: u32 = 1;
pub const CONFIG_HAVE_HW_BREAKPOINT: u32 = 1;
pub const CONFIG_KRETPROBES: u32 = 1;
pub const CONFIG_SND_JACK_INPUT_DEV: u32 = 1;
pub const CONFIG_CPU_UNRET_ENTRY: u32 = 1;
pub const CONFIG_HSI_BOARDINFO: u32 = 1;
pub const CONFIG_ARCH_WANT_GENERAL_HUGETLB: u32 = 1;
pub const CONFIG_HAVE_SAMPLE_FTRACE_DIRECT: u32 = 1;
pub const CONFIG_SATA_PMP: u32 = 1;
pub const CONFIG_XZ_DEC: u32 = 1;
pub const CONFIG_NET_VENDOR_TI: u32 = 1;
pub const CONFIG_LOCKD_V4: u32 = 1;
pub const CONFIG_NET_VENDOR_ALACRITECH: u32 = 1;
pub const CONFIG_WATCHDOG: u32 = 1;
pub const CONFIG_HAS_IOMEM: u32 = 1;
pub const CONFIG_NF_LOG_IPV6_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_RSA: u32 = 1;
pub const CONFIG_GENERIC_IRQ_PROBE: u32 = 1;
pub const CONFIG_HAVE_MOVE_PUD: u32 = 1;
pub const CONFIG_CRYPTO_ACOMP2: u32 = 1;
pub const CONFIG_PCI_MMCONFIG: u32 = 1;
pub const CONFIG_PM_TRACE: u32 = 1;
pub const CONFIG_HAVE_ARCH_KASAN_VMALLOC: u32 = 1;
pub const CONFIG_PROC_KCORE: u32 = 1;
pub const CONFIG_RETPOLINE: u32 = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_1: u32 = 1;
pub const CONFIG_NUMA: u32 = 1;
pub const CONFIG_SCHED_HRTICK: u32 = 1;
pub const CONFIG_CONSTRUCTORS: u32 = 1;
pub const CONFIG_EPOLL: u32 = 1;
pub const CONFIG_NET_IFE: u32 = 1;
pub const CONFIG_CRYPTO_LZO: u32 = 1;
pub const CONFIG_SND_PCM: u32 = 1;
pub const CONFIG_SATA_MOBILE_LPM_POLICY: u32 = 0;
pub const CONFIG_APERTURE_HELPERS: u32 = 1;
pub const CONFIG_FAILOVER: u32 = 1;
pub const CONFIG_CGROUP_HUGETLB: u32 = 1;
pub const CONFIG_GENERIC_PTDUMP: u32 = 1;
pub const CONFIG_NET: u32 = 1;
pub const CONFIG_SAMPLE_HW_BREAKPOINT_MODULE: u32 = 1;
pub const CONFIG_SAMPLE_KRETPROBES_MODULE: u32 = 1;
pub const CONFIG_USB_OHCI_HCD_PCI: u32 = 1;
pub const CONFIG_INPUT_EVDEV: u32 = 1;
pub const CONFIG_SND_JACK: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TCPMSS: u32 = 1;
pub const CONFIG_ACPI_SLEEP: u32 = 1;
pub const CONFIG_VIRTIO_DMA_SHARED_BUFFER: u32 = 1;
pub const CONFIG_X86_ESPFIX64: u32 = 1;
pub const CONFIG_CRYPTO_LIB_BLAKE2S_GENERIC: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNTRACK: u32 = 1;
pub const CONFIG_BLOCK_COMPAT: u32 = 1;
pub const CONFIG_QUOTA_TREE: u32 = 1;
pub const CONFIG_IRQ_DOMAIN_HIERARCHY: u32 = 1;
pub const CONFIG_ATA_FORCE: u32 = 1;
pub const CONFIG_MPILIB: u32 = 1;
pub const CONFIG_PACKET: u32 = 1;
pub const CONFIG_XFRM_ALGO: u32 = 1;
pub const CONFIG_CRYPTO_AKCIPHER2: u32 = 1;
pub const CONFIG_NODES_SHIFT: u32 = 6;
pub const CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE: u32 = 1;
pub const CONFIG_SND_CTL_FAST_LOOKUP: u32 = 1;
pub const CONFIG_SND_HDA_CORE: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE_ROWS: u32 = 25;
pub const CONFIG_NFS_V3: u32 = 1;
pub const CONFIG_NOP_TRACER: u32 = 1;
pub const CONFIG_INET: u32 = 1;
pub const CONFIG_IP_ROUTE_VERBOSE: u32 = 1;
pub const CONFIG_XZ_DEC_POWERPC: u32 = 1;
pub const CONFIG_IP_PNP_BOOTP: u32 = 1;
pub const CONFIG_VIRTIO_NET: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_ADDRTYPE_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_HUAWEI: u32 = 1;
pub const CONFIG_PREVENT_FIRMWARE_BUILD: u32 = 1;
pub const CONFIG_SERIAL_8250_PNP: u32 = 1;
pub const CONFIG_FREEZER: u32 = 1;
pub const CONFIG_HAVE_HARDLOCKUP_DETECTOR_PERF: u32 = 1;
pub const CONFIG_PCI_DOMAINS: u32 = 1;
pub const CONFIG_NET_CLS_ACT: u32 = 1;
pub const CONFIG_NET_VENDOR_CHELSIO: u32 = 1;
pub const CONFIG_LZ4HC_COMPRESS: u32 = 1;
pub const CONFIG_EFIVAR_FS_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_VMAP_STACK: u32 = 1;
pub const CONFIG_X86_DEBUGCTLMSR: u32 = 1;
pub const CONFIG_8139TOO_PIO: u32 = 1;
pub const CONFIG_SND_PCMCIA: u32 = 1;
pub const CONFIG_RTC_LIB: u32 = 1;
pub const CONFIG_X86_LOCAL_APIC: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_POLICY: u32 = 1;
pub const CONFIG_HAVE_KPROBES: u32 = 1;
pub const CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS: u32 = 1;
pub const CONFIG_X86_UMIP: u32 = 1;
pub const CONFIG_CRYPTO_AES: u32 = 1;
pub const CONFIG_HAVE_GENERIC_VDSO: u32 = 1;
pub const CONFIG_FUTEX_PI: u32 = 1;
pub const CONFIG_I2C_STUB_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CPU_VULNERABILITIES: u32 = 1;
pub const CONFIG_HAVE_ARCH_WITHIN_STACK_FRAMES: u32 = 1;
pub const CONFIG_HID_PID: u32 = 1;
pub const CONFIG_AUTOFS_FS: u32 = 1;
pub const CONFIG_ISO9660_FS: u32 = 1;
pub const CONFIG_SKY2: u32 = 1;
pub const CONFIG_NETFILTER_XT_NAT_MODULE: u32 = 1;
pub const CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR: u32 = 1;
pub const CONFIG_WERROR: u32 = 1;
pub const CONFIG_NET_VENDOR_AQUANTIA: u32 = 1;
pub const CONFIG_SCSI_VIRTIO: u32 = 1;
pub const CONFIG_HVC_DRIVER: u32 = 1;
pub const CONFIG_NETFILTER: u32 = 1;
pub const CONFIG_X86_MSR: u32 = 1;
pub const CONFIG_HAVE_ARCH_KASAN: u32 = 1;
pub const CONFIG_NET_VENDOR_SMSC: u32 = 1;
pub const CONFIG_NFS_DISABLE_UDP_SUPPORT: u32 = 1;
pub const CONFIG_SERIO_SERPORT: u32 = 1;
pub const CONFIG_HAVE_NMI: u32 = 1;
pub const CONFIG_RD_XZ: u32 = 1;
pub const CONFIG_AUXILIARY_BUS: u32 = 1;
pub const CONFIG_IP_MROUTE: u32 = 1;
pub const CONFIG_PREEMPT_RCU: u32 = 1;
pub const CONFIG_VGA_CONSOLE: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS: u32 = 1;
pub const CONFIG_ATA_VERBOSE_ERROR: u32 = 1;
pub const CONFIG_SND_DRIVERS: u32 = 1;
pub const CONFIG_NET_FLOW_LIMIT: u32 = 1;
pub const CONFIG_LOCKDEP_SUPPORT: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR_IDLE: u32 = 1;
pub const CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION: u32 = 1;
pub const CONFIG_NO_HZ: u32 = 1;
pub const CONFIG_ARCH_WANT_HUGE_PMD_SHARE: u32 = 1;
pub const CONFIG_POSIX_MQUEUE: u32 = 1;
pub const CONFIG_CC_HAS_WORKING_NOSANITIZE_ADDRESS: u32 = 1;
pub const CONFIG_NETFILTER_INGRESS: u32 = 1;
pub const CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE: u32 = 256;
pub const CONFIG_ARCH_MIGHT_HAVE_PC_SERIO: u32 = 1;
pub const CONFIG_GENERIC_STRNCPY_FROM_USER: u32 = 1;
pub const CONFIG_HAVE_RSEQ: u32 = 1;
pub const CONFIG_CONTEXT_TRACKING_IDLE: u32 = 1;
pub const CONFIG_CRASH_CORE: u32 = 1;
pub const CONFIG_NET_VENDOR_DEC: u32 = 1;
pub const CONFIG_INET6_ESP: u32 = 1;
pub const CONFIG_AUTOFS4_FS: u32 = 1;
pub const CONFIG_NET_NSH: u32 = 1;
pub const CONFIG_ACPI_BUTTON: u32 = 1;
pub const CONFIG_ILLEGAL_POINTER_VALUE: i64 = -2401263026318606336;
pub const CONFIG_GENERIC_GETTIMEOFDAY: u32 = 1;
pub const CONFIG_ARCH_USE_MEMTEST: u32 = 1;
pub const CONFIG_TASKSTATS: u32 = 1;
pub const CONFIG_MCB: u32 = 1;
pub const CONFIG_NET_VENDOR_PENSANDO: u32 = 1;
pub const CONFIG_IP6_NF_FILTER: u32 = 1;
pub const CONFIG_SYSTEM_DATA_VERIFICATION: u32 = 1;
pub const CONFIG_EFI_ESRT: u32 = 1;
pub const CONFIG_NEED_DMA_MAP_STATE: u32 = 1;
pub const CONFIG_SND_HDA: u32 = 1;
pub const CONFIG_SND_HDA_PREALLOC_SIZE: u32 = 0;
pub const CONFIG_YENTA_ENE_TUNE: u32 = 1;
pub const CONFIG_MOUSE_PS2_LIFEBOOK: u32 = 1;
pub const CONFIG_SERIO_LIBPS2: u32 = 1;
pub const CONFIG_X86_CPUID: u32 = 1;
pub const CONFIG_USB_PRINTER: u32 = 1;
pub const CONFIG_ACPI_PCC: u32 = 1;
pub const CONFIG_NET_VENDOR_ATHEROS: u32 = 1;
pub const CONFIG_EFI_GENERIC_STUB_INITRD_CMDLINE_LOADER: u32 = 1;
pub const CONFIG_RELOCATABLE: u32 = 1;
pub const CONFIG_QUEUED_SPINLOCKS: u32 = 1;
pub const CONFIG_TIME_NS: u32 = 1;
pub const CONFIG_NET_VENDOR_SUN: u32 = 1;
pub const CONFIG_DMIID: u32 = 1;
pub const CONFIG_ARCH_HAS_MEM_ENCRYPT: u32 = 1;
pub const CONFIG_PANIC_TIMEOUT: u32 = 0;
pub const CONFIG_QUOTA_NETLINK_INTERFACE: u32 = 1;
pub const CONFIG_INPUT_JOYSTICK: u32 = 1;
pub const CONFIG_QNX4FS_FS: u32 = 1;
pub const CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT: u32 = 1;
pub const CONFIG_HAVE_ARCH_SECCOMP: u32 = 1;
pub const CONFIG_STACKDEPOT: u32 = 1;
pub const CONFIG_CFG80211_DEFAULT_PS: u32 = 1;
pub const CONFIG_GENERIC_IOMAP: u32 = 1;
pub const CONFIG_NET_VENDOR_XILINX: u32 = 1;
pub const CONFIG_DECOMPRESS_LZ4: u32 = 1;
pub const CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK: u32 = 1;
pub const CONFIG_SMP: u32 = 1;
pub const CONFIG_NET_VENDOR_CADENCE: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROSOFT: u32 = 1;
pub const CONFIG_TTY: u32 = 1;
pub const CONFIG_HAVE_KERNEL_GZIP: u32 = 1;
pub const CONFIG_NET_VENDOR_I825XX: u32 = 1;
pub const CONFIG_PNP: u32 = 1;
pub const CONFIG_IOMMU_DMA: u32 = 1;
pub const CONFIG_RCU_EXP_CPU_STALL_TIMEOUT: u32 = 0;
pub const CONFIG_DW_DMAC_CORE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_NFLOG: u32 = 1;
pub const CONFIG_GENERIC_ALLOCATOR: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_WITH_DIRECT_CALLS: u32 = 1;
pub const CONFIG_SAMPLE_KOBJECT: u32 = 1;
pub const CONFIG_KALLSYMS_ALL: u32 = 1;
pub const CONFIG_ARCH_NR_GPIO: u32 = 1024;
pub const CONFIG_GENERIC_BUG: u32 = 1;
pub const CONFIG_CRYPTO_SHA256: u32 = 1;
pub const CONFIG_HAVE_FTRACE_MCOUNT_RECORD: u32 = 1;
pub const CONFIG_POSIX_TIMERS: u32 = 1;
pub const CONFIG_HID_SONY: u32 = 1;
pub const CONFIG_PCI_PASID: u32 = 1;
pub const CONFIG_HW_CONSOLE: u32 = 1;
pub const CONFIG_RAS: u32 = 1;
pub const CONFIG_DEVMEM: u32 = 1;
pub const CONFIG_MOUSE_PS2_FOCALTECH: u32 = 1;
pub const CONFIG_CRYPTO_LIB_SHA1: u32 = 1;
pub const CONFIG_HID_MONTEREY: u32 = 1;
pub const CONFIG_CGROUP_RDMA: u32 = 1;
pub const CONFIG_HID_EZKEY: u32 = 1;
pub const CONFIG_THERMAL_GOV_USER_SPACE: u32 = 1;
pub const CONFIG_HAVE_UID16: u32 = 1;
pub const CONFIG_SERIAL_NONSTANDARD: u32 = 1;
pub const CONFIG_COMPAT_OLD_SIGACTION: u32 = 1;
pub const CONFIG_SAMPLE_TRACE_EVENTS_MODULE: u32 = 1;
pub const CONFIG_IRQ_MSI_IOMMU: u32 = 1;
pub const CONFIG_RTC_NVMEM: u32 = 1;
pub const CONFIG_X86_FEATURE_NAMES: u32 = 1;
pub const CONFIG_QUOTACTL: u32 = 1;
pub const CONFIG_PARAVIRT: u32 = 1;
pub const CONFIG_LEGACY_VSYSCALL_XONLY: u32 = 1;
pub const CONFIG_ZSTD_COMMON: u32 = 1;
pub const CONFIG_HAVE_IOREMAP_PROT: u32 = 1;
pub const CONFIG_CC_HAS_KASAN_GENERIC: u32 = 1;
pub const CONFIG_DEBUG_KERNEL: u32 = 1;
pub const CONFIG_KASAN: u32 = 1;
pub const CONFIG_LOCALVERSION: &'static [u8; 1usize] = b"\0";
pub const CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_PAGE_TABLE_CHECK: u32 = 1;
pub const CONFIG_HAVE_PCSPKR_PLATFORM: u32 = 1;
pub const CONFIG_SYMBOLIC_ERRNAME: u32 = 1;
pub const CONFIG_CRYPTO: u32 = 1;
pub const CONFIG_NET_VENDOR_BROCADE: u32 = 1;
pub const CONFIG_DEFAULT_MMAP_MIN_ADDR: u32 = 4096;
pub const CONFIG_SYSTEM_TRUSTED_KEYS: &'static [u8; 1usize] = b"\0";
pub const CONFIG_PERF_EVENTS_INTEL_UNCORE: u32 = 1;
pub const CONFIG_SND_HDA_HWDEP: u32 = 1;
pub const CONFIG_IP_NF_IPTABLES: u32 = 1;
pub const CONFIG_NET_VENDOR_QLOGIC: u32 = 1;
pub const CONFIG_RUNTIME_TESTING_MENU: u32 = 1;
pub const CONFIG_USB_XHCI_HCD: u32 = 1;
pub const CONFIG_VIRTIO: u32 = 1;
pub const CONFIG_DEFAULT_CUBIC: u32 = 1;
pub const CONFIG_YENTA_TI: u32 = 1;
pub const CONFIG_HID_SAMSUNG: u32 = 1;
pub const CONFIG_IP_PIMSM_V2: u32 = 1;
pub const CONFIG_NET_SELFTESTS: u32 = 1;
pub const CONFIG_X86_MCE_THRESHOLD: u32 = 1;
pub const CONFIG_DMA_VIRTUAL_CHANNELS: u32 = 1;
pub const CONFIG_YENTA_O2: u32 = 1;
pub const CONFIG_GENERIC_MSI_IRQ_DOMAIN: u32 = 1;
pub const CONFIG_SND_SEQ_HRTIMER_DEFAULT: u32 = 1;
pub const CONFIG_USB_ARCH_HAS_HCD: u32 = 1;
pub const CONFIG_STRICT_DEVMEM: u32 = 1;
pub const CONFIG_PATA_OLDPIIX: u32 = 1;
pub const CONFIG_GENERIC_IRQ_SHOW: u32 = 1;
pub const CONFIG_NVMEM_SYSFS: u32 = 1;
pub const CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE: u32 = 1;
pub const CONFIG_ARCH_HAS_ELF_RANDOMIZE: u32 = 1;
pub const CONFIG_9P_FS: u32 = 1;
pub const CONFIG_NETFS_SUPPORT: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_ARG_ACCESS_API: u32 = 1;
pub const CONFIG_MD_AUTODETECT: u32 = 1;
pub const CONFIG_PANIC_ON_OOPS_VALUE: u32 = 0;
pub const CONFIG_NET_VENDOR_SAMSUNG: u32 = 1;
pub const CONFIG_INITRAMFS_PRESERVE_MTIME: u32 = 1;
pub const CONFIG_SCSI_MOD: u32 = 1;
pub const CONFIG_NET_VENDOR_MICREL: u32 = 1;
pub const CONFIG_ARCH_HAS_ADD_PAGES: u32 = 1;
pub const CONFIG_HID_ITE: u32 = 1;
pub const CONFIG_IOMMU_DEFAULT_DMA_LAZY: u32 = 1;
pub const CONFIG_CRYPTO_CRC32C: u32 = 1;
pub const CONFIG_SERIAL_CORE: u32 = 1;
pub const CONFIG_UID16: u32 = 1;
pub const CONFIG_DEBUG_PREEMPT: u32 = 1;
pub const CONFIG_HID_MICROSOFT: u32 = 1;
pub const CONFIG_PCC: u32 = 1;
pub const CONFIG_HAVE_KRETPROBES: u32 = 1;
pub const CONFIG_OBJTOOL: u32 = 1;
pub const CONFIG_ASSOCIATIVE_ARRAY: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_KMAP_LOCAL_FORCE_MAP: u32 = 1;
pub const CONFIG_NF_DEFRAG_IPV6: u32 = 1;
pub const CONFIG_MODULE_COMPRESS_NONE: u32 = 1;
pub const CONFIG_CC_HAS_ZERO_CALL_USED_REGS: u32 = 1;
pub const CONFIG_NFS_V4: u32 = 1;
pub const CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE: u32 = 1;
pub const CONFIG_MAILBOX: u32 = 1;
pub const CONFIG_INPUT_LEDS: u32 = 1;
pub const CONFIG_RCU_NEED_SEGCBLIST: u32 = 1;
pub const CONFIG_DEBUG_WX: u32 = 1;
pub const CONFIG_HAS_DMA: u32 = 1;
pub const CONFIG_DEBUG_BOOT_PARAMS: u32 = 1;
pub const CONFIG_SCSI: u32 = 1;
pub const CONFIG_HID_CHICONY: u32 = 1;
pub const CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST: u32 = 1;
pub const CONFIG_HID: u32 = 1;
pub const CONFIG_CGROUP_NET_PRIO: u32 = 1;
pub const CONFIG_RANDOM_TRUST_BOOTLOADER: u32 = 1;
pub const CONFIG_I2C_SMBUS: u32 = 1;
pub const CONFIG_FONT_8x16: u32 = 1;
pub const CONFIG_NET_VENDOR_MELLANOX: u32 = 1;
pub const CONFIG_SERIAL_8250_MANY_PORTS: u32 = 1;
pub const CONFIG_VT_CONSOLE_SLEEP: u32 = 1;
pub const CONFIG_X86_MCE_INTEL: u32 = 1;
pub const CONFIG_X86_64: u32 = 1;
pub const CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG: u32 = 1;
pub const CONFIG_RTC_DRV_CMOS: u32 = 1;
pub const CONFIG_PCI_LOCKLESS_CONFIG: u32 = 1;
pub const CONFIG_ARCH_HAS_CURRENT_STACK_POINTER: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK: u32 = 1;
pub const CONFIG_PATA_AMD: u32 = 1;
pub const CONFIG_DEBUG_STACK_USAGE: u32 = 1;
pub const CONFIG_ARCH_HAS_CACHE_LINE_SIZE: u32 = 1;
pub const CONFIG_JBD2: u32 = 1;
pub const CONFIG_SPARSEMEM_VMEMMAP: u32 = 1;
pub const CONFIG_X86_5LEVEL: u32 = 1;
pub const CONFIG_NET_VENDOR_MARVELL: u32 = 1;
pub const CONFIG_PHYLIB: u32 = 1;
pub const CONFIG_NET_VENDOR_NVIDIA: u32 = 1;
pub const CONFIG_FB_CMDLINE: u32 = 1;
pub const CONFIG_IRQ_DOMAIN: u32 = 1;
pub const CONFIG_LSM_MMAP_MIN_ADDR: u32 = 65536;
pub const CONFIG_LOCALVERSION_AUTO: u32 = 1;
pub const CONFIG_INTEGRITY_AUDIT: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_VIRTUAL: u32 = 1;
pub const CONFIG_NET_TULIP: u32 = 1;
pub const CONFIG_HAVE_ASM_MODVERSIONS: u32 = 1;
pub const CONFIG_IPC_NS: u32 = 1;
pub const CONFIG_MISC_FILESYSTEMS: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS_MIN: u32 = 28;
pub const CONFIG_FTRACE: u32 = 1;
pub const CONFIG_X86_THERMAL_VECTOR: u32 = 1;
pub const CONFIG_PERF_EVENTS_AMD_UNCORE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_LTO_CLANG: u32 = 1;
pub const CONFIG_COMPAT_32: u32 = 1;
pub const CONFIG_I2C_DEBUG_CORE: u32 = 1;
pub const CONFIG_CLOCKSOURCE_WATCHDOG: u32 = 1;
pub const CONFIG_HID_TOPSEED: u32 = 1;
pub const CONFIG_DECOMPRESS_BZIP2: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_UPROBES: u32 = 1;
pub const CONFIG_NET_VENDOR_STMICRO: u32 = 1;
pub const CONFIG_XZ_DEC_SPARC: u32 = 1;
pub const CONFIG_ARCH_SPARSEMEM_DEFAULT: u32 = 1;
pub const CONFIG_REALTEK_PHY: u32 = 1;
pub const CONFIG_PROC_VMCORE: u32 = 1;
pub const CONFIG_HID_A4TECH: u32 = 1;
pub const CONFIG_RTC_MC146818_LIB: u32 = 1;
pub const CONFIG_I2C_DEBUG_ALGO: u32 = 1;
pub const CONFIG_DST_CACHE: u32 = 1;
pub const CONFIG_UNWINDER_ORC: u32 = 1;
pub const CONFIG_NF_REJECT_IPV6: u32 = 1;
pub const CONFIG_RCU_CPU_STALL_TIMEOUT: u32 = 21;
pub const CONFIG_842_COMPRESS: u32 = 1;
pub const CONFIG_POSIX_CPU_TIMERS_TASK_WORK: u32 = 1;
pub const CONFIG_SND_VERBOSE_PROCFS: u32 = 1;
pub const CONFIG_HAVE_ARCH_COMPAT_MMAP_BASES: u32 = 1;
pub const CONFIG_LAPB: u32 = 1;
pub const CONFIG_IP_ROUTE_MULTIPATH: u32 = 1;
pub const CONFIG_INPUT_FF_MEMLESS: u32 = 1;
pub const CONFIG_PARAVIRT_CLOCK: u32 = 1;
pub const CONFIG_CHR_DEV_SG: u32 = 1;
pub const CONFIG_LLD_VERSION: u32 = 0;
pub const CONFIG_SECTION_MISMATCH_WARN_ONLY: u32 = 1;
pub const CONFIG_NETFILTER_EGRESS: u32 = 1;
pub const CONFIG_MDIO_DEVICE: u32 = 1;
pub const CONFIG_NEED_SG_DMA_LENGTH: u32 = 1;
pub const CONFIG_MODPROBE_PATH: &'static [u8; 15usize] = b"/sbin/modprobe\0";
pub const CONFIG_DRM_DISPLAY_HELPER: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_IPV6HEADER: u32 = 1;
pub const CONFIG_MMCONF_FAM10H: u32 = 1;
pub const CONFIG_PCIEASPM_DEFAULT: u32 = 1;
pub const CONFIG_PROFILING: u32 = 1;
pub const CONFIG_INTERVAL_TREE: u32 = 1;
pub const CONFIG_IOSF_MBI: u32 = 1;
pub const CONFIG_NET_VENDOR_AMAZON: u32 = 1;
pub const CONFIG_SPARSEMEM: u32 = 1;
pub const CONFIG_BLK_MQ_STACKING: u32 = 1;
pub const CONFIG_DRM_GEM_SHMEM_HELPER: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ATMEL: u32 = 1;
pub const CONFIG_GRACE_PERIOD: u32 = 1;
pub const CONFIG_NET_VENDOR_TEHUTI: u32 = 1;
pub const CONFIG_E1000E_HWTS: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER: u32 = 1;
pub const CONFIG_SCHED_SMT: u32 = 1;
pub const CONFIG_EDAC_SUPPORT: u32 = 1;
pub const CONFIG_RT_MUTEXES: u32 = 1;
pub const CONFIG_LOCK_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_KRETPROBE_ON_RETHOOK: u32 = 1;
pub const CONFIG_HUGETLBFS: u32 = 1;
pub const CONFIG_CHECK_SIGNATURE: u32 = 1;
pub const CONFIG_SLAB_MERGE_DEFAULT: u32 = 1;
pub const CONFIG_KERNFS: u32 = 1;
pub const CONFIG_I2C_ALGOBIT: u32 = 1;
pub const CONFIG_PAGE_COUNTER: u32 = 1;
pub const CONFIG_HAVE_STATIC_CALL_INLINE: u32 = 1;
pub const CONFIG_SND_PCI: u32 = 1;
pub const CONFIG_DMAR_TABLE: u32 = 1;
pub const CONFIG_ARCH_WANT_HUGETLB_PAGE_OPTIMIZE_VMEMMAP: u32 = 1;
pub const CONFIG_CFG80211_CRDA_SUPPORT: u32 = 1;
pub const CONFIG_BPFILTER: u32 = 1;
pub const CONFIG_WIRELESS: u32 = 1;
pub const CONFIG_CGROUP_MISC: u32 = 1;
pub const CONFIG_X86_IO_APIC: u32 = 1;
pub const CONFIG_ARCH_HAS_STRICT_KERNEL_RWX: u32 = 1;
pub const CONFIG_LOCK_DEBUGGING_SUPPORT: u32 = 1;
pub const CONFIG_PKCS7_MESSAGE_PARSER: u32 = 1;
pub const CONFIG_CC_HAS_SANE_STACKPROTECTOR: u32 = 1;
pub const CONFIG_TASK_IO_ACCOUNTING: u32 = 1;
pub const CONFIG_NF_LOG_SYSLOG_MODULE: u32 = 1;
pub const CONFIG_FAT_DEFAULT_IOCHARSET: &'static [u8; 10usize] = b"iso8859-1\0";
pub const CONFIG_HAVE_RUST: u32 = 1;
pub const CONFIG_FRAME_WARN: u32 = 2048;
pub const CONFIG_NET_VENDOR_AGERE: u32 = 1;
pub const CONFIG_HID_GENERIC: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS: u32 = 28;
pub const CONFIG_X86_VSYSCALL_EMULATION: u32 = 1;
pub const CONFIG_PATA_SCH: u32 = 1;
pub const CONFIG_INITRAMFS_SOURCE: &'static [u8; 1usize] = b"\0";
pub const CONFIG_RTL_CARDS: u32 = 1;
pub const CONFIG_ARCH_MHP_MEMMAP_ON_MEMORY_ENABLE: u32 = 1;
pub const CONFIG_CGROUPS: u32 = 1;
pub const CONFIG_LZO_COMPRESS: u32 = 1;
pub const CONFIG_VIRTIO_INPUT: u32 = 1;
pub const CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS: u32 = 1;
pub const CONFIG_CRYPTO_SEQIV: u32 = 1;
pub const CONFIG_ACPI_SPCR_TABLE: u32 = 1;
pub const CONFIG_SND_HDA_POWER_SAVE_DEFAULT: u32 = 0;
pub const CONFIG_HID_LOGITECH: u32 = 1;
pub const CONFIG_HAVE_GCC_PLUGINS: u32 = 1;
pub const CONFIG_DYNAMIC_EVENTS: u32 = 1;
pub const CONFIG_STACKTRACE: u32 = 1;
pub const CONFIG_HAVE_PCI: u32 = 1;
pub const CONFIG_HAVE_ACPI_APEI: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC: u32 = 1;
pub const CONFIG_CRYPTO_DRBG: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ADMTEK: u32 = 1;
pub const CONFIG_CGROUP_CPUACCT: u32 = 1;
pub const CONFIG_SND_HDA_COMPONENT: u32 = 1;
pub const CONFIG_HAS_IOPORT_MAP: u32 = 1;
pub const CONFIG_X86_CMPXCHG64: u32 = 1;
pub const CONFIG_HAVE_FAST_GUP: u32 = 1;
pub const CONFIG_VIRTIO_PCI_LIB: u32 = 1;
pub const CONFIG_NET_VENDOR_VIA: u32 = 1;
pub const CONFIG_ISA_DMA_API: u32 = 1;
pub const CONFIG_HZ: u32 = 1000;
pub const CONFIG_SERIAL_8250_SHARE_IRQ: u32 = 1;
pub const CONFIG_I2C_HELPER_AUTO: u32 = 1;
pub const CONFIG_AGP_INTEL: u32 = 1;
pub const CONFIG_SERIAL_8250_PERICOM: u32 = 1;
pub const CONFIG_SERIAL_8250_NR_UARTS: u32 = 32;
pub const CONFIG_ARCH_HAS_STRICT_MODULE_RWX: u32 = 1;
pub const CONFIG_CC_IS_GCC: u32 = 1;
pub const CONFIG_CPU_SUP_HYGON: u32 = 1;
pub const CONFIG_DMA_OPS: u32 = 1;
pub const CONFIG_NET_EGRESS: u32 = 1;
pub const CONFIG_NET_VENDOR_ARC: u32 = 1;
pub const CONFIG_SCHED_MC_PRIO: u32 = 1;
pub const CONFIG_RANDOMIZE_KSTACK_OFFSET: u32 = 1;
pub const CONFIG_HAVE_USER_RETURN_NOTIFIER: u32 = 1;
pub const CONFIG_HAVE_PERF_USER_STACK_DUMP: u32 = 1;
pub const CONFIG_CGROUP_PERF: u32 = 1;
pub const CONFIG_NLATTR: u32 = 1;
pub const CONFIG_HOTPLUG_PCI: u32 = 1;
pub const CONFIG_TCP_CONG_CUBIC: u32 = 1;
pub const CONFIG_NR_CPUS: u32 = 64;
pub const CONFIG_SUSPEND_FREEZER: u32 = 1;
pub const CONFIG_HAVE_EXIT_THREAD: u32 = 1;
pub const CONFIG_SND_SUPPORT_OLD_API: u32 = 1;
pub const CONFIG_NR_CPUS_RANGE_BEGIN: u32 = 2;
pub const CONFIG_LOGITECH_FF: u32 = 1;
pub const CONFIG_MOUSE_PS2_TRACKPOINT: u32 = 1;
pub const CONFIG_SYSFS: u32 = 1;
pub const CONFIG_USB_DEFAULT_PERSIST: u32 = 1;
pub const CONFIG_ARCH_HAS_PARANOID_L1D_FLUSH: u32 = 1;
pub const CONFIG_AS_HAS_NON_CONST_LEB128: u32 = 1;
pub const CONFIG_INPUT_TOUCHSCREEN: u32 = 1;
pub const CONFIG_DRM_PANEL_BRIDGE: u32 = 1;
pub const CONFIG_BLK_DEV_BSG_COMMON: u32 = 1;
pub const CONFIG_ASN1: u32 = 1;
pub const CONFIG_XZ_DEC_ARM: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK_OPTIONAL: u32 = 1;
pub const CONFIG_CRYPTO_HASH_INFO: u32 = 1;
pub const CONFIG_HAVE_SYSCALL_TRACEPOINTS: u32 = 1;
pub const CONFIG_HAVE_ARCH_HUGE_VMALLOC: u32 = 1;
pub const CONFIG_ACPI_BATTERY: u32 = 1;
pub const CONFIG_IO_WQ: u32 = 1;
pub const CONFIG_DECOMPRESS_ZSTD: u32 = 1;
pub const CONFIG_TRACING: u32 = 1;
pub const CONFIG_BLK_MQ_VIRTIO: u32 = 1;
pub const CONFIG_I2C_COMPAT: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ZYDAS: u32 = 1;
pub const CONFIG_SPARSEMEM_VMEMMAP_ENABLE: u32 = 1;
pub const CONFIG_HALTPOLL_CPUIDLE: u32 = 1;
pub const CONFIG_VIRTUALIZATION: u32 = 1;
pub const CONFIG_MSDOS_PARTITION: u32 = 1;
pub const CONFIG_RTC_I2C_AND_SPI: u32 = 1;
pub const CONFIG_HAVE_CONTEXT_TRACKING_USER_OFFSTACK: u32 = 1;
pub const CONFIG_HAVE_POSIX_CPU_TIMERS_TASK_WORK: u32 = 1;
pub const CONFIG_CPU_SUP_ZHAOXIN: u32 = 1;
pub const CONFIG_THERMAL: u32 = 1;
pub const CONFIG_SYNC_FILE: u32 = 1;
pub const CONFIG_USB_XHCI_PCI: u32 = 1;
pub const CONFIG_AMD_IOMMU: u32 = 1;
pub const CONFIG_IP_PNP_RARP: u32 = 1;
pub const CONFIG_NET_VENDOR_3COM: u32 = 1;
pub const CONFIG_HID_PETALYNX: u32 = 1;
pub const CONFIG_AMD_NUMA: u32 = 1;
pub const CONFIG_STACKPROTECTOR: u32 = 1;
pub const CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK: u32 = 1;
pub const CONFIG_HAVE_ARCH_KGDB: u32 = 1;
pub const CONFIG_JBD2_DEBUG: u32 = 1;
pub const CONFIG_ARCH_USE_QUEUED_SPINLOCKS: u32 = 1;
pub const CONFIG_BLK_DEBUG_FS: u32 = 1;
pub const CONFIG_X86_PM_TIMER: u32 = 1;
pub const CONFIG_X86_DEBUG_FPU: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_SCHEDUTIL: u32 = 1;
pub const CONFIG_NET_VENDOR_INTEL: u32 = 1;
pub const CONFIG_HAVE_SOFTIRQ_ON_OWN_STACK: u32 = 1;
pub const CONFIG_RPS: u32 = 1;
pub const CONFIG_SERIAL_8250_EXAR: u32 = 1;
pub const CONFIG_PROC_PID_CPUSET: u32 = 1;
pub const CONFIG_GENERIC_CSUM: u32 = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_2: u32 = 1;
pub const CONFIG_HYPERVISOR_GUEST: u32 = 1;
pub const CONFIG_ZISOFS: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MEDIATEK: u32 = 1;
pub const CONFIG_IP_MULTICAST: u32 = 1;
pub const CONFIG_GENERIC_CMOS_UPDATE: u32 = 1;
pub const CONFIG_NET_VENDOR_CISCO: u32 = 1;
pub const CONFIG_ARCH_HAS_PTE_DEVMAP: u32 = 1;
pub const CONFIG_TICK_ONESHOT: u32 = 1;
pub const CONFIG_CRYPTO_CTR: u32 = 1;
pub const CONFIG_COMPAT_FOR_U64_ALIGNMENT: u32 = 1;
pub const CONFIG_XARRAY_MULTI: u32 = 1;
pub const CONFIG_CGROUP_DEBUG: u32 = 1;
pub const CONFIG_SND_INTEL_DSP_CONFIG: u32 = 1;
pub const CONFIG_HW_RANDOM: u32 = 1;
pub const CONFIG_MUTEX_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_DYNAMIC_SIGFRAME: u32 = 1;
pub const CONFIG_RETHOOK: u32 = 1;
pub const CONFIG_EARLY_PRINTK: u32 = 1;
pub const CONFIG_CGROUP_NET_CLASSID: u32 = 1;
pub const CONFIG_HW_RANDOM_VIA: u32 = 1;
pub const CONFIG_HAVE_CMPXCHG_LOCAL: u32 = 1;
pub const CONFIG_INTEL_IOMMU_SCALABLE_MODE_DEFAULT_ON: u32 = 1;
pub const CONFIG_TREE_SRCU: u32 = 1;
pub const CONFIG_CRYPTO_NULL2: u32 = 1;
pub const CONFIG_ACPI_THERMAL: u32 = 1;
pub const CONFIG_ACPI_MDIO: u32 = 1;
pub const CONFIG_ARCH_HAS_ACPI_TABLE_UPGRADE: u32 = 1;
pub const CONFIG_HUGETLB_PAGE_OPTIMIZE_VMEMMAP: u32 = 1;
pub const CONFIG_SERIAL_8250_DMA: u32 = 1;
pub const CONFIG_BASE_SMALL: u32 = 0;
pub const CONFIG_SECURITY_SELINUX_AVC_STATS: u32 = 1;
pub const CONFIG_SND_SEQ_DUMMY: u32 = 1;
pub const CONFIG_COMPACTION: u32 = 1;
pub const CONFIG_NFS_V2: u32 = 1;
pub const CONFIG_SND_INTEL_NHLT: u32 = 1;
pub const CONFIG_PROC_FS: u32 = 1;
pub const CONFIG_GENERIC_BUG_RELATIVE_POINTERS: u32 = 1;
pub const CONFIG_MMU_GATHER_RCU_TABLE_FREE: u32 = 1;
pub const CONFIG_NET_VENDOR_ROCKER: u32 = 1;
pub const CONFIG_XFRM_AH: u32 = 1;
pub const CONFIG_SCSI_LOWLEVEL: u32 = 1;
pub const CONFIG_MEMFD_CREATE: u32 = 1;
pub const CONFIG_IRQ_FORCED_THREADING: u32 = 1;
pub const CONFIG_EDAC_ATOMIC_SCRUB: u32 = 1;
pub const CONFIG_CRYPTO_CMAC: u32 = 1;
pub const CONFIG_HID_PANTHERLORD: u32 = 1;
pub const CONFIG_SND: u32 = 1;
pub const CONFIG_LD_ORPHAN_WARN: u32 = 1;
pub const CONFIG_RFKILL_INPUT: u32 = 1;
pub const CONFIG_NET_VENDOR_NATSEMI: u32 = 1;
pub const CONFIG_VIRTIO_PCI_LIB_LEGACY: u32 = 1;
pub const CONFIG_NET_VENDOR_GOOGLE: u32 = 1;
pub const CONFIG_GENERIC_IRQ_MIGRATION: u32 = 1;
pub const CONFIG_NET_VENDOR_NETRONOME: u32 = 1;
pub const CONFIG_NFS_USE_KERNEL_DNS: u32 = 1;
pub const CONFIG_ARCH_HAS_FORTIFY_SOURCE: u32 = 1;
pub const CONFIG_GCC_VERSION: u32 = 110400;
pub const CONFIG_SND_HDA_I915: u32 = 1;
pub const CONFIG_CRYPTO_LIB_POLY1305_RSIZE: u32 = 11;
pub const CONFIG_SYSCTL: u32 = 1;
pub const CONFIG_CC_CAN_LINK_STATIC: u32 = 1;
pub const CONFIG_842_DECOMPRESS: u32 = 1;
pub const CONFIG_ARCH_HAS_GCOV_PROFILE_ALL: u32 = 1;
pub const CONFIG_PHYS_ADDR_T_64BIT: u32 = 1;
pub const CONFIG_THREAD_INFO_IN_TASK: u32 = 1;
pub const CONFIG_NET_VENDOR_LITEX: u32 = 1;
pub const CONFIG_CRYPTO_842: u32 = 1;
pub const CONFIG_HAVE_C_RECORDMCOUNT: u32 = 1;
pub const CONFIG_GENERIC_MSI_IRQ: u32 = 1;
pub const CONFIG_HAVE_ARCH_TRACEHOOK: u32 = 1;
pub const CONFIG_XFRM_USER: u32 = 1;
pub const CONFIG_DRM_I915_REQUEST_TIMEOUT: u32 = 20000;
pub const CONFIG_TASK_DELAY_ACCT: u32 = 1;
pub const CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE: u32 = 1;
pub const CONFIG_NET_NS: u32 = 1;
pub const CONFIG_HAVE_PERF_EVENTS: u32 = 1;
pub const CONFIG_ATA_SFF: u32 = 1;
pub const CONFIG_HAVE_ALIGNED_STRUCT_PAGE: u32 = 1;
pub const CONFIG_NET_VENDOR_SOLARFLARE: u32 = 1;
pub const CONFIG_CC_HAS_IBT: u32 = 1;
pub const CONFIG_DEBUG_MEMORY_INIT: u32 = 1;
pub const CONFIG_XFRM_ESP: u32 = 1;
pub const CONFIG_AUDIT: u32 = 1;
pub const CONFIG_INTEL_IOMMU: u32 = 1;
pub const CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE: u32 = 1;
pub const CONFIG_HAVE_RETHOOK: u32 = 1;
pub const CONFIG_NET_9P_FD: u32 = 1;
pub const CONFIG_LTO_NONE: u32 = 1;
pub const CONFIG_PCIEASPM: u32 = 1;
pub const CONFIG_DEBUG_FS_ALLOW_ALL: u32 = 1;
pub const CONFIG_ATA_PIIX: u32 = 1;
pub const CONFIG_KASAN_OUTLINE: u32 = 1;
pub const CONFIG_SATA_AHCI: u32 = 1;
pub const CONFIG_HAVE_STATIC_CALL: u32 = 1;
pub const CONFIG_SECURITY: u32 = 1;
pub const CONFIG_OPTPROBES: u32 = 1;
pub const CONFIG_ACPI_NUMA: u32 = 1;
pub const CONFIG_SND_TIMER: u32 = 1;
pub const CONFIG_USB_EHCI_TT_NEWSCHED: u32 = 1;
pub const CONFIG_FAT_DEFAULT_CODEPAGE: u32 = 437;
pub const CONFIG_BLK_DEV: u32 = 1;
pub const CONFIG_SERIO_I8042: u32 = 1;
pub const CONFIG_MAC80211_RC_DEFAULT: &'static [u8; 12usize] = b"minstrel_ht\0";
pub const CONFIG_NFS_ACL_SUPPORT: u32 = 1;
pub const CONFIG_CC_HAS_ASM_GOTO_TIED_OUTPUT: u32 = 1;
pub const CONFIG_HAVE_ARCH_KFENCE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_SILABS: u32 = 1;
pub const CONFIG_IOMMU_API: u32 = 1;
pub const CONFIG_TRACING_SUPPORT: u32 = 1;
pub const CONFIG_UNIX98_PTYS: u32 = 1;
pub const CONFIG_NET_RX_BUSY_POLL: u32 = 1;
pub const CONFIG_NET_VENDOR_SOCIONEXT: u32 = 1;
pub const CONFIG_SECURITY_SELINUX: u32 = 1;
pub const CONFIG_ZONE_DMA32: u32 = 1;
pub const CONFIG_NET_SCHED: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CONNSECMARK: u32 = 1;
pub const CONFIG_DRM_PANEL: u32 = 1;
pub const CONFIG_PRINTK_TIME: u32 = 1;
pub const CONFIG_TRACE_IRQFLAGS_NMI_SUPPORT: u32 = 1;
pub const CONFIG_TASKS_RCU_GENERIC: u32 = 1;
pub const CONFIG_SECCOMP_FILTER: u32 = 1;
pub const CONFIG_ARCH_MAY_HAVE_PC_FDC: u32 = 1;
pub const CONFIG_HAVE_KERNEL_LZO: u32 = 1;
pub const CONFIG_CRYPTO_GHASH: u32 = 1;
pub const CONFIG_GENERIC_ENTRY: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_SIDTAB_HASH_BITS: u32 = 9;
pub const CONFIG_NF_NAT_FTP: u32 = 1;
pub const CONFIG_MAC80211_RC_MINSTREL: u32 = 1;
pub const CONFIG_ELF_CORE: u32 = 1;
pub const CONFIG_ACPI_DOCK: u32 = 1;
pub const CONFIG_HAVE_CONTEXT_TRACKING_USER: u32 = 1;
pub const CONFIG_USB_SUPPORT: u32 = 1;
pub const CONFIG_MODIFY_LDT_SYSCALL: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ST: u32 = 1;
pub const CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS: u32 = 1;
pub const CONFIG_NET_VENDOR_SIS: u32 = 1;
pub const CONFIG_VT_CONSOLE: u32 = 1;
pub const CONFIG_SCHED_INFO: u32 = 1;
pub const CONFIG_MQ_IOSCHED_KYBER: u32 = 1;
pub const CONFIG_AS_VERSION: u32 = 23800;
pub const CONFIG_CC_HAS_INT128: u32 = 1;
pub const CONFIG_EFI_EARLYCON: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MARVELL: u32 = 1;
pub const CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE: u32 = 1;
pub const CONFIG_SERIAL_8250_DWLIB: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS: u32 = 8;
pub const CONFIG_NETFILTER_XT_MATCH_STATE: u32 = 1;
pub const CONFIG_PCI_DIRECT: u32 = 1;
pub const CONFIG_DRM: u32 = 1;
pub const CONFIG_DRM_I915_FORCE_PROBE: &'static [u8; 1usize] = b"\0";
pub const CONFIG_POSIX_MQUEUE_SYSCTL: u32 = 1;
pub const CONFIG_DRM_I915_TIMESLICE_DURATION: u32 = 1;
pub const CONFIG_VHOST_MENU: u32 = 1;
pub const CONFIG_DEBUG_MISC: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROSEMI: u32 = 1;
pub const CONFIG_BINARY_PRINTF: u32 = 1;
pub const CONFIG_ACPI_REV_OVERRIDE_POSSIBLE: u32 = 1;
pub const CONFIG_HAVE_PREEMPT_DYNAMIC_CALL: u32 = 1;
pub const CONFIG_AS_AVX512: u32 = 1;
pub const CONFIG_HARDLOCKUP_CHECK_TIMESTAMP: u32 = 1;
pub const CONFIG_SCHED_CLUSTER: u32 = 1;
pub const CONFIG_ZSTD_DECOMPRESS: u32 = 1;
pub const CONFIG_INPUT_SPARSEKMAP: u32 = 1;
pub const CONFIG_PTDUMP_CORE: u32 = 1;
pub const CONFIG_SYSFS_SYSCALL: u32 = 1;
pub const CONFIG_WLAN_VENDOR_QUANTENNA: u32 = 1;
pub const CONFIG_SND_PCM_TIMER: u32 = 1;
pub const CONFIG_ARCH_HAS_SET_DIRECT_MAP: u32 = 1;
pub const CONFIG_SYSVIPC_SYSCTL: u32 = 1;
pub const CONFIG_WLAN_VENDOR_TI: u32 = 1;
pub const CONFIG_HID_NTRIG: u32 = 1;
pub const CONFIG_X86_64_ACPI_NUMA: u32 = 1;
pub const CONFIG_DMA_SHARED_BUFFER: u32 = 1;
pub const CONFIG_RTC_SYSTOHC: u32 = 1;
pub const CONFIG_DECOMPRESS_GZIP: u32 = 1;
pub const CONFIG_VIRTIO_MENU: u32 = 1;
pub const CONFIG_VIRTIO_BLK: u32 = 1;
pub const CONFIG_DECOMPRESS_LZO: u32 = 1;
pub const CONFIG_64BIT: u32 = 1;
pub const CONFIG_QUOTA: u32 = 1;
pub const CONFIG_I2C_CHARDEV: u32 = 1;
pub const CONFIG_HAVE_JUMP_LABEL_HACK: u32 = 1;
pub const CONFIG_ARCH_USE_QUEUED_RWLOCKS: u32 = 1;
pub const CONFIG_ARCH_HAS_PKEYS: u32 = 1;
pub const CONFIG_NETWORK_SECMARK: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS_BROADCAST: u32 = 1;
pub const CONFIG_POWER_SUPPLY_HWMON: u32 = 1;
pub const CONFIG_ARCH_HAS_ELFCORE_COMPAT: u32 = 1;
pub const CONFIG_SERIAL_8250_PCI: u32 = 1;
pub const CONFIG_HAVE_MIXED_BREAKPOINTS_REGS: u32 = 1;
pub const CONFIG_MOUSE_PS2_SYNAPTICS: u32 = 1;
pub const CONFIG_ATA_BMDMA: u32 = 1;
pub const CONFIG_XZ_DEC_ARMTHUMB: u32 = 1;
pub const CONFIG_ARCH_USE_CMPXCHG_LOCKREF: u32 = 1;
pub const CONFIG_REGMAP: u32 = 1;
pub const CONFIG_NLS_UTF8: u32 = 1;
pub const CONFIG_PCIE_PME: u32 = 1;
pub const CONFIG_HAVE_MOD_ARCH_SPECIFIC: u32 = 1;
pub const CONFIG_STRICT_MODULE_RWX: u32 = 1;
pub const CONFIG_PCCARD_NONSTATIC: u32 = 1;
pub const CONFIG_PROC_PID_ARCH_STATUS: u32 = 1;
pub const CONFIG_CPU_SUP_CENTAUR: u32 = 1;
pub const CONFIG_HAVE_INTEL_TXT: u32 = 1;
pub const CONFIG_SYSCTL_EXCEPTION_TRACE: u32 = 1;
pub const CONFIG_SYSVIPC_COMPAT: u32 = 1;
pub const CONFIG_FHANDLE: u32 = 1;
pub const CONFIG_HAVE_SAMPLE_FTRACE_DIRECT_MULTI: u32 = 1;
pub const CONFIG_WATCHDOG_OPEN_TIMEOUT: u32 = 0;
pub const CONFIG_BPFILTER_UMH_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LIB_SHA256: u32 = 1;
pub const CONFIG_NEW_LEDS: u32 = 1;
pub const CONFIG_SWAP: u32 = 1;
pub const CONFIG_FW_CACHE: u32 = 1;
pub const CONFIG_MICROCODE_INTEL: u32 = 1;
pub const CONFIG_MAC80211: u32 = 1;
pub const CONFIG_ARCH_USES_PG_UNCACHED: u32 = 1;
pub const CONFIG_CRC_CCITT: u32 = 1;
pub const CONFIG_NET_VENDOR_CAVIUM: u32 = 1;
pub const CONFIG_IGBVF: u32 = 1;
pub const CONFIG_BLK_DEV_SD: u32 = 1;
pub const CONFIG_PHYSICAL_ALIGN: u32 = 2097152;
pub const CONFIG_ACPI_LEGACY_TABLES_LOOKUP: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK: u32 = 1;
pub const CONFIG_MODULE_UNLOAD: u32 = 1;
pub const CONFIG_CLOCKSOURCE_WATCHDOG_MAX_SKEW_US: u32 = 100;
pub const CONFIG_PREEMPT_COUNT: u32 = 1;
pub const CONFIG_NET_VENDOR_ENGLEDER: u32 = 1;
pub const CONFIG_HAVE_ACPI_APEI_NMI: u32 = 1;
pub const CONFIG_ARCH_WANT_OLD_COMPAT_IPC: u32 = 1;
pub const CONFIG_STACKDEPOT_ALWAYS_INIT: u32 = 1;
pub const CONFIG_RWSEM_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_HAVE_RELIABLE_STACKTRACE: u32 = 1;
pub const CONFIG_HAVE_NOINSTR_HACK: u32 = 1;
pub const CONFIG_CC_HAS_ASM_GOTO_OUTPUT: u32 = 1;
pub const CONFIG_BITREVERSE: u32 = 1;
pub const CONFIG_DEVPORT: u32 = 1;
pub const CONFIG_PREEMPTION: u32 = 1;
pub const CONFIG_DRM_I915_COMPRESS_ERROR: u32 = 1;
pub const CONFIG_X509_CERTIFICATE_PARSER: u32 = 1;
pub const CONFIG_EARLY_PRINTK_USB: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK_KVM: u32 = 1;
pub const CONFIG_SPECULATION_MITIGATIONS: u32 = 1;
pub const CONFIG_PCI_PRI: u32 = 1;
pub const CONFIG_X86_L1_CACHE_SHIFT: u32 = 6;
pub const CONFIG_X86_PAT: u32 = 1;
pub const CONFIG_PNP_DEBUG_MESSAGES: u32 = 1;
pub const CONFIG_NF_CONNTRACK: u32 = 1;
pub const CONFIG_IOASID: u32 = 1;
pub const CONFIG_EFI_RUNTIME_WRAPPERS: u32 = 1;
pub const CONFIG_MDIO_DEVRES: u32 = 1;
pub const CONFIG_LSM: &'static [u8; 85usize] =
    b"landlock,lockdown,yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor,bpf\0";
pub const CONFIG_ARCH_DMA_ADDR_T_64BIT: u32 = 1;
pub const CONFIG_FILE_LOCKING: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST: u32 = 1;
pub const CONFIG_NETPOLL: u32 = 1;
pub const CONFIG_AIO: u32 = 1;
pub const CONFIG_CLKEVT_I8253: u32 = 1;
pub const CONFIG_NET_EMATCH: u32 = 1;
pub const CONFIG_PERF_EVENTS: u32 = 1;
pub const CONFIG_GENERIC_TIME_VSYSCALL: u32 = 1;
pub const CONFIG_IP_NF_TARGET_REJECT: u32 = 1;
pub const CONFIG_HAVE_MOVE_PMD: u32 = 1;
pub const CONFIG_IOMMU_IO_PGTABLE: u32 = 1;
pub const CONFIG_LEDS_CLASS: u32 = 1;
pub const CONFIG_PERF_EVENTS_INTEL_CSTATE: u32 = 1;
pub const CONFIG_KALLSYMS_BASE_RELATIVE: u32 = 1;
pub const CONFIG_RTC_INTF_DEV: u32 = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_4: u32 = 1;
pub const CONFIG_EISA_VIRTUAL_ROOT: u32 = 1;
pub const CONFIG_DCACHE_WORD_ACCESS: u32 = 1;
pub const CONFIG_MAGIC_SYSRQ_SERIAL_SEQUENCE: &'static [u8; 1usize] = b"\0";
pub const CONFIG_MESSAGE_LOGLEVEL_DEFAULT: u32 = 4;
pub const CONFIG_AMD_NB: u32 = 1;
pub const CONFIG_NLS_DEFAULT: &'static [u8; 5usize] = b"utf8\0";
pub const CONFIG_ACPI_CONTAINER: u32 = 1;
pub const CONFIG_SND_DMA_SGBUF: u32 = 1;
pub const CONFIG_UTS_NS: u32 = 1;
pub const CONFIG_WMI_BMOF: u32 = 1;
pub const CONFIG_NF_CT_NETLINK: u32 = 1;
pub const CONFIG_EFS_FS: u32 = 1;
pub const CONFIG_DMA_ENGINE: u32 = 1;
pub const CONFIG_X86_ACPI_CPUFREQ: u32 = 1;
pub const CONFIG_DEFAULT_SECURITY_SELINUX: u32 = 1;
pub const CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD: u32 = 1;
pub const CONFIG_CGROUP_PIDS: u32 = 1;
pub const CONFIG_DEBUG_INFO: u32 = 1;
pub const CONFIG_CRYPTO_AEAD2: u32 = 1;
pub const CONFIG_X86_HV_CALLBACK_VECTOR: u32 = 1;
pub const CONFIG_MOUSE_PS2: u32 = 1;
pub const CONFIG_CRYPTO_ALGAPI2: u32 = 1;
pub const CONFIG_PHYSICAL_START: u32 = 16777216;
pub const CONFIG_GENERIC_IRQ_RESERVATION_MODE: u32 = 1;
pub const CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS: u32 = 1;
pub const CONFIG_INPUT: u32 = 1;
pub const CONFIG_SIOX: u32 = 1;
pub const CONFIG_PROC_SYSCTL: u32 = 1;
pub const CONFIG_FWNODE_MDIO: u32 = 1;
pub const CONFIG_HAVE_PERF_EVENTS_NMI: u32 = 1;
pub const CONFIG_RD_LZ4: u32 = 1;
pub const CONFIG_MMU: u32 = 1;
pub const CONFIG_LD_VERSION: u32 = 23800;
pub const CONFIG_AGP: u32 = 1;
pub const CONFIG_CC_HAS_SLS: u32 = 1;
pub const CONFIG_E1000: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __ARG_PLACEHOLDER_1: u32 = 0;
pub const KASAN_ABI_VERSION: u32 = 5;
pub const __BITS_PER_LONG: u32 = 64;
pub const BITS_PER_LONG: u32 = 64;
pub const BITS_PER_LONG_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const KCSAN_ACCESS_WRITE: u32 = 1;
pub const KCSAN_ACCESS_COMPOUND: u32 = 2;
pub const KCSAN_ACCESS_ATOMIC: u32 = 4;
pub const KCSAN_ACCESS_ASSERT: u32 = 8;
pub const KCSAN_ACCESS_SCOPED: u32 = 16;
pub const UNWIND_HINT_TYPE_CALL: u32 = 0;
pub const UNWIND_HINT_TYPE_REGS: u32 = 1;
pub const UNWIND_HINT_TYPE_REGS_PARTIAL: u32 = 2;
pub const UNWIND_HINT_TYPE_FUNC: u32 = 3;
pub const UNWIND_HINT_TYPE_ENTRY: u32 = 4;
pub const UNWIND_HINT_TYPE_SAVE: u32 = 5;
pub const UNWIND_HINT_TYPE_RESTORE: u32 = 6;
pub const EX_DATA_REG_SHIFT: u32 = 8;
pub const EX_DATA_FLAG_SHIFT: u32 = 12;
pub const EX_DATA_IMM_SHIFT: u32 = 16;
pub const EX_TYPE_NONE: u32 = 0;
pub const EX_TYPE_DEFAULT: u32 = 1;
pub const EX_TYPE_FAULT: u32 = 2;
pub const EX_TYPE_UACCESS: u32 = 3;
pub const EX_TYPE_COPY: u32 = 4;
pub const EX_TYPE_CLEAR_FS: u32 = 5;
pub const EX_TYPE_FPU_RESTORE: u32 = 6;
pub const EX_TYPE_BPF: u32 = 7;
pub const EX_TYPE_WRMSR: u32 = 8;
pub const EX_TYPE_RDMSR: u32 = 9;
pub const EX_TYPE_WRMSR_SAFE: u32 = 10;
pub const EX_TYPE_RDMSR_SAFE: u32 = 11;
pub const EX_TYPE_WRMSR_IN_MCE: u32 = 12;
pub const EX_TYPE_RDMSR_IN_MCE: u32 = 13;
pub const EX_TYPE_DEFAULT_MCE_SAFE: u32 = 14;
pub const EX_TYPE_FAULT_MCE_SAFE: u32 = 15;
pub const EX_TYPE_POP_REG: u32 = 16;
pub const EX_TYPE_IMM_REG: u32 = 17;
pub const EX_TYPE_FAULT_SGX: u32 = 18;
pub const EX_TYPE_UCOPY_LEN: u32 = 19;
pub const EX_TYPE_ZEROPAD: u32 = 20;
pub const DEFINE_EXTABLE_TYPE_REG : & 'static [u8 ; 533usize] = b".macro extable_type_reg type:req reg:req\n.set .Lfound, 0\n.set .Lregnr, 0\n.irp rs,rax,rcx,rdx,rbx,rsp,rbp,rsi,rdi,r8,r9,r10,r11,r12,r13,r14,r15\n.ifc \\reg, %%\\rs\n.set .Lfound, .Lfound+1\n.long \\type + (.Lregnr << 8)\n.endif\n.set .Lregnr, .Lregnr+1\n.endr\n.set .Lregnr, 0\n.irp rs,eax,ecx,edx,ebx,esp,ebp,esi,edi,r8d,r9d,r10d,r11d,r12d,r13d,r14d,r15d\n.ifc \\reg, %%\\rs\n.set .Lfound, .Lfound+1\n.long \\type + (.Lregnr << 8)\n.endif\n.set .Lregnr, .Lregnr+1\n.endr\n.if (.Lfound != 1)\n.error \"extable_type_reg: bad register argument\"\n.endif\n.endm\n\0" ;
pub const UNDEFINE_EXTABLE_TYPE_REG: &'static [u8; 26usize] = b".purgem extable_type_reg\n\0";
pub const ASM_REACHABLE: &'static [u8; 69usize] =
    b"998:\n\t.pushsection .discard.reachable\n\t.long 998b - .\n\t.popsection\n\t\0";
pub const ASM_UD2: &'static [u8; 17usize] = b".byte 0x0f, 0x0b\0";
pub const INSN_UD2: u32 = 2831;
pub const LEN_UD2: u32 = 2;
pub const CUT_HERE: &'static [u8; 38usize] = b"------------[ cut here ]------------\n\0";
pub const BUGFLAG_WARNING: u32 = 1;
pub const BUGFLAG_ONCE: u32 = 2;
pub const BUGFLAG_DONE: u32 = 4;
pub const BUGFLAG_NO_CUT_HERE: u32 = 8;
pub const PANIC_CPU_INVALID: i32 = -1;
pub const TAINT_PROPRIETARY_MODULE: u32 = 0;
pub const TAINT_FORCED_MODULE: u32 = 1;
pub const TAINT_CPU_OUT_OF_SPEC: u32 = 2;
pub const TAINT_FORCED_RMMOD: u32 = 3;
pub const TAINT_MACHINE_CHECK: u32 = 4;
pub const TAINT_BAD_PAGE: u32 = 5;
pub const TAINT_USER: u32 = 6;
pub const TAINT_DIE: u32 = 7;
pub const TAINT_OVERRIDDEN_ACPI_TABLE: u32 = 8;
pub const TAINT_WARN: u32 = 9;
pub const TAINT_CRAP: u32 = 10;
pub const TAINT_FIRMWARE_WORKAROUND: u32 = 11;
pub const TAINT_OOT_MODULE: u32 = 12;
pub const TAINT_UNSIGNED_MODULE: u32 = 13;
pub const TAINT_SOFTLOCKUP: u32 = 14;
pub const TAINT_LIVEPATCH: u32 = 15;
pub const TAINT_AUX: u32 = 16;
pub const TAINT_RANDSTRUCT: u32 = 17;
pub const TAINT_TEST: u32 = 18;
pub const TAINT_FLAGS_COUNT: u32 = 19;
pub const TAINT_FLAGS_MAX: u32 = 524287;
pub const KERN_SOH: &'static [u8; 2usize] = b"\x01\0";
pub const KERN_SOH_ASCII: u8 = 1u8;
pub const KERN_EMERG: &'static [u8; 3usize] = b"\x010\0";
pub const KERN_ALERT: &'static [u8; 3usize] = b"\x011\0";
pub const KERN_CRIT: &'static [u8; 3usize] = b"\x012\0";
pub const KERN_ERR: &'static [u8; 3usize] = b"\x013\0";
pub const KERN_WARNING: &'static [u8; 3usize] = b"\x014\0";
pub const KERN_NOTICE: &'static [u8; 3usize] = b"\x015\0";
pub const KERN_INFO: &'static [u8; 3usize] = b"\x016\0";
pub const KERN_DEBUG: &'static [u8; 3usize] = b"\x017\0";
pub const KERN_DEFAULT: &'static [u8; 1usize] = b"\0";
pub const KERN_CONT: &'static [u8; 3usize] = b"\x01c\0";
pub const LOGLEVEL_SCHED: i32 = -2;
pub const LOGLEVEL_DEFAULT: i32 = -1;
pub const LOGLEVEL_EMERG: u32 = 0;
pub const LOGLEVEL_ALERT: u32 = 1;
pub const LOGLEVEL_CRIT: u32 = 2;
pub const LOGLEVEL_ERR: u32 = 3;
pub const LOGLEVEL_WARNING: u32 = 4;
pub const LOGLEVEL_NOTICE: u32 = 5;
pub const LOGLEVEL_INFO: u32 = 6;
pub const LOGLEVEL_DEBUG: u32 = 7;
pub const HAS_KERNEL_IBT: u32 = 0;
pub const ENDBR_INSN_SIZE: u32 = 0;
pub const ASM_RET: &'static [u8; 25usize] = b"jmp __x86_return_thunk\n\t\0";
pub const __ALIGN_STR: &'static [u8; 14usize] = b".align 4,0x90\0";
pub const BITS_PER_BYTE: u32 = 8;
pub const HZ: u32 = 100;
pub const EXEC_PAGESIZE: u32 = 4096;
pub const NOGROUP: i32 = -1;
pub const MAXHOSTNAMELEN: u32 = 64;
pub const USER_HZ: u32 = 100;
pub const CLOCKS_PER_SEC: u32 = 100;
pub const _Q_LOCKED_OFFSET: u32 = 0;
pub const _Q_LOCKED_BITS: u32 = 8;
pub const _Q_PENDING_OFFSET: u32 = 8;
pub const _Q_PENDING_BITS: u32 = 8;
pub const _Q_TAIL_IDX_OFFSET: u32 = 16;
pub const _Q_TAIL_IDX_BITS: u32 = 2;
pub const _Q_TAIL_CPU_OFFSET: u32 = 18;
pub const _Q_TAIL_CPU_BITS: u32 = 14;
pub const _Q_TAIL_OFFSET: u32 = 16;
pub const _Q_LOCKED_VAL: u32 = 1;
pub const _Q_PENDING_VAL: u32 = 256;
pub const MAX_LOCKDEP_SUBCLASSES: u32 = 8;
pub const SPINLOCK_MAGIC: u32 = 3735899821;
pub const DEFAULT_RATELIMIT_INTERVAL: u32 = 5000;
pub const DEFAULT_RATELIMIT_BURST: u32 = 10;
pub const PRINTK_MAX_SINGLE_HEADER_LEN: u32 = 2;
pub const CONSOLE_EXT_LOG_MAX: u32 = 8192;
pub const MESSAGE_LOGLEVEL_DEFAULT: u32 = 4;
pub const CONSOLE_LOGLEVEL_SILENT: u32 = 0;
pub const CONSOLE_LOGLEVEL_MIN: u32 = 1;
pub const CONSOLE_LOGLEVEL_DEBUG: u32 = 10;
pub const CONSOLE_LOGLEVEL_MOTORMOUTH: u32 = 15;
pub const CONSOLE_LOGLEVEL_DEFAULT: u32 = 7;
pub const CONSOLE_LOGLEVEL_QUIET: u32 = 4;
pub const DEVKMSG_STR_MAX_SIZE: u32 = 10;
pub const FW_BUG: &'static [u8; 17usize] = b"[Firmware Bug]: \0";
pub const FW_WARN: &'static [u8; 18usize] = b"[Firmware Warn]: \0";
pub const FW_INFO: &'static [u8; 18usize] = b"[Firmware Info]: \0";
pub const HW_ERR: &'static [u8; 19usize] = b"[Hardware Error]: \0";
pub const DEPRECATED: &'static [u8; 15usize] = b"[Deprecated]: \0";
pub const BYTES_NOP1: u32 = 144;
pub const ASM_NOP_MAX: u32 = 8;
pub const JUMP_TYPE_FALSE: u32 = 0;
pub const JUMP_TYPE_TRUE: u32 = 1;
pub const JUMP_TYPE_LINKED: u32 = 2;
pub const JUMP_TYPE_MASK: u32 = 3;
pub const CLS_BITS: u32 = 6;
pub const _DPRINTK_CLASS_DFLT: u32 = 63;
pub const _DPRINTK_FLAGS_NONE: u32 = 0;
pub const _DPRINTK_FLAGS_PRINT: u32 = 1;
pub const _DPRINTK_FLAGS_INCL_MODNAME: u32 = 2;
pub const _DPRINTK_FLAGS_INCL_FUNCNAME: u32 = 4;
pub const _DPRINTK_FLAGS_INCL_LINENO: u32 = 8;
pub const _DPRINTK_FLAGS_INCL_TID: u32 = 16;
pub const _DPRINTK_FLAGS_INCL_ANY: u32 = 30;
pub const _DPRINTK_FLAGS_DEFAULT: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const MAX_ERRNO: u32 = 4095;
pub const ERESTARTSYS: u32 = 512;
pub const ERESTARTNOINTR: u32 = 513;
pub const ERESTARTNOHAND: u32 = 514;
pub const ENOIOCTLCMD: u32 = 515;
pub const ERESTART_RESTARTBLOCK: u32 = 516;
pub const EPROBE_DEFER: u32 = 517;
pub const EOPENSTALE: u32 = 518;
pub const ENOPARAM: u32 = 519;
pub const EBADHANDLE: u32 = 521;
pub const ENOTSYNC: u32 = 522;
pub const EBADCOOKIE: u32 = 523;
pub const ENOTSUPP: u32 = 524;
pub const ETOOSMALL: u32 = 525;
pub const ESERVERFAULT: u32 = 526;
pub const EBADTYPE: u32 = 527;
pub const EJUKEBOX: u32 = 528;
pub const EIOCBQUEUED: u32 = 529;
pub const ERECALLCONFLICT: u32 = 530;
pub const ENOGRACE: u32 = 531;
pub const __HAVE_ARCH_MEMCPY: u32 = 1;
pub const __HAVE_ARCH_MEMCPY_FLUSHCACHE: u32 = 1;
pub const SETUP_NONE: u32 = 0;
pub const SETUP_E820_EXT: u32 = 1;
pub const SETUP_DTB: u32 = 2;
pub const SETUP_PCI: u32 = 3;
pub const SETUP_EFI: u32 = 4;
pub const SETUP_APPLE_PROPERTIES: u32 = 5;
pub const SETUP_JAILHOUSE: u32 = 6;
pub const SETUP_CC_BLOB: u32 = 7;
pub const SETUP_IMA: u32 = 8;
pub const SETUP_RNG_SEED: u32 = 9;
pub const SETUP_ENUM_MAX: u32 = 9;
pub const SETUP_INDIRECT: u32 = 2147483648;
pub const SETUP_TYPE_MAX: u32 = 2147483657;
pub const RAMDISK_IMAGE_START_MASK: u32 = 2047;
pub const RAMDISK_PROMPT_FLAG: u32 = 32768;
pub const RAMDISK_LOAD_FLAG: u32 = 16384;
pub const LOADED_HIGH: u32 = 1;
pub const KASLR_FLAG: u32 = 2;
pub const QUIET_FLAG: u32 = 32;
pub const KEEP_SEGMENTS: u32 = 64;
pub const CAN_USE_HEAP: u32 = 128;
pub const XLF_KERNEL_64: u32 = 1;
pub const XLF_CAN_BE_LOADED_ABOVE_4G: u32 = 2;
pub const XLF_EFI_HANDOVER_32: u32 = 4;
pub const XLF_EFI_HANDOVER_64: u32 = 8;
pub const XLF_EFI_KEXEC: u32 = 16;
pub const XLF_5LEVEL: u32 = 32;
pub const XLF_5LEVEL_ENABLED: u32 = 64;
pub const VIDEO_TYPE_MDA: u32 = 16;
pub const VIDEO_TYPE_CGA: u32 = 17;
pub const VIDEO_TYPE_EGAM: u32 = 32;
pub const VIDEO_TYPE_EGAC: u32 = 33;
pub const VIDEO_TYPE_VGAC: u32 = 34;
pub const VIDEO_TYPE_VLFB: u32 = 35;
pub const VIDEO_TYPE_PICA_S3: u32 = 48;
pub const VIDEO_TYPE_MIPS_G364: u32 = 49;
pub const VIDEO_TYPE_SGI: u32 = 51;
pub const VIDEO_TYPE_TGAC: u32 = 64;
pub const VIDEO_TYPE_SUN: u32 = 80;
pub const VIDEO_TYPE_SUNPCI: u32 = 81;
pub const VIDEO_TYPE_PMAC: u32 = 96;
pub const VIDEO_TYPE_EFI: u32 = 112;
pub const VIDEO_FLAGS_NOCURSOR: u32 = 1;
pub const VIDEO_CAPABILITY_SKIP_QUIRKS: u32 = 1;
pub const VIDEO_CAPABILITY_64BIT_BASE: u32 = 2;
pub const APM_STATE_READY: u32 = 0;
pub const APM_STATE_STANDBY: u32 = 1;
pub const APM_STATE_SUSPEND: u32 = 2;
pub const APM_STATE_OFF: u32 = 3;
pub const APM_STATE_BUSY: u32 = 4;
pub const APM_STATE_REJECT: u32 = 5;
pub const APM_STATE_OEM_SYS: u32 = 32;
pub const APM_STATE_OEM_DEV: u32 = 64;
pub const APM_STATE_DISABLE: u32 = 0;
pub const APM_STATE_ENABLE: u32 = 1;
pub const APM_STATE_DISENGAGE: u32 = 0;
pub const APM_STATE_ENGAGE: u32 = 1;
pub const APM_SYS_STANDBY: u32 = 1;
pub const APM_SYS_SUSPEND: u32 = 2;
pub const APM_NORMAL_RESUME: u32 = 3;
pub const APM_CRITICAL_RESUME: u32 = 4;
pub const APM_LOW_BATTERY: u32 = 5;
pub const APM_POWER_STATUS_CHANGE: u32 = 6;
pub const APM_UPDATE_TIME: u32 = 7;
pub const APM_CRITICAL_SUSPEND: u32 = 8;
pub const APM_USER_STANDBY: u32 = 9;
pub const APM_USER_SUSPEND: u32 = 10;
pub const APM_STANDBY_RESUME: u32 = 11;
pub const APM_CAPABILITY_CHANGE: u32 = 12;
pub const APM_USER_HIBERNATION: u32 = 13;
pub const APM_HIBERNATION_RESUME: u32 = 14;
pub const APM_SUCCESS: u32 = 0;
pub const APM_DISABLED: u32 = 1;
pub const APM_CONNECTED: u32 = 2;
pub const APM_NOT_CONNECTED: u32 = 3;
pub const APM_16_CONNECTED: u32 = 5;
pub const APM_16_UNSUPPORTED: u32 = 6;
pub const APM_32_CONNECTED: u32 = 7;
pub const APM_32_UNSUPPORTED: u32 = 8;
pub const APM_BAD_DEVICE: u32 = 9;
pub const APM_BAD_PARAM: u32 = 10;
pub const APM_NOT_ENGAGED: u32 = 11;
pub const APM_BAD_FUNCTION: u32 = 12;
pub const APM_RESUME_DISABLED: u32 = 13;
pub const APM_NO_ERROR: u32 = 83;
pub const APM_BAD_STATE: u32 = 96;
pub const APM_NO_EVENTS: u32 = 128;
pub const APM_NOT_PRESENT: u32 = 134;
pub const APM_DEVICE_BIOS: u32 = 0;
pub const APM_DEVICE_ALL: u32 = 1;
pub const APM_DEVICE_DISPLAY: u32 = 256;
pub const APM_DEVICE_STORAGE: u32 = 512;
pub const APM_DEVICE_PARALLEL: u32 = 768;
pub const APM_DEVICE_SERIAL: u32 = 1024;
pub const APM_DEVICE_NETWORK: u32 = 1280;
pub const APM_DEVICE_PCMCIA: u32 = 1536;
pub const APM_DEVICE_BATTERY: u32 = 32768;
pub const APM_DEVICE_OEM: u32 = 57344;
pub const APM_DEVICE_OLD_ALL: u32 = 65535;
pub const APM_DEVICE_CLASS: u32 = 255;
pub const APM_DEVICE_MASK: u32 = 65280;
pub const APM_MAX_BATTERIES: u32 = 2;
pub const APM_CAP_GLOBAL_STANDBY: u32 = 1;
pub const APM_CAP_GLOBAL_SUSPEND: u32 = 2;
pub const APM_CAP_RESUME_STANDBY_TIMER: u32 = 4;
pub const APM_CAP_RESUME_SUSPEND_TIMER: u32 = 8;
pub const APM_CAP_RESUME_STANDBY_RING: u32 = 16;
pub const APM_CAP_RESUME_SUSPEND_RING: u32 = 32;
pub const APM_CAP_RESUME_STANDBY_PCMCIA: u32 = 64;
pub const APM_CAP_RESUME_SUSPEND_PCMCIA: u32 = 128;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const APM_16_BIT_SUPPORT: u32 = 1;
pub const APM_32_BIT_SUPPORT: u32 = 2;
pub const APM_IDLE_SLOWS_CLOCK: u32 = 4;
pub const APM_BIOS_DISABLED: u32 = 8;
pub const APM_BIOS_DISENGAGED: u32 = 16;
pub const APM_FUNC_INST_CHECK: u32 = 21248;
pub const APM_FUNC_REAL_CONN: u32 = 21249;
pub const APM_FUNC_16BIT_CONN: u32 = 21250;
pub const APM_FUNC_32BIT_CONN: u32 = 21251;
pub const APM_FUNC_DISCONN: u32 = 21252;
pub const APM_FUNC_IDLE: u32 = 21253;
pub const APM_FUNC_BUSY: u32 = 21254;
pub const APM_FUNC_SET_STATE: u32 = 21255;
pub const APM_FUNC_ENABLE_PM: u32 = 21256;
pub const APM_FUNC_RESTORE_BIOS: u32 = 21257;
pub const APM_FUNC_GET_STATUS: u32 = 21258;
pub const APM_FUNC_GET_EVENT: u32 = 21259;
pub const APM_FUNC_GET_STATE: u32 = 21260;
pub const APM_FUNC_ENABLE_DEV_PM: u32 = 21261;
pub const APM_FUNC_VERSION: u32 = 21262;
pub const APM_FUNC_ENGAGE_PM: u32 = 21263;
pub const APM_FUNC_GET_CAP: u32 = 21264;
pub const APM_FUNC_RESUME_TIMER: u32 = 21265;
pub const APM_FUNC_RESUME_ON_RING: u32 = 21266;
pub const APM_FUNC_TIMER: u32 = 21267;
pub const APM_FUNC_DISABLE_TIMER: u32 = 0;
pub const APM_FUNC_GET_TIMER: u32 = 1;
pub const APM_FUNC_SET_TIMER: u32 = 2;
pub const APM_FUNC_DISABLE_RING: u32 = 0;
pub const APM_FUNC_ENABLE_RING: u32 = 1;
pub const APM_FUNC_GET_RING: u32 = 2;
pub const APM_FUNC_TIMER_DISABLE: u32 = 0;
pub const APM_FUNC_TIMER_ENABLE: u32 = 1;
pub const APM_FUNC_TIMER_GET: u32 = 2;
pub const EDDNR: u32 = 489;
pub const EDDBUF: u32 = 3328;
pub const EDDMAXNR: u32 = 6;
pub const EDDEXTSIZE: u32 = 8;
pub const EDDPARMSIZE: u32 = 74;
pub const CHECKEXTENSIONSPRESENT: u32 = 65;
pub const GETDEVICEPARAMETERS: u32 = 72;
pub const LEGACYGETDEVICEPARAMETERS: u32 = 8;
pub const EDDMAGIC1: u32 = 21930;
pub const EDDMAGIC2: u32 = 43605;
pub const READ_SECTORS: u32 = 2;
pub const EDD_MBR_SIG_OFFSET: u32 = 440;
pub const EDD_MBR_SIG_BUF: u32 = 656;
pub const EDD_MBR_SIG_MAX: u32 = 16;
pub const EDD_MBR_SIG_NR_BUF: u32 = 490;
pub const EDD_EXT_FIXED_DISK_ACCESS: u32 = 1;
pub const EDD_EXT_DEVICE_LOCKING_AND_EJECTING: u32 = 2;
pub const EDD_EXT_ENHANCED_DISK_DRIVE_SUPPORT: u32 = 4;
pub const EDD_EXT_64BIT_EXTENSIONS: u32 = 8;
pub const EDD_INFO_DMA_BOUNDARY_ERROR_TRANSPARENT: u32 = 1;
pub const EDD_INFO_GEOMETRY_VALID: u32 = 2;
pub const EDD_INFO_REMOVABLE: u32 = 4;
pub const EDD_INFO_WRITE_VERIFY: u32 = 8;
pub const EDD_INFO_MEDIA_CHANGE_NOTIFICATION: u32 = 16;
pub const EDD_INFO_LOCKABLE: u32 = 32;
pub const EDD_INFO_NO_MEDIA_PRESENT: u32 = 64;
pub const EDD_INFO_USE_INT13_FN50: u32 = 128;
pub const E820_MAX_ENTRIES_ZEROPAGE: u32 = 128;
pub const JAILHOUSE_SETUP_REQUIRED_VERSION: u32 = 1;
pub const sme_me_mask: u32 = 0;
pub const PAGE_SHIFT: u32 = 12;
pub const HUGE_MAX_HSTATE: u32 = 2;
pub const KASAN_STACK_ORDER: u32 = 1;
pub const THREAD_SIZE_ORDER: u32 = 3;
pub const EXCEPTION_STACK_ORDER: u32 = 2;
pub const IRQ_STACK_ORDER: u32 = 3;
pub const IST_INDEX_DF: u32 = 0;
pub const IST_INDEX_NMI: u32 = 1;
pub const IST_INDEX_DB: u32 = 2;
pub const IST_INDEX_MCE: u32 = 3;
pub const IST_INDEX_VC: u32 = 4;
pub const __PHYSICAL_MASK_SHIFT: u32 = 52;
pub const KERNEL_IMAGE_SIZE: u32 = 536870912;
pub const NEED_3DNOW: u32 = 0;
pub const NEED_MOVBE: u32 = 0;
pub const REQUIRED_MASK2: u32 = 0;
pub const REQUIRED_MASK4: u32 = 0;
pub const REQUIRED_MASK5: u32 = 0;
pub const REQUIRED_MASK6: u32 = 0;
pub const REQUIRED_MASK7: u32 = 0;
pub const REQUIRED_MASK8: u32 = 0;
pub const REQUIRED_MASK9: u32 = 0;
pub const REQUIRED_MASK10: u32 = 0;
pub const REQUIRED_MASK11: u32 = 0;
pub const REQUIRED_MASK12: u32 = 0;
pub const REQUIRED_MASK13: u32 = 0;
pub const REQUIRED_MASK14: u32 = 0;
pub const REQUIRED_MASK15: u32 = 0;
pub const REQUIRED_MASK16: u32 = 0;
pub const REQUIRED_MASK17: u32 = 0;
pub const REQUIRED_MASK18: u32 = 0;
pub const REQUIRED_MASK19: u32 = 0;
pub const DISABLE_UMIP: u32 = 0;
pub const DISABLE_PCID: u32 = 0;
pub const DISABLE_PKU: u32 = 0;
pub const DISABLE_OSPKE: u32 = 0;
pub const DISABLE_LA57: u32 = 0;
pub const DISABLE_PTI: u32 = 0;
pub const DISABLE_RETPOLINE: u32 = 0;
pub const DISABLE_RETHUNK: u32 = 0;
pub const DISABLE_UNRET: u32 = 0;
pub const DISABLED_MASK1: u32 = 0;
pub const DISABLED_MASK2: u32 = 0;
pub const DISABLED_MASK4: u32 = 0;
pub const DISABLED_MASK5: u32 = 0;
pub const DISABLED_MASK6: u32 = 0;
pub const DISABLED_MASK7: u32 = 0;
pub const DISABLED_MASK10: u32 = 0;
pub const DISABLED_MASK11: u32 = 0;
pub const DISABLED_MASK12: u32 = 0;
pub const DISABLED_MASK13: u32 = 0;
pub const DISABLED_MASK14: u32 = 0;
pub const DISABLED_MASK15: u32 = 0;
pub const DISABLED_MASK17: u32 = 0;
pub const DISABLED_MASK18: u32 = 0;
pub const DISABLED_MASK19: u32 = 0;
pub const NCAPINTS: u32 = 20;
pub const NBUGINTS: u32 = 1;
pub const X86_FEATURE_FPU: u32 = 0;
pub const X86_FEATURE_VME: u32 = 1;
pub const X86_FEATURE_DE: u32 = 2;
pub const X86_FEATURE_PSE: u32 = 3;
pub const X86_FEATURE_TSC: u32 = 4;
pub const X86_FEATURE_MSR: u32 = 5;
pub const X86_FEATURE_PAE: u32 = 6;
pub const X86_FEATURE_MCE: u32 = 7;
pub const X86_FEATURE_CX8: u32 = 8;
pub const X86_FEATURE_APIC: u32 = 9;
pub const X86_FEATURE_SEP: u32 = 11;
pub const X86_FEATURE_MTRR: u32 = 12;
pub const X86_FEATURE_PGE: u32 = 13;
pub const X86_FEATURE_MCA: u32 = 14;
pub const X86_FEATURE_CMOV: u32 = 15;
pub const X86_FEATURE_PAT: u32 = 16;
pub const X86_FEATURE_PSE36: u32 = 17;
pub const X86_FEATURE_PN: u32 = 18;
pub const X86_FEATURE_CLFLUSH: u32 = 19;
pub const X86_FEATURE_DS: u32 = 21;
pub const X86_FEATURE_ACPI: u32 = 22;
pub const X86_FEATURE_MMX: u32 = 23;
pub const X86_FEATURE_FXSR: u32 = 24;
pub const X86_FEATURE_XMM: u32 = 25;
pub const X86_FEATURE_XMM2: u32 = 26;
pub const X86_FEATURE_SELFSNOOP: u32 = 27;
pub const X86_FEATURE_HT: u32 = 28;
pub const X86_FEATURE_ACC: u32 = 29;
pub const X86_FEATURE_IA64: u32 = 30;
pub const X86_FEATURE_PBE: u32 = 31;
pub const X86_FEATURE_SYSCALL: u32 = 43;
pub const X86_FEATURE_MP: u32 = 51;
pub const X86_FEATURE_NX: u32 = 52;
pub const X86_FEATURE_MMXEXT: u32 = 54;
pub const X86_FEATURE_FXSR_OPT: u32 = 57;
pub const X86_FEATURE_GBPAGES: u32 = 58;
pub const X86_FEATURE_RDTSCP: u32 = 59;
pub const X86_FEATURE_LM: u32 = 61;
pub const X86_FEATURE_3DNOWEXT: u32 = 62;
pub const X86_FEATURE_3DNOW: u32 = 63;
pub const X86_FEATURE_RECOVERY: u32 = 64;
pub const X86_FEATURE_LONGRUN: u32 = 65;
pub const X86_FEATURE_LRTI: u32 = 67;
pub const X86_FEATURE_CXMMX: u32 = 96;
pub const X86_FEATURE_K6_MTRR: u32 = 97;
pub const X86_FEATURE_CYRIX_ARR: u32 = 98;
pub const X86_FEATURE_CENTAUR_MCR: u32 = 99;
pub const X86_FEATURE_K8: u32 = 100;
pub const X86_FEATURE_P3: u32 = 102;
pub const X86_FEATURE_P4: u32 = 103;
pub const X86_FEATURE_CONSTANT_TSC: u32 = 104;
pub const X86_FEATURE_UP: u32 = 105;
pub const X86_FEATURE_ART: u32 = 106;
pub const X86_FEATURE_ARCH_PERFMON: u32 = 107;
pub const X86_FEATURE_PEBS: u32 = 108;
pub const X86_FEATURE_BTS: u32 = 109;
pub const X86_FEATURE_SYSCALL32: u32 = 110;
pub const X86_FEATURE_SYSENTER32: u32 = 111;
pub const X86_FEATURE_REP_GOOD: u32 = 112;
pub const X86_FEATURE_AMD_LBR_V2: u32 = 113;
pub const X86_FEATURE_LFENCE_RDTSC: u32 = 114;
pub const X86_FEATURE_ACC_POWER: u32 = 115;
pub const X86_FEATURE_NOPL: u32 = 116;
pub const X86_FEATURE_ALWAYS: u32 = 117;
pub const X86_FEATURE_XTOPOLOGY: u32 = 118;
pub const X86_FEATURE_TSC_RELIABLE: u32 = 119;
pub const X86_FEATURE_NONSTOP_TSC: u32 = 120;
pub const X86_FEATURE_CPUID: u32 = 121;
pub const X86_FEATURE_EXTD_APICID: u32 = 122;
pub const X86_FEATURE_AMD_DCM: u32 = 123;
pub const X86_FEATURE_APERFMPERF: u32 = 124;
pub const X86_FEATURE_RAPL: u32 = 125;
pub const X86_FEATURE_NONSTOP_TSC_S3: u32 = 126;
pub const X86_FEATURE_TSC_KNOWN_FREQ: u32 = 127;
pub const X86_FEATURE_XMM3: u32 = 128;
pub const X86_FEATURE_PCLMULQDQ: u32 = 129;
pub const X86_FEATURE_DTES64: u32 = 130;
pub const X86_FEATURE_MWAIT: u32 = 131;
pub const X86_FEATURE_DSCPL: u32 = 132;
pub const X86_FEATURE_VMX: u32 = 133;
pub const X86_FEATURE_SMX: u32 = 134;
pub const X86_FEATURE_EST: u32 = 135;
pub const X86_FEATURE_TM2: u32 = 136;
pub const X86_FEATURE_SSSE3: u32 = 137;
pub const X86_FEATURE_CID: u32 = 138;
pub const X86_FEATURE_SDBG: u32 = 139;
pub const X86_FEATURE_FMA: u32 = 140;
pub const X86_FEATURE_CX16: u32 = 141;
pub const X86_FEATURE_XTPR: u32 = 142;
pub const X86_FEATURE_PDCM: u32 = 143;
pub const X86_FEATURE_PCID: u32 = 145;
pub const X86_FEATURE_DCA: u32 = 146;
pub const X86_FEATURE_XMM4_1: u32 = 147;
pub const X86_FEATURE_XMM4_2: u32 = 148;
pub const X86_FEATURE_X2APIC: u32 = 149;
pub const X86_FEATURE_MOVBE: u32 = 150;
pub const X86_FEATURE_POPCNT: u32 = 151;
pub const X86_FEATURE_TSC_DEADLINE_TIMER: u32 = 152;
pub const X86_FEATURE_AES: u32 = 153;
pub const X86_FEATURE_XSAVE: u32 = 154;
pub const X86_FEATURE_OSXSAVE: u32 = 155;
pub const X86_FEATURE_AVX: u32 = 156;
pub const X86_FEATURE_F16C: u32 = 157;
pub const X86_FEATURE_RDRAND: u32 = 158;
pub const X86_FEATURE_HYPERVISOR: u32 = 159;
pub const X86_FEATURE_XSTORE: u32 = 162;
pub const X86_FEATURE_XSTORE_EN: u32 = 163;
pub const X86_FEATURE_XCRYPT: u32 = 166;
pub const X86_FEATURE_XCRYPT_EN: u32 = 167;
pub const X86_FEATURE_ACE2: u32 = 168;
pub const X86_FEATURE_ACE2_EN: u32 = 169;
pub const X86_FEATURE_PHE: u32 = 170;
pub const X86_FEATURE_PHE_EN: u32 = 171;
pub const X86_FEATURE_PMM: u32 = 172;
pub const X86_FEATURE_PMM_EN: u32 = 173;
pub const X86_FEATURE_LAHF_LM: u32 = 192;
pub const X86_FEATURE_CMP_LEGACY: u32 = 193;
pub const X86_FEATURE_SVM: u32 = 194;
pub const X86_FEATURE_EXTAPIC: u32 = 195;
pub const X86_FEATURE_CR8_LEGACY: u32 = 196;
pub const X86_FEATURE_ABM: u32 = 197;
pub const X86_FEATURE_SSE4A: u32 = 198;
pub const X86_FEATURE_MISALIGNSSE: u32 = 199;
pub const X86_FEATURE_3DNOWPREFETCH: u32 = 200;
pub const X86_FEATURE_OSVW: u32 = 201;
pub const X86_FEATURE_IBS: u32 = 202;
pub const X86_FEATURE_XOP: u32 = 203;
pub const X86_FEATURE_SKINIT: u32 = 204;
pub const X86_FEATURE_WDT: u32 = 205;
pub const X86_FEATURE_LWP: u32 = 207;
pub const X86_FEATURE_FMA4: u32 = 208;
pub const X86_FEATURE_TCE: u32 = 209;
pub const X86_FEATURE_NODEID_MSR: u32 = 211;
pub const X86_FEATURE_TBM: u32 = 213;
pub const X86_FEATURE_TOPOEXT: u32 = 214;
pub const X86_FEATURE_PERFCTR_CORE: u32 = 215;
pub const X86_FEATURE_PERFCTR_NB: u32 = 216;
pub const X86_FEATURE_BPEXT: u32 = 218;
pub const X86_FEATURE_PTSC: u32 = 219;
pub const X86_FEATURE_PERFCTR_LLC: u32 = 220;
pub const X86_FEATURE_MWAITX: u32 = 221;
pub const X86_FEATURE_RING3MWAIT: u32 = 224;
pub const X86_FEATURE_CPUID_FAULT: u32 = 225;
pub const X86_FEATURE_CPB: u32 = 226;
pub const X86_FEATURE_EPB: u32 = 227;
pub const X86_FEATURE_CAT_L3: u32 = 228;
pub const X86_FEATURE_CAT_L2: u32 = 229;
pub const X86_FEATURE_CDP_L3: u32 = 230;
pub const X86_FEATURE_INVPCID_SINGLE: u32 = 231;
pub const X86_FEATURE_HW_PSTATE: u32 = 232;
pub const X86_FEATURE_PROC_FEEDBACK: u32 = 233;
pub const X86_FEATURE_XCOMPACTED: u32 = 234;
pub const X86_FEATURE_PTI: u32 = 235;
pub const X86_FEATURE_KERNEL_IBRS: u32 = 236;
pub const X86_FEATURE_RSB_VMEXIT: u32 = 237;
pub const X86_FEATURE_INTEL_PPIN: u32 = 238;
pub const X86_FEATURE_CDP_L2: u32 = 239;
pub const X86_FEATURE_MSR_SPEC_CTRL: u32 = 240;
pub const X86_FEATURE_SSBD: u32 = 241;
pub const X86_FEATURE_MBA: u32 = 242;
pub const X86_FEATURE_RSB_CTXSW: u32 = 243;
pub const X86_FEATURE_PERFMON_V2: u32 = 244;
pub const X86_FEATURE_USE_IBPB: u32 = 245;
pub const X86_FEATURE_USE_IBRS_FW: u32 = 246;
pub const X86_FEATURE_SPEC_STORE_BYPASS_DISABLE: u32 = 247;
pub const X86_FEATURE_LS_CFG_SSBD: u32 = 248;
pub const X86_FEATURE_IBRS: u32 = 249;
pub const X86_FEATURE_IBPB: u32 = 250;
pub const X86_FEATURE_STIBP: u32 = 251;
pub const X86_FEATURE_ZEN: u32 = 252;
pub const X86_FEATURE_L1TF_PTEINV: u32 = 253;
pub const X86_FEATURE_IBRS_ENHANCED: u32 = 254;
pub const X86_FEATURE_MSR_IA32_FEAT_CTL: u32 = 255;
pub const X86_FEATURE_TPR_SHADOW: u32 = 256;
pub const X86_FEATURE_VNMI: u32 = 257;
pub const X86_FEATURE_FLEXPRIORITY: u32 = 258;
pub const X86_FEATURE_EPT: u32 = 259;
pub const X86_FEATURE_VPID: u32 = 260;
pub const X86_FEATURE_VMMCALL: u32 = 271;
pub const X86_FEATURE_XENPV: u32 = 272;
pub const X86_FEATURE_EPT_AD: u32 = 273;
pub const X86_FEATURE_VMCALL: u32 = 274;
pub const X86_FEATURE_VMW_VMMCALL: u32 = 275;
pub const X86_FEATURE_PVUNLOCK: u32 = 276;
pub const X86_FEATURE_VCPUPREEMPT: u32 = 277;
pub const X86_FEATURE_TDX_GUEST: u32 = 278;
pub const X86_FEATURE_FSGSBASE: u32 = 288;
pub const X86_FEATURE_TSC_ADJUST: u32 = 289;
pub const X86_FEATURE_SGX: u32 = 290;
pub const X86_FEATURE_BMI1: u32 = 291;
pub const X86_FEATURE_HLE: u32 = 292;
pub const X86_FEATURE_AVX2: u32 = 293;
pub const X86_FEATURE_FDP_EXCPTN_ONLY: u32 = 294;
pub const X86_FEATURE_SMEP: u32 = 295;
pub const X86_FEATURE_BMI2: u32 = 296;
pub const X86_FEATURE_ERMS: u32 = 297;
pub const X86_FEATURE_INVPCID: u32 = 298;
pub const X86_FEATURE_RTM: u32 = 299;
pub const X86_FEATURE_CQM: u32 = 300;
pub const X86_FEATURE_ZERO_FCS_FDS: u32 = 301;
pub const X86_FEATURE_MPX: u32 = 302;
pub const X86_FEATURE_RDT_A: u32 = 303;
pub const X86_FEATURE_AVX512F: u32 = 304;
pub const X86_FEATURE_AVX512DQ: u32 = 305;
pub const X86_FEATURE_RDSEED: u32 = 306;
pub const X86_FEATURE_ADX: u32 = 307;
pub const X86_FEATURE_SMAP: u32 = 308;
pub const X86_FEATURE_AVX512IFMA: u32 = 309;
pub const X86_FEATURE_CLFLUSHOPT: u32 = 311;
pub const X86_FEATURE_CLWB: u32 = 312;
pub const X86_FEATURE_INTEL_PT: u32 = 313;
pub const X86_FEATURE_AVX512PF: u32 = 314;
pub const X86_FEATURE_AVX512ER: u32 = 315;
pub const X86_FEATURE_AVX512CD: u32 = 316;
pub const X86_FEATURE_SHA_NI: u32 = 317;
pub const X86_FEATURE_AVX512BW: u32 = 318;
pub const X86_FEATURE_AVX512VL: u32 = 319;
pub const X86_FEATURE_XSAVEOPT: u32 = 320;
pub const X86_FEATURE_XSAVEC: u32 = 321;
pub const X86_FEATURE_XGETBV1: u32 = 322;
pub const X86_FEATURE_XSAVES: u32 = 323;
pub const X86_FEATURE_XFD: u32 = 324;
pub const X86_FEATURE_CQM_LLC: u32 = 352;
pub const X86_FEATURE_CQM_OCCUP_LLC: u32 = 353;
pub const X86_FEATURE_CQM_MBM_TOTAL: u32 = 354;
pub const X86_FEATURE_CQM_MBM_LOCAL: u32 = 355;
pub const X86_FEATURE_FENCE_SWAPGS_USER: u32 = 356;
pub const X86_FEATURE_FENCE_SWAPGS_KERNEL: u32 = 357;
pub const X86_FEATURE_SPLIT_LOCK_DETECT: u32 = 358;
pub const X86_FEATURE_PER_THREAD_MBA: u32 = 359;
pub const X86_FEATURE_SGX1: u32 = 360;
pub const X86_FEATURE_SGX2: u32 = 361;
pub const X86_FEATURE_ENTRY_IBPB: u32 = 362;
pub const X86_FEATURE_RRSBA_CTRL: u32 = 363;
pub const X86_FEATURE_RETPOLINE: u32 = 364;
pub const X86_FEATURE_RETPOLINE_LFENCE: u32 = 365;
pub const X86_FEATURE_RETHUNK: u32 = 366;
pub const X86_FEATURE_UNRET: u32 = 367;
pub const X86_FEATURE_USE_IBPB_FW: u32 = 368;
pub const X86_FEATURE_RSB_VMEXIT_LITE: u32 = 369;
pub const X86_FEATURE_MSR_TSX_CTRL: u32 = 372;
pub const X86_FEATURE_AVX_VNNI: u32 = 388;
pub const X86_FEATURE_AVX512_BF16: u32 = 389;
pub const X86_FEATURE_CLZERO: u32 = 416;
pub const X86_FEATURE_IRPERF: u32 = 417;
pub const X86_FEATURE_XSAVEERPTR: u32 = 418;
pub const X86_FEATURE_RDPRU: u32 = 420;
pub const X86_FEATURE_WBNOINVD: u32 = 425;
pub const X86_FEATURE_AMD_IBPB: u32 = 428;
pub const X86_FEATURE_AMD_IBRS: u32 = 430;
pub const X86_FEATURE_AMD_STIBP: u32 = 431;
pub const X86_FEATURE_AMD_STIBP_ALWAYS_ON: u32 = 433;
pub const X86_FEATURE_AMD_PPIN: u32 = 439;
pub const X86_FEATURE_AMD_SSBD: u32 = 440;
pub const X86_FEATURE_VIRT_SSBD: u32 = 441;
pub const X86_FEATURE_AMD_SSB_NO: u32 = 442;
pub const X86_FEATURE_CPPC: u32 = 443;
pub const X86_FEATURE_BTC_NO: u32 = 445;
pub const X86_FEATURE_BRS: u32 = 447;
pub const X86_FEATURE_DTHERM: u32 = 448;
pub const X86_FEATURE_IDA: u32 = 449;
pub const X86_FEATURE_ARAT: u32 = 450;
pub const X86_FEATURE_PLN: u32 = 452;
pub const X86_FEATURE_PTS: u32 = 454;
pub const X86_FEATURE_HWP: u32 = 455;
pub const X86_FEATURE_HWP_NOTIFY: u32 = 456;
pub const X86_FEATURE_HWP_ACT_WINDOW: u32 = 457;
pub const X86_FEATURE_HWP_EPP: u32 = 458;
pub const X86_FEATURE_HWP_PKG_REQ: u32 = 459;
pub const X86_FEATURE_HFI: u32 = 467;
pub const X86_FEATURE_NPT: u32 = 480;
pub const X86_FEATURE_LBRV: u32 = 481;
pub const X86_FEATURE_SVML: u32 = 482;
pub const X86_FEATURE_NRIPS: u32 = 483;
pub const X86_FEATURE_TSCRATEMSR: u32 = 484;
pub const X86_FEATURE_VMCBCLEAN: u32 = 485;
pub const X86_FEATURE_FLUSHBYASID: u32 = 486;
pub const X86_FEATURE_DECODEASSISTS: u32 = 487;
pub const X86_FEATURE_PAUSEFILTER: u32 = 490;
pub const X86_FEATURE_PFTHRESHOLD: u32 = 492;
pub const X86_FEATURE_AVIC: u32 = 493;
pub const X86_FEATURE_V_VMSAVE_VMLOAD: u32 = 495;
pub const X86_FEATURE_VGIF: u32 = 496;
pub const X86_FEATURE_X2AVIC: u32 = 498;
pub const X86_FEATURE_V_SPEC_CTRL: u32 = 500;
pub const X86_FEATURE_SVME_ADDR_CHK: u32 = 508;
pub const X86_FEATURE_AVX512VBMI: u32 = 513;
pub const X86_FEATURE_UMIP: u32 = 514;
pub const X86_FEATURE_PKU: u32 = 515;
pub const X86_FEATURE_OSPKE: u32 = 516;
pub const X86_FEATURE_WAITPKG: u32 = 517;
pub const X86_FEATURE_AVX512_VBMI2: u32 = 518;
pub const X86_FEATURE_GFNI: u32 = 520;
pub const X86_FEATURE_VAES: u32 = 521;
pub const X86_FEATURE_VPCLMULQDQ: u32 = 522;
pub const X86_FEATURE_AVX512_VNNI: u32 = 523;
pub const X86_FEATURE_AVX512_BITALG: u32 = 524;
pub const X86_FEATURE_TME: u32 = 525;
pub const X86_FEATURE_AVX512_VPOPCNTDQ: u32 = 526;
pub const X86_FEATURE_LA57: u32 = 528;
pub const X86_FEATURE_RDPID: u32 = 534;
pub const X86_FEATURE_BUS_LOCK_DETECT: u32 = 536;
pub const X86_FEATURE_CLDEMOTE: u32 = 537;
pub const X86_FEATURE_MOVDIRI: u32 = 539;
pub const X86_FEATURE_MOVDIR64B: u32 = 540;
pub const X86_FEATURE_ENQCMD: u32 = 541;
pub const X86_FEATURE_SGX_LC: u32 = 542;
pub const X86_FEATURE_OVERFLOW_RECOV: u32 = 544;
pub const X86_FEATURE_SUCCOR: u32 = 545;
pub const X86_FEATURE_SMCA: u32 = 547;
pub const X86_FEATURE_AVX512_4VNNIW: u32 = 578;
pub const X86_FEATURE_AVX512_4FMAPS: u32 = 579;
pub const X86_FEATURE_FSRM: u32 = 580;
pub const X86_FEATURE_AVX512_VP2INTERSECT: u32 = 584;
pub const X86_FEATURE_SRBDS_CTRL: u32 = 585;
pub const X86_FEATURE_MD_CLEAR: u32 = 586;
pub const X86_FEATURE_RTM_ALWAYS_ABORT: u32 = 587;
pub const X86_FEATURE_TSX_FORCE_ABORT: u32 = 589;
pub const X86_FEATURE_SERIALIZE: u32 = 590;
pub const X86_FEATURE_HYBRID_CPU: u32 = 591;
pub const X86_FEATURE_TSXLDTRK: u32 = 592;
pub const X86_FEATURE_PCONFIG: u32 = 594;
pub const X86_FEATURE_ARCH_LBR: u32 = 595;
pub const X86_FEATURE_IBT: u32 = 596;
pub const X86_FEATURE_AMX_BF16: u32 = 598;
pub const X86_FEATURE_AVX512_FP16: u32 = 599;
pub const X86_FEATURE_AMX_TILE: u32 = 600;
pub const X86_FEATURE_AMX_INT8: u32 = 601;
pub const X86_FEATURE_SPEC_CTRL: u32 = 602;
pub const X86_FEATURE_INTEL_STIBP: u32 = 603;
pub const X86_FEATURE_FLUSH_L1D: u32 = 604;
pub const X86_FEATURE_ARCH_CAPABILITIES: u32 = 605;
pub const X86_FEATURE_CORE_CAPABILITIES: u32 = 606;
pub const X86_FEATURE_SPEC_CTRL_SSBD: u32 = 607;
pub const X86_FEATURE_SME: u32 = 608;
pub const X86_FEATURE_SEV: u32 = 609;
pub const X86_FEATURE_VM_PAGE_FLUSH: u32 = 610;
pub const X86_FEATURE_SEV_ES: u32 = 611;
pub const X86_FEATURE_V_TSC_AUX: u32 = 617;
pub const X86_FEATURE_SME_COHERENT: u32 = 618;
pub const ALTINSTR_FLAG_INV: u32 = 32768;
pub const LOCK_PREFIX_HERE: &'static [u8; 70usize] =
    b".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\0";
pub const LOCK_PREFIX: &'static [u8; 78usize] =
    b".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; \0";
pub const ANNOTATE_IGNORE_ALTERNATIVE: &'static [u8; 71usize] =
    b"999:\n\t.pushsection .discard.ignore_alts\n\t.long 999b - .\n\t.popsection\n\t\0";
pub const alt_end_marker: &'static [u8; 4usize] = b"663\0";
pub const alt_slen: &'static [u8; 10usize] = b"662b-661b\0";
pub const alt_total_slen: &'static [u8; 10usize] = b"663b-661b\0";
pub const __HAVE_ARCH_GATE_AREA: u32 = 1;
pub const SI_LOAD_SHIFT: u32 = 16;
pub const _BITOPS_LONG_SHIFT: u32 = 6;
pub const REG_IN: &'static [u8; 2usize] = b"D\0";
pub const REG_OUT: &'static [u8; 2usize] = b"a\0";
pub const BITOP_LE_SWIZZLE: u32 = 0;
pub const _PAGE_BIT_PRESENT: u32 = 0;
pub const _PAGE_BIT_RW: u32 = 1;
pub const _PAGE_BIT_USER: u32 = 2;
pub const _PAGE_BIT_PWT: u32 = 3;
pub const _PAGE_BIT_PCD: u32 = 4;
pub const _PAGE_BIT_ACCESSED: u32 = 5;
pub const _PAGE_BIT_DIRTY: u32 = 6;
pub const _PAGE_BIT_PSE: u32 = 7;
pub const _PAGE_BIT_PAT: u32 = 7;
pub const _PAGE_BIT_GLOBAL: u32 = 8;
pub const _PAGE_BIT_SOFTW1: u32 = 9;
pub const _PAGE_BIT_SOFTW2: u32 = 10;
pub const _PAGE_BIT_SOFTW3: u32 = 11;
pub const _PAGE_BIT_PAT_LARGE: u32 = 12;
pub const _PAGE_BIT_SOFTW4: u32 = 58;
pub const _PAGE_BIT_PKEY_BIT0: u32 = 59;
pub const _PAGE_BIT_PKEY_BIT1: u32 = 60;
pub const _PAGE_BIT_PKEY_BIT2: u32 = 61;
pub const _PAGE_BIT_PKEY_BIT3: u32 = 62;
pub const _PAGE_BIT_NX: u32 = 63;
pub const _PAGE_BIT_SPECIAL: u32 = 9;
pub const _PAGE_BIT_CPA_TEST: u32 = 9;
pub const _PAGE_BIT_UFFD_WP: u32 = 10;
pub const _PAGE_BIT_SOFT_DIRTY: u32 = 11;
pub const _PAGE_BIT_DEVMAP: u32 = 58;
pub const _PAGE_BIT_PROTNONE: u32 = 8;
pub const SECTION_SIZE_BITS: u32 = 27;
pub const SHARED_KERNEL_PMD: u32 = 0;
pub const PTRS_PER_PGD: u32 = 512;
pub const P4D_SHIFT: u32 = 39;
pub const MAX_PTRS_PER_P4D: u32 = 512;
pub const MAX_POSSIBLE_PHYSMEM_BITS: u32 = 52;
pub const PUD_SHIFT: u32 = 30;
pub const PTRS_PER_PUD: u32 = 512;
pub const PMD_SHIFT: u32 = 21;
pub const PTRS_PER_PMD: u32 = 512;
pub const PTRS_PER_PTE: u32 = 512;
pub const GUARD_HOLE_PGD_ENTRY: i32 = -256;
pub const LDT_PGD_ENTRY: i32 = -240;
pub const __VMALLOC_BASE_L4: i64 = -60473139527680;
pub const __VMALLOC_BASE_L5: i64 = -27021597764222976;
pub const VMALLOC_SIZE_TB_L4: u32 = 32;
pub const VMALLOC_SIZE_TB_L5: u32 = 12800;
pub const __VMEMMAP_BASE_L4: i64 = -24189255811072;
pub const __VMEMMAP_BASE_L5: i64 = -12384898975268864;
pub const EARLY_DYNAMIC_PAGE_TABLES: u32 = 64;
pub const PGD_ALLOWED_BITS: i32 = -1;
pub const MSR_EFER: u32 = 3221225600;
pub const MSR_STAR: u32 = 3221225601;
pub const MSR_LSTAR: u32 = 3221225602;
pub const MSR_CSTAR: u32 = 3221225603;
pub const MSR_SYSCALL_MASK: u32 = 3221225604;
pub const MSR_FS_BASE: u32 = 3221225728;
pub const MSR_GS_BASE: u32 = 3221225729;
pub const MSR_KERNEL_GS_BASE: u32 = 3221225730;
pub const MSR_TSC_AUX: u32 = 3221225731;
pub const _EFER_SCE: u32 = 0;
pub const _EFER_LME: u32 = 8;
pub const _EFER_LMA: u32 = 10;
pub const _EFER_NX: u32 = 11;
pub const _EFER_SVME: u32 = 12;
pub const _EFER_LMSLE: u32 = 13;
pub const _EFER_FFXSR: u32 = 14;
pub const EFER_SCE: u32 = 1;
pub const EFER_LME: u32 = 256;
pub const EFER_LMA: u32 = 1024;
pub const EFER_NX: u32 = 2048;
pub const EFER_SVME: u32 = 4096;
pub const EFER_LMSLE: u32 = 8192;
pub const EFER_FFXSR: u32 = 16384;
pub const MSR_TEST_CTRL: u32 = 51;
pub const MSR_TEST_CTRL_SPLIT_LOCK_DETECT_BIT: u32 = 29;
pub const MSR_IA32_SPEC_CTRL: u32 = 72;
pub const SPEC_CTRL_STIBP_SHIFT: u32 = 1;
pub const SPEC_CTRL_SSBD_SHIFT: u32 = 2;
pub const SPEC_CTRL_RRSBA_DIS_S_SHIFT: u32 = 6;
pub const MSR_IA32_PRED_CMD: u32 = 73;
pub const MSR_PPIN_CTL: u32 = 78;
pub const MSR_PPIN: u32 = 79;
pub const MSR_IA32_PERFCTR0: u32 = 193;
pub const MSR_IA32_PERFCTR1: u32 = 194;
pub const MSR_FSB_FREQ: u32 = 205;
pub const MSR_PLATFORM_INFO: u32 = 206;
pub const MSR_PLATFORM_INFO_CPUID_FAULT_BIT: u32 = 31;
pub const MSR_IA32_UMWAIT_CONTROL: u32 = 225;
pub const MSR_IA32_UMWAIT_CONTROL_TIME_MASK: i32 = -4;
pub const MSR_IA32_CORE_CAPS: u32 = 207;
pub const MSR_IA32_CORE_CAPS_INTEGRITY_CAPS_BIT: u32 = 2;
pub const MSR_IA32_CORE_CAPS_SPLIT_LOCK_DETECT_BIT: u32 = 5;
pub const MSR_PKG_CST_CONFIG_CONTROL: u32 = 226;
pub const NHM_C3_AUTO_DEMOTE: u32 = 33554432;
pub const NHM_C1_AUTO_DEMOTE: u32 = 67108864;
pub const ATM_LNC_C6_AUTO_DEMOTE: u32 = 33554432;
pub const SNB_C3_AUTO_UNDEMOTE: u32 = 134217728;
pub const SNB_C1_AUTO_UNDEMOTE: u32 = 268435456;
pub const MSR_MTRRcap: u32 = 254;
pub const MSR_IA32_ARCH_CAPABILITIES: u32 = 266;
pub const MSR_IA32_FLUSH_CMD: u32 = 267;
pub const MSR_IA32_BBL_CR_CTL: u32 = 281;
pub const MSR_IA32_BBL_CR_CTL3: u32 = 286;
pub const MSR_IA32_TSX_CTRL: u32 = 290;
pub const MSR_IA32_MCU_OPT_CTRL: u32 = 291;
pub const MSR_IA32_SYSENTER_CS: u32 = 372;
pub const MSR_IA32_SYSENTER_ESP: u32 = 373;
pub const MSR_IA32_SYSENTER_EIP: u32 = 374;
pub const MSR_IA32_MCG_CAP: u32 = 377;
pub const MSR_IA32_MCG_STATUS: u32 = 378;
pub const MSR_IA32_MCG_CTL: u32 = 379;
pub const MSR_ERROR_CONTROL: u32 = 383;
pub const MSR_IA32_MCG_EXT_CTL: u32 = 1232;
pub const MSR_OFFCORE_RSP_0: u32 = 422;
pub const MSR_OFFCORE_RSP_1: u32 = 423;
pub const MSR_TURBO_RATIO_LIMIT: u32 = 429;
pub const MSR_TURBO_RATIO_LIMIT1: u32 = 430;
pub const MSR_TURBO_RATIO_LIMIT2: u32 = 431;
pub const MSR_LBR_SELECT: u32 = 456;
pub const MSR_LBR_TOS: u32 = 457;
pub const MSR_IA32_POWER_CTL: u32 = 508;
pub const MSR_IA32_POWER_CTL_BIT_EE: u32 = 19;
pub const MSR_INTEGRITY_CAPS: u32 = 729;
pub const MSR_INTEGRITY_CAPS_PERIODIC_BIST_BIT: u32 = 4;
pub const MSR_LBR_NHM_FROM: u32 = 1664;
pub const MSR_LBR_NHM_TO: u32 = 1728;
pub const MSR_LBR_CORE_FROM: u32 = 64;
pub const MSR_LBR_CORE_TO: u32 = 96;
pub const MSR_LBR_INFO_0: u32 = 3520;
pub const LBR_INFO_CYCLES: u32 = 65535;
pub const LBR_INFO_BR_TYPE_OFFSET: u32 = 56;
pub const LBR_INFO_BR_TYPE: u64 = 1080863910568919040;
pub const MSR_ARCH_LBR_CTL: u32 = 5326;
pub const ARCH_LBR_CTL_CPL_OFFSET: u32 = 1;
pub const ARCH_LBR_CTL_CPL: u32 = 6;
pub const ARCH_LBR_CTL_STACK_OFFSET: u32 = 3;
pub const ARCH_LBR_CTL_STACK: u32 = 8;
pub const ARCH_LBR_CTL_FILTER_OFFSET: u32 = 16;
pub const ARCH_LBR_CTL_FILTER: u32 = 8323072;
pub const MSR_ARCH_LBR_DEPTH: u32 = 5327;
pub const MSR_ARCH_LBR_FROM_0: u32 = 5376;
pub const MSR_ARCH_LBR_TO_0: u32 = 5632;
pub const MSR_ARCH_LBR_INFO_0: u32 = 4608;
pub const MSR_IA32_PEBS_ENABLE: u32 = 1009;
pub const MSR_PEBS_DATA_CFG: u32 = 1010;
pub const MSR_IA32_DS_AREA: u32 = 1536;
pub const MSR_IA32_PERF_CAPABILITIES: u32 = 837;
pub const PERF_CAP_METRICS_IDX: u32 = 15;
pub const PERF_CAP_PT_IDX: u32 = 16;
pub const MSR_PEBS_LD_LAT_THRESHOLD: u32 = 1014;
pub const PERF_CAP_PEBS_FORMAT: u32 = 3840;
pub const MSR_IA32_RTIT_CTL: u32 = 1392;
pub const RTIT_CTL_MTC_RANGE_OFFSET: u32 = 14;
pub const RTIT_CTL_MTC_RANGE: u32 = 245760;
pub const RTIT_CTL_CYC_THRESH_OFFSET: u32 = 19;
pub const RTIT_CTL_CYC_THRESH: u32 = 7864320;
pub const RTIT_CTL_PSB_FREQ_OFFSET: u32 = 24;
pub const RTIT_CTL_PSB_FREQ: u32 = 251658240;
pub const RTIT_CTL_ADDR0_OFFSET: u32 = 32;
pub const RTIT_CTL_ADDR0: u64 = 64424509440;
pub const RTIT_CTL_ADDR1_OFFSET: u32 = 36;
pub const RTIT_CTL_ADDR1: u64 = 1030792151040;
pub const RTIT_CTL_ADDR2_OFFSET: u32 = 40;
pub const RTIT_CTL_ADDR2: u64 = 16492674416640;
pub const RTIT_CTL_ADDR3_OFFSET: u32 = 44;
pub const RTIT_CTL_ADDR3: u64 = 263882790666240;
pub const MSR_IA32_RTIT_STATUS: u32 = 1393;
pub const RTIT_STATUS_BYTECNT_OFFSET: u32 = 32;
pub const RTIT_STATUS_BYTECNT: u64 = 562945658454016;
pub const MSR_IA32_RTIT_ADDR0_A: u32 = 1408;
pub const MSR_IA32_RTIT_ADDR0_B: u32 = 1409;
pub const MSR_IA32_RTIT_ADDR1_A: u32 = 1410;
pub const MSR_IA32_RTIT_ADDR1_B: u32 = 1411;
pub const MSR_IA32_RTIT_ADDR2_A: u32 = 1412;
pub const MSR_IA32_RTIT_ADDR2_B: u32 = 1413;
pub const MSR_IA32_RTIT_ADDR3_A: u32 = 1414;
pub const MSR_IA32_RTIT_ADDR3_B: u32 = 1415;
pub const MSR_IA32_RTIT_CR3_MATCH: u32 = 1394;
pub const MSR_IA32_RTIT_OUTPUT_BASE: u32 = 1376;
pub const MSR_IA32_RTIT_OUTPUT_MASK: u32 = 1377;
pub const MSR_MTRRfix64K_00000: u32 = 592;
pub const MSR_MTRRfix16K_80000: u32 = 600;
pub const MSR_MTRRfix16K_A0000: u32 = 601;
pub const MSR_MTRRfix4K_C0000: u32 = 616;
pub const MSR_MTRRfix4K_C8000: u32 = 617;
pub const MSR_MTRRfix4K_D0000: u32 = 618;
pub const MSR_MTRRfix4K_D8000: u32 = 619;
pub const MSR_MTRRfix4K_E0000: u32 = 620;
pub const MSR_MTRRfix4K_E8000: u32 = 621;
pub const MSR_MTRRfix4K_F0000: u32 = 622;
pub const MSR_MTRRfix4K_F8000: u32 = 623;
pub const MSR_MTRRdefType: u32 = 767;
pub const MSR_IA32_CR_PAT: u32 = 631;
pub const MSR_IA32_DEBUGCTLMSR: u32 = 473;
pub const MSR_IA32_LASTBRANCHFROMIP: u32 = 475;
pub const MSR_IA32_LASTBRANCHTOIP: u32 = 476;
pub const MSR_IA32_LASTINTFROMIP: u32 = 477;
pub const MSR_IA32_LASTINTTOIP: u32 = 478;
pub const MSR_IA32_PASID: u32 = 3475;
pub const DEBUGCTLMSR_LBR: u32 = 1;
pub const DEBUGCTLMSR_BTF_SHIFT: u32 = 1;
pub const DEBUGCTLMSR_BTF: u32 = 2;
pub const DEBUGCTLMSR_BUS_LOCK_DETECT: u32 = 4;
pub const DEBUGCTLMSR_TR: u32 = 64;
pub const DEBUGCTLMSR_BTS: u32 = 128;
pub const DEBUGCTLMSR_BTINT: u32 = 256;
pub const DEBUGCTLMSR_BTS_OFF_OS: u32 = 512;
pub const DEBUGCTLMSR_BTS_OFF_USR: u32 = 1024;
pub const DEBUGCTLMSR_FREEZE_LBRS_ON_PMI: u32 = 2048;
pub const DEBUGCTLMSR_FREEZE_PERFMON_ON_PMI: u32 = 4096;
pub const DEBUGCTLMSR_FREEZE_IN_SMM_BIT: u32 = 14;
pub const DEBUGCTLMSR_FREEZE_IN_SMM: u32 = 16384;
pub const MSR_PEBS_FRONTEND: u32 = 1015;
pub const MSR_IA32_MC0_CTL: u32 = 1024;
pub const MSR_IA32_MC0_STATUS: u32 = 1025;
pub const MSR_IA32_MC0_ADDR: u32 = 1026;
pub const MSR_IA32_MC0_MISC: u32 = 1027;
pub const MSR_PKG_C3_RESIDENCY: u32 = 1016;
pub const MSR_PKG_C6_RESIDENCY: u32 = 1017;
pub const MSR_ATOM_PKG_C6_RESIDENCY: u32 = 1018;
pub const MSR_PKG_C7_RESIDENCY: u32 = 1018;
pub const MSR_CORE_C3_RESIDENCY: u32 = 1020;
pub const MSR_CORE_C6_RESIDENCY: u32 = 1021;
pub const MSR_CORE_C7_RESIDENCY: u32 = 1022;
pub const MSR_KNL_CORE_C6_RESIDENCY: u32 = 1023;
pub const MSR_PKG_C2_RESIDENCY: u32 = 1549;
pub const MSR_PKG_C8_RESIDENCY: u32 = 1584;
pub const MSR_PKG_C9_RESIDENCY: u32 = 1585;
pub const MSR_PKG_C10_RESIDENCY: u32 = 1586;
pub const MSR_PKGC3_IRTL: u32 = 1546;
pub const MSR_PKGC6_IRTL: u32 = 1547;
pub const MSR_PKGC7_IRTL: u32 = 1548;
pub const MSR_PKGC8_IRTL: u32 = 1587;
pub const MSR_PKGC9_IRTL: u32 = 1588;
pub const MSR_PKGC10_IRTL: u32 = 1589;
pub const MSR_VR_CURRENT_CONFIG: u32 = 1537;
pub const MSR_RAPL_POWER_UNIT: u32 = 1542;
pub const MSR_PKG_POWER_LIMIT: u32 = 1552;
pub const MSR_PKG_ENERGY_STATUS: u32 = 1553;
pub const MSR_PKG_PERF_STATUS: u32 = 1555;
pub const MSR_PKG_POWER_INFO: u32 = 1556;
pub const MSR_DRAM_POWER_LIMIT: u32 = 1560;
pub const MSR_DRAM_ENERGY_STATUS: u32 = 1561;
pub const MSR_DRAM_PERF_STATUS: u32 = 1563;
pub const MSR_DRAM_POWER_INFO: u32 = 1564;
pub const MSR_PP0_POWER_LIMIT: u32 = 1592;
pub const MSR_PP0_ENERGY_STATUS: u32 = 1593;
pub const MSR_PP0_POLICY: u32 = 1594;
pub const MSR_PP0_PERF_STATUS: u32 = 1595;
pub const MSR_PP1_POWER_LIMIT: u32 = 1600;
pub const MSR_PP1_ENERGY_STATUS: u32 = 1601;
pub const MSR_PP1_POLICY: u32 = 1602;
pub const MSR_AMD_RAPL_POWER_UNIT: u32 = 3221291673;
pub const MSR_AMD_CORE_ENERGY_STATUS: u32 = 3221291674;
pub const MSR_AMD_PKG_ENERGY_STATUS: u32 = 3221291675;
pub const MSR_CONFIG_TDP_NOMINAL: u32 = 1608;
pub const MSR_CONFIG_TDP_LEVEL_1: u32 = 1609;
pub const MSR_CONFIG_TDP_LEVEL_2: u32 = 1610;
pub const MSR_CONFIG_TDP_CONTROL: u32 = 1611;
pub const MSR_TURBO_ACTIVATION_RATIO: u32 = 1612;
pub const MSR_PLATFORM_ENERGY_STATUS: u32 = 1613;
pub const MSR_SECONDARY_TURBO_RATIO_LIMIT: u32 = 1616;
pub const MSR_PKG_WEIGHTED_CORE_C0_RES: u32 = 1624;
pub const MSR_PKG_ANY_CORE_C0_RES: u32 = 1625;
pub const MSR_PKG_ANY_GFXE_C0_RES: u32 = 1626;
pub const MSR_PKG_BOTH_CORE_GFXE_C0_RES: u32 = 1627;
pub const MSR_CORE_C1_RES: u32 = 1632;
pub const MSR_MODULE_C6_RES_MS: u32 = 1636;
pub const MSR_CC6_DEMOTION_POLICY_CONFIG: u32 = 1640;
pub const MSR_MC6_DEMOTION_POLICY_CONFIG: u32 = 1641;
pub const MSR_ATOM_CORE_RATIOS: u32 = 1642;
pub const MSR_ATOM_CORE_VIDS: u32 = 1643;
pub const MSR_ATOM_CORE_TURBO_RATIOS: u32 = 1644;
pub const MSR_ATOM_CORE_TURBO_VIDS: u32 = 1645;
pub const MSR_CORE_PERF_LIMIT_REASONS: u32 = 1680;
pub const MSR_GFX_PERF_LIMIT_REASONS: u32 = 1712;
pub const MSR_RING_PERF_LIMIT_REASONS: u32 = 1713;
pub const MSR_IA32_U_CET: u32 = 1696;
pub const MSR_IA32_S_CET: u32 = 1698;
pub const MSR_IA32_PL0_SSP: u32 = 1700;
pub const MSR_IA32_PL1_SSP: u32 = 1701;
pub const MSR_IA32_PL2_SSP: u32 = 1702;
pub const MSR_IA32_PL3_SSP: u32 = 1703;
pub const MSR_IA32_INT_SSP_TAB: u32 = 1704;
pub const MSR_PPERF: u32 = 1614;
pub const MSR_PERF_LIMIT_REASONS: u32 = 1615;
pub const MSR_PM_ENABLE: u32 = 1904;
pub const MSR_HWP_CAPABILITIES: u32 = 1905;
pub const MSR_HWP_REQUEST_PKG: u32 = 1906;
pub const MSR_HWP_INTERRUPT: u32 = 1907;
pub const MSR_HWP_REQUEST: u32 = 1908;
pub const MSR_HWP_STATUS: u32 = 1911;
pub const HWP_BASE_BIT: u32 = 128;
pub const HWP_NOTIFICATIONS_BIT: u32 = 256;
pub const HWP_ACTIVITY_WINDOW_BIT: u32 = 512;
pub const HWP_ENERGY_PERF_PREFERENCE_BIT: u32 = 1024;
pub const HWP_PACKAGE_LEVEL_REQUEST_BIT: u32 = 2048;
pub const HWP_EPP_PERFORMANCE: u32 = 0;
pub const HWP_EPP_BALANCE_PERFORMANCE: u32 = 128;
pub const HWP_EPP_BALANCE_POWERSAVE: u32 = 192;
pub const HWP_EPP_POWERSAVE: u32 = 255;
pub const MSR_AMD64_MC0_MASK: u32 = 3221291076;
pub const MSR_IA32_MC0_CTL2: u32 = 640;
pub const MSR_P6_PERFCTR0: u32 = 193;
pub const MSR_P6_PERFCTR1: u32 = 194;
pub const MSR_P6_EVNTSEL0: u32 = 390;
pub const MSR_P6_EVNTSEL1: u32 = 391;
pub const MSR_KNC_PERFCTR0: u32 = 32;
pub const MSR_KNC_PERFCTR1: u32 = 33;
pub const MSR_KNC_EVNTSEL0: u32 = 40;
pub const MSR_KNC_EVNTSEL1: u32 = 41;
pub const MSR_IA32_PMC0: u32 = 1217;
pub const MSR_RELOAD_PMC0: u32 = 5313;
pub const MSR_RELOAD_FIXED_CTR0: u32 = 4873;
pub const MSR_AMD64_PATCH_LEVEL: u32 = 139;
pub const MSR_AMD64_TSC_RATIO: u32 = 3221225732;
pub const MSR_AMD64_NB_CFG: u32 = 3221291039;
pub const MSR_AMD64_PATCH_LOADER: u32 = 3221291040;
pub const MSR_AMD_PERF_CTL: u32 = 3221291106;
pub const MSR_AMD_PERF_STATUS: u32 = 3221291107;
pub const MSR_AMD_PSTATE_DEF_BASE: u32 = 3221291108;
pub const MSR_AMD64_OSVW_ID_LENGTH: u32 = 3221291328;
pub const MSR_AMD64_OSVW_STATUS: u32 = 3221291329;
pub const MSR_AMD_PPIN_CTL: u32 = 3221291760;
pub const MSR_AMD_PPIN: u32 = 3221291761;
pub const MSR_AMD64_CPUID_FN_1: u32 = 3221295108;
pub const MSR_AMD64_LS_CFG: u32 = 3221295136;
pub const MSR_AMD64_DC_CFG: u32 = 3221295138;
pub const MSR_AMD64_DE_CFG: u32 = 3221295145;
pub const MSR_AMD64_DE_CFG_LFENCE_SERIALIZE_BIT: u32 = 1;
pub const MSR_AMD64_BU_CFG2: u32 = 3221295146;
pub const MSR_AMD64_IBSFETCHCTL: u32 = 3221295152;
pub const MSR_AMD64_IBSFETCHLINAD: u32 = 3221295153;
pub const MSR_AMD64_IBSFETCHPHYSAD: u32 = 3221295154;
pub const MSR_AMD64_IBSFETCH_REG_COUNT: u32 = 3;
pub const MSR_AMD64_IBSFETCH_REG_MASK: u32 = 7;
pub const MSR_AMD64_IBSOPCTL: u32 = 3221295155;
pub const MSR_AMD64_IBSOPRIP: u32 = 3221295156;
pub const MSR_AMD64_IBSOPDATA: u32 = 3221295157;
pub const MSR_AMD64_IBSOPDATA2: u32 = 3221295158;
pub const MSR_AMD64_IBSOPDATA3: u32 = 3221295159;
pub const MSR_AMD64_IBSDCLINAD: u32 = 3221295160;
pub const MSR_AMD64_IBSDCPHYSAD: u32 = 3221295161;
pub const MSR_AMD64_IBSOP_REG_COUNT: u32 = 7;
pub const MSR_AMD64_IBSOP_REG_MASK: u32 = 127;
pub const MSR_AMD64_IBSCTL: u32 = 3221295162;
pub const MSR_AMD64_IBSBRTARGET: u32 = 3221295163;
pub const MSR_AMD64_ICIBSEXTDCTL: u32 = 3221295164;
pub const MSR_AMD64_IBSOPDATA4: u32 = 3221295165;
pub const MSR_AMD64_IBS_REG_COUNT_MAX: u32 = 8;
pub const MSR_AMD64_SVM_AVIC_DOORBELL: u32 = 3221291291;
pub const MSR_AMD64_VM_PAGE_FLUSH: u32 = 3221291294;
pub const MSR_AMD64_SEV_ES_GHCB: u32 = 3221291312;
pub const MSR_AMD64_SEV: u32 = 3221291313;
pub const MSR_AMD64_SEV_ENABLED_BIT: u32 = 0;
pub const MSR_AMD64_SEV_ES_ENABLED_BIT: u32 = 1;
pub const MSR_AMD64_SEV_SNP_ENABLED_BIT: u32 = 2;
pub const MSR_AMD64_VIRT_SPEC_CTRL: u32 = 3221291295;
pub const MSR_AMD_CPPC_CAP1: u32 = 3221291696;
pub const MSR_AMD_CPPC_ENABLE: u32 = 3221291697;
pub const MSR_AMD_CPPC_CAP2: u32 = 3221291698;
pub const MSR_AMD_CPPC_REQ: u32 = 3221291699;
pub const MSR_AMD_CPPC_STATUS: u32 = 3221291700;
pub const MSR_AMD64_PERF_CNTR_GLOBAL_STATUS: u32 = 3221226240;
pub const MSR_AMD64_PERF_CNTR_GLOBAL_CTL: u32 = 3221226241;
pub const MSR_AMD64_PERF_CNTR_GLOBAL_STATUS_CLR: u32 = 3221226242;
pub const MSR_AMD64_LBR_SELECT: u32 = 3221225742;
pub const MSR_F17H_IRPERF: u32 = 3221225705;
pub const MSR_ZEN2_SPECTRAL_CHICKEN: u32 = 3221295331;
pub const MSR_F16H_L2I_PERF_CTL: u32 = 3221291568;
pub const MSR_F16H_L2I_PERF_CTR: u32 = 3221291569;
pub const MSR_F16H_DR1_ADDR_MASK: u32 = 3221295129;
pub const MSR_F16H_DR2_ADDR_MASK: u32 = 3221295130;
pub const MSR_F16H_DR3_ADDR_MASK: u32 = 3221295131;
pub const MSR_F16H_DR0_ADDR_MASK: u32 = 3221295143;
pub const MSR_F15H_CU_PWR_ACCUMULATOR: u32 = 3221291130;
pub const MSR_F15H_CU_MAX_PWR_ACCUMULATOR: u32 = 3221291131;
pub const MSR_F15H_PERF_CTL: u32 = 3221291520;
pub const MSR_F15H_PERF_CTL0: u32 = 3221291520;
pub const MSR_F15H_PERF_CTL1: u32 = 3221291522;
pub const MSR_F15H_PERF_CTL2: u32 = 3221291524;
pub const MSR_F15H_PERF_CTL3: u32 = 3221291526;
pub const MSR_F15H_PERF_CTL4: u32 = 3221291528;
pub const MSR_F15H_PERF_CTL5: u32 = 3221291530;
pub const MSR_F15H_PERF_CTR: u32 = 3221291521;
pub const MSR_F15H_PERF_CTR0: u32 = 3221291521;
pub const MSR_F15H_PERF_CTR1: u32 = 3221291523;
pub const MSR_F15H_PERF_CTR2: u32 = 3221291525;
pub const MSR_F15H_PERF_CTR3: u32 = 3221291527;
pub const MSR_F15H_PERF_CTR4: u32 = 3221291529;
pub const MSR_F15H_PERF_CTR5: u32 = 3221291531;
pub const MSR_F15H_NB_PERF_CTL: u32 = 3221291584;
pub const MSR_F15H_NB_PERF_CTR: u32 = 3221291585;
pub const MSR_F15H_PTSC: u32 = 3221291648;
pub const MSR_F15H_IC_CFG: u32 = 3221295137;
pub const MSR_F15H_EX_CFG: u32 = 3221295148;
pub const MSR_FAM10H_MMIO_CONF_BASE: u32 = 3221291096;
pub const FAM10H_MMIO_CONF_ENABLE: u32 = 1;
pub const FAM10H_MMIO_CONF_BUSRANGE_MASK: u32 = 15;
pub const FAM10H_MMIO_CONF_BUSRANGE_SHIFT: u32 = 2;
pub const FAM10H_MMIO_CONF_BASE_MASK: u32 = 268435455;
pub const FAM10H_MMIO_CONF_BASE_SHIFT: u32 = 20;
pub const MSR_FAM10H_NODE_ID: u32 = 3221295116;
pub const MSR_K8_TOP_MEM1: u32 = 3221291034;
pub const MSR_K8_TOP_MEM2: u32 = 3221291037;
pub const MSR_AMD64_SYSCFG: u32 = 3221291024;
pub const MSR_AMD64_SYSCFG_MEM_ENCRYPT_BIT: u32 = 23;
pub const MSR_K8_INT_PENDING_MSG: u32 = 3221291093;
pub const K8_INTP_C1E_ACTIVE_MASK: u32 = 402653184;
pub const MSR_K8_TSEG_ADDR: u32 = 3221291282;
pub const MSR_K8_TSEG_MASK: u32 = 3221291283;
pub const K8_MTRRFIXRANGE_DRAM_ENABLE: u32 = 262144;
pub const K8_MTRRFIXRANGE_DRAM_MODIFY: u32 = 524288;
pub const K8_MTRR_RDMEM_WRMEM_MASK: u32 = 404232216;
pub const MSR_K7_EVNTSEL0: u32 = 3221291008;
pub const MSR_K7_PERFCTR0: u32 = 3221291012;
pub const MSR_K7_EVNTSEL1: u32 = 3221291009;
pub const MSR_K7_PERFCTR1: u32 = 3221291013;
pub const MSR_K7_EVNTSEL2: u32 = 3221291010;
pub const MSR_K7_PERFCTR2: u32 = 3221291014;
pub const MSR_K7_EVNTSEL3: u32 = 3221291011;
pub const MSR_K7_PERFCTR3: u32 = 3221291015;
pub const MSR_K7_CLK_CTL: u32 = 3221291035;
pub const MSR_K7_HWCR: u32 = 3221291029;
pub const MSR_K7_HWCR_SMMLOCK_BIT: u32 = 0;
pub const MSR_K7_HWCR_IRPERF_EN_BIT: u32 = 30;
pub const MSR_K7_FID_VID_CTL: u32 = 3221291073;
pub const MSR_K7_FID_VID_STATUS: u32 = 3221291074;
pub const MSR_K6_WHCR: u32 = 3221225602;
pub const MSR_K6_UWCCR: u32 = 3221225605;
pub const MSR_K6_EPMR: u32 = 3221225606;
pub const MSR_K6_PSOR: u32 = 3221225607;
pub const MSR_K6_PFIR: u32 = 3221225608;
pub const MSR_IDT_FCR1: u32 = 263;
pub const MSR_IDT_FCR2: u32 = 264;
pub const MSR_IDT_FCR3: u32 = 265;
pub const MSR_IDT_FCR4: u32 = 266;
pub const MSR_IDT_MCR0: u32 = 272;
pub const MSR_IDT_MCR1: u32 = 273;
pub const MSR_IDT_MCR2: u32 = 274;
pub const MSR_IDT_MCR3: u32 = 275;
pub const MSR_IDT_MCR4: u32 = 276;
pub const MSR_IDT_MCR5: u32 = 277;
pub const MSR_IDT_MCR6: u32 = 278;
pub const MSR_IDT_MCR7: u32 = 279;
pub const MSR_IDT_MCR_CTRL: u32 = 288;
pub const MSR_VIA_FCR: u32 = 4359;
pub const MSR_VIA_LONGHAUL: u32 = 4362;
pub const MSR_VIA_RNG: u32 = 4363;
pub const MSR_VIA_BCR2: u32 = 4423;
pub const MSR_TMTA_LONGRUN_CTRL: u32 = 2156298256;
pub const MSR_TMTA_LONGRUN_FLAGS: u32 = 2156298257;
pub const MSR_TMTA_LRTI_READOUT: u32 = 2156298264;
pub const MSR_TMTA_LRTI_VOLT_MHZ: u32 = 2156298266;
pub const MSR_IA32_P5_MC_ADDR: u32 = 0;
pub const MSR_IA32_P5_MC_TYPE: u32 = 1;
pub const MSR_IA32_TSC: u32 = 16;
pub const MSR_IA32_PLATFORM_ID: u32 = 23;
pub const MSR_IA32_EBL_CR_POWERON: u32 = 42;
pub const MSR_EBC_FREQUENCY_ID: u32 = 44;
pub const MSR_SMI_COUNT: u32 = 52;
pub const MSR_IA32_FEAT_CTL: u32 = 58;
pub const MSR_IA32_TSC_ADJUST: u32 = 59;
pub const MSR_IA32_BNDCFGS: u32 = 3472;
pub const MSR_IA32_BNDCFGS_RSVD: u32 = 4092;
pub const MSR_IA32_XFD: u32 = 452;
pub const MSR_IA32_XFD_ERR: u32 = 453;
pub const MSR_IA32_XSS: u32 = 3488;
pub const MSR_IA32_APICBASE: u32 = 27;
pub const MSR_IA32_APICBASE_BSP: u32 = 256;
pub const MSR_IA32_APICBASE_ENABLE: u32 = 2048;
pub const MSR_IA32_APICBASE_BASE: u32 = 4294963200;
pub const MSR_IA32_UCODE_WRITE: u32 = 121;
pub const MSR_IA32_UCODE_REV: u32 = 139;
pub const MSR_IA32_SGXLEPUBKEYHASH0: u32 = 140;
pub const MSR_IA32_SGXLEPUBKEYHASH1: u32 = 141;
pub const MSR_IA32_SGXLEPUBKEYHASH2: u32 = 142;
pub const MSR_IA32_SGXLEPUBKEYHASH3: u32 = 143;
pub const MSR_IA32_SMM_MONITOR_CTL: u32 = 155;
pub const MSR_IA32_SMBASE: u32 = 158;
pub const MSR_IA32_PERF_STATUS: u32 = 408;
pub const MSR_IA32_PERF_CTL: u32 = 409;
pub const INTEL_PERF_CTL_MASK: u32 = 65535;
pub const MSR_AMD_DBG_EXTN_CFG: u32 = 3221225743;
pub const MSR_AMD_SAMP_BR_FROM: u32 = 3221291776;
pub const MSR_IA32_MPERF: u32 = 231;
pub const MSR_IA32_APERF: u32 = 232;
pub const MSR_IA32_THERM_CONTROL: u32 = 410;
pub const MSR_IA32_THERM_INTERRUPT: u32 = 411;
pub const THERM_INT_HIGH_ENABLE: u32 = 1;
pub const THERM_INT_LOW_ENABLE: u32 = 2;
pub const THERM_INT_PLN_ENABLE: u32 = 16777216;
pub const MSR_IA32_THERM_STATUS: u32 = 412;
pub const THERM_STATUS_PROCHOT: u32 = 1;
pub const THERM_STATUS_POWER_LIMIT: u32 = 1024;
pub const MSR_THERM2_CTL: u32 = 413;
pub const MSR_THERM2_CTL_TM_SELECT: u32 = 65536;
pub const MSR_IA32_MISC_ENABLE: u32 = 416;
pub const MSR_IA32_TEMPERATURE_TARGET: u32 = 418;
pub const MSR_MISC_FEATURE_CONTROL: u32 = 420;
pub const MSR_MISC_PWR_MGMT: u32 = 426;
pub const MSR_IA32_ENERGY_PERF_BIAS: u32 = 432;
pub const ENERGY_PERF_BIAS_PERFORMANCE: u32 = 0;
pub const ENERGY_PERF_BIAS_BALANCE_PERFORMANCE: u32 = 4;
pub const ENERGY_PERF_BIAS_NORMAL: u32 = 6;
pub const ENERGY_PERF_BIAS_BALANCE_POWERSAVE: u32 = 8;
pub const ENERGY_PERF_BIAS_POWERSAVE: u32 = 15;
pub const MSR_IA32_PACKAGE_THERM_STATUS: u32 = 433;
pub const PACKAGE_THERM_STATUS_PROCHOT: u32 = 1;
pub const PACKAGE_THERM_STATUS_POWER_LIMIT: u32 = 1024;
pub const PACKAGE_THERM_STATUS_HFI_UPDATED: u32 = 67108864;
pub const MSR_IA32_PACKAGE_THERM_INTERRUPT: u32 = 434;
pub const PACKAGE_THERM_INT_HIGH_ENABLE: u32 = 1;
pub const PACKAGE_THERM_INT_LOW_ENABLE: u32 = 2;
pub const PACKAGE_THERM_INT_PLN_ENABLE: u32 = 16777216;
pub const PACKAGE_THERM_INT_HFI_ENABLE: u32 = 33554432;
pub const THERM_INT_THRESHOLD0_ENABLE: u32 = 32768;
pub const THERM_SHIFT_THRESHOLD0: u32 = 8;
pub const THERM_MASK_THRESHOLD0: u32 = 32512;
pub const THERM_INT_THRESHOLD1_ENABLE: u32 = 8388608;
pub const THERM_SHIFT_THRESHOLD1: u32 = 16;
pub const THERM_MASK_THRESHOLD1: u32 = 8323072;
pub const THERM_STATUS_THRESHOLD0: u32 = 64;
pub const THERM_LOG_THRESHOLD0: u32 = 128;
pub const THERM_STATUS_THRESHOLD1: u32 = 256;
pub const THERM_LOG_THRESHOLD1: u32 = 512;
pub const MSR_IA32_MISC_ENABLE_FAST_STRING_BIT: u32 = 0;
pub const MSR_IA32_MISC_ENABLE_FAST_STRING: u32 = 1;
pub const MSR_IA32_MISC_ENABLE_TCC_BIT: u32 = 1;
pub const MSR_IA32_MISC_ENABLE_TCC: u32 = 2;
pub const MSR_IA32_MISC_ENABLE_EMON_BIT: u32 = 7;
pub const MSR_IA32_MISC_ENABLE_EMON: u32 = 128;
pub const MSR_IA32_MISC_ENABLE_BTS_UNAVAIL_BIT: u32 = 11;
pub const MSR_IA32_MISC_ENABLE_BTS_UNAVAIL: u32 = 2048;
pub const MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL_BIT: u32 = 12;
pub const MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL: u32 = 4096;
pub const MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP_BIT: u32 = 16;
pub const MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP: u32 = 65536;
pub const MSR_IA32_MISC_ENABLE_MWAIT_BIT: u32 = 18;
pub const MSR_IA32_MISC_ENABLE_MWAIT: u32 = 262144;
pub const MSR_IA32_MISC_ENABLE_LIMIT_CPUID_BIT: u32 = 22;
pub const MSR_IA32_MISC_ENABLE_LIMIT_CPUID: u32 = 4194304;
pub const MSR_IA32_MISC_ENABLE_XTPR_DISABLE_BIT: u32 = 23;
pub const MSR_IA32_MISC_ENABLE_XTPR_DISABLE: u32 = 8388608;
pub const MSR_IA32_MISC_ENABLE_XD_DISABLE_BIT: u32 = 34;
pub const MSR_IA32_MISC_ENABLE_XD_DISABLE: u64 = 17179869184;
pub const MSR_IA32_MISC_ENABLE_X87_COMPAT_BIT: u32 = 2;
pub const MSR_IA32_MISC_ENABLE_X87_COMPAT: u32 = 4;
pub const MSR_IA32_MISC_ENABLE_TM1_BIT: u32 = 3;
pub const MSR_IA32_MISC_ENABLE_TM1: u32 = 8;
pub const MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE_BIT: u32 = 4;
pub const MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE: u32 = 16;
pub const MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE_BIT: u32 = 6;
pub const MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE: u32 = 64;
pub const MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK_BIT: u32 = 8;
pub const MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK: u32 = 256;
pub const MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE_BIT: u32 = 9;
pub const MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE: u32 = 512;
pub const MSR_IA32_MISC_ENABLE_FERR_BIT: u32 = 10;
pub const MSR_IA32_MISC_ENABLE_FERR: u32 = 1024;
pub const MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX_BIT: u32 = 10;
pub const MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX: u32 = 1024;
pub const MSR_IA32_MISC_ENABLE_TM2_BIT: u32 = 13;
pub const MSR_IA32_MISC_ENABLE_TM2: u32 = 8192;
pub const MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE_BIT: u32 = 19;
pub const MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE: u32 = 524288;
pub const MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK_BIT: u32 = 20;
pub const MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK: u32 = 1048576;
pub const MSR_IA32_MISC_ENABLE_L1D_CONTEXT_BIT: u32 = 24;
pub const MSR_IA32_MISC_ENABLE_L1D_CONTEXT: u32 = 16777216;
pub const MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE_BIT: u32 = 37;
pub const MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE: u64 = 137438953472;
pub const MSR_IA32_MISC_ENABLE_TURBO_DISABLE_BIT: u32 = 38;
pub const MSR_IA32_MISC_ENABLE_TURBO_DISABLE: u64 = 274877906944;
pub const MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE_BIT: u32 = 39;
pub const MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE: u64 = 549755813888;
pub const MSR_MISC_FEATURES_ENABLES: u32 = 320;
pub const MSR_MISC_FEATURES_ENABLES_CPUID_FAULT_BIT: u32 = 0;
pub const MSR_MISC_FEATURES_ENABLES_RING3MWAIT_BIT: u32 = 1;
pub const MSR_IA32_TSC_DEADLINE: u32 = 1760;
pub const MSR_TSX_FORCE_ABORT: u32 = 271;
pub const MSR_TFA_RTM_FORCE_ABORT_BIT: u32 = 0;
pub const MSR_TFA_TSX_CPUID_CLEAR_BIT: u32 = 1;
pub const MSR_TFA_SDV_ENABLE_RTM_BIT: u32 = 2;
pub const MSR_IA32_MCG_EAX: u32 = 384;
pub const MSR_IA32_MCG_EBX: u32 = 385;
pub const MSR_IA32_MCG_ECX: u32 = 386;
pub const MSR_IA32_MCG_EDX: u32 = 387;
pub const MSR_IA32_MCG_ESI: u32 = 388;
pub const MSR_IA32_MCG_EDI: u32 = 389;
pub const MSR_IA32_MCG_EBP: u32 = 390;
pub const MSR_IA32_MCG_ESP: u32 = 391;
pub const MSR_IA32_MCG_EFLAGS: u32 = 392;
pub const MSR_IA32_MCG_EIP: u32 = 393;
pub const MSR_IA32_MCG_RESERVED: u32 = 394;
pub const MSR_P4_BPU_PERFCTR0: u32 = 768;
pub const MSR_P4_BPU_PERFCTR1: u32 = 769;
pub const MSR_P4_BPU_PERFCTR2: u32 = 770;
pub const MSR_P4_BPU_PERFCTR3: u32 = 771;
pub const MSR_P4_MS_PERFCTR0: u32 = 772;
pub const MSR_P4_MS_PERFCTR1: u32 = 773;
pub const MSR_P4_MS_PERFCTR2: u32 = 774;
pub const MSR_P4_MS_PERFCTR3: u32 = 775;
pub const MSR_P4_FLAME_PERFCTR0: u32 = 776;
pub const MSR_P4_FLAME_PERFCTR1: u32 = 777;
pub const MSR_P4_FLAME_PERFCTR2: u32 = 778;
pub const MSR_P4_FLAME_PERFCTR3: u32 = 779;
pub const MSR_P4_IQ_PERFCTR0: u32 = 780;
pub const MSR_P4_IQ_PERFCTR1: u32 = 781;
pub const MSR_P4_IQ_PERFCTR2: u32 = 782;
pub const MSR_P4_IQ_PERFCTR3: u32 = 783;
pub const MSR_P4_IQ_PERFCTR4: u32 = 784;
pub const MSR_P4_IQ_PERFCTR5: u32 = 785;
pub const MSR_P4_BPU_CCCR0: u32 = 864;
pub const MSR_P4_BPU_CCCR1: u32 = 865;
pub const MSR_P4_BPU_CCCR2: u32 = 866;
pub const MSR_P4_BPU_CCCR3: u32 = 867;
pub const MSR_P4_MS_CCCR0: u32 = 868;
pub const MSR_P4_MS_CCCR1: u32 = 869;
pub const MSR_P4_MS_CCCR2: u32 = 870;
pub const MSR_P4_MS_CCCR3: u32 = 871;
pub const MSR_P4_FLAME_CCCR0: u32 = 872;
pub const MSR_P4_FLAME_CCCR1: u32 = 873;
pub const MSR_P4_FLAME_CCCR2: u32 = 874;
pub const MSR_P4_FLAME_CCCR3: u32 = 875;
pub const MSR_P4_IQ_CCCR0: u32 = 876;
pub const MSR_P4_IQ_CCCR1: u32 = 877;
pub const MSR_P4_IQ_CCCR2: u32 = 878;
pub const MSR_P4_IQ_CCCR3: u32 = 879;
pub const MSR_P4_IQ_CCCR4: u32 = 880;
pub const MSR_P4_IQ_CCCR5: u32 = 881;
pub const MSR_P4_ALF_ESCR0: u32 = 970;
pub const MSR_P4_ALF_ESCR1: u32 = 971;
pub const MSR_P4_BPU_ESCR0: u32 = 946;
pub const MSR_P4_BPU_ESCR1: u32 = 947;
pub const MSR_P4_BSU_ESCR0: u32 = 928;
pub const MSR_P4_BSU_ESCR1: u32 = 929;
pub const MSR_P4_CRU_ESCR0: u32 = 952;
pub const MSR_P4_CRU_ESCR1: u32 = 953;
pub const MSR_P4_CRU_ESCR2: u32 = 972;
pub const MSR_P4_CRU_ESCR3: u32 = 973;
pub const MSR_P4_CRU_ESCR4: u32 = 992;
pub const MSR_P4_CRU_ESCR5: u32 = 993;
pub const MSR_P4_DAC_ESCR0: u32 = 936;
pub const MSR_P4_DAC_ESCR1: u32 = 937;
pub const MSR_P4_FIRM_ESCR0: u32 = 932;
pub const MSR_P4_FIRM_ESCR1: u32 = 933;
pub const MSR_P4_FLAME_ESCR0: u32 = 934;
pub const MSR_P4_FLAME_ESCR1: u32 = 935;
pub const MSR_P4_FSB_ESCR0: u32 = 930;
pub const MSR_P4_FSB_ESCR1: u32 = 931;
pub const MSR_P4_IQ_ESCR0: u32 = 954;
pub const MSR_P4_IQ_ESCR1: u32 = 955;
pub const MSR_P4_IS_ESCR0: u32 = 948;
pub const MSR_P4_IS_ESCR1: u32 = 949;
pub const MSR_P4_ITLB_ESCR0: u32 = 950;
pub const MSR_P4_ITLB_ESCR1: u32 = 951;
pub const MSR_P4_IX_ESCR0: u32 = 968;
pub const MSR_P4_IX_ESCR1: u32 = 969;
pub const MSR_P4_MOB_ESCR0: u32 = 938;
pub const MSR_P4_MOB_ESCR1: u32 = 939;
pub const MSR_P4_MS_ESCR0: u32 = 960;
pub const MSR_P4_MS_ESCR1: u32 = 961;
pub const MSR_P4_PMH_ESCR0: u32 = 940;
pub const MSR_P4_PMH_ESCR1: u32 = 941;
pub const MSR_P4_RAT_ESCR0: u32 = 956;
pub const MSR_P4_RAT_ESCR1: u32 = 957;
pub const MSR_P4_SAAT_ESCR0: u32 = 942;
pub const MSR_P4_SAAT_ESCR1: u32 = 943;
pub const MSR_P4_SSU_ESCR0: u32 = 958;
pub const MSR_P4_SSU_ESCR1: u32 = 959;
pub const MSR_P4_TBPU_ESCR0: u32 = 962;
pub const MSR_P4_TBPU_ESCR1: u32 = 963;
pub const MSR_P4_TC_ESCR0: u32 = 964;
pub const MSR_P4_TC_ESCR1: u32 = 965;
pub const MSR_P4_U2L_ESCR0: u32 = 944;
pub const MSR_P4_U2L_ESCR1: u32 = 945;
pub const MSR_P4_PEBS_MATRIX_VERT: u32 = 1010;
pub const MSR_CORE_PERF_FIXED_CTR0: u32 = 777;
pub const MSR_CORE_PERF_FIXED_CTR1: u32 = 778;
pub const MSR_CORE_PERF_FIXED_CTR2: u32 = 779;
pub const MSR_CORE_PERF_FIXED_CTR3: u32 = 780;
pub const MSR_CORE_PERF_FIXED_CTR_CTRL: u32 = 909;
pub const MSR_CORE_PERF_GLOBAL_STATUS: u32 = 910;
pub const MSR_CORE_PERF_GLOBAL_CTRL: u32 = 911;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL: u32 = 912;
pub const MSR_PERF_METRICS: u32 = 809;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_TRACE_TOPA_PMI_BIT: u32 = 55;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_TRACE_TOPA_PMI: u64 = 36028797018963968;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_OVF_BUF_BIT: u32 = 62;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_OVF_BUF: u64 = 4611686018427387904;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_COND_CHGD_BIT: u32 = 63;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_COND_CHGD: i64 = -9223372036854775808;
pub const MSR_GEODE_BUSCONT_CONF0: u32 = 6400;
pub const MSR_IA32_VMX_BASIC: u32 = 1152;
pub const MSR_IA32_VMX_PINBASED_CTLS: u32 = 1153;
pub const MSR_IA32_VMX_PROCBASED_CTLS: u32 = 1154;
pub const MSR_IA32_VMX_EXIT_CTLS: u32 = 1155;
pub const MSR_IA32_VMX_ENTRY_CTLS: u32 = 1156;
pub const MSR_IA32_VMX_MISC: u32 = 1157;
pub const MSR_IA32_VMX_CR0_FIXED0: u32 = 1158;
pub const MSR_IA32_VMX_CR0_FIXED1: u32 = 1159;
pub const MSR_IA32_VMX_CR4_FIXED0: u32 = 1160;
pub const MSR_IA32_VMX_CR4_FIXED1: u32 = 1161;
pub const MSR_IA32_VMX_VMCS_ENUM: u32 = 1162;
pub const MSR_IA32_VMX_PROCBASED_CTLS2: u32 = 1163;
pub const MSR_IA32_VMX_EPT_VPID_CAP: u32 = 1164;
pub const MSR_IA32_VMX_TRUE_PINBASED_CTLS: u32 = 1165;
pub const MSR_IA32_VMX_TRUE_PROCBASED_CTLS: u32 = 1166;
pub const MSR_IA32_VMX_TRUE_EXIT_CTLS: u32 = 1167;
pub const MSR_IA32_VMX_TRUE_ENTRY_CTLS: u32 = 1168;
pub const MSR_IA32_VMX_VMFUNC: u32 = 1169;
pub const MSR_IA32_VMX_PROCBASED_CTLS3: u32 = 1170;
pub const VMX_BASIC_VMCS_SIZE_SHIFT: u32 = 32;
pub const VMX_BASIC_TRUE_CTLS: u64 = 36028797018963968;
pub const VMX_BASIC_64: u64 = 281474976710656;
pub const VMX_BASIC_MEM_TYPE_SHIFT: u32 = 50;
pub const VMX_BASIC_MEM_TYPE_MASK: u64 = 16888498602639360;
pub const VMX_BASIC_MEM_TYPE_WB: u32 = 6;
pub const VMX_BASIC_INOUT: u64 = 18014398509481984;
pub const MSR_IA32_VMX_MISC_INTEL_PT: u32 = 16384;
pub const MSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS: u32 = 536870912;
pub const MSR_IA32_VMX_MISC_PREEMPTION_TIMER_SCALE: u32 = 31;
pub const MSR_VM_CR: u32 = 3221291284;
pub const MSR_VM_IGNNE: u32 = 3221291285;
pub const MSR_VM_HSAVE_PA: u32 = 3221291287;
pub const MSR_IA32_HW_FEEDBACK_PTR: u32 = 6096;
pub const MSR_IA32_HW_FEEDBACK_CONFIG: u32 = 6097;
pub const MSR_IA32_XAPIC_DISABLE_STATUS: u32 = 189;
pub const ORC_REG_UNDEFINED: u32 = 0;
pub const ORC_REG_PREV_SP: u32 = 1;
pub const ORC_REG_DX: u32 = 2;
pub const ORC_REG_DI: u32 = 3;
pub const ORC_REG_BP: u32 = 4;
pub const ORC_REG_SP: u32 = 5;
pub const ORC_REG_R10: u32 = 6;
pub const ORC_REG_R13: u32 = 7;
pub const ORC_REG_BP_INDIRECT: u32 = 8;
pub const ORC_REG_SP_INDIRECT: u32 = 9;
pub const ORC_REG_MAX: u32 = 15;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const UINT_MAX: i32 = -1;
pub const ULONG_MAX: i32 = -1;
pub const ULLONG_MAX: i32 = -1;
pub const UINTPTR_MAX: i32 = -1;
pub const STATIC_CALL_SITE_TAIL: u32 = 1;
pub const STATIC_CALL_SITE_INIT: u32 = 2;
pub const STATIC_CALL_SITE_FLAGS: u32 = 3;
pub const STACK_MAGIC: u32 = 3735928559;
pub const READ: u32 = 0;
pub const WRITE: u32 = 1;
pub const NR_CPUS: u32 = 64;
pub const MIN_THREADS_LEFT_FOR_ROOT: u32 = 4;
pub const PIDS_PER_CPU_DEFAULT: u32 = 1024;
pub const PIDS_PER_CPU_MIN: u32 = 8;
pub const PER_CPU_SHARED_ALIGNED_SECTION: &'static [u8; 17usize] = b"..shared_aligned\0";
pub const PER_CPU_ALIGNED_SECTION: &'static [u8; 17usize] = b"..shared_aligned\0";
pub const PER_CPU_FIRST_SECTION: &'static [u8; 8usize] = b"..first\0";
pub const PER_CPU_BASE_SECTION: &'static [u8; 14usize] = b".data..percpu\0";
pub const RETPOLINE_THUNK_SIZE: u32 = 32;
pub const RSB_CLEAR_LOOPS: u32 = 32;
pub const GDT_ENTRY_BOOT_CS: u32 = 2;
pub const GDT_ENTRY_BOOT_DS: u32 = 3;
pub const GDT_ENTRY_BOOT_TSS: u32 = 4;
pub const __BOOT_CS: u32 = 16;
pub const __BOOT_DS: u32 = 24;
pub const __BOOT_TSS: u32 = 32;
pub const SEGMENT_RPL_MASK: u32 = 3;
pub const USER_SEGMENT_RPL_MASK: u32 = 2;
pub const USER_RPL: u32 = 3;
pub const SEGMENT_TI_MASK: u32 = 4;
pub const SEGMENT_LDT: u32 = 4;
pub const SEGMENT_GDT: u32 = 0;
pub const GDT_ENTRY_INVALID_SEG: u32 = 0;
pub const L1_CACHE_SHIFT: u32 = 6;
pub const L1_CACHE_BYTES: u32 = 64;
pub const INTERNODE_CACHE_SHIFT: u32 = 6;
pub const INTERNODE_CACHE_BYTES: u32 = 64;
pub const GDT_ENTRY_KERNEL32_CS: u32 = 1;
pub const GDT_ENTRY_KERNEL_CS: u32 = 2;
pub const GDT_ENTRY_KERNEL_DS: u32 = 3;
pub const GDT_ENTRY_DEFAULT_USER32_CS: u32 = 4;
pub const GDT_ENTRY_DEFAULT_USER_DS: u32 = 5;
pub const GDT_ENTRY_DEFAULT_USER_CS: u32 = 6;
pub const GDT_ENTRY_TSS: u32 = 8;
pub const GDT_ENTRY_LDT: u32 = 10;
pub const GDT_ENTRY_TLS_MIN: u32 = 12;
pub const GDT_ENTRY_TLS_MAX: u32 = 14;
pub const GDT_ENTRY_CPUNODE: u32 = 15;
pub const GDT_ENTRIES: u32 = 16;
pub const __KERNEL32_CS: u32 = 8;
pub const __KERNEL_CS: u32 = 16;
pub const __KERNEL_DS: u32 = 24;
pub const __USER32_CS: u32 = 35;
pub const __USER_DS: u32 = 43;
pub const __USER32_DS: u32 = 43;
pub const __USER_CS: u32 = 51;
pub const __CPUNODE_SEG: u32 = 123;
pub const IDT_ENTRIES: u32 = 256;
pub const NUM_EXCEPTION_VECTORS: u32 = 32;
pub const EXCEPTION_ERRCODE_MASK: u32 = 537033984;
pub const GDT_SIZE: u32 = 128;
pub const GDT_ENTRY_TLS_ENTRIES: u32 = 3;
pub const TLS_SIZE: u32 = 24;
pub const VDSO_CPUNODE_BITS: u32 = 12;
pub const VDSO_CPUNODE_MASK: u32 = 4095;
pub const EARLY_IDT_HANDLER_SIZE: u32 = 9;
pub const XEN_EARLY_IDT_HANDLER_SIZE: u32 = 8;
pub const CLBR_EAX: u32 = 1;
pub const CLBR_ECX: u32 = 2;
pub const CLBR_EDX: u32 = 4;
pub const CLBR_EDI: u32 = 8;
pub const CLBR_RAX: u32 = 1;
pub const CLBR_RCX: u32 = 2;
pub const CLBR_RDX: u32 = 4;
pub const CLBR_RDI: u32 = 8;
pub const CLBR_RSI: u32 = 16;
pub const CLBR_R8: u32 = 32;
pub const CLBR_R9: u32 = 64;
pub const CLBR_R10: u32 = 128;
pub const CLBR_R11: u32 = 256;
pub const CLBR_ANY: u32 = 511;
pub const CLBR_ARG_REGS: u32 = 126;
pub const CLBR_RET_REG: u32 = 1;
pub const BOOT_IDT_ENTRIES: u32 = 32;
pub const AR_TYPE_RODATA: u32 = 0;
pub const AR_TYPE_RWDATA: u32 = 512;
pub const AR_TYPE_RODATA_EXPDOWN: u32 = 1024;
pub const AR_TYPE_RWDATA_EXPDOWN: u32 = 1536;
pub const AR_TYPE_XOCODE: u32 = 2048;
pub const AR_TYPE_XRCODE: u32 = 2560;
pub const AR_TYPE_XOCODE_CONF: u32 = 3072;
pub const AR_TYPE_XRCODE_CONF: u32 = 3584;
pub const AR_TYPE_MASK: u32 = 3584;
pub const AR_DPL0: u32 = 0;
pub const AR_DPL3: u32 = 24576;
pub const AR_DPL_MASK: u32 = 24576;
pub const AR_A: u32 = 256;
pub const AR_S: u32 = 4096;
pub const AR_P: u32 = 32768;
pub const AR_AVL: u32 = 1048576;
pub const AR_L: u32 = 2097152;
pub const AR_DB: u32 = 4194304;
pub const AR_G: u32 = 8388608;
pub const BITMAP_MEM_ALIGNMENT: u32 = 8;
pub const BITMAP_MEM_MASK: u32 = 7;
pub const __X86_CASE_B: u32 = 1;
pub const __X86_CASE_W: u32 = 2;
pub const __X86_CASE_L: u32 = 4;
pub const __X86_CASE_Q: u32 = 8;
pub const ___GFP_DMA: u32 = 1;
pub const ___GFP_HIGHMEM: u32 = 2;
pub const ___GFP_DMA32: u32 = 4;
pub const ___GFP_MOVABLE: u32 = 8;
pub const ___GFP_RECLAIMABLE: u32 = 16;
pub const ___GFP_HIGH: u32 = 32;
pub const ___GFP_IO: u32 = 64;
pub const ___GFP_FS: u32 = 128;
pub const ___GFP_ZERO: u32 = 256;
pub const ___GFP_ATOMIC: u32 = 512;
pub const ___GFP_DIRECT_RECLAIM: u32 = 1024;
pub const ___GFP_KSWAPD_RECLAIM: u32 = 2048;
pub const ___GFP_WRITE: u32 = 4096;
pub const ___GFP_NOWARN: u32 = 8192;
pub const ___GFP_RETRY_MAYFAIL: u32 = 16384;
pub const ___GFP_NOFAIL: u32 = 32768;
pub const ___GFP_NORETRY: u32 = 65536;
pub const ___GFP_MEMALLOC: u32 = 131072;
pub const ___GFP_COMP: u32 = 262144;
pub const ___GFP_NOMEMALLOC: u32 = 524288;
pub const ___GFP_HARDWALL: u32 = 1048576;
pub const ___GFP_THISNODE: u32 = 2097152;
pub const ___GFP_ACCOUNT: u32 = 4194304;
pub const ___GFP_ZEROTAGS: u32 = 8388608;
pub const ___GFP_SKIP_ZERO: u32 = 0;
pub const ___GFP_SKIP_KASAN_UNPOISON: u32 = 0;
pub const ___GFP_SKIP_KASAN_POISON: u32 = 0;
pub const ___GFP_NOLOCKDEP: u32 = 0;
pub const NODES_SHIFT: u32 = 6;
pub const MAX_NUMNODES: u32 = 64;
pub const NUMA_NO_NODE: i32 = -1;
pub const FRAME_OFFSET: u32 = 0;
pub const PV_SAVE_ALL_CALLER_REGS: &'static [u8; 79usize] =
    b"push %rcx;push %rdx;push %rsi;push %rdi;push %r8;push %r9;push %r10;push %r11;\0";
pub const PV_RESTORE_ALL_CALLER_REGS: &'static [u8; 71usize] =
    b"pop %r11;pop %r10;pop %r9;pop %r8;pop %rdi;pop %rsi;pop %rdx;pop %rcx;\0";
pub const IO_SPACE_LIMIT: u32 = 65535;
pub const PAGE_POISON: u32 = 170;
pub const RED_INACTIVE: u64 = 718624318471594843;
pub const RED_ACTIVE: i64 = -2863912482255763264;
pub const SLUB_RED_INACTIVE: u32 = 187;
pub const SLUB_RED_ACTIVE: u32 = 204;
pub const POISON_INUSE: u32 = 90;
pub const POISON_FREE: u32 = 107;
pub const POISON_END: u32 = 165;
pub const POISON_FREE_INITMEM: u32 = 204;
pub const JBD_POISON_FREE: u32 = 91;
pub const JBD2_POISON_FREE: u32 = 92;
pub const POOL_POISON_FREED: u32 = 167;
pub const POOL_POISON_ALLOCATED: u32 = 169;
pub const ATM_POISON_FREE: u32 = 18;
pub const ATM_POISON: u32 = 3735928559;
pub const MUTEX_DEBUG_INIT: u32 = 17;
pub const MUTEX_DEBUG_FREE: u32 = 34;
pub const KEY_DESTROY: u32 = 189;
pub const SWNODE_GRAPH_PORT_NAME_FMT: &'static [u8; 8usize] = b"port@%u\0";
pub const SWNODE_GRAPH_ENDPOINT_NAME_FMT: &'static [u8; 12usize] = b"endpoint@%u\0";
pub const NR_FWNODE_REFERENCE_ARGS: u32 = 8;
pub const PIO_INDIRECT_SIZE: u32 = 0;
pub const MMIO_UPPER_LIMIT: u32 = 65535;
pub const PREEMPT_BITS: u32 = 8;
pub const SOFTIRQ_BITS: u32 = 8;
pub const HARDIRQ_BITS: u32 = 4;
pub const NMI_BITS: u32 = 4;
pub const PREEMPT_SHIFT: u32 = 0;
pub const SOFTIRQ_SHIFT: u32 = 8;
pub const HARDIRQ_SHIFT: u32 = 16;
pub const NMI_SHIFT: u32 = 20;
pub const PREEMPT_OFFSET: u32 = 1;
pub const SOFTIRQ_OFFSET: u32 = 256;
pub const HARDIRQ_OFFSET: u32 = 65536;
pub const NMI_OFFSET: u32 = 1048576;
pub const SOFTIRQ_DISABLE_OFFSET: u32 = 512;
pub const INIT_PREEMPT_COUNT: u32 = 1;
pub const MSEC_PER_SEC: u32 = 1000;
pub const USEC_PER_MSEC: u32 = 1000;
pub const NSEC_PER_USEC: u32 = 1000;
pub const NSEC_PER_MSEC: u32 = 1000000;
pub const USEC_PER_SEC: u32 = 1000000;
pub const NSEC_PER_SEC: u32 = 1000000000;
pub const PSEC_PER_SEC: u64 = 1000000000000;
pub const FSEC_PER_SEC: u64 = 1000000000000000;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_SGI_CYCLE: u32 = 10;
pub const CLOCK_TAI: u32 = 11;
pub const MAX_CLOCKS: u32 = 16;
pub const CLOCKS_MASK: u32 = 1;
pub const CLOCKS_MONO: u32 = 1;
pub const TIMER_ABSTIME: u32 = 1;
pub const PSEC_PER_NSEC: u32 = 1000;
pub const TIME_UPTIME_SEC_MAX: u32 = 946080000;
pub const TOP_OF_KERNEL_STACK_PADDING: u32 = 0;
pub const X86_EFLAGS_CF_BIT: u32 = 0;
pub const X86_EFLAGS_FIXED_BIT: u32 = 1;
pub const X86_EFLAGS_PF_BIT: u32 = 2;
pub const X86_EFLAGS_AF_BIT: u32 = 4;
pub const X86_EFLAGS_ZF_BIT: u32 = 6;
pub const X86_EFLAGS_SF_BIT: u32 = 7;
pub const X86_EFLAGS_TF_BIT: u32 = 8;
pub const X86_EFLAGS_IF_BIT: u32 = 9;
pub const X86_EFLAGS_DF_BIT: u32 = 10;
pub const X86_EFLAGS_OF_BIT: u32 = 11;
pub const X86_EFLAGS_IOPL_BIT: u32 = 12;
pub const X86_EFLAGS_NT_BIT: u32 = 14;
pub const X86_EFLAGS_RF_BIT: u32 = 16;
pub const X86_EFLAGS_VM_BIT: u32 = 17;
pub const X86_EFLAGS_AC_BIT: u32 = 18;
pub const X86_EFLAGS_VIF_BIT: u32 = 19;
pub const X86_EFLAGS_VIP_BIT: u32 = 20;
pub const X86_EFLAGS_ID_BIT: u32 = 21;
pub const X86_CR0_PE_BIT: u32 = 0;
pub const X86_CR0_MP_BIT: u32 = 1;
pub const X86_CR0_EM_BIT: u32 = 2;
pub const X86_CR0_TS_BIT: u32 = 3;
pub const X86_CR0_ET_BIT: u32 = 4;
pub const X86_CR0_NE_BIT: u32 = 5;
pub const X86_CR0_WP_BIT: u32 = 16;
pub const X86_CR0_AM_BIT: u32 = 18;
pub const X86_CR0_NW_BIT: u32 = 29;
pub const X86_CR0_CD_BIT: u32 = 30;
pub const X86_CR0_PG_BIT: u32 = 31;
pub const X86_CR3_PWT_BIT: u32 = 3;
pub const X86_CR3_PCD_BIT: u32 = 4;
pub const X86_CR3_PCID_BITS: u32 = 12;
pub const X86_CR3_PCID_NOFLUSH_BIT: u32 = 63;
pub const X86_CR4_VME_BIT: u32 = 0;
pub const X86_CR4_PVI_BIT: u32 = 1;
pub const X86_CR4_TSD_BIT: u32 = 2;
pub const X86_CR4_DE_BIT: u32 = 3;
pub const X86_CR4_PSE_BIT: u32 = 4;
pub const X86_CR4_PAE_BIT: u32 = 5;
pub const X86_CR4_MCE_BIT: u32 = 6;
pub const X86_CR4_PGE_BIT: u32 = 7;
pub const X86_CR4_PCE_BIT: u32 = 8;
pub const X86_CR4_OSFXSR_BIT: u32 = 9;
pub const X86_CR4_OSXMMEXCPT_BIT: u32 = 10;
pub const X86_CR4_UMIP_BIT: u32 = 11;
pub const X86_CR4_LA57_BIT: u32 = 12;
pub const X86_CR4_VMXE_BIT: u32 = 13;
pub const X86_CR4_SMXE_BIT: u32 = 14;
pub const X86_CR4_FSGSBASE_BIT: u32 = 16;
pub const X86_CR4_PCIDE_BIT: u32 = 17;
pub const X86_CR4_OSXSAVE_BIT: u32 = 18;
pub const X86_CR4_SMEP_BIT: u32 = 20;
pub const X86_CR4_SMAP_BIT: u32 = 21;
pub const X86_CR4_PKE_BIT: u32 = 22;
pub const X86_CR4_CET_BIT: u32 = 23;
pub const CX86_PCR0: u32 = 32;
pub const CX86_GCR: u32 = 184;
pub const CX86_CCR0: u32 = 192;
pub const CX86_CCR1: u32 = 193;
pub const CX86_CCR2: u32 = 194;
pub const CX86_CCR3: u32 = 195;
pub const CX86_CCR4: u32 = 232;
pub const CX86_CCR5: u32 = 233;
pub const CX86_CCR6: u32 = 234;
pub const CX86_CCR7: u32 = 235;
pub const CX86_PCR1: u32 = 240;
pub const CX86_DIR0: u32 = 254;
pub const CX86_DIR1: u32 = 255;
pub const CX86_ARR_BASE: u32 = 196;
pub const CX86_RCR_BASE: u32 = 220;
pub const X86_VM_MASK: u32 = 0;
pub const CR3_PCID_MASK: u32 = 4095;
pub const X86_CR3_PTI_PCID_USER_BIT: u32 = 11;
pub const FRAME_SIZE: u32 = 168;
pub const PTRACE_GETREGS: u32 = 12;
pub const PTRACE_SETREGS: u32 = 13;
pub const PTRACE_GETFPREGS: u32 = 14;
pub const PTRACE_SETFPREGS: u32 = 15;
pub const PTRACE_GETFPXREGS: u32 = 18;
pub const PTRACE_SETFPXREGS: u32 = 19;
pub const PTRACE_OLDSETOPTIONS: u32 = 21;
pub const PTRACE_GET_THREAD_AREA: u32 = 25;
pub const PTRACE_SET_THREAD_AREA: u32 = 26;
pub const PTRACE_ARCH_PRCTL: u32 = 30;
pub const PTRACE_SYSEMU: u32 = 31;
pub const PTRACE_SYSEMU_SINGLESTEP: u32 = 32;
pub const PTRACE_SINGLEBLOCK: u32 = 33;
pub const LDT_ENTRIES: u32 = 8192;
pub const LDT_ENTRY_SIZE: u32 = 8;
pub const MODIFY_LDT_CONTENTS_DATA: u32 = 0;
pub const MODIFY_LDT_CONTENTS_STACK: u32 = 1;
pub const MODIFY_LDT_CONTENTS_CODE: u32 = 2;
pub const NR_REG_ARGUMENTS: u32 = 6;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const X86_FXSR_MAGIC: u32 = 0;
pub const TRACEPOINT_DEFS_H: u32 = 1;
pub const MXCSR_DEFAULT: u32 = 8064;
pub const NVMXINTS: u32 = 5;
pub const VMX_FEATURE_INTR_EXITING: u32 = 0;
pub const VMX_FEATURE_NMI_EXITING: u32 = 3;
pub const VMX_FEATURE_VIRTUAL_NMIS: u32 = 5;
pub const VMX_FEATURE_PREEMPTION_TIMER: u32 = 6;
pub const VMX_FEATURE_POSTED_INTR: u32 = 7;
pub const VMX_FEATURE_INVVPID: u32 = 16;
pub const VMX_FEATURE_EPT_EXECUTE_ONLY: u32 = 17;
pub const VMX_FEATURE_EPT_AD: u32 = 18;
pub const VMX_FEATURE_EPT_1GB: u32 = 19;
pub const VMX_FEATURE_FLEXPRIORITY: u32 = 24;
pub const VMX_FEATURE_APICV: u32 = 25;
pub const VMX_FEATURE_EPTP_SWITCHING: u32 = 28;
pub const VMX_FEATURE_INTR_WINDOW_EXITING: u32 = 34;
pub const VMX_FEATURE_USE_TSC_OFFSETTING: u32 = 35;
pub const VMX_FEATURE_HLT_EXITING: u32 = 39;
pub const VMX_FEATURE_INVLPG_EXITING: u32 = 41;
pub const VMX_FEATURE_MWAIT_EXITING: u32 = 42;
pub const VMX_FEATURE_RDPMC_EXITING: u32 = 43;
pub const VMX_FEATURE_RDTSC_EXITING: u32 = 44;
pub const VMX_FEATURE_CR3_LOAD_EXITING: u32 = 47;
pub const VMX_FEATURE_CR3_STORE_EXITING: u32 = 48;
pub const VMX_FEATURE_TERTIARY_CONTROLS: u32 = 49;
pub const VMX_FEATURE_CR8_LOAD_EXITING: u32 = 51;
pub const VMX_FEATURE_CR8_STORE_EXITING: u32 = 52;
pub const VMX_FEATURE_VIRTUAL_TPR: u32 = 53;
pub const VMX_FEATURE_NMI_WINDOW_EXITING: u32 = 54;
pub const VMX_FEATURE_MOV_DR_EXITING: u32 = 55;
pub const VMX_FEATURE_UNCOND_IO_EXITING: u32 = 56;
pub const VMX_FEATURE_USE_IO_BITMAPS: u32 = 57;
pub const VMX_FEATURE_MONITOR_TRAP_FLAG: u32 = 59;
pub const VMX_FEATURE_USE_MSR_BITMAPS: u32 = 60;
pub const VMX_FEATURE_MONITOR_EXITING: u32 = 61;
pub const VMX_FEATURE_PAUSE_EXITING: u32 = 62;
pub const VMX_FEATURE_SEC_CONTROLS: u32 = 63;
pub const VMX_FEATURE_VIRT_APIC_ACCESSES: u32 = 64;
pub const VMX_FEATURE_EPT: u32 = 65;
pub const VMX_FEATURE_DESC_EXITING: u32 = 66;
pub const VMX_FEATURE_RDTSCP: u32 = 67;
pub const VMX_FEATURE_VIRTUAL_X2APIC: u32 = 68;
pub const VMX_FEATURE_VPID: u32 = 69;
pub const VMX_FEATURE_WBINVD_EXITING: u32 = 70;
pub const VMX_FEATURE_UNRESTRICTED_GUEST: u32 = 71;
pub const VMX_FEATURE_APIC_REGISTER_VIRT: u32 = 72;
pub const VMX_FEATURE_VIRT_INTR_DELIVERY: u32 = 73;
pub const VMX_FEATURE_PAUSE_LOOP_EXITING: u32 = 74;
pub const VMX_FEATURE_RDRAND_EXITING: u32 = 75;
pub const VMX_FEATURE_INVPCID: u32 = 76;
pub const VMX_FEATURE_VMFUNC: u32 = 77;
pub const VMX_FEATURE_SHADOW_VMCS: u32 = 78;
pub const VMX_FEATURE_ENCLS_EXITING: u32 = 79;
pub const VMX_FEATURE_RDSEED_EXITING: u32 = 80;
pub const VMX_FEATURE_PAGE_MOD_LOGGING: u32 = 81;
pub const VMX_FEATURE_EPT_VIOLATION_VE: u32 = 82;
pub const VMX_FEATURE_PT_CONCEAL_VMX: u32 = 83;
pub const VMX_FEATURE_XSAVES: u32 = 84;
pub const VMX_FEATURE_MODE_BASED_EPT_EXEC: u32 = 86;
pub const VMX_FEATURE_PT_USE_GPA: u32 = 88;
pub const VMX_FEATURE_TSC_SCALING: u32 = 89;
pub const VMX_FEATURE_USR_WAIT_PAUSE: u32 = 90;
pub const VMX_FEATURE_ENCLV_EXITING: u32 = 92;
pub const VMX_FEATURE_BUS_LOCK_DETECTION: u32 = 94;
pub const VMX_FEATURE_NOTIFY_VM_EXITING: u32 = 95;
pub const VMX_FEATURE_IPI_VIRT: u32 = 100;
pub const SMP_CACHE_BYTES: u32 = 64;
pub const NET_IP_ALIGN: u32 = 0;
pub const HBP_NUM: u32 = 4;
pub const ARCH_MIN_MMSTRUCT_ALIGN: u32 = 0;
pub const X86_VENDOR_INTEL: u32 = 0;
pub const X86_VENDOR_CYRIX: u32 = 1;
pub const X86_VENDOR_AMD: u32 = 2;
pub const X86_VENDOR_UMC: u32 = 3;
pub const X86_VENDOR_CENTAUR: u32 = 5;
pub const X86_VENDOR_TRANSMETA: u32 = 7;
pub const X86_VENDOR_NSC: u32 = 8;
pub const X86_VENDOR_HYGON: u32 = 9;
pub const X86_VENDOR_ZHAOXIN: u32 = 10;
pub const X86_VENDOR_VORTEX: u32 = 11;
pub const X86_VENDOR_NUM: u32 = 12;
pub const X86_VENDOR_UNKNOWN: u32 = 255;
pub const IO_BITMAP_BITS: u32 = 65536;
pub const IO_BITMAP_BYTES: u32 = 8192;
pub const HAVE_ARCH_PICK_MMAP_LAYOUT: u32 = 1;
pub const BASE_PREFETCH: &'static [u8; 15usize] = b"prefetcht0 %P1\0";
pub const xen_set_default_idle: u32 = 0;
pub const X86_CAP_FMT_NUM: &'static [u8; 6usize] = b"%d:%d\0";
pub const X86_CAP_FMT: &'static [u8; 3usize] = b"%s\0";
pub const MAX_CPU_FEATURES: u32 = 640;
pub const CPU_FEATURE_TYPEFMT: &'static [u8; 26usize] = b"x86,ven%04Xfam%04Xmod%04X\0";
pub const TIF_NOTIFY_RESUME: u32 = 1;
pub const TIF_SIGPENDING: u32 = 2;
pub const TIF_NEED_RESCHED: u32 = 3;
pub const TIF_SINGLESTEP: u32 = 4;
pub const TIF_SSBD: u32 = 5;
pub const TIF_SPEC_IB: u32 = 9;
pub const TIF_SPEC_L1D_FLUSH: u32 = 10;
pub const TIF_USER_RETURN_NOTIFY: u32 = 11;
pub const TIF_UPROBE: u32 = 12;
pub const TIF_PATCH_PENDING: u32 = 13;
pub const TIF_NEED_FPU_LOAD: u32 = 14;
pub const TIF_NOCPUID: u32 = 15;
pub const TIF_NOTSC: u32 = 16;
pub const TIF_NOTIFY_SIGNAL: u32 = 17;
pub const TIF_MEMDIE: u32 = 20;
pub const TIF_POLLING_NRFLAG: u32 = 21;
pub const TIF_IO_BITMAP: u32 = 22;
pub const TIF_SPEC_FORCE_UPDATE: u32 = 23;
pub const TIF_FORCED_TF: u32 = 24;
pub const TIF_BLOCKSTEP: u32 = 25;
pub const TIF_LAZY_MMU_UPDATES: u32 = 27;
pub const TIF_ADDR32: u32 = 29;
pub const _TIF_NOTIFY_RESUME: u32 = 2;
pub const _TIF_SIGPENDING: u32 = 4;
pub const _TIF_NEED_RESCHED: u32 = 8;
pub const _TIF_SINGLESTEP: u32 = 16;
pub const _TIF_SSBD: u32 = 32;
pub const _TIF_SPEC_IB: u32 = 512;
pub const _TIF_SPEC_L1D_FLUSH: u32 = 1024;
pub const _TIF_USER_RETURN_NOTIFY: u32 = 2048;
pub const _TIF_UPROBE: u32 = 4096;
pub const _TIF_PATCH_PENDING: u32 = 8192;
pub const _TIF_NEED_FPU_LOAD: u32 = 16384;
pub const _TIF_NOCPUID: u32 = 32768;
pub const _TIF_NOTSC: u32 = 65536;
pub const _TIF_NOTIFY_SIGNAL: u32 = 131072;
pub const _TIF_POLLING_NRFLAG: u32 = 2097152;
pub const _TIF_IO_BITMAP: u32 = 4194304;
pub const _TIF_SPEC_FORCE_UPDATE: u32 = 8388608;
pub const _TIF_FORCED_TF: u32 = 16777216;
pub const _TIF_BLOCKSTEP: u32 = 33554432;
pub const _TIF_LAZY_MMU_UPDATES: u32 = 134217728;
pub const _TIF_ADDR32: u32 = 536870912;
pub const _TIF_WORK_CTXSW_BASE: u32 = 42041376;
pub const _TIF_WORK_CTXSW: u32 = 42041888;
pub const _TIF_WORK_CTXSW_PREV: u32 = 46238240;
pub const _TIF_WORK_CTXSW_NEXT: u32 = 42041888;
pub const TS_COMPAT: u32 = 2;
pub const TS_I386_REGS_POKED: u32 = 4;
pub const PREEMPT_NEED_RESCHED: u32 = 2147483648;
pub const PREEMPT_ENABLED: u32 = 2147483648;
pub const PREEMPT_DISABLE_OFFSET: u32 = 1;
pub const PREEMPT_LOCK_OFFSET: u32 = 1;
pub const SOFTIRQ_LOCK_OFFSET: u32 = 513;
pub const force_read_lock_recursive: u32 = 0;
pub const SINGLE_DEPTH_NESTING: u32 = 1;
pub const LOCK_SECTION_NAME: &'static [u8; 13usize] = b".text..lock.\0";
pub const LOCK_SECTION_END: &'static [u8; 12usize] = b".previous\n\t\0";
pub const RWLOCK_MAGIC: u32 = 3736018669;
pub const SPIN_THRESHOLD: u32 = 32768;
pub const _Q_PENDING_LOOPS: u32 = 512;
pub const _QW_WAITING: u32 = 256;
pub const _QW_LOCKED: u32 = 255;
pub const _QW_WMASK: u32 = 511;
pub const _QR_SHIFT: u32 = 9;
pub const _QR_BIAS: u32 = 512;
pub const NUM_ACTIVE_RCU_POLL_OLDSTATE: u32 = 2;
pub const NUM_ACTIVE_RCU_POLL_FULL_OLDSTATE: u32 = 4;
pub const VM_IOREMAP: u32 = 1;
pub const VM_ALLOC: u32 = 2;
pub const VM_MAP: u32 = 4;
pub const VM_USERMAP: u32 = 8;
pub const VM_DMA_COHERENT: u32 = 16;
pub const VM_UNINITIALIZED: u32 = 32;
pub const VM_NO_GUARD: u32 = 64;
pub const VM_KASAN: u32 = 128;
pub const VM_FLUSH_RESET_PERMS: u32 = 256;
pub const VM_MAP_PUT_PAGES: u32 = 512;
pub const VM_ALLOW_HUGE_VMAP: u32 = 1024;
pub const VM_DEFER_KMEMLEAK: u32 = 2048;
pub const ARCH_PAGE_TABLE_SYNC_MASK: u32 = 0;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_branch_data {
    pub func: *const ::std::os::raw::c_char,
    pub file: *const ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: ftrace_branch_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ftrace_branch_data__bindgen_ty_1 {
    pub __bindgen_anon_1: ftrace_branch_data__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: ftrace_branch_data__bindgen_ty_1__bindgen_ty_2,
    pub miss_hit: [::std::os::raw::c_ulong; 2usize],
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrace_branch_data__bindgen_ty_1__bindgen_ty_1 {
    pub correct: ::std::os::raw::c_ulong,
    pub incorrect: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ftrace_branch_data__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_1>())).correct
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(correct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_1>())).incorrect
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(incorrect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrace_branch_data__bindgen_ty_1__bindgen_ty_2 {
    pub miss: ::std::os::raw::c_ulong,
    pub hit: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ftrace_branch_data__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_2>())).miss
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(miss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_2>())).hit
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hit)
        )
    );
}
#[test]
fn bindgen_test_layout_ftrace_branch_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ftrace_branch_data__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ftrace_branch_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ftrace_branch_data__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ftrace_branch_data__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ftrace_branch_data__bindgen_ty_1>())).miss_hit as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data__bindgen_ty_1),
            "::",
            stringify!(miss_hit)
        )
    );
}
#[test]
fn bindgen_test_layout_ftrace_branch_data() {
    assert_eq!(
        ::std::mem::size_of::<ftrace_branch_data>(),
        40usize,
        concat!("Size of: ", stringify!(ftrace_branch_data))
    );
    assert_eq!(
        ::std::mem::align_of::<ftrace_branch_data>(),
        8usize,
        concat!("Alignment of ", stringify!(ftrace_branch_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrace_branch_data>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrace_branch_data>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrace_branch_data>())).line as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data),
            "::",
            stringify!(line)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_likely_data {
    pub data: ftrace_branch_data,
    pub constant: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ftrace_likely_data() {
    assert_eq!(
        ::std::mem::size_of::<ftrace_likely_data>(),
        48usize,
        concat!("Size of: ", stringify!(ftrace_likely_data))
    );
    assert_eq!(
        ::std::mem::align_of::<ftrace_likely_data>(),
        8usize,
        concat!("Alignment of ", stringify!(ftrace_likely_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrace_likely_data>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_likely_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrace_likely_data>())).constant as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_likely_data),
            "::",
            stringify!(constant)
        )
    );
}
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type s8 = __s8;
pub type u8_ = __u8;
pub type s16 = __s16;
pub type u16_ = __u16;
pub type s32 = __s32;
pub type u32_ = __u32;
pub type s64 = __s64;
pub type u64_ = __u64;
pub const false_: ::std::os::raw::c_uint = 0;
pub const true_: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
pub type __kernel_dev_t = u32_;
pub type fd_set = __kernel_fd_set;
pub type dev_t = __kernel_dev_t;
pub type ino_t = __kernel_ulong_t;
pub type mode_t = __kernel_mode_t;
pub type umode_t = ::std::os::raw::c_ushort;
pub type nlink_t = u32_;
pub type off_t = __kernel_off_t;
pub type pid_t = __kernel_pid_t;
pub type daddr_t = __kernel_daddr_t;
pub type key_t = __kernel_key_t;
pub type suseconds_t = __kernel_suseconds_t;
pub type timer_t = __kernel_timer_t;
pub type clockid_t = __kernel_clockid_t;
pub type mqd_t = __kernel_mqd_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type uid16_t = __kernel_uid16_t;
pub type gid16_t = __kernel_gid16_t;
pub type old_uid_t = __kernel_old_uid_t;
pub type old_gid_t = __kernel_old_gid_t;
pub type loff_t = __kernel_loff_t;
pub type size_t = __kernel_size_t;
pub type ssize_t = __kernel_ssize_t;
pub type clock_t = __kernel_clock_t;
pub type caddr_t = __kernel_caddr_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type unchar = ::std::os::raw::c_uchar;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type ulong = ::std::os::raw::c_ulong;
pub type u_int8_t = u8_;
pub type u_int16_t = u16_;
pub type u_int32_t = u32_;
pub type u_int64_t = u64_;
#[doc = " The type used for indexing onto a disc or disc partition."]
#[doc = ""]
#[doc = " Linux always considers sectors to be 512 bytes long independently"]
#[doc = " of the devices real block size."]
#[doc = ""]
#[doc = " blkcnt_t is the type of the inode's block count."]
pub type sector_t = u64_;
pub type blkcnt_t = u64_;
pub type dma_addr_t = u64_;
pub type gfp_t = ::std::os::raw::c_uint;
pub type slab_flags_t = ::std::os::raw::c_uint;
pub type fmode_t = ::std::os::raw::c_uint;
pub type phys_addr_t = u64_;
pub type resource_size_t = phys_addr_t;
pub type irq_hw_number_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic_t {
    pub counter: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_atomic_t() {
    assert_eq!(
        ::std::mem::size_of::<atomic_t>(),
        4usize,
        concat!("Size of: ", stringify!(atomic_t))
    );
    assert_eq!(
        ::std::mem::align_of::<atomic_t>(),
        4usize,
        concat!("Alignment of ", stringify!(atomic_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atomic_t>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_t),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic64_t {
    pub counter: s64,
}
#[test]
fn bindgen_test_layout_atomic64_t() {
    assert_eq!(
        ::std::mem::size_of::<atomic64_t>(),
        8usize,
        concat!("Size of: ", stringify!(atomic64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<atomic64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(atomic64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atomic64_t>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic64_t),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
#[test]
fn bindgen_test_layout_list_head() {
    assert_eq!(
        ::std::mem::size_of::<list_head>(),
        16usize,
        concat!("Size of: ", stringify!(list_head))
    );
    assert_eq!(
        ::std::mem::align_of::<list_head>(),
        8usize,
        concat!("Alignment of ", stringify!(list_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_head>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_head() {
    assert_eq!(
        ::std::mem::size_of::<hlist_head>(),
        8usize,
        concat!("Size of: ", stringify!(hlist_head))
    );
    assert_eq!(
        ::std::mem::align_of::<hlist_head>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hlist_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_head),
            "::",
            stringify!(first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_node() {
    assert_eq!(
        ::std::mem::size_of::<hlist_node>(),
        16usize,
        concat!("Size of: ", stringify!(hlist_node))
    );
    assert_eq!(
        ::std::mem::align_of::<hlist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hlist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hlist_node>())).pprev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(pprev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ustat {
    pub f_tfree: __kernel_daddr_t,
    pub f_tinode: ::std::os::raw::c_ulong,
    pub f_fname: [::std::os::raw::c_char; 6usize],
    pub f_fpack: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout_ustat() {
    assert_eq!(
        ::std::mem::size_of::<ustat>(),
        32usize,
        concat!("Size of: ", stringify!(ustat))
    );
    assert_eq!(
        ::std::mem::align_of::<ustat>(),
        8usize,
        concat!("Alignment of ", stringify!(ustat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ustat>())).f_tfree as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ustat),
            "::",
            stringify!(f_tfree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ustat>())).f_tinode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ustat),
            "::",
            stringify!(f_tinode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ustat>())).f_fname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ustat),
            "::",
            stringify!(f_fname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ustat>())).f_fpack as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ustat),
            "::",
            stringify!(f_fpack)
        )
    );
}
#[doc = " struct callback_head - callback structure for use with RCU and task_work"]
#[doc = " @next: next update requests in a list"]
#[doc = " @func: actual update function to call after the grace period."]
#[doc = ""]
#[doc = " The struct is aligned to size of pointer. On most architectures it happens"]
#[doc = " naturally due ABI requirements, but some architectures (like CRIS) have"]
#[doc = " weird ABI and we need to ask it explicitly."]
#[doc = ""]
#[doc = " The alignment is required to guarantee that bit 0 of @next will be"]
#[doc = " clear under normal conditions -- as long as we use call_rcu() or"]
#[doc = " call_srcu() to queue the callback."]
#[doc = ""]
#[doc = " This guarantee is important for few reasons:"]
#[doc = "  - future call_rcu_lazy() will make use of lower bits in the pointer;"]
#[doc = "  - the structure shares storage space in struct page with @compound_head,"]
#[doc = "    which encode PageTail() in bit 0. The guarantee is needed to avoid"]
#[doc = "    false-positive PageTail()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::std::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
}
#[test]
fn bindgen_test_layout_callback_head() {
    assert_eq!(
        ::std::mem::size_of::<callback_head>(),
        16usize,
        concat!("Size of: ", stringify!(callback_head))
    );
    assert_eq!(
        ::std::mem::align_of::<callback_head>(),
        8usize,
        concat!("Alignment of ", stringify!(callback_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callback_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callback_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callback_head>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(callback_head),
            "::",
            stringify!(func)
        )
    );
}
pub type rcu_callback_t = ::std::option::Option<unsafe extern "C" fn(head: *mut callback_head)>;
pub type call_rcu_func_t =
    ::std::option::Option<unsafe extern "C" fn(head: *mut callback_head, func: rcu_callback_t)>;
pub type swap_r_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
        priv_: *const ::std::os::raw::c_void,
    ),
>;
pub type swap_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ),
>;
pub type cmp_r_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
        priv_: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type cmp_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __kasan_check_read(
        p: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __kasan_check_write(
        p: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    ) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kcsan_scoped_access {}
#[test]
fn bindgen_test_layout_kcsan_scoped_access() {
    assert_eq!(
        ::std::mem::size_of::<kcsan_scoped_access>(),
        0usize,
        concat!("Size of: ", stringify!(kcsan_scoped_access))
    );
    assert_eq!(
        ::std::mem::align_of::<kcsan_scoped_access>(),
        1usize,
        concat!("Alignment of ", stringify!(kcsan_scoped_access))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_symbol {
    pub value_offset: ::std::os::raw::c_int,
    pub name_offset: ::std::os::raw::c_int,
    pub namespace_offset: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_kernel_symbol() {
    assert_eq!(
        ::std::mem::size_of::<kernel_symbol>(),
        12usize,
        concat!("Size of: ", stringify!(kernel_symbol))
    );
    assert_eq!(
        ::std::mem::align_of::<kernel_symbol>(),
        4usize,
        concat!("Alignment of ", stringify!(kernel_symbol))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_symbol>())).value_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_symbol),
            "::",
            stringify!(value_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_symbol>())).name_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_symbol),
            "::",
            stringify!(name_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_symbol>())).namespace_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_symbol),
            "::",
            stringify!(namespace_offset)
        )
    );
}
pub type initcall_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type exitcall_t = ::std::option::Option<unsafe extern "C" fn()>;
pub type initcall_entry_t = ::std::os::raw::c_int;
extern "C" {
    pub static mut __con_initcall_start: [initcall_entry_t; 0usize];
}
extern "C" {
    pub static mut __con_initcall_end: [initcall_entry_t; 0usize];
}
pub type ctor_fn_t = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_system_type {
    _unused: [u8; 0],
}
extern "C" {
    pub fn do_one_initcall(fn_: initcall_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut boot_command_line: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut saved_command_line: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut reset_devices: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn setup_arch(arg1: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn prepare_namespace();
}
extern "C" {
    pub fn init_rootfs();
}
extern "C" {
    pub static mut rootfs_fs_type: file_system_type;
}
extern "C" {
    pub static mut rodata_enabled: bool_;
}
extern "C" {
    pub fn mark_rodata_ro();
}
extern "C" {
    pub static mut late_time_init: ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub static mut initcall_debug: bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_kernel_param {
    pub str_: *const ::std::os::raw::c_char,
    pub setup_func: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int,
    >,
    pub early: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_obs_kernel_param() {
    assert_eq!(
        ::std::mem::size_of::<obs_kernel_param>(),
        24usize,
        concat!("Size of: ", stringify!(obs_kernel_param))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_kernel_param>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_kernel_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_kernel_param>())).str_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_kernel_param),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_kernel_param>())).setup_func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_kernel_param),
            "::",
            stringify!(setup_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_kernel_param>())).early as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_kernel_param),
            "::",
            stringify!(early)
        )
    );
}
extern "C" {
    pub fn parse_early_param();
}
extern "C" {
    pub fn parse_early_options(cmdline: *mut ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unwind_hint {
    pub ip: u32_,
    pub sp_offset: s16,
    pub sp_reg: u8_,
    pub type_: u8_,
    pub end: u8_,
}
#[test]
fn bindgen_test_layout_unwind_hint() {
    assert_eq!(
        ::std::mem::size_of::<unwind_hint>(),
        12usize,
        concat!("Size of: ", stringify!(unwind_hint))
    );
    assert_eq!(
        ::std::mem::align_of::<unwind_hint>(),
        4usize,
        concat!("Alignment of ", stringify!(unwind_hint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unwind_hint>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_hint),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unwind_hint>())).sp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_hint),
            "::",
            stringify!(sp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unwind_hint>())).sp_reg as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_hint),
            "::",
            stringify!(sp_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unwind_hint>())).type_ as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_hint),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unwind_hint>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_hint),
            "::",
            stringify!(end)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}rsp"]
    pub static mut current_stack_pointer: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut panic_blink: ::std::option::Option<
        unsafe extern "C" fn(state: ::std::os::raw::c_int) -> ::std::os::raw::c_long,
    >;
}
extern "C" {
    pub fn panic(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn nmi_panic(regs: *mut pt_regs, msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn oops_enter();
}
extern "C" {
    pub fn oops_exit();
}
extern "C" {
    pub fn oops_may_print() -> bool_;
}
extern "C" {
    pub static mut panic_timeout: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut panic_print: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut panic_on_oops: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut panic_on_unrecovered_nmi: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut panic_on_io_nmi: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut panic_on_warn: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut panic_on_taint: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut panic_on_taint_nousertaint: bool_;
}
extern "C" {
    pub static mut sysctl_panic_on_rcu_stall: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sysctl_max_rcu_stall_to_panic: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sysctl_panic_on_stackoverflow: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut crash_kexec_post_notifiers: bool_;
}
extern "C" {
    pub static mut panic_cpu: atomic_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct taint_flag {
    pub c_true: ::std::os::raw::c_char,
    pub c_false: ::std::os::raw::c_char,
    pub module: bool_,
}
#[test]
fn bindgen_test_layout_taint_flag() {
    assert_eq!(
        ::std::mem::size_of::<taint_flag>(),
        3usize,
        concat!("Size of: ", stringify!(taint_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<taint_flag>(),
        1usize,
        concat!("Alignment of ", stringify!(taint_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<taint_flag>())).c_true as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(taint_flag),
            "::",
            stringify!(c_true)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<taint_flag>())).c_false as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(taint_flag),
            "::",
            stringify!(c_false)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<taint_flag>())).module as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(taint_flag),
            "::",
            stringify!(module)
        )
    );
}
extern "C" {
    pub static taint_flags: [taint_flag; 19usize];
}
pub const lockdep_ok_LOCKDEP_STILL_OK: lockdep_ok = 0;
pub const lockdep_ok_LOCKDEP_NOW_UNRELIABLE: lockdep_ok = 1;
pub type lockdep_ok = ::std::os::raw::c_uint;
extern "C" {
    pub fn print_tainted() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn add_taint(flag: ::std::os::raw::c_uint, arg1: lockdep_ok);
}
extern "C" {
    pub fn test_taint(flag: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_taint() -> ::std::os::raw::c_ulong;
}
pub type va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qspinlock {
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qspinlock__bindgen_ty_1 {
    pub val: atomic_t,
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: qspinlock__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_1 {
    pub locked: u8_,
    pub pending: u8_,
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).locked as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).pending as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pending)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_2 {
    pub locked_pending: u16_,
    pub tail: u16_,
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).locked_pending
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(locked_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).tail as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(tail)
        )
    );
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qspinlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qspinlock__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qspinlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(qspinlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qspinlock__bindgen_ty_1>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
#[test]
fn bindgen_test_layout_qspinlock() {
    assert_eq!(
        ::std::mem::size_of::<qspinlock>(),
        4usize,
        concat!("Size of: ", stringify!(qspinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<qspinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(qspinlock))
    );
}
pub type arch_spinlock_t = qspinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qrwlock {
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1,
    pub wait_lock: arch_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qrwlock__bindgen_ty_1 {
    pub cnts: atomic_t,
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qrwlock__bindgen_ty_1__bindgen_ty_1 {
    pub wlocked: u8_,
    pub __lstate: [u8_; 3usize],
}
#[test]
fn bindgen_test_layout_qrwlock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qrwlock__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qrwlock__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qrwlock__bindgen_ty_1__bindgen_ty_1>())).wlocked as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(wlocked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qrwlock__bindgen_ty_1__bindgen_ty_1>())).__lstate as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__lstate)
        )
    );
}
#[test]
fn bindgen_test_layout_qrwlock__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qrwlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qrwlock__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qrwlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(qrwlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qrwlock__bindgen_ty_1>())).cnts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1),
            "::",
            stringify!(cnts)
        )
    );
}
#[test]
fn bindgen_test_layout_qrwlock() {
    assert_eq!(
        ::std::mem::size_of::<qrwlock>(),
        8usize,
        concat!("Size of: ", stringify!(qrwlock))
    );
    assert_eq!(
        ::std::mem::align_of::<qrwlock>(),
        4usize,
        concat!("Alignment of ", stringify!(qrwlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qrwlock>())).wait_lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock),
            "::",
            stringify!(wait_lock)
        )
    );
}
pub type arch_rwlock_t = qrwlock;
pub const lockdep_wait_type_LD_WAIT_INV: lockdep_wait_type = 0;
pub const lockdep_wait_type_LD_WAIT_FREE: lockdep_wait_type = 1;
pub const lockdep_wait_type_LD_WAIT_SPIN: lockdep_wait_type = 2;
pub const lockdep_wait_type_LD_WAIT_CONFIG: lockdep_wait_type = 2;
pub const lockdep_wait_type_LD_WAIT_SLEEP: lockdep_wait_type = 3;
pub const lockdep_wait_type_LD_WAIT_MAX: lockdep_wait_type = 4;
pub type lockdep_wait_type = ::std::os::raw::c_uint;
pub const lockdep_lock_type_LD_LOCK_NORMAL: lockdep_lock_type = 0;
pub const lockdep_lock_type_LD_LOCK_PERCPU: lockdep_lock_type = 1;
pub const lockdep_lock_type_LD_LOCK_MAX: lockdep_lock_type = 2;
pub type lockdep_lock_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_class_key {}
#[test]
fn bindgen_test_layout_lock_class_key() {
    assert_eq!(
        ::std::mem::size_of::<lock_class_key>(),
        0usize,
        concat!("Size of: ", stringify!(lock_class_key))
    );
    assert_eq!(
        ::std::mem::align_of::<lock_class_key>(),
        1usize,
        concat!("Alignment of ", stringify!(lock_class_key))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lockdep_map {}
#[test]
fn bindgen_test_layout_lockdep_map() {
    assert_eq!(
        ::std::mem::size_of::<lockdep_map>(),
        0usize,
        concat!("Size of: ", stringify!(lockdep_map))
    );
    assert_eq!(
        ::std::mem::align_of::<lockdep_map>(),
        1usize,
        concat!("Alignment of ", stringify!(lockdep_map))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pin_cookie {}
#[test]
fn bindgen_test_layout_pin_cookie() {
    assert_eq!(
        ::std::mem::size_of::<pin_cookie>(),
        0usize,
        concat!("Size of: ", stringify!(pin_cookie))
    );
    assert_eq!(
        ::std::mem::align_of::<pin_cookie>(),
        1usize,
        concat!("Alignment of ", stringify!(pin_cookie))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
}
#[test]
fn bindgen_test_layout_raw_spinlock() {
    assert_eq!(
        ::std::mem::size_of::<raw_spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(raw_spinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<raw_spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(raw_spinlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raw_spinlock>())).raw_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raw_spinlock),
            "::",
            stringify!(raw_lock)
        )
    );
}
pub type raw_spinlock_t = raw_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ratelimit_state {
    pub lock: raw_spinlock_t,
    pub interval: ::std::os::raw::c_int,
    pub burst: ::std::os::raw::c_int,
    pub printed: ::std::os::raw::c_int,
    pub missed: ::std::os::raw::c_int,
    pub begin: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ratelimit_state() {
    assert_eq!(
        ::std::mem::size_of::<ratelimit_state>(),
        40usize,
        concat!("Size of: ", stringify!(ratelimit_state))
    );
    assert_eq!(
        ::std::mem::align_of::<ratelimit_state>(),
        8usize,
        concat!("Alignment of ", stringify!(ratelimit_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratelimit_state>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratelimit_state>())).interval as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratelimit_state>())).burst as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(burst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratelimit_state>())).printed as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(printed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratelimit_state>())).missed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(missed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratelimit_state>())).begin as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratelimit_state>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn ___ratelimit(
        rs: *mut ratelimit_state,
        func: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut linux_banner: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut linux_proc_banner: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut oops_in_progress: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut console_printk: [::std::os::raw::c_int; 0usize];
}
extern "C" {
    pub fn console_verbose();
}
extern "C" {
    pub static mut devkmsg_log_str: [::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_table {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut suppress_printk: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct va_format {
    pub fmt: *const ::std::os::raw::c_char,
    pub va: *mut va_list,
}
#[test]
fn bindgen_test_layout_va_format() {
    assert_eq!(
        ::std::mem::size_of::<va_format>(),
        16usize,
        concat!("Size of: ", stringify!(va_format))
    );
    assert_eq!(
        ::std::mem::align_of::<va_format>(),
        8usize,
        concat!("Alignment of ", stringify!(va_format))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<va_format>())).fmt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(va_format),
            "::",
            stringify!(fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<va_format>())).va as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(va_format),
            "::",
            stringify!(va)
        )
    );
}
extern "C" {
    pub fn early_printk(fmt: *const ::std::os::raw::c_char, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_printk_info {
    _unused: [u8; 0],
}
extern "C" {
    pub fn vprintk_emit(
        facility: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
        dev_info: *const dev_printk_info,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintk(
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _printk(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _printk_deferred(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __printk_safe_enter();
}
extern "C" {
    pub fn __printk_safe_exit();
}
extern "C" {
    pub fn __printk_ratelimit(func: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printk_timed_ratelimit(
        caller_jiffies: *mut ::std::os::raw::c_ulong,
        interval_msec: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub static mut printk_delay_msec: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut dmesg_restrict: ::std::os::raw::c_int;
}
extern "C" {
    pub fn wake_up_klogd();
}
extern "C" {
    pub fn log_buf_addr_get() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn log_buf_len_get() -> u32_;
}
extern "C" {
    pub fn log_buf_vmcoreinfo_setup();
}
extern "C" {
    pub fn setup_log_buf(early: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dump_stack_set_arch_desc(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn dump_stack_print_info(log_lvl: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn show_regs_print_info(log_lvl: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn dump_stack_lvl(log_lvl: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn dump_stack();
}
extern "C" {
    pub fn printk_trigger_flush();
}
extern "C" {
    pub fn __printk_cpu_sync_try_get() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __printk_cpu_sync_wait();
}
extern "C" {
    pub fn __printk_cpu_sync_put();
}
extern "C" {
    pub static mut kptr_restrict: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut static_key_initialized: bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key {
    pub enabled: atomic_t,
    pub __bindgen_anon_1: static_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_key__bindgen_ty_1 {
    pub type_: ::std::os::raw::c_ulong,
    pub entries: *mut jump_entry,
    pub next: *mut static_key_mod,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_static_key__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<static_key__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(static_key__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<static_key__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(static_key__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_key__bindgen_ty_1>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<static_key__bindgen_ty_1>())).entries as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key__bindgen_ty_1),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_key__bindgen_ty_1>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
}
#[test]
fn bindgen_test_layout_static_key() {
    assert_eq!(
        ::std::mem::size_of::<static_key>(),
        16usize,
        concat!("Size of: ", stringify!(static_key))
    );
    assert_eq!(
        ::std::mem::align_of::<static_key>(),
        8usize,
        concat!("Alignment of ", stringify!(static_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_key>())).enabled as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key),
            "::",
            stringify!(enabled)
        )
    );
}
extern "C" {
    pub static mut x86_nops: [*const ::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    pub fn arch_jump_entry_size(entry: *mut jump_entry) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jump_entry {
    pub code: s32,
    pub target: s32,
    pub key: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_jump_entry() {
    assert_eq!(
        ::std::mem::size_of::<jump_entry>(),
        16usize,
        concat!("Size of: ", stringify!(jump_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<jump_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(jump_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jump_entry>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jump_entry),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jump_entry>())).target as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(jump_entry),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jump_entry>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jump_entry),
            "::",
            stringify!(key)
        )
    );
}
pub const jump_label_type_JUMP_LABEL_NOP: jump_label_type = 0;
pub const jump_label_type_JUMP_LABEL_JMP: jump_label_type = 1;
pub type jump_label_type = ::std::os::raw::c_uint;
extern "C" {
    pub static mut __start___jump_table: [jump_entry; 0usize];
}
extern "C" {
    pub static mut __stop___jump_table: [jump_entry; 0usize];
}
extern "C" {
    pub fn jump_label_init();
}
extern "C" {
    pub fn jump_label_lock();
}
extern "C" {
    pub fn jump_label_unlock();
}
extern "C" {
    pub fn arch_jump_label_transform(entry: *mut jump_entry, type_: jump_label_type);
}
extern "C" {
    pub fn arch_jump_label_transform_queue(entry: *mut jump_entry, type_: jump_label_type)
        -> bool_;
}
extern "C" {
    pub fn arch_jump_label_transform_apply();
}
extern "C" {
    pub fn jump_label_text_reserved(
        start: *mut ::std::os::raw::c_void,
        end: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn static_key_slow_inc(key: *mut static_key);
}
extern "C" {
    pub fn static_key_slow_dec(key: *mut static_key);
}
extern "C" {
    pub fn static_key_slow_inc_cpuslocked(key: *mut static_key);
}
extern "C" {
    pub fn static_key_slow_dec_cpuslocked(key: *mut static_key);
}
extern "C" {
    pub fn static_key_count(key: *mut static_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn static_key_enable(key: *mut static_key);
}
extern "C" {
    pub fn static_key_disable(key: *mut static_key);
}
extern "C" {
    pub fn static_key_enable_cpuslocked(key: *mut static_key);
}
extern "C" {
    pub fn static_key_disable_cpuslocked(key: *mut static_key);
}
extern "C" {
    pub fn jump_label_init_type(entry: *mut jump_entry) -> jump_label_type;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_true {
    pub key: static_key,
}
#[test]
fn bindgen_test_layout_static_key_true() {
    assert_eq!(
        ::std::mem::size_of::<static_key_true>(),
        16usize,
        concat!("Size of: ", stringify!(static_key_true))
    );
    assert_eq!(
        ::std::mem::align_of::<static_key_true>(),
        8usize,
        concat!("Alignment of ", stringify!(static_key_true))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_key_true>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key_true),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_false {
    pub key: static_key,
}
#[test]
fn bindgen_test_layout_static_key_false() {
    assert_eq!(
        ::std::mem::size_of::<static_key_false>(),
        16usize,
        concat!("Size of: ", stringify!(static_key_false))
    );
    assert_eq!(
        ::std::mem::align_of::<static_key_false>(),
        8usize,
        concat!("Alignment of ", stringify!(static_key_false))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_key_false>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key_false),
            "::",
            stringify!(key)
        )
    );
}
extern "C" {
    pub fn ____wrong_branch_error() -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ddebug {
    pub modname: *const ::std::os::raw::c_char,
    pub function: *const ::std::os::raw::c_char,
    pub filename: *const ::std::os::raw::c_char,
    pub format: *const ::std::os::raw::c_char,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub key: _ddebug__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ddebug__bindgen_ty_1 {
    pub dd_key_true: static_key_true,
    pub dd_key_false: static_key_false,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout__ddebug__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_ddebug__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_ddebug__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_ddebug__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_ddebug__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ddebug__bindgen_ty_1>())).dd_key_true as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug__bindgen_ty_1),
            "::",
            stringify!(dd_key_true)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ddebug__bindgen_ty_1>())).dd_key_false as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug__bindgen_ty_1),
            "::",
            stringify!(dd_key_false)
        )
    );
}
#[test]
fn bindgen_test_layout__ddebug() {
    assert_eq!(
        ::std::mem::size_of::<_ddebug>(),
        56usize,
        concat!("Size of: ", stringify!(_ddebug))
    );
    assert_eq!(
        ::std::mem::align_of::<_ddebug>(),
        8usize,
        concat!("Alignment of ", stringify!(_ddebug))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug>())).modname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug),
            "::",
            stringify!(modname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug>())).function as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug>())).filename as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug>())).format as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug>())).key as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug),
            "::",
            stringify!(key)
        )
    );
}
impl _ddebug {
    #[inline]
    pub fn lineno(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_lineno(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn class_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_class_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lineno: ::std::os::raw::c_uint,
        class_id: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let lineno: u32 = unsafe { ::std::mem::transmute(lineno) };
            lineno as u64
        });
        __bindgen_bitfield_unit.set(18usize, 6u8, {
            let class_id: u32 = unsafe { ::std::mem::transmute(class_id) };
            class_id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const class_map_type_DD_CLASS_TYPE_DISJOINT_BITS: class_map_type = 0;
#[doc = " DD_CLASS_TYPE_DISJOINT_BITS: classes are independent, one per bit."]
#[doc = " expecting hex input. Built for drm.debug, basis for other types."]
pub const class_map_type_DD_CLASS_TYPE_LEVEL_NUM: class_map_type = 1;
#[doc = " DD_CLASS_TYPE_LEVEL_NUM: input is numeric level, 0-N."]
#[doc = " N turns on just bits N-1 .. 0, so N=0 turns all bits off."]
pub const class_map_type_DD_CLASS_TYPE_DISJOINT_NAMES: class_map_type = 2;
#[doc = " DD_CLASS_TYPE_DISJOINT_NAMES: input is a CSV of [+-]CLASS_NAMES,"]
#[doc = " classes are independent, like _DISJOINT_BITS."]
pub const class_map_type_DD_CLASS_TYPE_LEVEL_NAMES: class_map_type = 3;
pub type class_map_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddebug_class_map {
    pub link: list_head,
    pub mod_: *mut module,
    pub mod_name: *const ::std::os::raw::c_char,
    pub class_names: *mut *const ::std::os::raw::c_char,
    pub length: ::std::os::raw::c_int,
    pub base: ::std::os::raw::c_int,
    pub map_type: class_map_type,
}
#[test]
fn bindgen_test_layout_ddebug_class_map() {
    assert_eq!(
        ::std::mem::size_of::<ddebug_class_map>(),
        56usize,
        concat!("Size of: ", stringify!(ddebug_class_map))
    );
    assert_eq!(
        ::std::mem::align_of::<ddebug_class_map>(),
        8usize,
        concat!("Alignment of ", stringify!(ddebug_class_map))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_map>())).link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_map),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_map>())).mod_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_map),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_map>())).mod_name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_map),
            "::",
            stringify!(mod_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_map>())).class_names as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_map),
            "::",
            stringify!(class_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_map>())).length as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_map),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_map>())).base as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_map),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_map>())).map_type as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_map),
            "::",
            stringify!(map_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ddebug_info {
    pub descs: *mut _ddebug,
    pub classes: *mut ddebug_class_map,
    pub num_descs: ::std::os::raw::c_uint,
    pub num_classes: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__ddebug_info() {
    assert_eq!(
        ::std::mem::size_of::<_ddebug_info>(),
        24usize,
        concat!("Size of: ", stringify!(_ddebug_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_ddebug_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_ddebug_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug_info>())).descs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug_info),
            "::",
            stringify!(descs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug_info>())).classes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug_info),
            "::",
            stringify!(classes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug_info>())).num_descs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug_info),
            "::",
            stringify!(num_descs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug_info>())).num_classes as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug_info),
            "::",
            stringify!(num_classes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ddebug_class_param {
    pub __bindgen_anon_1: ddebug_class_param__bindgen_ty_1,
    pub flags: [::std::os::raw::c_char; 8usize],
    pub map: *const ddebug_class_map,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ddebug_class_param__bindgen_ty_1 {
    pub bits: *mut ::std::os::raw::c_ulong,
    pub lvl: *mut ::std::os::raw::c_uint,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_ddebug_class_param__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ddebug_class_param__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ddebug_class_param__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ddebug_class_param__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ddebug_class_param__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddebug_class_param__bindgen_ty_1>())).bits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_param__bindgen_ty_1),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddebug_class_param__bindgen_ty_1>())).lvl as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_param__bindgen_ty_1),
            "::",
            stringify!(lvl)
        )
    );
}
#[test]
fn bindgen_test_layout_ddebug_class_param() {
    assert_eq!(
        ::std::mem::size_of::<ddebug_class_param>(),
        24usize,
        concat!("Size of: ", stringify!(ddebug_class_param))
    );
    assert_eq!(
        ::std::mem::align_of::<ddebug_class_param>(),
        8usize,
        concat!("Alignment of ", stringify!(ddebug_class_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_param>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_param),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_param>())).map as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_param),
            "::",
            stringify!(map)
        )
    );
}
extern "C" {
    pub fn ddebug_add_module(
        dyndbg: *mut _ddebug_info,
        modname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ddebug_remove_module(mod_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __dynamic_pr_debug(descriptor: *mut _ddebug, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn ddebug_dyndbg_module_param_cb(
        param: *mut ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_char,
        modname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __dynamic_dev_dbg(
        descriptor: *mut _ddebug,
        dev: *const device,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __dynamic_netdev_dbg(
        descriptor: *mut _ddebug,
        dev: *const net_device,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __dynamic_ibdev_dbg(
        descriptor: *mut _ddebug,
        ibdev: *const ib_device,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_param {
    _unused: [u8; 0],
}
extern "C" {
    pub fn param_set_dyndbg_classes(
        instr: *const ::std::os::raw::c_char,
        kp: *const kernel_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn param_get_dyndbg_classes(
        buffer: *mut ::std::os::raw::c_char,
        kp: *const kernel_param,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_param_ops {
    _unused: [u8; 0],
}
extern "C" {
    pub static param_ops_dyndbg_classes: kernel_param_ops;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_operations {
    _unused: [u8; 0],
}
extern "C" {
    pub static kmsg_fops: file_operations;
}
pub const DUMP_PREFIX_NONE: ::std::os::raw::c_uint = 0;
pub const DUMP_PREFIX_ADDRESS: ::std::os::raw::c_uint = 1;
pub const DUMP_PREFIX_OFFSET: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
extern "C" {
    pub fn hex_dump_to_buffer(
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        rowsize: ::std::os::raw::c_int,
        groupsize: ::std::os::raw::c_int,
        linebuf: *mut ::std::os::raw::c_char,
        linebuflen: size_t,
        ascii: bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn print_hex_dump(
        level: *const ::std::os::raw::c_char,
        prefix_str: *const ::std::os::raw::c_char,
        prefix_type: ::std::os::raw::c_int,
        rowsize: ::std::os::raw::c_int,
        groupsize: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        ascii: bool_,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct warn_args {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __warn(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        caller: *mut ::std::os::raw::c_void,
        taint: ::std::os::raw::c_uint,
        regs: *mut pt_regs,
        args: *mut warn_args,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bug_entry {
    pub bug_addr_disp: ::std::os::raw::c_int,
    pub file_disp: ::std::os::raw::c_int,
    pub line: ::std::os::raw::c_ushort,
    pub flags: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_bug_entry() {
    assert_eq!(
        ::std::mem::size_of::<bug_entry>(),
        12usize,
        concat!("Size of: ", stringify!(bug_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<bug_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(bug_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bug_entry>())).bug_addr_disp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(bug_addr_disp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bug_entry>())).file_disp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(file_disp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bug_entry>())).line as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bug_entry>())).flags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn __warn_printk(fmt: *const ::std::os::raw::c_char, ...);
}
pub const bug_trap_type_BUG_TRAP_TYPE_NONE: bug_trap_type = 0;
pub const bug_trap_type_BUG_TRAP_TYPE_WARN: bug_trap_type = 1;
pub const bug_trap_type_BUG_TRAP_TYPE_BUG: bug_trap_type = 2;
pub type bug_trap_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn bug_get_file_line(
        bug: *mut bug_entry,
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn find_bug(bugaddr: ::std::os::raw::c_ulong) -> *mut bug_entry;
}
extern "C" {
    pub fn report_bug(bug_addr: ::std::os::raw::c_ulong, regs: *mut pt_regs) -> bug_trap_type;
}
extern "C" {
    pub fn is_valid_bugaddr(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_bug_clear_once();
}
extern "C" {
    pub fn strndup_user(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memdup_user(
        arg1: *const ::std::os::raw::c_void,
        arg2: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmemdup_user(
        arg1: *const ::std::os::raw::c_void,
        arg2: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memdup_user_nul(
        arg1: *const ::std::os::raw::c_void,
        arg2: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcpy(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __memcpy(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        s: *mut ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __memset(
        s: *mut ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        dest: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __memmove(
        dest: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        cs: *const ::std::os::raw::c_void,
        ct: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcpy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        cs: *const ::std::os::raw::c_char,
        ct: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcpy_flushcache(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        cnt: size_t,
    );
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strscpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn strscpy_pad(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        count: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __kernel_size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnchrnul(
        arg1: *const ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn skip_spaces(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strim(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: __kernel_size_t) -> __kernel_size_t;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __memcat_p(
        a: *mut *mut ::std::os::raw::c_void,
        b: *mut *mut ::std::os::raw::c_void,
    ) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memscan(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: __kernel_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memchr_inv(
        s: *const ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strreplace(
        s: *mut ::std::os::raw::c_char,
        old: ::std::os::raw::c_char,
        new: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kfree_const(x: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn kstrdup(s: *const ::std::os::raw::c_char, gfp: gfp_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kstrdup_const(
        s: *const ::std::os::raw::c_char,
        gfp: gfp_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn kstrndup(
        s: *const ::std::os::raw::c_char,
        len: size_t,
        gfp: gfp_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kmemdup(
        src: *const ::std::os::raw::c_void,
        len: size_t,
        gfp: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmemdup_nul(
        s: *const ::std::os::raw::c_char,
        len: size_t,
        gfp: gfp_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn argv_split(
        gfp: gfp_t,
        str_: *const ::std::os::raw::c_char,
        argcp: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn argv_free(argv: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn sysfs_streq(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> bool_;
}
extern "C" {
    pub fn match_string(
        array: *const *const ::std::os::raw::c_char,
        n: size_t,
        string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sysfs_match_string(
        array: *const *const ::std::os::raw::c_char,
        n: size_t,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vbin_printf(
        bin_buf: *mut u32_,
        size: size_t,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bstr_printf(
        buf: *mut ::std::os::raw::c_char,
        size: size_t,
        fmt: *const ::std::os::raw::c_char,
        bin_buf: *const u32_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bprintf(
        bin_buf: *mut u32_,
        size: size_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memory_read_from_buffer(
        to: *mut ::std::os::raw::c_void,
        count: size_t,
        ppos: *mut loff_t,
        from: *const ::std::os::raw::c_void,
        available: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn ptr_to_hashval(
        ptr: *const ::std::os::raw::c_void,
        hashval_out: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memweight(ptr: *const ::std::os::raw::c_void, bytes: size_t) -> size_t;
}
extern "C" {
    pub fn memcpy_and_pad(
        dest: *mut ::std::os::raw::c_void,
        dest_len: size_t,
        src: *const ::std::os::raw::c_void,
        count: size_t,
        pad: ::std::os::raw::c_int,
    );
}
#[doc = " @CC_ATTR_MEM_ENCRYPT: Memory encryption is active"]
#[doc = ""]
#[doc = " The platform/OS is running with active memory encryption. This"]
#[doc = " includes running either as a bare-metal system or a hypervisor"]
#[doc = " and actively using memory encryption or as a guest/virtual machine"]
#[doc = " and actively using memory encryption."]
#[doc = ""]
#[doc = " Examples include SME, SEV and SEV-ES."]
pub const cc_attr_CC_ATTR_MEM_ENCRYPT: cc_attr = 0;
#[doc = " @CC_ATTR_HOST_MEM_ENCRYPT: Host memory encryption is active"]
#[doc = ""]
#[doc = " The platform/OS is running as a bare-metal system or a hypervisor"]
#[doc = " and actively using memory encryption."]
#[doc = ""]
#[doc = " Examples include SME."]
pub const cc_attr_CC_ATTR_HOST_MEM_ENCRYPT: cc_attr = 1;
#[doc = " @CC_ATTR_GUEST_MEM_ENCRYPT: Guest memory encryption is active"]
#[doc = ""]
#[doc = " The platform/OS is running as a guest/virtual machine and actively"]
#[doc = " using memory encryption."]
#[doc = ""]
#[doc = " Examples include SEV and SEV-ES."]
pub const cc_attr_CC_ATTR_GUEST_MEM_ENCRYPT: cc_attr = 2;
#[doc = " @CC_ATTR_GUEST_STATE_ENCRYPT: Guest state encryption is active"]
#[doc = ""]
#[doc = " The platform/OS is running as a guest/virtual machine and actively"]
#[doc = " using memory encryption and register state encryption."]
#[doc = ""]
#[doc = " Examples include SEV-ES."]
pub const cc_attr_CC_ATTR_GUEST_STATE_ENCRYPT: cc_attr = 3;
#[doc = " @CC_ATTR_GUEST_UNROLL_STRING_IO: String I/O is implemented with"]
#[doc = "                                  IN/OUT instructions"]
#[doc = ""]
#[doc = " The platform/OS is running as a guest/virtual machine and uses"]
#[doc = " IN/OUT instructions in place of string I/O."]
#[doc = ""]
#[doc = " Examples include TDX guest & SEV."]
pub const cc_attr_CC_ATTR_GUEST_UNROLL_STRING_IO: cc_attr = 4;
#[doc = " @CC_ATTR_SEV_SNP: Guest SNP is active."]
#[doc = ""]
#[doc = " The platform/OS is running as a guest/virtual machine and actively"]
#[doc = " using AMD SEV-SNP features."]
pub const cc_attr_CC_ATTR_GUEST_SEV_SNP: cc_attr = 5;
#[doc = " @CC_ATTR_HOTPLUG_DISABLED: Hotplug is not supported or disabled."]
#[doc = ""]
#[doc = " The platform/OS is running as a guest/virtual machine does not"]
#[doc = " support CPU hotplug feature."]
#[doc = ""]
#[doc = " Examples include TDX Guest."]
pub const cc_attr_CC_ATTR_HOTPLUG_DISABLED: cc_attr = 6;
#[doc = " enum cc_attr - Confidential computing attributes"]
#[doc = ""]
#[doc = " These attributes represent confidential computing features that are"]
#[doc = " currently active."]
pub type cc_attr = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct screen_info {
    pub orig_x: __u8,
    pub orig_y: __u8,
    pub ext_mem_k: __u16,
    pub orig_video_page: __u16,
    pub orig_video_mode: __u8,
    pub orig_video_cols: __u8,
    pub flags: __u8,
    pub unused2: __u8,
    pub orig_video_ega_bx: __u16,
    pub unused3: __u16,
    pub orig_video_lines: __u8,
    pub orig_video_isVGA: __u8,
    pub orig_video_points: __u16,
    pub lfb_width: __u16,
    pub lfb_height: __u16,
    pub lfb_depth: __u16,
    pub lfb_base: __u32,
    pub lfb_size: __u32,
    pub cl_magic: __u16,
    pub cl_offset: __u16,
    pub lfb_linelength: __u16,
    pub red_size: __u8,
    pub red_pos: __u8,
    pub green_size: __u8,
    pub green_pos: __u8,
    pub blue_size: __u8,
    pub blue_pos: __u8,
    pub rsvd_size: __u8,
    pub rsvd_pos: __u8,
    pub vesapm_seg: __u16,
    pub vesapm_off: __u16,
    pub pages: __u16,
    pub vesa_attributes: __u16,
    pub capabilities: __u32,
    pub ext_lfb_base: __u32,
    pub _reserved: [__u8; 2usize],
}
#[test]
fn bindgen_test_layout_screen_info() {
    assert_eq!(
        ::std::mem::size_of::<screen_info>(),
        64usize,
        concat!("Size of: ", stringify!(screen_info))
    );
    assert_eq!(
        ::std::mem::align_of::<screen_info>(),
        1usize,
        concat!("Alignment of ", stringify!(screen_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_y as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).ext_mem_k as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(ext_mem_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_page as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_mode as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_cols as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).unused2 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(unused2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_ega_bx as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_ega_bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).unused3 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(unused3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_lines as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_isVGA as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_isVGA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_points as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_points)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_width as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_height as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_depth as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).cl_magic as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(cl_magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).cl_offset as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(cl_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_linelength as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_linelength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).red_size as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(red_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).red_pos as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(red_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).green_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(green_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).green_pos as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(green_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).blue_size as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(blue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).blue_pos as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(blue_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).rsvd_size as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(rsvd_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).rsvd_pos as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(rsvd_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).vesapm_seg as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(vesapm_seg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).vesapm_off as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(vesapm_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).pages as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).vesa_attributes as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(vesa_attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).capabilities as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).ext_lfb_base as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(ext_lfb_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>()))._reserved as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(_reserved)
        )
    );
}
extern "C" {
    pub static mut screen_info: screen_info;
}
pub type apm_event_t = ::std::os::raw::c_ushort;
pub type apm_eventinfo_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apm_bios_info {
    pub version: __u16,
    pub cseg: __u16,
    pub offset: __u32,
    pub cseg_16: __u16,
    pub dseg: __u16,
    pub flags: __u16,
    pub cseg_len: __u16,
    pub cseg_16_len: __u16,
    pub dseg_len: __u16,
}
#[test]
fn bindgen_test_layout_apm_bios_info() {
    assert_eq!(
        ::std::mem::size_of::<apm_bios_info>(),
        20usize,
        concat!("Size of: ", stringify!(apm_bios_info))
    );
    assert_eq!(
        ::std::mem::align_of::<apm_bios_info>(),
        4usize,
        concat!("Alignment of ", stringify!(apm_bios_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).cseg as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(cseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).cseg_16 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(cseg_16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).dseg as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(dseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).cseg_len as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(cseg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).cseg_16_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(cseg_16_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).dseg_len as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(dseg_len)
        )
    );
}
extern "C" {
    pub static mut __invalid_size_argument_for_IOC: ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apm_info {
    pub bios: apm_bios_info,
    pub connection_version: ::std::os::raw::c_ushort,
    pub get_power_status_broken: ::std::os::raw::c_int,
    pub get_power_status_swabinminutes: ::std::os::raw::c_int,
    pub allow_ints: ::std::os::raw::c_int,
    pub forbid_idle: ::std::os::raw::c_int,
    pub realmode_power_off: ::std::os::raw::c_int,
    pub disabled: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_apm_info() {
    assert_eq!(
        ::std::mem::size_of::<apm_info>(),
        48usize,
        concat!("Size of: ", stringify!(apm_info))
    );
    assert_eq!(
        ::std::mem::align_of::<apm_info>(),
        4usize,
        concat!("Alignment of ", stringify!(apm_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).bios as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(bios)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).connection_version as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(connection_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apm_info>())).get_power_status_broken as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(get_power_status_broken)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apm_info>())).get_power_status_swabinminutes as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(get_power_status_swabinminutes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).allow_ints as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(allow_ints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).forbid_idle as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(forbid_idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).realmode_power_off as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(realmode_power_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).disabled as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(disabled)
        )
    );
}
extern "C" {
    pub static mut apm_info: apm_info;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params {
    pub length: __u16,
    pub info_flags: __u16,
    pub num_default_cylinders: __u32,
    pub num_default_heads: __u32,
    pub sectors_per_track: __u32,
    pub number_of_sectors: __u64,
    pub bytes_per_sector: __u16,
    pub dpte_ptr: __u32,
    pub key: __u16,
    pub device_path_info_length: __u8,
    pub reserved2: __u8,
    pub reserved3: __u16,
    pub host_bus_type: [__u8; 4usize],
    pub interface_type: [__u8; 8usize],
    pub interface_path: edd_device_params__bindgen_ty_1,
    pub device_path: edd_device_params__bindgen_ty_2,
    pub reserved4: __u8,
    pub checksum: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union edd_device_params__bindgen_ty_1 {
    pub isa: edd_device_params__bindgen_ty_1__bindgen_ty_1,
    pub pci: edd_device_params__bindgen_ty_1__bindgen_ty_2,
    pub ibnd: edd_device_params__bindgen_ty_1__bindgen_ty_3,
    pub xprs: edd_device_params__bindgen_ty_1__bindgen_ty_4,
    pub htpt: edd_device_params__bindgen_ty_1__bindgen_ty_5,
    pub unknown: edd_device_params__bindgen_ty_1__bindgen_ty_6,
    _bindgen_union_align: [u8; 8usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_1 {
    pub base_address: __u16,
    pub reserved1: __u16,
    pub reserved2: __u32,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_1>())).base_address
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(base_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_1>())).reserved1
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_1>())).reserved2
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_2 {
    pub bus: __u8,
    pub slot: __u8,
    pub function: __u8,
    pub channel: __u8,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_2>())).bus
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_2>())).slot
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_2>())).function
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_2>())).channel
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_2>())).reserved
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_3 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_3>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_4 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_4>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_4>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_5>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_5>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_6 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_6>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_6>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(edd_device_params__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(edd_device_params__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).isa as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(isa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).pci as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(pci)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).ibnd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(ibnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).xprs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(xprs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).htpt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(htpt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).unknown as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(unknown)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union edd_device_params__bindgen_ty_2 {
    pub ata: edd_device_params__bindgen_ty_2__bindgen_ty_1,
    pub atapi: edd_device_params__bindgen_ty_2__bindgen_ty_2,
    pub scsi: edd_device_params__bindgen_ty_2__bindgen_ty_3,
    pub usb: edd_device_params__bindgen_ty_2__bindgen_ty_4,
    pub i1394: edd_device_params__bindgen_ty_2__bindgen_ty_5,
    pub fibre: edd_device_params__bindgen_ty_2__bindgen_ty_6,
    pub i2o: edd_device_params__bindgen_ty_2__bindgen_ty_7,
    pub raid: edd_device_params__bindgen_ty_2__bindgen_ty_8,
    pub sata: edd_device_params__bindgen_ty_2__bindgen_ty_9,
    pub unknown: edd_device_params__bindgen_ty_2__bindgen_ty_10,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_1 {
    pub device: __u8,
    pub reserved1: __u8,
    pub reserved2: __u16,
    pub reserved3: __u32,
    pub reserved4: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_1>())).device
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_1>())).reserved1
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_1>())).reserved2
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_1>())).reserved3
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_1>())).reserved4
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(reserved4)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_2 {
    pub device: __u8,
    pub lun: __u8,
    pub reserved1: __u8,
    pub reserved2: __u8,
    pub reserved3: __u32,
    pub reserved4: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).device
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).lun
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(lun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).reserved1
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).reserved2
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).reserved3
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).reserved4
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(reserved4)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_3 {
    pub id: __u16,
    pub lun: __u64,
    pub reserved1: __u16,
    pub reserved2: __u32,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_3>())).id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_3>())).lun
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(lun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_3>())).reserved1
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_3>())).reserved2
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_4 {
    pub serial_number: __u64,
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_4>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_4>())).serial_number
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_4),
            "::",
            stringify!(serial_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_4>())).reserved
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_4),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_5 {
    pub eui: __u64,
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_5>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_5>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_5>())).eui
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_5),
            "::",
            stringify!(eui)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_5>())).reserved
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_5),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_6 {
    pub wwid: __u64,
    pub lun: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_6>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_6>())).wwid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_6),
            "::",
            stringify!(wwid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_6>())).lun
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_6),
            "::",
            stringify!(lun)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_7 {
    pub identity_tag: __u64,
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_7>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_7>())).identity_tag
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_7),
            "::",
            stringify!(identity_tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_7>())).reserved
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_7),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_8 {
    pub array_number: __u32,
    pub reserved1: __u32,
    pub reserved2: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_8>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_8>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_8>())).array_number
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_8),
            "::",
            stringify!(array_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_8>())).reserved1
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_8),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_8>())).reserved2
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_8),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_9 {
    pub device: __u8,
    pub reserved1: __u8,
    pub reserved2: __u16,
    pub reserved3: __u32,
    pub reserved4: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_9>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_9>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_9>())).device
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_9>())).reserved1
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_9>())).reserved2
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_9>())).reserved3
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_9>())).reserved4
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(reserved4)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_10 {
    pub reserved1: __u64,
    pub reserved2: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_10>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_10)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_10>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_10>())).reserved1
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_10),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_10>())).reserved2
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_10),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(edd_device_params__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(edd_device_params__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).ata as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(ata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).atapi as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(atapi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).scsi as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(scsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).usb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(usb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).i1394 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(i1394)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).fibre as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(fibre)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).i2o as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(i2o)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).raid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(raid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).sata as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(sata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).unknown as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(unknown)
        )
    );
}
#[test]
fn bindgen_test_layout_edd_device_params() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params>(),
        74usize,
        concat!("Size of: ", stringify!(edd_device_params))
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params>(),
        1usize,
        concat!("Alignment of ", stringify!(edd_device_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).info_flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(info_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).num_default_cylinders as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(num_default_cylinders)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).num_default_heads as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(num_default_heads)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).sectors_per_track as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(sectors_per_track)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).number_of_sectors as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(number_of_sectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).bytes_per_sector as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(bytes_per_sector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).dpte_ptr as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(dpte_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).key as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).device_path_info_length as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(device_path_info_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).reserved2 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).reserved3 as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).host_bus_type as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(host_bus_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).interface_type as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(interface_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).interface_path as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(interface_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).device_path as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(device_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).reserved4 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).checksum as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(checksum)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_info {
    pub device: __u8,
    pub version: __u8,
    pub interface_support: __u16,
    pub legacy_max_cylinder: __u16,
    pub legacy_max_head: __u8,
    pub legacy_sectors_per_track: __u8,
    pub params: edd_device_params,
}
#[test]
fn bindgen_test_layout_edd_info() {
    assert_eq!(
        ::std::mem::size_of::<edd_info>(),
        82usize,
        concat!("Size of: ", stringify!(edd_info))
    );
    assert_eq!(
        ::std::mem::align_of::<edd_info>(),
        1usize,
        concat!("Alignment of ", stringify!(edd_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).version as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).interface_support as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(interface_support)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).legacy_max_cylinder as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(legacy_max_cylinder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).legacy_max_head as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(legacy_max_head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_info>())).legacy_sectors_per_track as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(legacy_sectors_per_track)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).params as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(params)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct edd {
    pub mbr_signature: [::std::os::raw::c_uint; 16usize],
    pub edd_info: [edd_info; 6usize],
    pub mbr_signature_nr: ::std::os::raw::c_uchar,
    pub edd_info_nr: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_edd() {
    assert_eq!(
        ::std::mem::size_of::<edd>(),
        560usize,
        concat!("Size of: ", stringify!(edd))
    );
    assert_eq!(
        ::std::mem::align_of::<edd>(),
        4usize,
        concat!("Alignment of ", stringify!(edd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd>())).mbr_signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd),
            "::",
            stringify!(mbr_signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd>())).edd_info as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(edd),
            "::",
            stringify!(edd_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd>())).mbr_signature_nr as *const _ as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(edd),
            "::",
            stringify!(mbr_signature_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd>())).edd_info_nr as *const _ as usize },
        557usize,
        concat!(
            "Offset of field: ",
            stringify!(edd),
            "::",
            stringify!(edd_info_nr)
        )
    );
}
extern "C" {
    pub static mut edd: edd;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ist_info {
    pub signature: __u32,
    pub command: __u32,
    pub event: __u32,
    pub perf_level: __u32,
}
#[test]
fn bindgen_test_layout_ist_info() {
    assert_eq!(
        ::std::mem::size_of::<ist_info>(),
        16usize,
        concat!("Size of: ", stringify!(ist_info))
    );
    assert_eq!(
        ::std::mem::align_of::<ist_info>(),
        4usize,
        concat!("Alignment of ", stringify!(ist_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ist_info>())).signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ist_info),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ist_info>())).command as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ist_info),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ist_info>())).event as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ist_info),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ist_info>())).perf_level as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ist_info),
            "::",
            stringify!(perf_level)
        )
    );
}
extern "C" {
    pub static mut ist_info: ist_info;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct edid_info {
    pub dummy: [::std::os::raw::c_uchar; 128usize],
}
#[test]
fn bindgen_test_layout_edid_info() {
    assert_eq!(
        ::std::mem::size_of::<edid_info>(),
        128usize,
        concat!("Size of: ", stringify!(edid_info))
    );
    assert_eq!(
        ::std::mem::align_of::<edid_info>(),
        1usize,
        concat!("Alignment of ", stringify!(edid_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edid_info>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edid_info),
            "::",
            stringify!(dummy)
        )
    );
}
extern "C" {
    pub static mut edid_info: edid_info;
}
#[repr(C)]
#[derive(Debug)]
pub struct setup_data {
    pub next: __u64,
    pub type_: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_setup_data() {
    assert_eq!(
        ::std::mem::size_of::<setup_data>(),
        16usize,
        concat!("Size of: ", stringify!(setup_data))
    );
    assert_eq!(
        ::std::mem::align_of::<setup_data>(),
        8usize,
        concat!("Alignment of ", stringify!(setup_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_data>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_data),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_data>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_data),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_data>())).len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_data),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_data>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_data),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct setup_indirect {
    pub type_: __u32,
    pub reserved: __u32,
    pub len: __u64,
    pub addr: __u64,
}
#[test]
fn bindgen_test_layout_setup_indirect() {
    assert_eq!(
        ::std::mem::size_of::<setup_indirect>(),
        24usize,
        concat!("Size of: ", stringify!(setup_indirect))
    );
    assert_eq!(
        ::std::mem::align_of::<setup_indirect>(),
        8usize,
        concat!("Alignment of ", stringify!(setup_indirect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_indirect>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_indirect),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_indirect>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_indirect),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_indirect>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_indirect),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_indirect>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_indirect),
            "::",
            stringify!(addr)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct setup_header {
    pub setup_sects: __u8,
    pub root_flags: __u16,
    pub syssize: __u32,
    pub ram_size: __u16,
    pub vid_mode: __u16,
    pub root_dev: __u16,
    pub boot_flag: __u16,
    pub jump: __u16,
    pub header: __u32,
    pub version: __u16,
    pub realmode_swtch: __u32,
    pub start_sys_seg: __u16,
    pub kernel_version: __u16,
    pub type_of_loader: __u8,
    pub loadflags: __u8,
    pub setup_move_size: __u16,
    pub code32_start: __u32,
    pub ramdisk_image: __u32,
    pub ramdisk_size: __u32,
    pub bootsect_kludge: __u32,
    pub heap_end_ptr: __u16,
    pub ext_loader_ver: __u8,
    pub ext_loader_type: __u8,
    pub cmd_line_ptr: __u32,
    pub initrd_addr_max: __u32,
    pub kernel_alignment: __u32,
    pub relocatable_kernel: __u8,
    pub min_alignment: __u8,
    pub xloadflags: __u16,
    pub cmdline_size: __u32,
    pub hardware_subarch: __u32,
    pub hardware_subarch_data: __u64,
    pub payload_offset: __u32,
    pub payload_length: __u32,
    pub setup_data: __u64,
    pub pref_address: __u64,
    pub init_size: __u32,
    pub handover_offset: __u32,
    pub kernel_info_offset: __u32,
}
#[test]
fn bindgen_test_layout_setup_header() {
    assert_eq!(
        ::std::mem::size_of::<setup_header>(),
        123usize,
        concat!("Size of: ", stringify!(setup_header))
    );
    assert_eq!(
        ::std::mem::align_of::<setup_header>(),
        1usize,
        concat!("Alignment of ", stringify!(setup_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).setup_sects as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(setup_sects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).root_flags as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(root_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).syssize as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(syssize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).ram_size as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(ram_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).vid_mode as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(vid_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).root_dev as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(root_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).boot_flag as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(boot_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).jump as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(jump)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).header as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).version as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).realmode_swtch as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(realmode_swtch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).start_sys_seg as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(start_sys_seg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).kernel_version as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(kernel_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).type_of_loader as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(type_of_loader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).loadflags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(loadflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).setup_move_size as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(setup_move_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).code32_start as *const _ as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(code32_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).ramdisk_image as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(ramdisk_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).ramdisk_size as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(ramdisk_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).bootsect_kludge as *const _ as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(bootsect_kludge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).heap_end_ptr as *const _ as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(heap_end_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).ext_loader_ver as *const _ as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(ext_loader_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).ext_loader_type as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(ext_loader_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).cmd_line_ptr as *const _ as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(cmd_line_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).initrd_addr_max as *const _ as usize },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(initrd_addr_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).kernel_alignment as *const _ as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(kernel_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).relocatable_kernel as *const _ as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(relocatable_kernel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).min_alignment as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(min_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).xloadflags as *const _ as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(xloadflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).cmdline_size as *const _ as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(cmdline_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).hardware_subarch as *const _ as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(hardware_subarch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<setup_header>())).hardware_subarch_data as *const _ as usize
        },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(hardware_subarch_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).payload_offset as *const _ as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(payload_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).payload_length as *const _ as usize },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(payload_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).setup_data as *const _ as usize },
        95usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(setup_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).pref_address as *const _ as usize },
        103usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(pref_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).init_size as *const _ as usize },
        111usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(init_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).handover_offset as *const _ as usize },
        115usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(handover_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).kernel_info_offset as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(kernel_info_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sys_desc_table {
    pub length: __u16,
    pub table: [__u8; 14usize],
}
#[test]
fn bindgen_test_layout_sys_desc_table() {
    assert_eq!(
        ::std::mem::size_of::<sys_desc_table>(),
        16usize,
        concat!("Size of: ", stringify!(sys_desc_table))
    );
    assert_eq!(
        ::std::mem::align_of::<sys_desc_table>(),
        2usize,
        concat!("Alignment of ", stringify!(sys_desc_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sys_desc_table>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_desc_table),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sys_desc_table>())).table as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_desc_table),
            "::",
            stringify!(table)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct olpc_ofw_header {
    pub ofw_magic: __u32,
    pub ofw_version: __u32,
    pub cif_handler: __u32,
    pub irq_desc_table: __u32,
}
#[test]
fn bindgen_test_layout_olpc_ofw_header() {
    assert_eq!(
        ::std::mem::size_of::<olpc_ofw_header>(),
        16usize,
        concat!("Size of: ", stringify!(olpc_ofw_header))
    );
    assert_eq!(
        ::std::mem::align_of::<olpc_ofw_header>(),
        1usize,
        concat!("Alignment of ", stringify!(olpc_ofw_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<olpc_ofw_header>())).ofw_magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(olpc_ofw_header),
            "::",
            stringify!(ofw_magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<olpc_ofw_header>())).ofw_version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(olpc_ofw_header),
            "::",
            stringify!(ofw_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<olpc_ofw_header>())).cif_handler as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(olpc_ofw_header),
            "::",
            stringify!(cif_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<olpc_ofw_header>())).irq_desc_table as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(olpc_ofw_header),
            "::",
            stringify!(irq_desc_table)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct efi_info {
    pub efi_loader_signature: __u32,
    pub efi_systab: __u32,
    pub efi_memdesc_size: __u32,
    pub efi_memdesc_version: __u32,
    pub efi_memmap: __u32,
    pub efi_memmap_size: __u32,
    pub efi_systab_hi: __u32,
    pub efi_memmap_hi: __u32,
}
#[test]
fn bindgen_test_layout_efi_info() {
    assert_eq!(
        ::std::mem::size_of::<efi_info>(),
        32usize,
        concat!("Size of: ", stringify!(efi_info))
    );
    assert_eq!(
        ::std::mem::align_of::<efi_info>(),
        4usize,
        concat!("Alignment of ", stringify!(efi_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_loader_signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_loader_signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_systab as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_systab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_memdesc_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_memdesc_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_memdesc_version as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_memdesc_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_memmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_memmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_memmap_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_memmap_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_systab_hi as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_systab_hi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_memmap_hi as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_memmap_hi)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct boot_e820_entry {
    pub addr: __u64,
    pub size: __u64,
    pub type_: __u32,
}
#[test]
fn bindgen_test_layout_boot_e820_entry() {
    assert_eq!(
        ::std::mem::size_of::<boot_e820_entry>(),
        20usize,
        concat!("Size of: ", stringify!(boot_e820_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<boot_e820_entry>(),
        1usize,
        concat!("Alignment of ", stringify!(boot_e820_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_e820_entry>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_e820_entry),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_e820_entry>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_e820_entry),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_e820_entry>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_e820_entry),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct jailhouse_setup_data {
    pub hdr: jailhouse_setup_data__bindgen_ty_1,
    pub v1: jailhouse_setup_data__bindgen_ty_2,
    pub v2: jailhouse_setup_data__bindgen_ty_3,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct jailhouse_setup_data__bindgen_ty_1 {
    pub version: __u16,
    pub compatible_version: __u16,
}
#[test]
fn bindgen_test_layout_jailhouse_setup_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<jailhouse_setup_data__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(jailhouse_setup_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<jailhouse_setup_data__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(jailhouse_setup_data__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_1>())).version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_1>())).compatible_version
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_1),
            "::",
            stringify!(compatible_version)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct jailhouse_setup_data__bindgen_ty_2 {
    pub pm_timer_address: __u16,
    pub num_cpus: __u16,
    pub pci_mmconfig_base: __u64,
    pub tsc_khz: __u32,
    pub apic_khz: __u32,
    pub standard_ioapic: __u8,
    pub cpu_ids: [__u8; 255usize],
}
#[test]
fn bindgen_test_layout_jailhouse_setup_data__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<jailhouse_setup_data__bindgen_ty_2>(),
        276usize,
        concat!("Size of: ", stringify!(jailhouse_setup_data__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<jailhouse_setup_data__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(jailhouse_setup_data__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_2>())).pm_timer_address
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_2),
            "::",
            stringify!(pm_timer_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_2>())).num_cpus as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_2),
            "::",
            stringify!(num_cpus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_2>())).pci_mmconfig_base
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_2),
            "::",
            stringify!(pci_mmconfig_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_2>())).tsc_khz as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_2),
            "::",
            stringify!(tsc_khz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_2>())).apic_khz as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_2),
            "::",
            stringify!(apic_khz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_2>())).standard_ioapic
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_2),
            "::",
            stringify!(standard_ioapic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_2>())).cpu_ids as *const _
                as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_2),
            "::",
            stringify!(cpu_ids)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct jailhouse_setup_data__bindgen_ty_3 {
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_jailhouse_setup_data__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<jailhouse_setup_data__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(jailhouse_setup_data__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<jailhouse_setup_data__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(jailhouse_setup_data__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_3>())).flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_3),
            "::",
            stringify!(flags)
        )
    );
}
#[test]
fn bindgen_test_layout_jailhouse_setup_data() {
    assert_eq!(
        ::std::mem::size_of::<jailhouse_setup_data>(),
        284usize,
        concat!("Size of: ", stringify!(jailhouse_setup_data))
    );
    assert_eq!(
        ::std::mem::align_of::<jailhouse_setup_data>(),
        1usize,
        concat!("Alignment of ", stringify!(jailhouse_setup_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jailhouse_setup_data>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jailhouse_setup_data>())).v1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data),
            "::",
            stringify!(v1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jailhouse_setup_data>())).v2 as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data),
            "::",
            stringify!(v2)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ima_setup_data {
    pub addr: __u64,
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_ima_setup_data() {
    assert_eq!(
        ::std::mem::size_of::<ima_setup_data>(),
        16usize,
        concat!("Size of: ", stringify!(ima_setup_data))
    );
    assert_eq!(
        ::std::mem::align_of::<ima_setup_data>(),
        1usize,
        concat!("Alignment of ", stringify!(ima_setup_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ima_setup_data>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ima_setup_data),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ima_setup_data>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ima_setup_data),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct boot_params {
    pub screen_info: screen_info,
    pub apm_bios_info: apm_bios_info,
    pub _pad2: [__u8; 4usize],
    pub tboot_addr: __u64,
    pub ist_info: ist_info,
    pub acpi_rsdp_addr: __u64,
    pub _pad3: [__u8; 8usize],
    pub hd0_info: [__u8; 16usize],
    pub hd1_info: [__u8; 16usize],
    pub sys_desc_table: sys_desc_table,
    pub olpc_ofw_header: olpc_ofw_header,
    pub ext_ramdisk_image: __u32,
    pub ext_ramdisk_size: __u32,
    pub ext_cmd_line_ptr: __u32,
    pub _pad4: [__u8; 112usize],
    pub cc_blob_address: __u32,
    pub edid_info: edid_info,
    pub efi_info: efi_info,
    pub alt_mem_k: __u32,
    pub scratch: __u32,
    pub e820_entries: __u8,
    pub eddbuf_entries: __u8,
    pub edd_mbr_sig_buf_entries: __u8,
    pub kbd_status: __u8,
    pub secure_boot: __u8,
    pub _pad5: [__u8; 2usize],
    pub sentinel: __u8,
    pub _pad6: [__u8; 1usize],
    pub hdr: setup_header,
    pub _pad7: [__u8; 36usize],
    pub edd_mbr_sig_buffer: [__u32; 16usize],
    pub e820_table: [boot_e820_entry; 128usize],
    pub _pad8: [__u8; 48usize],
    pub eddbuf: [edd_info; 6usize],
    pub _pad9: [__u8; 276usize],
}
#[test]
fn bindgen_test_layout_boot_params() {
    assert_eq!(
        ::std::mem::size_of::<boot_params>(),
        4096usize,
        concat!("Size of: ", stringify!(boot_params))
    );
    assert_eq!(
        ::std::mem::align_of::<boot_params>(),
        1usize,
        concat!("Alignment of ", stringify!(boot_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).screen_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(screen_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).apm_bios_info as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(apm_bios_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad2 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).tboot_addr as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(tboot_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).ist_info as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(ist_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).acpi_rsdp_addr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(acpi_rsdp_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad3 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).hd0_info as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(hd0_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).hd1_info as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(hd1_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).sys_desc_table as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(sys_desc_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).olpc_ofw_header as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(olpc_ofw_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).ext_ramdisk_image as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(ext_ramdisk_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).ext_ramdisk_size as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(ext_ramdisk_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).ext_cmd_line_ptr as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(ext_cmd_line_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad4 as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).cc_blob_address as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(cc_blob_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).edid_info as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(edid_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).efi_info as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(efi_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).alt_mem_k as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(alt_mem_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).scratch as *const _ as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(scratch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).e820_entries as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(e820_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).eddbuf_entries as *const _ as usize },
        489usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(eddbuf_entries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<boot_params>())).edd_mbr_sig_buf_entries as *const _ as usize
        },
        490usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(edd_mbr_sig_buf_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).kbd_status as *const _ as usize },
        491usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(kbd_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).secure_boot as *const _ as usize },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(secure_boot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad5 as *const _ as usize },
        493usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).sentinel as *const _ as usize },
        495usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(sentinel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad6 as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).hdr as *const _ as usize },
        497usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad7 as *const _ as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).edd_mbr_sig_buffer as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(edd_mbr_sig_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).e820_table as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(e820_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad8 as *const _ as usize },
        3280usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).eddbuf as *const _ as usize },
        3328usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(eddbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad9 as *const _ as usize },
        3820usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad9)
        )
    );
}
pub const x86_hardware_subarch_X86_SUBARCH_PC: x86_hardware_subarch = 0;
pub const x86_hardware_subarch_X86_SUBARCH_LGUEST: x86_hardware_subarch = 1;
pub const x86_hardware_subarch_X86_SUBARCH_XEN: x86_hardware_subarch = 2;
pub const x86_hardware_subarch_X86_SUBARCH_INTEL_MID: x86_hardware_subarch = 3;
pub const x86_hardware_subarch_X86_SUBARCH_CE4100: x86_hardware_subarch = 4;
pub const x86_hardware_subarch_X86_NR_SUBARCHS: x86_hardware_subarch = 5;
#[doc = " enum x86_hardware_subarch - x86 hardware subarchitecture"]
#[doc = ""]
#[doc = " The x86 hardware_subarch and hardware_subarch_data were added as of the x86"]
#[doc = " boot protocol 2.07 to help distinguish and support custom x86 boot"]
#[doc = " sequences. This enum represents accepted values for the x86"]
#[doc = " hardware_subarch.  Custom x86 boot sequences (not X86_SUBARCH_PC) do not"]
#[doc = " have or simply *cannot* make use of natural stubs like BIOS or EFI, the"]
#[doc = " hardware_subarch can be used on the Linux entry path to revector to a"]
#[doc = " subarchitecture stub when needed. This subarchitecture stub can be used to"]
#[doc = " set up Linux boot parameters or for special care to account for nonstandard"]
#[doc = " handling of page tables."]
#[doc = ""]
#[doc = " These enums should only ever be used by x86 code, and the code that uses"]
#[doc = " it should be well contained and compartmentalized."]
#[doc = ""]
#[doc = " KVM and Xen HVM do not have a subarch as these are expected to follow"]
#[doc = " standard x86 boot entries. If there is a genuine need for \"hypervisor\" type"]
#[doc = " that should be considered separately in the future. Future guest types"]
#[doc = " should seriously consider working with standard x86 boot stubs such as"]
#[doc = " the BIOS or EFI boot stubs."]
#[doc = ""]
#[doc = " WARNING: this enum is only used for legacy hacks, for platform features that"]
#[doc = "\t    are not easily enumerated or discoverable. You should not ever use"]
#[doc = "\t    this for new features."]
#[doc = ""]
#[doc = " @X86_SUBARCH_PC: Should be used if the hardware is enumerable using standard"]
#[doc = "\tPC mechanisms (PCI, ACPI) and doesn't need a special boot flow."]
#[doc = " @X86_SUBARCH_LGUEST: Used for x86 hypervisor demo, lguest, deprecated"]
#[doc = " @X86_SUBARCH_XEN: Used for Xen guest types which follow the PV boot path,"]
#[doc = " \twhich start at asm startup_xen() entry point and later jump to the C"]
#[doc = " \txen_start_kernel() entry point. Both domU and dom0 type of guests are"]
#[doc = " \tcurrently supported through this PV boot path."]
#[doc = " @X86_SUBARCH_INTEL_MID: Used for Intel MID (Mobile Internet Device) platform"]
#[doc = "\tsystems which do not have the PCI legacy interfaces."]
#[doc = " @X86_SUBARCH_CE4100: Used for Intel CE media processor (CE4100) SoC"]
#[doc = " \tfor settop boxes and media devices, the use of a subarch for CE4100"]
#[doc = " \tis more of a hack..."]
pub type x86_hardware_subarch = ::std::os::raw::c_uint;
extern "C" {
    pub fn mem_encrypt_init();
}
extern "C" {
    pub fn add_encrypt_protection_map();
}
extern "C" {
    pub static mut __start_bss_decrypted: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut __end_bss_decrypted: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut __start_bss_decrypted_unused: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn kaslr_get_random_long(purpose: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn devmem_is_allowed(pagenr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut max_low_pfn_mapped: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut max_pfn_mapped: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn pfn_range_is_mapped(
        start_pfn: ::std::os::raw::c_ulong,
        end_pfn: ::std::os::raw::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn initmem_init();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct alt_instr {
    pub instr_offset: s32,
    pub repl_offset: s32,
    pub cpuid: u16_,
    pub instrlen: u8_,
    pub replacementlen: u8_,
}
#[test]
fn bindgen_test_layout_alt_instr() {
    assert_eq!(
        ::std::mem::size_of::<alt_instr>(),
        12usize,
        concat!("Size of: ", stringify!(alt_instr))
    );
    assert_eq!(
        ::std::mem::align_of::<alt_instr>(),
        1usize,
        concat!("Alignment of ", stringify!(alt_instr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).instr_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(instr_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).repl_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(repl_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).cpuid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(cpuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).instrlen as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(instrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).replacementlen as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(replacementlen)
        )
    );
}
extern "C" {
    pub static mut alternatives_patched: ::std::os::raw::c_int;
}
extern "C" {
    pub fn alternative_instructions();
}
extern "C" {
    pub fn apply_alternatives(start: *mut alt_instr, end: *mut alt_instr);
}
extern "C" {
    pub fn apply_retpolines(start: *mut s32, end: *mut s32);
}
extern "C" {
    pub fn apply_returns(start: *mut s32, end: *mut s32);
}
extern "C" {
    pub fn apply_ibt_endbr(start: *mut s32, end: *mut s32);
}
extern "C" {
    pub fn alternatives_smp_module_add(
        mod_: *mut module,
        name: *mut ::std::os::raw::c_char,
        locks: *mut ::std::os::raw::c_void,
        locks_end: *mut ::std::os::raw::c_void,
        text: *mut ::std::os::raw::c_void,
        text_end: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn alternatives_smp_module_del(mod_: *mut module);
}
extern "C" {
    pub fn alternatives_enable_smp();
}
extern "C" {
    pub fn alternatives_text_reserved(
        start: *mut ::std::os::raw::c_void,
        end: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut skip_smp_alternatives: bool_;
}
extern "C" {
    pub static mut max_pfn: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut phys_base: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut page_offset_base: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut vmalloc_base: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut vmemmap_base: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn clear_page_orig(page: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn clear_page_rep(page: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn clear_page_erms(page: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn copy_page(to: *mut ::std::os::raw::c_void, from: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct range {
    pub start: u64_,
    pub end: u64_,
}
#[test]
fn bindgen_test_layout_range() {
    assert_eq!(
        ::std::mem::size_of::<range>(),
        16usize,
        concat!("Size of: ", stringify!(range))
    );
    assert_eq!(
        ::std::mem::align_of::<range>(),
        8usize,
        concat!("Alignment of ", stringify!(range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<range>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(range),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<range>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(range),
            "::",
            stringify!(end)
        )
    );
}
extern "C" {
    pub fn add_range(
        range: *mut range,
        az: ::std::os::raw::c_int,
        nr_range: ::std::os::raw::c_int,
        start: u64_,
        end: u64_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_range_with_merge(
        range: *mut range,
        az: ::std::os::raw::c_int,
        nr_range: ::std::os::raw::c_int,
        start: u64_,
        end: u64_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn subtract_range(range: *mut range, az: ::std::os::raw::c_int, start: u64_, end: u64_);
}
extern "C" {
    pub fn clean_sort_range(range: *mut range, az: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sort_range(range: *mut range, nr_range: ::std::os::raw::c_int);
}
extern "C" {
    pub static mut pfn_mapped: [range; 0usize];
}
extern "C" {
    pub static mut nr_pfn_mapped: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __virt_addr_valid(kaddr: ::std::os::raw::c_ulong) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pfn_t {
    pub val: u64_,
}
#[test]
fn bindgen_test_layout_pfn_t() {
    assert_eq!(
        ::std::mem::size_of::<pfn_t>(),
        8usize,
        concat!("Size of: ", stringify!(pfn_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pfn_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pfn_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfn_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pfn_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct sysinfo {
    pub uptime: __kernel_long_t,
    pub loads: [__kernel_ulong_t; 3usize],
    pub totalram: __kernel_ulong_t,
    pub freeram: __kernel_ulong_t,
    pub sharedram: __kernel_ulong_t,
    pub bufferram: __kernel_ulong_t,
    pub totalswap: __kernel_ulong_t,
    pub freeswap: __kernel_ulong_t,
    pub procs: __u16,
    pub pad: __u16,
    pub totalhigh: __kernel_ulong_t,
    pub freehigh: __kernel_ulong_t,
    pub mem_unit: __u32,
    pub _f: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_sysinfo() {
    assert_eq!(
        ::std::mem::size_of::<sysinfo>(),
        112usize,
        concat!("Size of: ", stringify!(sysinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<sysinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(sysinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).uptime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(uptime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).loads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(loads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).totalram as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(totalram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).freeram as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(freeram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).sharedram as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(sharedram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).bufferram as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(bufferram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).totalswap as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(totalswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).freeswap as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(freeswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).procs as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(procs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).pad as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).totalhigh as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(totalhigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).freehigh as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(freehigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).mem_unit as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(mem_unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>()))._f as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(_f)
        )
    );
}
extern "C" {
    pub fn __sw_hweight8(w: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __sw_hweight16(w: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __sw_hweight32(w: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __sw_hweight64(w: __u64) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn early_ioremap(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_memremap(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_memremap_ro(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_memremap_prot(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
        prot_val: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_iounmap(addr: *mut ::std::os::raw::c_void, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn early_memunmap(addr: *mut ::std::os::raw::c_void, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn early_ioremap_init();
}
extern "C" {
    pub fn early_ioremap_setup();
}
extern "C" {
    pub fn early_ioremap_reset();
}
extern "C" {
    pub fn copy_from_early_mem(
        dest: *mut ::std::os::raw::c_void,
        src: phys_addr_t,
        size: ::std::os::raw::c_ulong,
    );
}
pub const page_cache_mode__PAGE_CACHE_MODE_WB: page_cache_mode = 0;
pub const page_cache_mode__PAGE_CACHE_MODE_WC: page_cache_mode = 1;
pub const page_cache_mode__PAGE_CACHE_MODE_UC_MINUS: page_cache_mode = 2;
pub const page_cache_mode__PAGE_CACHE_MODE_UC: page_cache_mode = 3;
pub const page_cache_mode__PAGE_CACHE_MODE_WT: page_cache_mode = 4;
pub const page_cache_mode__PAGE_CACHE_MODE_WP: page_cache_mode = 5;
pub const page_cache_mode__PAGE_CACHE_MODE_NUM: page_cache_mode = 8;
pub type page_cache_mode = ::std::os::raw::c_uint;
pub type pteval_t = ::std::os::raw::c_ulong;
pub type pmdval_t = ::std::os::raw::c_ulong;
pub type pudval_t = ::std::os::raw::c_ulong;
pub type p4dval_t = ::std::os::raw::c_ulong;
pub type pgdval_t = ::std::os::raw::c_ulong;
pub type pgprotval_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pte_t {
    pub pte: pteval_t,
}
#[test]
fn bindgen_test_layout_pte_t() {
    assert_eq!(
        ::std::mem::size_of::<pte_t>(),
        8usize,
        concat!("Size of: ", stringify!(pte_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pte_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pte_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pte_t>())).pte as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pte_t),
            "::",
            stringify!(pte)
        )
    );
}
extern "C" {
    pub static mut __pgtable_l5_enabled: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut pgdir_shift: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut ptrs_per_p4d: ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pgprot {
    pub pgprot: pgprotval_t,
}
#[test]
fn bindgen_test_layout_pgprot() {
    assert_eq!(
        ::std::mem::size_of::<pgprot>(),
        8usize,
        concat!("Size of: ", stringify!(pgprot))
    );
    assert_eq!(
        ::std::mem::align_of::<pgprot>(),
        8usize,
        concat!("Alignment of ", stringify!(pgprot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pgprot>())).pgprot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pgprot),
            "::",
            stringify!(pgprot)
        )
    );
}
pub type pgprot_t = pgprot;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pgd_t {
    pub pgd: pgdval_t,
}
#[test]
fn bindgen_test_layout_pgd_t() {
    assert_eq!(
        ::std::mem::size_of::<pgd_t>(),
        8usize,
        concat!("Size of: ", stringify!(pgd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pgd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pgd_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pgd_t>())).pgd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pgd_t),
            "::",
            stringify!(pgd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct p4d_t {
    pub p4d: p4dval_t,
}
#[test]
fn bindgen_test_layout_p4d_t() {
    assert_eq!(
        ::std::mem::size_of::<p4d_t>(),
        8usize,
        concat!("Size of: ", stringify!(p4d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<p4d_t>(),
        8usize,
        concat!("Alignment of ", stringify!(p4d_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<p4d_t>())).p4d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(p4d_t),
            "::",
            stringify!(p4d)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pud_t {
    pub pud: pudval_t,
}
#[test]
fn bindgen_test_layout_pud_t() {
    assert_eq!(
        ::std::mem::size_of::<pud_t>(),
        8usize,
        concat!("Size of: ", stringify!(pud_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pud_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pud_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pud_t>())).pud as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pud_t),
            "::",
            stringify!(pud)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmd_t {
    pub pmd: pmdval_t,
}
#[test]
fn bindgen_test_layout_pmd_t() {
    assert_eq!(
        ::std::mem::size_of::<pmd_t>(),
        8usize,
        concat!("Size of: ", stringify!(pmd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pmd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pmd_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pmd_t>())).pmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmd_t),
            "::",
            stringify!(pmd)
        )
    );
}
extern "C" {
    pub fn cachemode2protval(pcm: page_cache_mode) -> ::std::os::raw::c_ulong;
}
pub type pgtable_t = *mut page;
extern "C" {
    pub static mut __supported_pte_mask: pteval_t;
}
extern "C" {
    pub static mut __default_kernel_pte_mask: pteval_t;
}
extern "C" {
    pub fn set_nx();
}
extern "C" {
    pub static mut nx_enabled: ::std::os::raw::c_int;
}
extern "C" {
    pub fn pgprot_writecombine(prot: pgprot_t) -> pgprot_t;
}
extern "C" {
    pub fn pgprot_writethrough(prot: pgprot_t) -> pgprot_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file {
    _unused: [u8; 0],
}
extern "C" {
    pub fn phys_mem_access_prot(
        file: *mut file,
        pfn: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        vma_prot: pgprot_t,
    ) -> pgprot_t;
}
extern "C" {
    pub fn set_pte_vaddr(vaddr: ::std::os::raw::c_ulong, pte: pte_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seq_file {
    _unused: [u8; 0],
}
extern "C" {
    pub fn arch_report_meminfo(m: *mut seq_file);
}
pub const pg_level_PG_LEVEL_NONE: pg_level = 0;
pub const pg_level_PG_LEVEL_4K: pg_level = 1;
pub const pg_level_PG_LEVEL_2M: pg_level = 2;
pub const pg_level_PG_LEVEL_1G: pg_level = 3;
pub const pg_level_PG_LEVEL_512G: pg_level = 4;
pub const pg_level_PG_LEVEL_NUM: pg_level = 5;
pub type pg_level = ::std::os::raw::c_uint;
extern "C" {
    pub fn update_page_count(level: ::std::os::raw::c_int, pages: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn lookup_address(
        address: ::std::os::raw::c_ulong,
        level: *mut ::std::os::raw::c_uint,
    ) -> *mut pte_t;
}
extern "C" {
    pub fn lookup_address_in_pgd(
        pgd: *mut pgd_t,
        address: ::std::os::raw::c_ulong,
        level: *mut ::std::os::raw::c_uint,
    ) -> *mut pte_t;
}
extern "C" {
    pub fn lookup_pmd_address(address: ::std::os::raw::c_ulong) -> *mut pmd_t;
}
extern "C" {
    pub fn slow_virt_to_phys(__address: *mut ::std::os::raw::c_void) -> phys_addr_t;
}
extern "C" {
    pub fn kernel_map_pages_in_pgd(
        pgd: *mut pgd_t,
        pfn: u64_,
        address: ::std::os::raw::c_ulong,
        numpages: ::std::os::raw::c_uint,
        page_flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kernel_unmap_pages_in_pgd(
        pgd: *mut pgd_t,
        address: ::std::os::raw::c_ulong,
        numpages: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn valid_phys_addr_range(addr: phys_addr_t, size: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn valid_mmap_phys_addr_range(
        pfn: ::std::os::raw::c_ulong,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ioremap_uc(
        offset: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioremap_cache(
        offset: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioremap_prot(
        offset: resource_size_t,
        size: ::std::os::raw::c_ulong,
        prot_val: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioremap_encrypted(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " ioremap     -   map bus memory into CPU space"]
    #[doc = " @offset:    bus address of the memory"]
    #[doc = " @size:      size of the resource to map"]
    #[doc = ""]
    #[doc = " ioremap performs a platform specific sequence of operations to"]
    #[doc = " make bus memory CPU accessible via the readb/readw/readl/writeb/"]
    #[doc = " writew/writel functions and the other mmio helpers. The returned"]
    #[doc = " address is not guaranteed to be usable directly as a virtual"]
    #[doc = " address."]
    #[doc = ""]
    #[doc = " If the area you are trying to map is a PCI BAR you should have a"]
    #[doc = " look at pci_iomap()."]
    pub fn ioremap(
        offset: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn iounmap(addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn memcpy_fromio(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
    );
}
extern "C" {
    pub fn memcpy_toio(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
    );
}
extern "C" {
    pub fn memset_io(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_int, arg3: size_t);
}
extern "C" {
    pub fn ioread8(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ioread16(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ioread16be(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ioread32(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ioread32be(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ioread64(arg1: *const ::std::os::raw::c_void) -> u64_;
}
extern "C" {
    pub fn ioread64be(arg1: *const ::std::os::raw::c_void) -> u64_;
}
extern "C" {
    pub fn ioread64_lo_hi(addr: *const ::std::os::raw::c_void) -> u64_;
}
extern "C" {
    pub fn ioread64_hi_lo(addr: *const ::std::os::raw::c_void) -> u64_;
}
extern "C" {
    pub fn ioread64be_lo_hi(addr: *const ::std::os::raw::c_void) -> u64_;
}
extern "C" {
    pub fn ioread64be_hi_lo(addr: *const ::std::os::raw::c_void) -> u64_;
}
extern "C" {
    pub fn iowrite8(arg1: u8_, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite16(arg1: u16_, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite16be(arg1: u16_, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite32(arg1: u32_, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite32be(arg1: u32_, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite64(arg1: u64_, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite64be(arg1: u64_, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite64_lo_hi(val: u64_, addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite64_hi_lo(val: u64_, addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite64be_lo_hi(val: u64_, addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn iowrite64be_hi_lo(val: u64_, addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ioread8_rep(
        port: *const ::std::os::raw::c_void,
        buf: *mut ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn ioread16_rep(
        port: *const ::std::os::raw::c_void,
        buf: *mut ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn ioread32_rep(
        port: *const ::std::os::raw::c_void,
        buf: *mut ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn iowrite8_rep(
        port: *mut ::std::os::raw::c_void,
        buf: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn iowrite16_rep(
        port: *mut ::std::os::raw::c_void,
        buf: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn iowrite32_rep(
        port: *mut ::std::os::raw::c_void,
        buf: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn ioport_map(
        port: ::std::os::raw::c_ulong,
        nr: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioport_unmap(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pci_dev {
    _unused: [u8; 0],
}
extern "C" {
    pub fn pci_iomap(
        dev: *mut pci_dev,
        bar: ::std::os::raw::c_int,
        max: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pci_iomap_wc(
        dev: *mut pci_dev,
        bar: ::std::os::raw::c_int,
        max: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pci_iomap_range(
        dev: *mut pci_dev,
        bar: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_ulong,
        maxlen: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pci_iomap_wc_range(
        dev: *mut pci_dev,
        bar: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_ulong,
        maxlen: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pci_iounmap(dev: *mut pci_dev, arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn native_io_delay();
}
extern "C" {
    pub static mut io_delay_type: ::std::os::raw::c_int;
}
extern "C" {
    pub fn io_delay_init();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct orc_entry {
    pub sp_offset: s16,
    pub bp_offset: s16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_orc_entry() {
    assert_eq!(
        ::std::mem::size_of::<orc_entry>(),
        6usize,
        concat!("Size of: ", stringify!(orc_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<orc_entry>(),
        1usize,
        concat!("Alignment of ", stringify!(orc_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<orc_entry>())).sp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(orc_entry),
            "::",
            stringify!(sp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<orc_entry>())).bp_offset as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(orc_entry),
            "::",
            stringify!(bp_offset)
        )
    );
}
impl orc_entry {
    #[inline]
    pub fn sp_reg(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sp_reg(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bp_reg(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_bp_reg(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn end(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_end(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sp_reg: ::std::os::raw::c_uint,
        bp_reg: ::std::os::raw::c_uint,
        type_: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sp_reg: u32 = unsafe { ::std::mem::transmute(sp_reg) };
            sp_reg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let bp_reg: u32 = unsafe { ::std::mem::transmute(bp_reg) };
            bp_reg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let end: u32 = unsafe { ::std::mem::transmute(end) };
            end as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn _kstrtoul(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _kstrtol(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoull(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoll(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtouint(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoint(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou16(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut u16_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos16(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut s16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou8(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut u8_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos8(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut s8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtobool(s: *const ::std::os::raw::c_char, res: *mut bool_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoull_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoll_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoul_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtol_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtouint_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoint_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou16_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut u16_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos16_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut s16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou8_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut u8_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos8_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut s8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtobool_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        res: *mut bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_strtoul(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn simple_strtol(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn simple_strtoull(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn simple_strtoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s16_fract {
    pub numerator: __s16,
    pub denominator: __s16,
}
#[test]
fn bindgen_test_layout_s16_fract() {
    assert_eq!(
        ::std::mem::size_of::<s16_fract>(),
        4usize,
        concat!("Size of: ", stringify!(s16_fract))
    );
    assert_eq!(
        ::std::mem::align_of::<s16_fract>(),
        2usize,
        concat!("Alignment of ", stringify!(s16_fract))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<s16_fract>())).numerator as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(s16_fract),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<s16_fract>())).denominator as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(s16_fract),
            "::",
            stringify!(denominator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct u16_fract {
    pub numerator: __u16,
    pub denominator: __u16,
}
#[test]
fn bindgen_test_layout_u16_fract() {
    assert_eq!(
        ::std::mem::size_of::<u16_fract>(),
        4usize,
        concat!("Size of: ", stringify!(u16_fract))
    );
    assert_eq!(
        ::std::mem::align_of::<u16_fract>(),
        2usize,
        concat!("Alignment of ", stringify!(u16_fract))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<u16_fract>())).numerator as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(u16_fract),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<u16_fract>())).denominator as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(u16_fract),
            "::",
            stringify!(denominator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s32_fract {
    pub numerator: __s32,
    pub denominator: __s32,
}
#[test]
fn bindgen_test_layout_s32_fract() {
    assert_eq!(
        ::std::mem::size_of::<s32_fract>(),
        8usize,
        concat!("Size of: ", stringify!(s32_fract))
    );
    assert_eq!(
        ::std::mem::align_of::<s32_fract>(),
        4usize,
        concat!("Alignment of ", stringify!(s32_fract))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<s32_fract>())).numerator as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(s32_fract),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<s32_fract>())).denominator as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(s32_fract),
            "::",
            stringify!(denominator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct u32_fract {
    pub numerator: __u32,
    pub denominator: __u32,
}
#[test]
fn bindgen_test_layout_u32_fract() {
    assert_eq!(
        ::std::mem::size_of::<u32_fract>(),
        8usize,
        concat!("Size of: ", stringify!(u32_fract))
    );
    assert_eq!(
        ::std::mem::align_of::<u32_fract>(),
        4usize,
        concat!("Alignment of ", stringify!(u32_fract))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<u32_fract>())).numerator as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(u32_fract),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<u32_fract>())).denominator as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(u32_fract),
            "::",
            stringify!(denominator)
        )
    );
}
extern "C" {
    pub fn int_pow(base: u64_, exp: ::std::os::raw::c_uint) -> u64_;
}
extern "C" {
    pub fn int_sqrt(arg1: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct static_call_site {
    pub addr: s32,
    pub key: s32,
}
#[test]
fn bindgen_test_layout_static_call_site() {
    assert_eq!(
        ::std::mem::size_of::<static_call_site>(),
        8usize,
        concat!("Size of: ", stringify!(static_call_site))
    );
    assert_eq!(
        ::std::mem::align_of::<static_call_site>(),
        4usize,
        concat!("Alignment of ", stringify!(static_call_site))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_call_site>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_call_site),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_call_site>())).key as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(static_call_site),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_call_key {
    pub func: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: static_call_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_call_key__bindgen_ty_1 {
    pub type_: ::std::os::raw::c_ulong,
    pub mods: *mut static_call_mod,
    pub sites: *mut static_call_site,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_static_call_key__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<static_call_key__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(static_call_key__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<static_call_key__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(static_call_key__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<static_call_key__bindgen_ty_1>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_call_key__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<static_call_key__bindgen_ty_1>())).mods as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_call_key__bindgen_ty_1),
            "::",
            stringify!(mods)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<static_call_key__bindgen_ty_1>())).sites as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_call_key__bindgen_ty_1),
            "::",
            stringify!(sites)
        )
    );
}
#[test]
fn bindgen_test_layout_static_call_key() {
    assert_eq!(
        ::std::mem::size_of::<static_call_key>(),
        16usize,
        concat!("Size of: ", stringify!(static_call_key))
    );
    assert_eq!(
        ::std::mem::align_of::<static_call_key>(),
        8usize,
        concat!("Alignment of ", stringify!(static_call_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_call_key>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_call_key),
            "::",
            stringify!(func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct completion {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __cond_resched() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __SCK__might_resched: static_call_key;
}
extern "C" {
    pub fn __SCT__might_resched() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_exit(error_code: ::std::os::raw::c_long);
}
extern "C" {
    pub fn num_to_str(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        num: ::std::os::raw::c_ulonglong,
        width: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        buf: *mut ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        buf: *mut ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scnprintf(
        buf: *mut ::std::os::raw::c_char,
        size: size_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscnprintf(
        buf: *mut ::std::os::raw::c_char,
        size: size_t,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kasprintf(
        gfp: gfp_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kvasprintf(
        gfp: gfp_t,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kvasprintf_const(
        gfp: gfp_t,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn no_hash_pointers_enable(str_: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_option(
        str_: *mut *mut ::std::os::raw::c_char,
        pint: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_options(
        str_: *const ::std::os::raw::c_char,
        nints: ::std::os::raw::c_int,
        ints: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memparse(
        ptr: *const ::std::os::raw::c_char,
        retptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn parse_option_str(
        str_: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
    ) -> bool_;
}
extern "C" {
    pub fn next_arg(
        args: *mut ::std::os::raw::c_char,
        param: *mut *mut ::std::os::raw::c_char,
        val: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn core_kernel_text(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __kernel_text_address(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kernel_text_address(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn func_ptr_is_kernel_text(ptr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bust_spinlocks(yes: ::std::os::raw::c_int);
}
extern "C" {
    pub static mut root_mountflags: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut early_boot_irqs_disabled: bool_;
}
pub const system_states_SYSTEM_BOOTING: system_states = 0;
pub const system_states_SYSTEM_SCHEDULING: system_states = 1;
pub const system_states_SYSTEM_FREEING_INITMEM: system_states = 2;
pub const system_states_SYSTEM_RUNNING: system_states = 3;
pub const system_states_SYSTEM_HALT: system_states = 4;
pub const system_states_SYSTEM_POWER_OFF: system_states = 5;
pub const system_states_SYSTEM_RESTART: system_states = 6;
pub const system_states_SYSTEM_SUSPEND: system_states = 7;
pub type system_states = ::std::os::raw::c_uint;
extern "C" {
    pub static mut system_state: system_states;
}
extern "C" {
    pub static mut hex_asc: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut hex_asc_upper: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn hex_to_bin(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hex2bin(
        dst: *mut u8_,
        src: *const ::std::os::raw::c_char,
        count: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bin2hex(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_void,
        count: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mac_pton(s: *const ::std::os::raw::c_char, mac: *mut u8_) -> bool_;
}
pub const ftrace_dump_mode_DUMP_NONE: ftrace_dump_mode = 0;
pub const ftrace_dump_mode_DUMP_ALL: ftrace_dump_mode = 1;
pub const ftrace_dump_mode_DUMP_ORIG: ftrace_dump_mode = 2;
pub type ftrace_dump_mode = ::std::os::raw::c_uint;
extern "C" {
    pub fn tracing_on();
}
extern "C" {
    pub fn tracing_off();
}
extern "C" {
    pub fn tracing_is_on() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tracing_snapshot();
}
extern "C" {
    pub fn tracing_snapshot_alloc();
}
extern "C" {
    pub fn tracing_start();
}
extern "C" {
    pub fn tracing_stop();
}
extern "C" {
    pub fn __trace_bprintk(
        ip: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __trace_printk(
        ip: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __trace_bputs(
        ip: ::std::os::raw::c_ulong,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __trace_puts(
        ip: ::std::os::raw::c_ulong,
        str_: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn trace_dump_stack(skip: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __ftrace_vbprintk(
        ip: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ftrace_vprintk(
        ip: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftrace_dump(oops_dump_mode: ftrace_dump_mode);
}
extern "C" {
    pub fn __bad_size_call_parameter();
}
extern "C" {
    pub fn __this_cpu_preempt_check(op: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut __per_cpu_offset: [::std::os::raw::c_ulong; 64usize];
}
extern "C" {
    pub fn setup_per_cpu_areas();
}
extern "C" {
    pub static mut this_cpu_off: ::std::os::raw::c_ulong;
}
pub type retpoline_thunk_t = [u8_; 32usize];
extern "C" {
    pub static mut __x86_indirect_thunk_array: [retpoline_thunk_t; 0usize];
}
extern "C" {
    pub fn __x86_return_thunk();
}
extern "C" {
    pub fn zen_untrain_ret();
}
extern "C" {
    pub fn entry_ibpb();
}
extern "C" {
    pub static mut __x86_indirect_thunk_rax: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rcx: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rdx: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rbx: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rsp: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rbp: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rsi: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rdi: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r8: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r9: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r10: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r11: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r12: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r13: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r14: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r15: retpoline_thunk_t;
}
pub const spectre_v2_mitigation_SPECTRE_V2_NONE: spectre_v2_mitigation = 0;
pub const spectre_v2_mitigation_SPECTRE_V2_RETPOLINE: spectre_v2_mitigation = 1;
pub const spectre_v2_mitigation_SPECTRE_V2_LFENCE: spectre_v2_mitigation = 2;
pub const spectre_v2_mitigation_SPECTRE_V2_EIBRS: spectre_v2_mitigation = 3;
pub const spectre_v2_mitigation_SPECTRE_V2_EIBRS_RETPOLINE: spectre_v2_mitigation = 4;
pub const spectre_v2_mitigation_SPECTRE_V2_EIBRS_LFENCE: spectre_v2_mitigation = 5;
pub const spectre_v2_mitigation_SPECTRE_V2_IBRS: spectre_v2_mitigation = 6;
pub type spectre_v2_mitigation = ::std::os::raw::c_uint;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_NONE: spectre_v2_user_mitigation = 0;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_STRICT: spectre_v2_user_mitigation = 1;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_STRICT_PREFERRED: spectre_v2_user_mitigation =
    2;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_PRCTL: spectre_v2_user_mitigation = 3;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_SECCOMP: spectre_v2_user_mitigation = 4;
pub type spectre_v2_user_mitigation = ::std::os::raw::c_uint;
pub const ssb_mitigation_SPEC_STORE_BYPASS_NONE: ssb_mitigation = 0;
pub const ssb_mitigation_SPEC_STORE_BYPASS_DISABLE: ssb_mitigation = 1;
pub const ssb_mitigation_SPEC_STORE_BYPASS_PRCTL: ssb_mitigation = 2;
pub const ssb_mitigation_SPEC_STORE_BYPASS_SECCOMP: ssb_mitigation = 3;
pub type ssb_mitigation = ::std::os::raw::c_uint;
extern "C" {
    pub static mut __indirect_thunk_start: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut __indirect_thunk_end: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut x86_spec_ctrl_base: u64_;
}
extern "C" {
    pub static mut x86_spec_ctrl_current: ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn update_spec_ctrl_cond(val: u64_);
}
extern "C" {
    pub fn spec_ctrl_current() -> u64_;
}
extern "C" {
    pub static mut switch_to_cond_stibp: static_key_false;
}
extern "C" {
    pub static mut switch_mm_cond_ibpb: static_key_false;
}
extern "C" {
    pub static mut switch_mm_always_ibpb: static_key_false;
}
extern "C" {
    pub static mut mds_user_clear: static_key_false;
}
extern "C" {
    pub static mut mds_idle_clear: static_key_false;
}
extern "C" {
    pub static mut switch_mm_cond_l1d_flush: static_key_false;
}
extern "C" {
    pub static mut mmio_stale_data_clear: static_key_false;
}
extern "C" {
    pub static mut early_idt_handler_array: [[::std::os::raw::c_char; 9usize]; 32usize];
}
extern "C" {
    pub fn early_ignore_irq();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct desc_struct {
    pub limit0: u16_,
    pub base0: u16_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_desc_struct() {
    assert_eq!(
        ::std::mem::size_of::<desc_struct>(),
        8usize,
        concat!("Size of: ", stringify!(desc_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<desc_struct>(),
        1usize,
        concat!("Alignment of ", stringify!(desc_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<desc_struct>())).limit0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(desc_struct),
            "::",
            stringify!(limit0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<desc_struct>())).base0 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(desc_struct),
            "::",
            stringify!(base0)
        )
    );
}
impl desc_struct {
    #[inline]
    pub fn base1(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn s(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit1(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_limit1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn avl(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_avl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_l(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn d(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_d(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_g(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn base2(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base2(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        base1: u16_,
        type_: u16_,
        s: u16_,
        dpl: u16_,
        p: u16_,
        limit1: u16_,
        avl: u16_,
        l: u16_,
        d: u16_,
        g: u16_,
        base2: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let base1: u16 = unsafe { ::std::mem::transmute(base1) };
            base1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let type_: u16 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let s: u16 = unsafe { ::std::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u16 = unsafe { ::std::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u16 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let limit1: u16 = unsafe { ::std::mem::transmute(limit1) };
            limit1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let avl: u16 = unsafe { ::std::mem::transmute(avl) };
            avl as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let l: u16 = unsafe { ::std::mem::transmute(l) };
            l as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let d: u16 = unsafe { ::std::mem::transmute(d) };
            d as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let g: u16 = unsafe { ::std::mem::transmute(g) };
            g as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let base2: u16 = unsafe { ::std::mem::transmute(base2) };
            base2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const GATE_INTERRUPT: ::std::os::raw::c_uint = 14;
pub const GATE_TRAP: ::std::os::raw::c_uint = 15;
pub const GATE_CALL: ::std::os::raw::c_uint = 12;
pub const GATE_TASK: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const DESC_TSS: ::std::os::raw::c_uint = 9;
pub const DESC_LDT: ::std::os::raw::c_uint = 2;
pub const DESCTYPE_S: ::std::os::raw::c_uint = 16;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ldttss_desc {
    pub limit0: u16_,
    pub base0: u16_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub base3: u32_,
    pub zero1: u32_,
}
#[test]
fn bindgen_test_layout_ldttss_desc() {
    assert_eq!(
        ::std::mem::size_of::<ldttss_desc>(),
        16usize,
        concat!("Size of: ", stringify!(ldttss_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<ldttss_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(ldttss_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldttss_desc>())).limit0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldttss_desc),
            "::",
            stringify!(limit0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldttss_desc>())).base0 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ldttss_desc),
            "::",
            stringify!(base0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldttss_desc>())).base3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldttss_desc),
            "::",
            stringify!(base3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldttss_desc>())).zero1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ldttss_desc),
            "::",
            stringify!(zero1)
        )
    );
}
impl ldttss_desc {
    #[inline]
    pub fn base1(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit1(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_limit1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn zero0(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_zero0(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn g(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_g(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn base2(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base2(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        base1: u16_,
        type_: u16_,
        dpl: u16_,
        p: u16_,
        limit1: u16_,
        zero0: u16_,
        g: u16_,
        base2: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let base1: u16 = unsafe { ::std::mem::transmute(base1) };
            base1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let type_: u16 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u16 = unsafe { ::std::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u16 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let limit1: u16 = unsafe { ::std::mem::transmute(limit1) };
            limit1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let zero0: u16 = unsafe { ::std::mem::transmute(zero0) };
            zero0 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let g: u16 = unsafe { ::std::mem::transmute(g) };
            g as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let base2: u16 = unsafe { ::std::mem::transmute(base2) };
            base2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ldt_desc = ldttss_desc;
pub type tss_desc = ldttss_desc;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct idt_bits {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_idt_bits() {
    assert_eq!(
        ::std::mem::size_of::<idt_bits>(),
        2usize,
        concat!("Size of: ", stringify!(idt_bits))
    );
    assert_eq!(
        ::std::mem::align_of::<idt_bits>(),
        1usize,
        concat!("Alignment of ", stringify!(idt_bits))
    );
}
impl idt_bits {
    #[inline]
    pub fn ist(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_ist(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn zero(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_zero(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ist: u16_,
        zero: u16_,
        type_: u16_,
        dpl: u16_,
        p: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let ist: u16 = unsafe { ::std::mem::transmute(ist) };
            ist as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let zero: u16 = unsafe { ::std::mem::transmute(zero) };
            zero as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let type_: u16 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u16 = unsafe { ::std::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u16 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idt_data {
    pub vector: ::std::os::raw::c_uint,
    pub segment: ::std::os::raw::c_uint,
    pub bits: idt_bits,
    pub addr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_idt_data() {
    assert_eq!(
        ::std::mem::size_of::<idt_data>(),
        24usize,
        concat!("Size of: ", stringify!(idt_data))
    );
    assert_eq!(
        ::std::mem::align_of::<idt_data>(),
        8usize,
        concat!("Alignment of ", stringify!(idt_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idt_data>())).vector as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idt_data),
            "::",
            stringify!(vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idt_data>())).segment as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(idt_data),
            "::",
            stringify!(segment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idt_data>())).bits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(idt_data),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idt_data>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(idt_data),
            "::",
            stringify!(addr)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct gate_struct {
    pub offset_low: u16_,
    pub segment: u16_,
    pub bits: idt_bits,
    pub offset_middle: u16_,
    pub offset_high: u32_,
    pub reserved: u32_,
}
#[test]
fn bindgen_test_layout_gate_struct() {
    assert_eq!(
        ::std::mem::size_of::<gate_struct>(),
        16usize,
        concat!("Size of: ", stringify!(gate_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<gate_struct>(),
        1usize,
        concat!("Alignment of ", stringify!(gate_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).offset_low as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(offset_low)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).segment as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(segment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).bits as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).offset_middle as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(offset_middle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).offset_high as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(offset_high)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(reserved)
        )
    );
}
pub type gate_desc = gate_struct;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct desc_ptr {
    pub size: ::std::os::raw::c_ushort,
    pub address: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_desc_ptr() {
    assert_eq!(
        ::std::mem::size_of::<desc_ptr>(),
        10usize,
        concat!("Size of: ", stringify!(desc_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<desc_ptr>(),
        1usize,
        concat!("Alignment of ", stringify!(desc_ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<desc_ptr>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(desc_ptr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<desc_ptr>())).address as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(desc_ptr),
            "::",
            stringify!(address)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mm_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flush_tlb_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmu_gather {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct paravirt_callee_save {
    pub func: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_paravirt_callee_save() {
    assert_eq!(
        ::std::mem::size_of::<paravirt_callee_save>(),
        8usize,
        concat!("Size of: ", stringify!(paravirt_callee_save))
    );
    assert_eq!(
        ::std::mem::align_of::<paravirt_callee_save>(),
        8usize,
        concat!("Alignment of ", stringify!(paravirt_callee_save))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_callee_save>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_callee_save),
            "::",
            stringify!(func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pv_info {
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_pv_info() {
    assert_eq!(
        ::std::mem::size_of::<pv_info>(),
        8usize,
        concat!("Size of: ", stringify!(pv_info))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_info>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_info),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pv_cpu_ops {
    pub io_delay: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_pv_cpu_ops() {
    assert_eq!(
        ::std::mem::size_of::<pv_cpu_ops>(),
        8usize,
        concat!("Size of: ", stringify!(pv_cpu_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_cpu_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_cpu_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).io_delay as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(io_delay)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pv_irq_ops {}
#[test]
fn bindgen_test_layout_pv_irq_ops() {
    assert_eq!(
        ::std::mem::size_of::<pv_irq_ops>(),
        0usize,
        concat!("Size of: ", stringify!(pv_irq_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_irq_ops>(),
        1usize,
        concat!("Alignment of ", stringify!(pv_irq_ops))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pv_mmu_ops {
    pub flush_tlb_user: ::std::option::Option<unsafe extern "C" fn()>,
    pub flush_tlb_kernel: ::std::option::Option<unsafe extern "C" fn()>,
    pub flush_tlb_one_user:
        ::std::option::Option<unsafe extern "C" fn(addr: ::std::os::raw::c_ulong)>,
    pub flush_tlb_multi: ::std::option::Option<
        unsafe extern "C" fn(cpus: *const cpumask, info: *const flush_tlb_info),
    >,
    pub tlb_remove_table: ::std::option::Option<
        unsafe extern "C" fn(tlb: *mut mmu_gather, table: *mut ::std::os::raw::c_void),
    >,
    pub exit_mmap: ::std::option::Option<unsafe extern "C" fn(mm: *mut mm_struct)>,
    pub notify_page_enc_status_changed: ::std::option::Option<
        unsafe extern "C" fn(
            pfn: ::std::os::raw::c_ulong,
            npages: ::std::os::raw::c_int,
            enc: bool_,
        ),
    >,
}
#[test]
fn bindgen_test_layout_pv_mmu_ops() {
    assert_eq!(
        ::std::mem::size_of::<pv_mmu_ops>(),
        56usize,
        concat!("Size of: ", stringify!(pv_mmu_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_mmu_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_mmu_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).flush_tlb_user as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(flush_tlb_user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).flush_tlb_kernel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(flush_tlb_kernel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).flush_tlb_one_user as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(flush_tlb_one_user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).flush_tlb_multi as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(flush_tlb_multi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).tlb_remove_table as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(tlb_remove_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).exit_mmap as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(exit_mmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pv_mmu_ops>())).notify_page_enc_status_changed as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(notify_page_enc_status_changed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_spinlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pv_lock_ops {
    pub queued_spin_lock_slowpath:
        ::std::option::Option<unsafe extern "C" fn(lock: *mut qspinlock, val: u32_)>,
    pub queued_spin_unlock: paravirt_callee_save,
    pub wait: ::std::option::Option<unsafe extern "C" fn(ptr: *mut u8_, val: u8_)>,
    pub kick: ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_int)>,
    pub vcpu_is_preempted: paravirt_callee_save,
}
#[test]
fn bindgen_test_layout_pv_lock_ops() {
    assert_eq!(
        ::std::mem::size_of::<pv_lock_ops>(),
        40usize,
        concat!("Size of: ", stringify!(pv_lock_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_lock_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_lock_ops))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pv_lock_ops>())).queued_spin_lock_slowpath as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lock_ops),
            "::",
            stringify!(queued_spin_lock_slowpath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_lock_ops>())).queued_spin_unlock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lock_ops),
            "::",
            stringify!(queued_spin_unlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_lock_ops>())).wait as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lock_ops),
            "::",
            stringify!(wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_lock_ops>())).kick as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lock_ops),
            "::",
            stringify!(kick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_lock_ops>())).vcpu_is_preempted as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lock_ops),
            "::",
            stringify!(vcpu_is_preempted)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct paravirt_patch_template {
    pub cpu: pv_cpu_ops,
    pub irq: pv_irq_ops,
    pub mmu: pv_mmu_ops,
    pub lock: pv_lock_ops,
}
#[test]
fn bindgen_test_layout_paravirt_patch_template() {
    assert_eq!(
        ::std::mem::size_of::<paravirt_patch_template>(),
        104usize,
        concat!("Size of: ", stringify!(paravirt_patch_template))
    );
    assert_eq!(
        ::std::mem::align_of::<paravirt_patch_template>(),
        8usize,
        concat!("Alignment of ", stringify!(paravirt_patch_template))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_template>())).cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_template),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_template>())).irq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_template),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_template>())).mmu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_template),
            "::",
            stringify!(mmu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_template>())).lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_template),
            "::",
            stringify!(lock)
        )
    );
}
extern "C" {
    pub static mut pv_info: pv_info;
}
extern "C" {
    pub static mut pv_ops: paravirt_patch_template;
}
extern "C" {
    pub fn paravirt_patch(
        type_: u8_,
        insn_buff: *mut ::std::os::raw::c_void,
        addr: ::std::os::raw::c_ulong,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_disable_iospace() -> ::std::os::raw::c_int;
}
pub const paravirt_lazy_mode_PARAVIRT_LAZY_NONE: paravirt_lazy_mode = 0;
pub const paravirt_lazy_mode_PARAVIRT_LAZY_MMU: paravirt_lazy_mode = 1;
pub const paravirt_lazy_mode_PARAVIRT_LAZY_CPU: paravirt_lazy_mode = 2;
pub type paravirt_lazy_mode = ::std::os::raw::c_uint;
extern "C" {
    pub fn paravirt_get_lazy_mode() -> paravirt_lazy_mode;
}
extern "C" {
    pub fn paravirt_start_context_switch(prev: *mut task_struct);
}
extern "C" {
    pub fn paravirt_end_context_switch(next: *mut task_struct);
}
extern "C" {
    pub fn paravirt_enter_lazy_mmu();
}
extern "C" {
    pub fn paravirt_leave_lazy_mmu();
}
extern "C" {
    pub fn paravirt_flush_lazy_mmu();
}
extern "C" {
    pub fn _paravirt_nop();
}
extern "C" {
    pub fn paravirt_BUG();
}
extern "C" {
    pub fn _paravirt_ident_64(arg1: u64_) -> u64_;
}
extern "C" {
    pub fn paravirt_ret0() -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct paravirt_patch_site {
    pub instr: *mut u8_,
    pub type_: u8_,
    pub len: u8_,
}
#[test]
fn bindgen_test_layout_paravirt_patch_site() {
    assert_eq!(
        ::std::mem::size_of::<paravirt_patch_site>(),
        16usize,
        concat!("Size of: ", stringify!(paravirt_patch_site))
    );
    assert_eq!(
        ::std::mem::align_of::<paravirt_patch_site>(),
        8usize,
        concat!("Alignment of ", stringify!(paravirt_patch_site))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_site>())).instr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_site),
            "::",
            stringify!(instr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_site>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_site),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_site>())).len as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_site),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub static mut __parainstructions: [paravirt_patch_site; 0usize];
}
extern "C" {
    pub static mut __parainstructions_end: [paravirt_patch_site; 0usize];
}
extern "C" {
    pub fn _find_next_bit(
        addr1: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _find_next_and_bit(
        addr1: *const ::std::os::raw::c_ulong,
        addr2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _find_next_andnot_bit(
        addr1: *const ::std::os::raw::c_ulong,
        addr2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _find_next_zero_bit(
        addr: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _find_first_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __find_nth_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __find_nth_and_bit(
        addr1: *const ::std::os::raw::c_ulong,
        addr2: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __find_nth_andnot_bit(
        addr1: *const ::std::os::raw::c_ulong,
        addr2: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _find_first_and_bit(
        addr1: *const ::std::os::raw::c_ulong,
        addr2: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _find_first_zero_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _find_last_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " find_next_clump8 - find next 8-bit clump with set bits in a memory region"]
    #[doc = " @clump: location to store copy of found clump"]
    #[doc = " @addr: address to base the search on"]
    #[doc = " @size: bitmap size in number of bits"]
    #[doc = " @offset: bit offset at which to start searching"]
    #[doc = ""]
    #[doc = " Returns the bit offset for the next set clump; the found clump value is"]
    #[doc = " copied to the location pointed by @clump. If no bits are set, returns @size."]
    pub fn find_next_clump8(
        clump: *mut ::std::os::raw::c_ulong,
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        offset: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " DOC: declare bitmap"]
    #[doc = " The DECLARE_BITMAP(name,bits) macro, in linux/types.h, can be used"]
    #[doc = " to declare an array named 'name' of just enough unsigned longs to"]
    #[doc = " contain all bit positions from 0 to 'bits' - 1."]
    pub fn bitmap_alloc(
        nbits: ::std::os::raw::c_uint,
        flags: gfp_t,
    ) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bitmap_zalloc(
        nbits: ::std::os::raw::c_uint,
        flags: gfp_t,
    ) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bitmap_alloc_node(
        nbits: ::std::os::raw::c_uint,
        flags: gfp_t,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bitmap_zalloc_node(
        nbits: ::std::os::raw::c_uint,
        flags: gfp_t,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bitmap_free(bitmap: *const ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn devm_bitmap_alloc(
        dev: *mut device,
        nbits: ::std::os::raw::c_uint,
        flags: gfp_t,
    ) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn devm_bitmap_zalloc(
        dev: *mut device,
        nbits: ::std::os::raw::c_uint,
        flags: gfp_t,
    ) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __bitmap_equal(
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_or_equal(
        src1: *const ::std::os::raw::c_ulong,
        src2: *const ::std::os::raw::c_ulong,
        src3: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_complement(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_shift_right(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        shift: ::std::os::raw::c_uint,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_shift_left(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        shift: ::std::os::raw::c_uint,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn bitmap_cut(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        first: ::std::os::raw::c_uint,
        cut: ::std::os::raw::c_uint,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_and(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_or(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_xor(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_andnot(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_replace(
        dst: *mut ::std::os::raw::c_ulong,
        old: *const ::std::os::raw::c_ulong,
        new: *const ::std::os::raw::c_ulong,
        mask: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_intersects(
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_subset(
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_weight(
        bitmap: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __bitmap_weight_and(
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __bitmap_set(
        map: *mut ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn __bitmap_clear(
        map: *mut ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn bitmap_find_next_zero_area_off(
        map: *mut ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
        nr: ::std::os::raw::c_uint,
        align_mask: ::std::os::raw::c_ulong,
        align_offset: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bitmap_parse(
        buf: *const ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_uint,
        dst: *mut ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_parse_user(
        ubuf: *const ::std::os::raw::c_char,
        ulen: ::std::os::raw::c_uint,
        dst: *mut ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_parselist(
        buf: *const ::std::os::raw::c_char,
        maskp: *mut ::std::os::raw::c_ulong,
        nmaskbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_parselist_user(
        ubuf: *const ::std::os::raw::c_char,
        ulen: ::std::os::raw::c_uint,
        dst: *mut ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_remap(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        old: *const ::std::os::raw::c_ulong,
        new: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn bitmap_bitremap(
        oldbit: ::std::os::raw::c_int,
        old: *const ::std::os::raw::c_ulong,
        new: *const ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_onto(
        dst: *mut ::std::os::raw::c_ulong,
        orig: *const ::std::os::raw::c_ulong,
        relmap: *const ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn bitmap_fold(
        dst: *mut ::std::os::raw::c_ulong,
        orig: *const ::std::os::raw::c_ulong,
        sz: ::std::os::raw::c_uint,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn bitmap_find_free_region(
        bitmap: *mut ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_uint,
        order: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_release_region(
        bitmap: *mut ::std::os::raw::c_ulong,
        pos: ::std::os::raw::c_uint,
        order: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn bitmap_allocate_region(
        bitmap: *mut ::std::os::raw::c_ulong,
        pos: ::std::os::raw::c_uint,
        order: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_print_to_pagebuf(
        list: bool_,
        buf: *mut ::std::os::raw::c_char,
        maskp: *const ::std::os::raw::c_ulong,
        nmaskbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_print_bitmask_to_buf(
        buf: *mut ::std::os::raw::c_char,
        maskp: *const ::std::os::raw::c_ulong,
        nmaskbits: ::std::os::raw::c_int,
        off: loff_t,
        count: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_print_list_to_buf(
        buf: *mut ::std::os::raw::c_char,
        maskp: *const ::std::os::raw::c_ulong,
        nmaskbits: ::std::os::raw::c_int,
        off: loff_t,
        count: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_from_arr32(
        bitmap: *mut ::std::os::raw::c_ulong,
        buf: *const u32_,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn bitmap_to_arr32(
        buf: *mut u32_,
        bitmap: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __xchg_wrong_size();
}
extern "C" {
    pub fn __cmpxchg_wrong_size();
}
extern "C" {
    pub fn __xadd_wrong_size();
}
extern "C" {
    pub fn __add_wrong_size();
}
pub type atomic_long_t = atomic64_t;
extern "C" {
    pub fn numa_map_to_online_node(node: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpumask {
    pub bits: [::std::os::raw::c_ulong; 1usize],
}
#[test]
fn bindgen_test_layout_cpumask() {
    assert_eq!(
        ::std::mem::size_of::<cpumask>(),
        8usize,
        concat!("Size of: ", stringify!(cpumask))
    );
    assert_eq!(
        ::std::mem::align_of::<cpumask>(),
        8usize,
        concat!("Alignment of ", stringify!(cpumask))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpumask>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpumask),
            "::",
            stringify!(bits)
        )
    );
}
pub type cpumask_t = cpumask;
extern "C" {
    pub static mut nr_cpu_ids: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut __cpu_possible_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_online_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_present_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_active_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_dying_mask: cpumask;
}
extern "C" {
    pub static mut __num_online_cpus: atomic_t;
}
extern "C" {
    pub static mut cpus_booted_once_mask: cpumask_t;
}
extern "C" {
    pub fn cpumask_local_spread(
        i: ::std::os::raw::c_uint,
        node: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn cpumask_any_and_distribute(
        src1p: *const cpumask,
        src2p: *const cpumask,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn cpumask_any_distribute(srcp: *const cpumask) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn cpumask_next_wrap(
        n: ::std::os::raw::c_int,
        mask: *const cpumask,
        start: ::std::os::raw::c_int,
        wrap: bool_,
    ) -> ::std::os::raw::c_uint;
}
pub type cpumask_var_t = [cpumask; 1usize];
extern "C" {
    pub static cpu_all_bits: [::std::os::raw::c_ulong; 1usize];
}
extern "C" {
    pub fn init_cpu_present(src: *const cpumask);
}
extern "C" {
    pub fn init_cpu_possible(src: *const cpumask);
}
extern "C" {
    pub fn init_cpu_online(src: *const cpumask);
}
extern "C" {
    pub fn set_cpu_online(cpu: ::std::os::raw::c_uint, online: bool_);
}
extern "C" {
    pub static mut cpu_bit_bitmap: [[::std::os::raw::c_ulong; 1usize]; 65usize];
}
extern "C" {
    pub fn dummy_steal_clock(cpu: ::std::os::raw::c_int) -> u64_;
}
extern "C" {
    pub fn dummy_sched_clock() -> u64_;
}
extern "C" {
    pub static mut __SCK__pv_steal_clock: static_call_key;
}
extern "C" {
    pub fn __SCT__pv_steal_clock(arg1: ::std::os::raw::c_int) -> u64_;
}
extern "C" {
    pub static mut __SCK__pv_sched_clock: static_call_key;
}
extern "C" {
    pub fn __SCT__pv_sched_clock() -> u64_;
}
extern "C" {
    pub fn paravirt_set_sched_clock(func: ::std::option::Option<unsafe extern "C" fn() -> u64_>);
}
extern "C" {
    pub static mut paravirt_steal_enabled: static_key;
}
extern "C" {
    pub static mut paravirt_steal_rq_enabled: static_key;
}
extern "C" {
    pub fn __native_queued_spin_unlock(lock: *mut qspinlock);
}
extern "C" {
    pub fn pv_is_native_spin_unlock() -> bool_;
}
extern "C" {
    pub fn __native_vcpu_is_preempted(cpu: ::std::os::raw::c_long) -> bool_;
}
extern "C" {
    pub fn pv_is_native_vcpu_is_preempted() -> bool_;
}
extern "C" {
    pub fn native_flush_tlb_local();
}
extern "C" {
    pub fn native_flush_tlb_global();
}
extern "C" {
    pub fn native_flush_tlb_one_user(addr: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn native_flush_tlb_multi(cpumask: *const cpumask, info: *const flush_tlb_info);
}
extern "C" {
    pub fn default_banner();
}
extern "C" {
    pub fn xlate_dev_mem_ptr(phys: phys_addr_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn unxlate_dev_mem_ptr(phys: phys_addr_t, addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn ioremap_change_attr(
        vaddr: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        pcm: page_cache_mode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ioremap_wc(
        offset: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioremap_wt(
        offset: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn is_early_ioremap_ptep(ptep: *mut pte_t) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_handle {
    pub secondary: *mut fwnode_handle,
    pub ops: *const fwnode_operations,
    pub dev: *mut device,
    pub suppliers: list_head,
    pub consumers: list_head,
    pub flags: u8_,
}
#[test]
fn bindgen_test_layout_fwnode_handle() {
    assert_eq!(
        ::std::mem::size_of::<fwnode_handle>(),
        64usize,
        concat!("Size of: ", stringify!(fwnode_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<fwnode_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_handle>())).secondary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_handle),
            "::",
            stringify!(secondary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_handle>())).ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_handle),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_handle>())).dev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_handle),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_handle>())).suppliers as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_handle),
            "::",
            stringify!(suppliers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_handle>())).consumers as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_handle),
            "::",
            stringify!(consumers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_handle>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_handle),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_link {
    pub supplier: *mut fwnode_handle,
    pub s_hook: list_head,
    pub consumer: *mut fwnode_handle,
    pub c_hook: list_head,
}
#[test]
fn bindgen_test_layout_fwnode_link() {
    assert_eq!(
        ::std::mem::size_of::<fwnode_link>(),
        48usize,
        concat!("Size of: ", stringify!(fwnode_link))
    );
    assert_eq!(
        ::std::mem::align_of::<fwnode_link>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_link))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_link>())).supplier as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_link),
            "::",
            stringify!(supplier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_link>())).s_hook as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_link),
            "::",
            stringify!(s_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_link>())).consumer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_link),
            "::",
            stringify!(consumer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_link>())).c_hook as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_link),
            "::",
            stringify!(c_hook)
        )
    );
}
#[doc = " struct fwnode_endpoint - Fwnode graph endpoint"]
#[doc = " @port: Port number"]
#[doc = " @id: Endpoint id"]
#[doc = " @local_fwnode: reference to the related fwnode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_endpoint {
    pub port: ::std::os::raw::c_uint,
    pub id: ::std::os::raw::c_uint,
    pub local_fwnode: *const fwnode_handle,
}
#[test]
fn bindgen_test_layout_fwnode_endpoint() {
    assert_eq!(
        ::std::mem::size_of::<fwnode_endpoint>(),
        16usize,
        concat!("Size of: ", stringify!(fwnode_endpoint))
    );
    assert_eq!(
        ::std::mem::align_of::<fwnode_endpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_endpoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_endpoint>())).port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_endpoint),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_endpoint>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_endpoint),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_endpoint>())).local_fwnode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_endpoint),
            "::",
            stringify!(local_fwnode)
        )
    );
}
#[doc = " struct fwnode_reference_args - Fwnode reference with additional arguments"]
#[doc = " @fwnode:- A reference to the base fwnode"]
#[doc = " @nargs: Number of elements in @args array"]
#[doc = " @args: Integer arguments on the fwnode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_reference_args {
    pub fwnode: *mut fwnode_handle,
    pub nargs: ::std::os::raw::c_uint,
    pub args: [u64_; 8usize],
}
#[test]
fn bindgen_test_layout_fwnode_reference_args() {
    assert_eq!(
        ::std::mem::size_of::<fwnode_reference_args>(),
        80usize,
        concat!("Size of: ", stringify!(fwnode_reference_args))
    );
    assert_eq!(
        ::std::mem::align_of::<fwnode_reference_args>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_reference_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_reference_args>())).fwnode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_reference_args),
            "::",
            stringify!(fwnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_reference_args>())).nargs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_reference_args),
            "::",
            stringify!(nargs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_reference_args>())).args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_reference_args),
            "::",
            stringify!(args)
        )
    );
}
#[doc = " struct fwnode_operations - Operations for fwnode interface"]
#[doc = " @get: Get a reference to an fwnode."]
#[doc = " @put: Put a reference to an fwnode."]
#[doc = " @device_is_available: Return true if the device is available."]
#[doc = " @device_get_match_data: Return the device driver match data."]
#[doc = " @property_present: Return true if a property is present."]
#[doc = " @property_read_int_array: Read an array of integer properties. Return zero on"]
#[doc = "\t\t\t     success, a negative error code otherwise."]
#[doc = " @property_read_string_array: Read an array of string properties. Return zero"]
#[doc = "\t\t\t\ton success, a negative error code otherwise."]
#[doc = " @get_name: Return the name of an fwnode."]
#[doc = " @get_name_prefix: Get a prefix for a node (for printing purposes)."]
#[doc = " @get_parent: Return the parent of an fwnode."]
#[doc = " @get_next_child_node: Return the next child node in an iteration."]
#[doc = " @get_named_child_node: Return a child node with a given name."]
#[doc = " @get_reference_args: Return a reference pointed to by a property, with args"]
#[doc = " @graph_get_next_endpoint: Return an endpoint node in an iteration."]
#[doc = " @graph_get_remote_endpoint: Return the remote endpoint node of a local"]
#[doc = "\t\t\t       endpoint node."]
#[doc = " @graph_get_port_parent: Return the parent node of a port node."]
#[doc = " @graph_parse_endpoint: Parse endpoint for port and endpoint id."]
#[doc = " @add_links:\tCreate fwnode links to all the suppliers of the fwnode. Return"]
#[doc = "\t\tzero on success, a negative error code otherwise."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fwnode_operations {
    pub get: ::std::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub put: ::std::option::Option<unsafe extern "C" fn(fwnode: *mut fwnode_handle)>,
    pub device_is_available:
        ::std::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> bool_>,
    pub device_get_match_data: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            dev: *const device,
        ) -> *const ::std::os::raw::c_void,
    >,
    pub device_dma_supported:
        ::std::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> bool_>,
    pub device_get_dma_attr:
        ::std::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> dev_dma_attr>,
    pub property_present: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            propname: *const ::std::os::raw::c_char,
        ) -> bool_,
    >,
    pub property_read_int_array: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            propname: *const ::std::os::raw::c_char,
            elem_size: ::std::os::raw::c_uint,
            val: *mut ::std::os::raw::c_void,
            nval: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub property_read_string_array: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode_handle: *const fwnode_handle,
            propname: *const ::std::os::raw::c_char,
            val: *mut *const ::std::os::raw::c_char,
            nval: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *const ::std::os::raw::c_char,
    >,
    pub get_name_prefix: ::std::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *const ::std::os::raw::c_char,
    >,
    pub get_parent: ::std::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub get_next_child_node: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            child: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub get_named_child_node: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            name: *const ::std::os::raw::c_char,
        ) -> *mut fwnode_handle,
    >,
    pub get_reference_args: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            prop: *const ::std::os::raw::c_char,
            nargs_prop: *const ::std::os::raw::c_char,
            nargs: ::std::os::raw::c_uint,
            index: ::std::os::raw::c_uint,
            args: *mut fwnode_reference_args,
        ) -> ::std::os::raw::c_int,
    >,
    pub graph_get_next_endpoint: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            prev: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub graph_get_remote_endpoint: ::std::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_get_port_parent: ::std::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_parse_endpoint: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            endpoint: *mut fwnode_endpoint,
        ) -> ::std::os::raw::c_int,
    >,
    pub iomap: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *mut fwnode_handle,
            index: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub irq_get: ::std::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            index: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_links: ::std::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_fwnode_operations() {
    assert_eq!(
        ::std::mem::size_of::<fwnode_operations>(),
        176usize,
        concat!("Size of: ", stringify!(fwnode_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<fwnode_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(fwnode_operations))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_operations>())).get as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_operations>())).put as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(put)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).device_is_available as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(device_is_available)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).device_get_match_data as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(device_get_match_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).device_dma_supported as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(device_dma_supported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).device_get_dma_attr as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(device_get_dma_attr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).property_present as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(property_present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).property_read_int_array as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(property_read_int_array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).property_read_string_array as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(property_read_string_array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_operations>())).get_name as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).get_name_prefix as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_name_prefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_operations>())).get_parent as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).get_next_child_node as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_next_child_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).get_named_child_node as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_named_child_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).get_reference_args as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(get_reference_args)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).graph_get_next_endpoint as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_get_next_endpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).graph_get_remote_endpoint as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_get_remote_endpoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).graph_get_port_parent as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_get_port_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fwnode_operations>())).graph_parse_endpoint as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(graph_parse_endpoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_operations>())).iomap as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(iomap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_operations>())).irq_get as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(irq_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fwnode_operations>())).add_links as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(fwnode_operations),
            "::",
            stringify!(add_links)
        )
    );
}
extern "C" {
    pub fn fw_devlink_get_flags() -> u32_;
}
extern "C" {
    pub fn fw_devlink_is_strict() -> bool_;
}
extern "C" {
    pub fn fwnode_link_add(
        con: *mut fwnode_handle,
        sup: *mut fwnode_handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwnode_links_purge(fwnode: *mut fwnode_handle);
}
extern "C" {
    pub fn fw_devlink_purge_absent_suppliers(fwnode: *mut fwnode_handle);
}
pub const LOGIC_PIO_INDIRECT: ::std::os::raw::c_uint = 0;
pub const LOGIC_PIO_CPU_MMIO: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct logic_pio_hwaddr {
    pub list: list_head,
    pub fwnode: *mut fwnode_handle,
    pub hw_start: resource_size_t,
    pub io_start: resource_size_t,
    pub size: resource_size_t,
    pub flags: ::std::os::raw::c_ulong,
    pub hostdata: *mut ::std::os::raw::c_void,
    pub ops: *const logic_pio_host_ops,
}
#[test]
fn bindgen_test_layout_logic_pio_hwaddr() {
    assert_eq!(
        ::std::mem::size_of::<logic_pio_hwaddr>(),
        72usize,
        concat!("Size of: ", stringify!(logic_pio_hwaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<logic_pio_hwaddr>(),
        8usize,
        concat!("Alignment of ", stringify!(logic_pio_hwaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).fwnode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(fwnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).hw_start as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(hw_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).io_start as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(io_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).hostdata as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(hostdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_hwaddr>())).ops as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_hwaddr),
            "::",
            stringify!(ops)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct logic_pio_host_ops {
    pub in_: ::std::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut ::std::os::raw::c_void,
            addr: ::std::os::raw::c_ulong,
            dwidth: size_t,
        ) -> u32_,
    >,
    pub out: ::std::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut ::std::os::raw::c_void,
            addr: ::std::os::raw::c_ulong,
            val: u32_,
            dwidth: size_t,
        ),
    >,
    pub ins: ::std::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut ::std::os::raw::c_void,
            addr: ::std::os::raw::c_ulong,
            buffer: *mut ::std::os::raw::c_void,
            dwidth: size_t,
            count: ::std::os::raw::c_uint,
        ) -> u32_,
    >,
    pub outs: ::std::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut ::std::os::raw::c_void,
            addr: ::std::os::raw::c_ulong,
            buffer: *const ::std::os::raw::c_void,
            dwidth: size_t,
            count: ::std::os::raw::c_uint,
        ),
    >,
}
#[test]
fn bindgen_test_layout_logic_pio_host_ops() {
    assert_eq!(
        ::std::mem::size_of::<logic_pio_host_ops>(),
        32usize,
        concat!("Size of: ", stringify!(logic_pio_host_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<logic_pio_host_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(logic_pio_host_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_host_ops>())).in_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_host_ops),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_host_ops>())).out as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_host_ops),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_host_ops>())).ins as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_host_ops),
            "::",
            stringify!(ins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<logic_pio_host_ops>())).outs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(logic_pio_host_ops),
            "::",
            stringify!(outs)
        )
    );
}
extern "C" {
    pub fn find_io_range_by_fwnode(fwnode: *mut fwnode_handle) -> *mut logic_pio_hwaddr;
}
extern "C" {
    pub fn logic_pio_trans_hwaddr(
        fwnode: *mut fwnode_handle,
        hw_addr: resource_size_t,
        size: resource_size_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn logic_pio_register_range(newrange: *mut logic_pio_hwaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn logic_pio_unregister_range(range: *mut logic_pio_hwaddr);
}
extern "C" {
    pub fn logic_pio_to_hwaddr(pio: ::std::os::raw::c_ulong) -> resource_size_t;
}
extern "C" {
    pub fn logic_pio_trans_cpuaddr(hw_addr: resource_size_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn iter_div_u64_rem(dividend: u64_, divisor: u32_, remainder: *mut u64_) -> u32_;
}
pub type time64_t = __s64;
pub type timeu64_t = __u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_timespec {
    pub tv_sec: __kernel_time64_t,
    pub tv_nsec: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___kernel_timespec() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_timespec>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_itimerspec {
    pub it_interval: __kernel_timespec,
    pub it_value: __kernel_timespec,
}
#[test]
fn bindgen_test_layout___kernel_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(__kernel_itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_old_timeval {
    pub tv_sec: __kernel_long_t,
    pub tv_usec: __kernel_long_t,
}
#[test]
fn bindgen_test_layout___kernel_old_timeval() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_old_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_old_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_old_timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_old_timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_old_timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_old_timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_old_timespec {
    pub tv_sec: __kernel_old_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout___kernel_old_timespec() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_old_timespec>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_old_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_old_timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_old_timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_old_timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_old_timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_old_itimerval {
    pub it_interval: __kernel_old_timeval,
    pub it_value: __kernel_old_timeval,
}
#[test]
fn bindgen_test_layout___kernel_old_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_old_itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(__kernel_old_itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_old_itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_old_itimerval))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__kernel_old_itimerval>())).it_interval as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_old_itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_sock_timeval {
    pub tv_sec: __s64,
    pub tv_usec: __s64,
}
#[test]
fn bindgen_test_layout___kernel_sock_timeval() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_sock_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_sock_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_sock_timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_sock_timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sock_timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sock_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sock_timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sock_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec64 {
    pub tv_sec: time64_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec64() {
    assert_eq!(
        ::std::mem::size_of::<timespec64>(),
        16usize,
        concat!("Size of: ", stringify!(timespec64))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec64>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec64>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec64),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec64>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec64),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec64 {
    pub it_interval: timespec64,
    pub it_value: timespec64,
}
#[test]
fn bindgen_test_layout_itimerspec64() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec64>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec64))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec64>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec64>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec64),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec64>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec64),
            "::",
            stringify!(it_value)
        )
    );
}
extern "C" {
    pub fn set_normalized_timespec64(ts: *mut timespec64, sec: time64_t, nsec: s64);
}
extern "C" {
    #[doc = " ns_to_timespec64 - Convert nanoseconds to timespec64"]
    #[doc = " @nsec:\tthe nanoseconds value to be converted"]
    #[doc = ""]
    #[doc = " Returns the timespec64 representation of the nsec parameter."]
    pub fn ns_to_timespec64(nsec: s64) -> timespec64;
}
extern "C" {
    pub fn timespec64_add_safe(lhs: timespec64, rhs: timespec64) -> timespec64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct old_timespec32 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    _unused: [u8; 0],
}
pub const timespec_type_TT_NONE: timespec_type = 0;
pub const timespec_type_TT_NATIVE: timespec_type = 1;
pub const timespec_type_TT_COMPAT: timespec_type = 2;
pub type timespec_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block {
    pub arch_data: ::std::os::raw::c_ulong,
    pub fn_: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut restart_block) -> ::std::os::raw::c_long,
    >,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1 {
    pub futex: restart_block__bindgen_ty_1__bindgen_ty_1,
    pub nanosleep: restart_block__bindgen_ty_1__bindgen_ty_2,
    pub poll: restart_block__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_1 {
    pub uaddr: *mut u32_,
    pub val: u32_,
    pub flags: u32_,
    pub bitset: u32_,
    pub time: u64_,
    pub uaddr2: *mut u32_,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).uaddr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uaddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).val as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).flags as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).bitset as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(bitset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).time as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).uaddr2 as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uaddr2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_2 {
    pub clockid: clockid_t,
    pub type_: timespec_type,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub expires: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub rmtp: *mut __kernel_timespec,
    pub compat_rmtp: *mut old_timespec32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>())).rmtp
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(rmtp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                .compat_rmtp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(compat_rmtp)
        )
    );
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).clockid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(clockid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).type_ as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).expires
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(expires)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_3 {
    pub ufds: *mut pollfd,
    pub nfds: ::std::os::raw::c_int,
    pub has_timeout: ::std::os::raw::c_int,
    pub tv_sec: ::std::os::raw::c_ulong,
    pub tv_nsec: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_3>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).ufds as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(ufds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).nfds as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(nfds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).has_timeout
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(has_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).tv_sec as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).tv_nsec
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<restart_block__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(restart_block__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(restart_block__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1>())).futex as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1>())).nanosleep as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(nanosleep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1>())).poll as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(poll)
        )
    );
}
#[test]
fn bindgen_test_layout_restart_block() {
    assert_eq!(
        ::std::mem::size_of::<restart_block>(),
        56usize,
        concat!("Size of: ", stringify!(restart_block))
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block>(),
        8usize,
        concat!("Alignment of ", stringify!(restart_block))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<restart_block>())).arch_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block),
            "::",
            stringify!(arch_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<restart_block>())).fn_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block),
            "::",
            stringify!(fn_)
        )
    );
}
extern "C" {
    pub fn do_no_restart_syscall(parm: *mut restart_block) -> ::std::os::raw::c_long;
}
extern "C" {
    pub static mut current_task: *mut task_struct;
}
pub const BAD_STACK: ::std::os::raw::c_int = -1;
pub const NOT_STACK: ::std::os::raw::c_int = 0;
pub const GOOD_FRAME: ::std::os::raw::c_int = 1;
pub const GOOD_STACK: ::std::os::raw::c_int = 2;
pub type _bindgen_ty_6 = ::std::os::raw::c_int;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SECCOMP: syscall_work_bit = 0;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_TRACEPOINT: syscall_work_bit = 1;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_TRACE: syscall_work_bit = 2;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_EMU: syscall_work_bit = 3;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_AUDIT: syscall_work_bit = 4;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_USER_DISPATCH: syscall_work_bit = 5;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_EXIT_TRAP: syscall_work_bit = 6;
pub type syscall_work_bit = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_bitmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm86 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_regs {
    pub r15: ::std::os::raw::c_ulong,
    pub r14: ::std::os::raw::c_ulong,
    pub r13: ::std::os::raw::c_ulong,
    pub r12: ::std::os::raw::c_ulong,
    pub bp: ::std::os::raw::c_ulong,
    pub bx: ::std::os::raw::c_ulong,
    pub r11: ::std::os::raw::c_ulong,
    pub r10: ::std::os::raw::c_ulong,
    pub r9: ::std::os::raw::c_ulong,
    pub r8: ::std::os::raw::c_ulong,
    pub ax: ::std::os::raw::c_ulong,
    pub cx: ::std::os::raw::c_ulong,
    pub dx: ::std::os::raw::c_ulong,
    pub si: ::std::os::raw::c_ulong,
    pub di: ::std::os::raw::c_ulong,
    pub orig_ax: ::std::os::raw::c_ulong,
    pub ip: ::std::os::raw::c_ulong,
    pub cs: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub sp: ::std::os::raw::c_ulong,
    pub ss: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_pt_regs() {
    assert_eq!(
        ::std::mem::size_of::<pt_regs>(),
        168usize,
        concat!("Size of: ", stringify!(pt_regs))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_regs>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_regs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r15 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r14 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r13 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r12 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).bp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).bx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r11 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r10 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r9 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r8 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).ax as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).cx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).dx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).si as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(si)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).di as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(di)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).orig_ax as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(orig_ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).ip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).cs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).flags as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).sp as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).ss as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ss)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user_desc {
    pub entry_number: ::std::os::raw::c_uint,
    pub base_addr: ::std::os::raw::c_uint,
    pub limit: ::std::os::raw::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_user_desc() {
    assert_eq!(
        ::std::mem::size_of::<user_desc>(),
        16usize,
        concat!("Size of: ", stringify!(user_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<user_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(user_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_desc>())).entry_number as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(user_desc),
            "::",
            stringify!(entry_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_desc>())).base_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(user_desc),
            "::",
            stringify!(base_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_desc>())).limit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(user_desc),
            "::",
            stringify!(limit)
        )
    );
}
impl user_desc {
    #[inline]
    pub fn seg_32bit(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_seg_32bit(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn contents(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_contents(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn read_exec_only(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read_exec_only(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit_in_pages(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_limit_in_pages(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn seg_not_present(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_seg_not_present(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn useable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lm(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lm(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        seg_32bit: ::std::os::raw::c_uint,
        contents: ::std::os::raw::c_uint,
        read_exec_only: ::std::os::raw::c_uint,
        limit_in_pages: ::std::os::raw::c_uint,
        seg_not_present: ::std::os::raw::c_uint,
        useable: ::std::os::raw::c_uint,
        lm: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let seg_32bit: u32 = unsafe { ::std::mem::transmute(seg_32bit) };
            seg_32bit as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let contents: u32 = unsafe { ::std::mem::transmute(contents) };
            contents as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let read_exec_only: u32 = unsafe { ::std::mem::transmute(read_exec_only) };
            read_exec_only as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let limit_in_pages: u32 = unsafe { ::std::mem::transmute(limit_in_pages) };
            limit_in_pages as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let seg_not_present: u32 = unsafe { ::std::mem::transmute(seg_not_present) };
            seg_not_present as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let useable: u32 = unsafe { ::std::mem::transmute(useable) };
            useable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let lm: u32 = unsafe { ::std::mem::transmute(lm) };
            lm as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn syscall_init();
}
extern "C" {
    pub fn entry_SYSCALL_64();
}
extern "C" {
    pub fn entry_SYSCALL_64_safe_stack();
}
extern "C" {
    pub fn entry_SYSRETQ_unsafe_stack();
}
extern "C" {
    pub fn entry_SYSRETQ_end();
}
extern "C" {
    pub fn do_arch_prctl_64(
        task: *mut task_struct,
        option: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn entry_SYSENTER_compat();
}
extern "C" {
    pub fn __end_entry_SYSENTER_compat();
}
extern "C" {
    pub fn entry_SYSCALL_compat();
}
extern "C" {
    pub fn entry_SYSCALL_compat_safe_stack();
}
extern "C" {
    pub fn entry_SYSRETL_compat_unsafe_stack();
}
extern "C" {
    pub fn entry_SYSRETL_compat_end();
}
extern "C" {
    pub fn entry_INT80_compat();
}
extern "C" {
    pub fn x86_configure_nx();
}
extern "C" {
    pub static mut reboot_force: ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_arch_prctl_common(
        option: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn profile_pc(regs: *mut pt_regs) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn convert_ip_to_linear(
        child: *mut task_struct,
        regs: *mut pt_regs,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn send_sigtrap(
        regs: *mut pt_regs,
        error_code: ::std::os::raw::c_int,
        si_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn regs_query_register_offset(name: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regs_query_register_name(
        offset: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn copy_from_kernel_nofault(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn do_get_thread_area(
        p: *mut task_struct,
        idx: ::std::os::raw::c_int,
        info: *mut user_desc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_set_thread_area(
        p: *mut task_struct,
        idx: ::std::os::raw::c_int,
        info: *mut user_desc,
        can_allocate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct math_emu_info {
    pub ___orig_eip: ::std::os::raw::c_long,
    pub regs: *mut pt_regs,
}
#[test]
fn bindgen_test_layout_math_emu_info() {
    assert_eq!(
        ::std::mem::size_of::<math_emu_info>(),
        16usize,
        concat!("Size of: ", stringify!(math_emu_info))
    );
    assert_eq!(
        ::std::mem::align_of::<math_emu_info>(),
        8usize,
        concat!("Alignment of ", stringify!(math_emu_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<math_emu_info>())).___orig_eip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(math_emu_info),
            "::",
            stringify!(___orig_eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<math_emu_info>())).regs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(math_emu_info),
            "::",
            stringify!(regs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __u32,
    pub extended_size: __u32,
    pub xfeatures: __u64,
    pub xstate_size: __u32,
    pub padding: [__u32; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(
        ::std::mem::size_of::<_fpx_sw_bytes>(),
        48usize,
        concat!("Size of: ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpx_sw_bytes>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).magic1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(magic1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).extended_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(extended_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xfeatures as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).padding as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [__u16; 4usize],
    pub exponent: __u16,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpreg>(),
        10usize,
        concat!("Size of: ", stringify!(_fpreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [__u16; 4usize],
    pub exponent: __u16,
    pub padding: [__u16; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).padding as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__u32; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _fpstate_32 {
    pub cw: __u32,
    pub sw: __u32,
    pub tag: __u32,
    pub ipoff: __u32,
    pub cssel: __u32,
    pub dataoff: __u32,
    pub datasel: __u32,
    pub _st: [_fpreg; 8usize],
    pub status: __u16,
    pub magic: __u16,
    pub _fxsr_env: [__u32; 6usize],
    pub mxcsr: __u32,
    pub reserved: __u32,
    pub _fxsr_st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 8usize],
    pub __bindgen_anon_1: _fpstate_32__bindgen_ty_1,
    pub __bindgen_anon_2: _fpstate_32__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fpstate_32__bindgen_ty_1 {
    pub padding1: [__u32; 44usize],
    pub padding: [__u32; 44usize],
    _bindgen_union_align: [u32; 44usize],
}
#[test]
fn bindgen_test_layout__fpstate_32__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_32__bindgen_ty_1>(),
        176usize,
        concat!("Size of: ", stringify!(_fpstate_32__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_32__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_fpstate_32__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_1>())).padding1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_1),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_1>())).padding as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fpstate_32__bindgen_ty_2 {
    pub padding2: [__u32; 12usize],
    pub sw_reserved: _fpx_sw_bytes,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout__fpstate_32__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_32__bindgen_ty_2>(),
        48usize,
        concat!("Size of: ", stringify!(_fpstate_32__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_32__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate_32__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_2>())).padding2 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_2),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_2>())).sw_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_2),
            "::",
            stringify!(sw_reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__fpstate_32() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_32>(),
        624usize,
        concat!("Size of: ", stringify!(_fpstate_32))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_32>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate_32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).cw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(cw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).sw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(sw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).tag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).ipoff as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(ipoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).cssel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(cssel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).dataoff as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(dataoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).datasel as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(datasel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._st as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).status as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).magic as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._fxsr_env as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_fxsr_env)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).mxcsr as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).reserved as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._fxsr_st as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_fxsr_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._xmm as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_xmm)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _fpstate_64 {
    pub cwd: __u16,
    pub swd: __u16,
    pub twd: __u16,
    pub fop: __u16,
    pub rip: __u64,
    pub rdp: __u64,
    pub mxcsr: __u32,
    pub mxcsr_mask: __u32,
    pub st_space: [__u32; 32usize],
    pub xmm_space: [__u32; 64usize],
    pub reserved2: [__u32; 12usize],
    pub __bindgen_anon_1: _fpstate_64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fpstate_64__bindgen_ty_1 {
    pub reserved3: [__u32; 12usize],
    pub sw_reserved: _fpx_sw_bytes,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout__fpstate_64__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_64__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(_fpstate_64__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_64__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate_64__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_64__bindgen_ty_1>())).reserved3 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64__bindgen_ty_1),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_64__bindgen_ty_1>())).sw_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64__bindgen_ty_1),
            "::",
            stringify!(sw_reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__fpstate_64() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_64>(),
        512usize,
        concat!("Size of: ", stringify!(_fpstate_64))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_64>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate_64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).twd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).mxcsr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(mxcsr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).st_space as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).xmm_space as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(xmm_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).reserved2 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _header {
    pub xfeatures: __u64,
    pub reserved1: [__u64; 2usize],
    pub reserved2: [__u64; 5usize],
}
#[test]
fn bindgen_test_layout__header() {
    assert_eq!(
        ::std::mem::size_of::<_header>(),
        64usize,
        concat!("Size of: ", stringify!(_header))
    );
    assert_eq!(
        ::std::mem::align_of::<_header>(),
        8usize,
        concat!("Alignment of ", stringify!(_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header>())).xfeatures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_header),
            "::",
            stringify!(xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header>())).reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_header),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header>())).reserved2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_header),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__u32; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(
        ::std::mem::size_of::<_ymmh_state>(),
        256usize,
        concat!("Size of: ", stringify!(_ymmh_state))
    );
    assert_eq!(
        ::std::mem::align_of::<_ymmh_state>(),
        4usize,
        concat!("Alignment of ", stringify!(_ymmh_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ymmh_state>())).ymmh_space as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ymmh_state),
            "::",
            stringify!(ymmh_space)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate_64,
    pub xstate_hdr: _header,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(
        ::std::mem::size_of::<_xstate>(),
        832usize,
        concat!("Size of: ", stringify!(_xstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_xstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_xstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).fpstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).xstate_hdr as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(xstate_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).ymmh as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(ymmh)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext_32 {
    pub gs: __u16,
    pub __gsh: __u16,
    pub fs: __u16,
    pub __fsh: __u16,
    pub es: __u16,
    pub __esh: __u16,
    pub ds: __u16,
    pub __dsh: __u16,
    pub di: __u32,
    pub si: __u32,
    pub bp: __u32,
    pub sp: __u32,
    pub bx: __u32,
    pub dx: __u32,
    pub cx: __u32,
    pub ax: __u32,
    pub trapno: __u32,
    pub err: __u32,
    pub ip: __u32,
    pub cs: __u16,
    pub __csh: __u16,
    pub flags: __u32,
    pub sp_at_signal: __u32,
    pub ss: __u16,
    pub __ssh: __u16,
    pub fpstate: __u32,
    pub oldmask: __u32,
    pub cr2: __u32,
}
#[test]
fn bindgen_test_layout_sigcontext_32() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext_32>(),
        88usize,
        concat!("Size of: ", stringify!(sigcontext_32))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext_32>(),
        4usize,
        concat!("Alignment of ", stringify!(sigcontext_32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).gs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__gsh as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__gsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).fs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__fsh as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__fsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).es as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__esh as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__esh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ds as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__dsh as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__dsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).di as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(di)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).si as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(si)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).bp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).sp as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).bx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).dx as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).cx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ax as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).trapno as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).err as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ip as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).cs as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__csh as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__csh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).sp_at_signal as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(sp_at_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ss as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__ssh as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__ssh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).fpstate as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).oldmask as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).cr2 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(cr2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext_64 {
    pub r8: __u64,
    pub r9: __u64,
    pub r10: __u64,
    pub r11: __u64,
    pub r12: __u64,
    pub r13: __u64,
    pub r14: __u64,
    pub r15: __u64,
    pub di: __u64,
    pub si: __u64,
    pub bp: __u64,
    pub bx: __u64,
    pub dx: __u64,
    pub ax: __u64,
    pub cx: __u64,
    pub sp: __u64,
    pub ip: __u64,
    pub flags: __u64,
    pub cs: __u16,
    pub gs: __u16,
    pub fs: __u16,
    pub ss: __u16,
    pub err: __u64,
    pub trapno: __u64,
    pub oldmask: __u64,
    pub cr2: __u64,
    pub fpstate: __u64,
    pub reserved1: [__u64; 8usize],
}
#[test]
fn bindgen_test_layout_sigcontext_64() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext_64>(),
        256usize,
        concat!("Size of: ", stringify!(sigcontext_64))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext_64>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext_64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r9 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r10 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r11 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r12 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r13 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r14 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r15 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).di as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(di)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).si as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(si)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).bp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).bx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).dx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).ax as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).cx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).sp as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).ip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).cs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).gs as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).fs as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).ss as *const _ as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).err as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).trapno as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).oldmask as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).cr2 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).fpstate as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(reserved1)
        )
    );
}
extern "C" {
    pub static mut cpu_callin_mask: cpumask_var_t;
}
extern "C" {
    pub static mut cpu_callout_mask: cpumask_var_t;
}
extern "C" {
    pub static mut cpu_initialized_mask: cpumask_var_t;
}
extern "C" {
    pub static mut cpu_sibling_setup_mask: cpumask_var_t;
}
extern "C" {
    pub fn setup_cpu_local_masks();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msr {
    pub __bindgen_anon_1: msr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msr__bindgen_ty_1 {
    pub __bindgen_anon_1: msr__bindgen_ty_1__bindgen_ty_1,
    pub q: u64_,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msr__bindgen_ty_1__bindgen_ty_1 {
    pub l: u32_,
    pub h: u32_,
}
#[test]
fn bindgen_test_layout_msr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<msr__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(msr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<msr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(msr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<msr__bindgen_ty_1__bindgen_ty_1>())).l as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<msr__bindgen_ty_1__bindgen_ty_1>())).h as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(msr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(h)
        )
    );
}
#[test]
fn bindgen_test_layout_msr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<msr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(msr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<msr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(msr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr__bindgen_ty_1>())).q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msr__bindgen_ty_1),
            "::",
            stringify!(q)
        )
    );
}
#[test]
fn bindgen_test_layout_msr() {
    assert_eq!(
        ::std::mem::size_of::<msr>(),
        8usize,
        concat!("Size of: ", stringify!(msr))
    );
    assert_eq!(
        ::std::mem::align_of::<msr>(),
        8usize,
        concat!("Alignment of ", stringify!(msr))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msr_info {
    pub msr_no: u32_,
    pub reg: msr,
    pub msrs: *mut msr,
    pub err: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msr_info() {
    assert_eq!(
        ::std::mem::size_of::<msr_info>(),
        32usize,
        concat!("Size of: ", stringify!(msr_info))
    );
    assert_eq!(
        ::std::mem::align_of::<msr_info>(),
        8usize,
        concat!("Alignment of ", stringify!(msr_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_info>())).msr_no as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_info),
            "::",
            stringify!(msr_no)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_info>())).reg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_info),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_info>())).msrs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_info),
            "::",
            stringify!(msrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_info>())).err as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_info),
            "::",
            stringify!(err)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msr_regs_info {
    pub regs: *mut u32_,
    pub err: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msr_regs_info() {
    assert_eq!(
        ::std::mem::size_of::<msr_regs_info>(),
        16usize,
        concat!("Size of: ", stringify!(msr_regs_info))
    );
    assert_eq!(
        ::std::mem::align_of::<msr_regs_info>(),
        8usize,
        concat!("Alignment of ", stringify!(msr_regs_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_regs_info>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_regs_info),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_regs_info>())).err as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_regs_info),
            "::",
            stringify!(err)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct saved_msr {
    pub valid: bool_,
    pub info: msr_info,
}
#[test]
fn bindgen_test_layout_saved_msr() {
    assert_eq!(
        ::std::mem::size_of::<saved_msr>(),
        40usize,
        concat!("Size of: ", stringify!(saved_msr))
    );
    assert_eq!(
        ::std::mem::align_of::<saved_msr>(),
        8usize,
        concat!("Alignment of ", stringify!(saved_msr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<saved_msr>())).valid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(saved_msr),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<saved_msr>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(saved_msr),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saved_msrs {
    pub num: ::std::os::raw::c_uint,
    pub array: *mut saved_msr,
}
#[test]
fn bindgen_test_layout_saved_msrs() {
    assert_eq!(
        ::std::mem::size_of::<saved_msrs>(),
        16usize,
        concat!("Size of: ", stringify!(saved_msrs))
    );
    assert_eq!(
        ::std::mem::align_of::<saved_msrs>(),
        8usize,
        concat!("Alignment of ", stringify!(saved_msrs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<saved_msrs>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(saved_msrs),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<saved_msrs>())).array as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(saved_msrs),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_print_flags {
    pub mask: ::std::os::raw::c_ulong,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_trace_print_flags() {
    assert_eq!(
        ::std::mem::size_of::<trace_print_flags>(),
        16usize,
        concat!("Size of: ", stringify!(trace_print_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<trace_print_flags>(),
        8usize,
        concat!("Alignment of ", stringify!(trace_print_flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trace_print_flags>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(trace_print_flags),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trace_print_flags>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(trace_print_flags),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_print_flags_u64 {
    pub mask: ::std::os::raw::c_ulonglong,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_trace_print_flags_u64() {
    assert_eq!(
        ::std::mem::size_of::<trace_print_flags_u64>(),
        16usize,
        concat!("Size of: ", stringify!(trace_print_flags_u64))
    );
    assert_eq!(
        ::std::mem::align_of::<trace_print_flags_u64>(),
        8usize,
        concat!("Alignment of ", stringify!(trace_print_flags_u64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trace_print_flags_u64>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(trace_print_flags_u64),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trace_print_flags_u64>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(trace_print_flags_u64),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tracepoint_func {
    pub func: *mut ::std::os::raw::c_void,
    pub data: *mut ::std::os::raw::c_void,
    pub prio: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tracepoint_func() {
    assert_eq!(
        ::std::mem::size_of::<tracepoint_func>(),
        24usize,
        concat!("Size of: ", stringify!(tracepoint_func))
    );
    assert_eq!(
        ::std::mem::align_of::<tracepoint_func>(),
        8usize,
        concat!("Alignment of ", stringify!(tracepoint_func))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint_func>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint_func),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint_func>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint_func),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint_func>())).prio as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint_func),
            "::",
            stringify!(prio)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint {
    pub name: *const ::std::os::raw::c_char,
    pub key: static_key,
    pub static_call_key: *mut static_call_key,
    pub static_call_tramp: *mut ::std::os::raw::c_void,
    pub iterator: *mut ::std::os::raw::c_void,
    pub regfunc: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub unregfunc: ::std::option::Option<unsafe extern "C" fn()>,
    pub funcs: *mut tracepoint_func,
}
#[test]
fn bindgen_test_layout_tracepoint() {
    assert_eq!(
        ::std::mem::size_of::<tracepoint>(),
        72usize,
        concat!("Size of: ", stringify!(tracepoint))
    );
    assert_eq!(
        ::std::mem::align_of::<tracepoint>(),
        8usize,
        concat!("Alignment of ", stringify!(tracepoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).static_call_key as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(static_call_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).static_call_tramp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(static_call_tramp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).iterator as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(iterator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).regfunc as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(regfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).unregfunc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(unregfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).funcs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(funcs)
        )
    );
}
pub type tracepoint_ptr_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct bpf_raw_event_map {
    pub tp: *mut tracepoint,
    pub bpf_func: *mut ::std::os::raw::c_void,
    pub num_args: u32_,
    pub writable_size: u32_,
}
#[test]
fn bindgen_test_layout_bpf_raw_event_map() {
    assert_eq!(
        ::std::mem::size_of::<bpf_raw_event_map>(),
        32usize,
        concat!("Size of: ", stringify!(bpf_raw_event_map))
    );
    assert_eq!(
        ::std::mem::align_of::<bpf_raw_event_map>(),
        32usize,
        concat!("Alignment of ", stringify!(bpf_raw_event_map))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_raw_event_map>())).tp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_raw_event_map),
            "::",
            stringify!(tp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_raw_event_map>())).bpf_func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_raw_event_map),
            "::",
            stringify!(bpf_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_raw_event_map>())).num_args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_raw_event_map),
            "::",
            stringify!(num_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_raw_event_map>())).writable_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_raw_event_map),
            "::",
            stringify!(writable_size)
        )
    );
}
extern "C" {
    pub static mut __tracepoint_read_msr: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_write_msr: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_rdpmc: tracepoint;
}
extern "C" {
    pub fn do_trace_write_msr(
        msr: ::std::os::raw::c_uint,
        val: u64_,
        failed: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn do_trace_read_msr(msr: ::std::os::raw::c_uint, val: u64_, failed: ::std::os::raw::c_int);
}
extern "C" {
    pub fn do_trace_rdpmc(msr: ::std::os::raw::c_uint, val: u64_, failed: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rdmsr_safe_regs(regs: *mut u32_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe_regs(regs: *mut u32_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msrs_alloc() -> *mut msr;
}
extern "C" {
    pub fn msrs_free(msrs: *mut msr);
}
extern "C" {
    pub fn msr_set_bit(msr: u32_, bit: u8_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msr_clear_bit(msr: u32_, bit: u8_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsr_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        l: *mut u32_,
        h: *mut u32_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        l: u32_,
        h: u32_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsrl_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        q: *mut u64_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsrl_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        q: u64_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsr_on_cpus(mask: *const cpumask, msr_no: u32_, msrs: *mut msr);
}
extern "C" {
    pub fn wrmsr_on_cpus(mask: *const cpumask, msr_no: u32_, msrs: *mut msr);
}
extern "C" {
    pub fn rdmsr_safe_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        l: *mut u32_,
        h: *mut u32_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        l: u32_,
        h: u32_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsrl_safe_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        q: *mut u64_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsrl_safe_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        q: u64_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsr_safe_regs_on_cpu(
        cpu: ::std::os::raw::c_uint,
        regs: *mut u32_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe_regs_on_cpu(
        cpu: ::std::os::raw::c_uint,
        regs: *mut u32_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_write_cr0(val: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn native_write_cr4(val: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn asm_load_gs_index(selector: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fregs_state {
    pub cwd: u32_,
    pub swd: u32_,
    pub twd: u32_,
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
    pub st_space: [u32_; 20usize],
    pub status: u32_,
}
#[test]
fn bindgen_test_layout_fregs_state() {
    assert_eq!(
        ::std::mem::size_of::<fregs_state>(),
        112usize,
        concat!("Size of: ", stringify!(fregs_state))
    );
    assert_eq!(
        ::std::mem::align_of::<fregs_state>(),
        4usize,
        concat!("Alignment of ", stringify!(fregs_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).swd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).twd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).fip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).fcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).foo as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).fos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).st_space as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).status as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct fxregs_state {
    pub cwd: u16_,
    pub swd: u16_,
    pub twd: u16_,
    pub fop: u16_,
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1,
    pub mxcsr: u32_,
    pub mxcsr_mask: u32_,
    pub st_space: [u32_; 32usize],
    pub xmm_space: [u32_; 64usize],
    pub padding: [u32_; 12usize],
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_1 {
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_1 {
    pub rip: u64_,
    pub rdp: u64_,
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_1>())).rip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_1>())).rdp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rdp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_2 {
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fcs as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).foo as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fos as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fos)
        )
    );
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<fxregs_state__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(fxregs_state__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<fxregs_state__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(fxregs_state__bindgen_ty_1))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_2 {
    pub padding1: [u32_; 12usize],
    pub sw_reserved: [u32_; 12usize],
    _bindgen_union_align: [u32; 12usize],
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<fxregs_state__bindgen_ty_2>(),
        48usize,
        concat!("Size of: ", stringify!(fxregs_state__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<fxregs_state__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(fxregs_state__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_2>())).padding1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_2),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_2>())).sw_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_2),
            "::",
            stringify!(sw_reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_fxregs_state() {
    assert_eq!(
        ::std::mem::size_of::<fxregs_state>(),
        512usize,
        concat!("Size of: ", stringify!(fxregs_state))
    );
    assert_eq!(
        ::std::mem::align_of::<fxregs_state>(),
        16usize,
        concat!("Alignment of ", stringify!(fxregs_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).twd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).mxcsr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(mxcsr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).st_space as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).xmm_space as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(xmm_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).padding as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swregs_state {
    pub cwd: u32_,
    pub swd: u32_,
    pub twd: u32_,
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
    pub st_space: [u32_; 20usize],
    pub ftop: u8_,
    pub changed: u8_,
    pub lookahead: u8_,
    pub no_update: u8_,
    pub rm: u8_,
    pub alimit: u8_,
    pub info: *mut math_emu_info,
    pub entry_eip: u32_,
}
#[test]
fn bindgen_test_layout_swregs_state() {
    assert_eq!(
        ::std::mem::size_of::<swregs_state>(),
        136usize,
        concat!("Size of: ", stringify!(swregs_state))
    );
    assert_eq!(
        ::std::mem::align_of::<swregs_state>(),
        8usize,
        concat!("Alignment of ", stringify!(swregs_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).swd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).twd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).fip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).fcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).foo as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).fos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).st_space as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).ftop as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(ftop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).changed as *const _ as usize },
        109usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).lookahead as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(lookahead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).no_update as *const _ as usize },
        111usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(no_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).rm as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(rm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).alimit as *const _ as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(alimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).info as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).entry_eip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(entry_eip)
        )
    );
}
pub const xfeature_XFEATURE_FP: xfeature = 0;
pub const xfeature_XFEATURE_SSE: xfeature = 1;
pub const xfeature_XFEATURE_YMM: xfeature = 2;
pub const xfeature_XFEATURE_BNDREGS: xfeature = 3;
pub const xfeature_XFEATURE_BNDCSR: xfeature = 4;
pub const xfeature_XFEATURE_OPMASK: xfeature = 5;
pub const xfeature_XFEATURE_ZMM_Hi256: xfeature = 6;
pub const xfeature_XFEATURE_Hi16_ZMM: xfeature = 7;
pub const xfeature_XFEATURE_PT_UNIMPLEMENTED_SO_FAR: xfeature = 8;
pub const xfeature_XFEATURE_PKRU: xfeature = 9;
pub const xfeature_XFEATURE_PASID: xfeature = 10;
pub const xfeature_XFEATURE_RSRVD_COMP_11: xfeature = 11;
pub const xfeature_XFEATURE_RSRVD_COMP_12: xfeature = 12;
pub const xfeature_XFEATURE_RSRVD_COMP_13: xfeature = 13;
pub const xfeature_XFEATURE_RSRVD_COMP_14: xfeature = 14;
pub const xfeature_XFEATURE_LBR: xfeature = 15;
pub const xfeature_XFEATURE_RSRVD_COMP_16: xfeature = 16;
pub const xfeature_XFEATURE_XTILE_CFG: xfeature = 17;
pub const xfeature_XFEATURE_XTILE_DATA: xfeature = 18;
pub const xfeature_XFEATURE_MAX: xfeature = 19;
pub type xfeature = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reg_128_bit {
    pub regbytes: [u8_; 16usize],
}
#[test]
fn bindgen_test_layout_reg_128_bit() {
    assert_eq!(
        ::std::mem::size_of::<reg_128_bit>(),
        16usize,
        concat!("Size of: ", stringify!(reg_128_bit))
    );
    assert_eq!(
        ::std::mem::align_of::<reg_128_bit>(),
        1usize,
        concat!("Alignment of ", stringify!(reg_128_bit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reg_128_bit>())).regbytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_128_bit),
            "::",
            stringify!(regbytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reg_256_bit {
    pub regbytes: [u8_; 32usize],
}
#[test]
fn bindgen_test_layout_reg_256_bit() {
    assert_eq!(
        ::std::mem::size_of::<reg_256_bit>(),
        32usize,
        concat!("Size of: ", stringify!(reg_256_bit))
    );
    assert_eq!(
        ::std::mem::align_of::<reg_256_bit>(),
        1usize,
        concat!("Alignment of ", stringify!(reg_256_bit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reg_256_bit>())).regbytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_256_bit),
            "::",
            stringify!(regbytes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct reg_512_bit {
    pub regbytes: [u8_; 64usize],
}
#[test]
fn bindgen_test_layout_reg_512_bit() {
    assert_eq!(
        ::std::mem::size_of::<reg_512_bit>(),
        64usize,
        concat!("Size of: ", stringify!(reg_512_bit))
    );
    assert_eq!(
        ::std::mem::align_of::<reg_512_bit>(),
        1usize,
        concat!("Alignment of ", stringify!(reg_512_bit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reg_512_bit>())).regbytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_512_bit),
            "::",
            stringify!(regbytes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct reg_1024_byte {
    pub regbytes: [u8_; 1024usize],
}
#[test]
fn bindgen_test_layout_reg_1024_byte() {
    assert_eq!(
        ::std::mem::size_of::<reg_1024_byte>(),
        1024usize,
        concat!("Size of: ", stringify!(reg_1024_byte))
    );
    assert_eq!(
        ::std::mem::align_of::<reg_1024_byte>(),
        1usize,
        concat!("Alignment of ", stringify!(reg_1024_byte))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reg_1024_byte>())).regbytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_1024_byte),
            "::",
            stringify!(regbytes)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ymmh_struct {
    pub hi_ymm: [reg_128_bit; 16usize],
}
#[test]
fn bindgen_test_layout_ymmh_struct() {
    assert_eq!(
        ::std::mem::size_of::<ymmh_struct>(),
        256usize,
        concat!("Size of: ", stringify!(ymmh_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<ymmh_struct>(),
        1usize,
        concat!("Alignment of ", stringify!(ymmh_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ymmh_struct>())).hi_ymm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ymmh_struct),
            "::",
            stringify!(hi_ymm)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct mpx_bndreg {
    pub lower_bound: u64_,
    pub upper_bound: u64_,
}
#[test]
fn bindgen_test_layout_mpx_bndreg() {
    assert_eq!(
        ::std::mem::size_of::<mpx_bndreg>(),
        16usize,
        concat!("Size of: ", stringify!(mpx_bndreg))
    );
    assert_eq!(
        ::std::mem::align_of::<mpx_bndreg>(),
        1usize,
        concat!("Alignment of ", stringify!(mpx_bndreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpx_bndreg>())).lower_bound as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndreg),
            "::",
            stringify!(lower_bound)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpx_bndreg>())).upper_bound as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndreg),
            "::",
            stringify!(upper_bound)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct mpx_bndreg_state {
    pub bndreg: [mpx_bndreg; 4usize],
}
#[test]
fn bindgen_test_layout_mpx_bndreg_state() {
    assert_eq!(
        ::std::mem::size_of::<mpx_bndreg_state>(),
        64usize,
        concat!("Size of: ", stringify!(mpx_bndreg_state))
    );
    assert_eq!(
        ::std::mem::align_of::<mpx_bndreg_state>(),
        1usize,
        concat!("Alignment of ", stringify!(mpx_bndreg_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpx_bndreg_state>())).bndreg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndreg_state),
            "::",
            stringify!(bndreg)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct mpx_bndcsr {
    pub bndcfgu: u64_,
    pub bndstatus: u64_,
}
#[test]
fn bindgen_test_layout_mpx_bndcsr() {
    assert_eq!(
        ::std::mem::size_of::<mpx_bndcsr>(),
        16usize,
        concat!("Size of: ", stringify!(mpx_bndcsr))
    );
    assert_eq!(
        ::std::mem::align_of::<mpx_bndcsr>(),
        1usize,
        concat!("Alignment of ", stringify!(mpx_bndcsr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpx_bndcsr>())).bndcfgu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndcsr),
            "::",
            stringify!(bndcfgu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpx_bndcsr>())).bndstatus as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndcsr),
            "::",
            stringify!(bndstatus)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mpx_bndcsr_state {
    pub __bindgen_anon_1: mpx_bndcsr_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mpx_bndcsr_state__bindgen_ty_1 {
    pub bndcsr: mpx_bndcsr,
    pub pad_to_64_bytes: [u8_; 64usize],
    _bindgen_union_align: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_mpx_bndcsr_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mpx_bndcsr_state__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(mpx_bndcsr_state__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mpx_bndcsr_state__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(mpx_bndcsr_state__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpx_bndcsr_state__bindgen_ty_1>())).bndcsr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndcsr_state__bindgen_ty_1),
            "::",
            stringify!(bndcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpx_bndcsr_state__bindgen_ty_1>())).pad_to_64_bytes as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndcsr_state__bindgen_ty_1),
            "::",
            stringify!(pad_to_64_bytes)
        )
    );
}
#[test]
fn bindgen_test_layout_mpx_bndcsr_state() {
    assert_eq!(
        ::std::mem::size_of::<mpx_bndcsr_state>(),
        64usize,
        concat!("Size of: ", stringify!(mpx_bndcsr_state))
    );
    assert_eq!(
        ::std::mem::align_of::<mpx_bndcsr_state>(),
        1usize,
        concat!("Alignment of ", stringify!(mpx_bndcsr_state))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct avx_512_opmask_state {
    pub opmask_reg: [u64_; 8usize],
}
#[test]
fn bindgen_test_layout_avx_512_opmask_state() {
    assert_eq!(
        ::std::mem::size_of::<avx_512_opmask_state>(),
        64usize,
        concat!("Size of: ", stringify!(avx_512_opmask_state))
    );
    assert_eq!(
        ::std::mem::align_of::<avx_512_opmask_state>(),
        1usize,
        concat!("Alignment of ", stringify!(avx_512_opmask_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avx_512_opmask_state>())).opmask_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avx_512_opmask_state),
            "::",
            stringify!(opmask_reg)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct avx_512_zmm_uppers_state {
    pub zmm_upper: [reg_256_bit; 16usize],
}
#[test]
fn bindgen_test_layout_avx_512_zmm_uppers_state() {
    assert_eq!(
        ::std::mem::size_of::<avx_512_zmm_uppers_state>(),
        512usize,
        concat!("Size of: ", stringify!(avx_512_zmm_uppers_state))
    );
    assert_eq!(
        ::std::mem::align_of::<avx_512_zmm_uppers_state>(),
        1usize,
        concat!("Alignment of ", stringify!(avx_512_zmm_uppers_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<avx_512_zmm_uppers_state>())).zmm_upper as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avx_512_zmm_uppers_state),
            "::",
            stringify!(zmm_upper)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct avx_512_hi16_state {
    pub hi16_zmm: [reg_512_bit; 16usize],
}
#[test]
fn bindgen_test_layout_avx_512_hi16_state() {
    assert_eq!(
        ::std::mem::size_of::<avx_512_hi16_state>(),
        1024usize,
        concat!("Size of: ", stringify!(avx_512_hi16_state))
    );
    assert_eq!(
        ::std::mem::align_of::<avx_512_hi16_state>(),
        1usize,
        concat!("Alignment of ", stringify!(avx_512_hi16_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avx_512_hi16_state>())).hi16_zmm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avx_512_hi16_state),
            "::",
            stringify!(hi16_zmm)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pkru_state {
    pub pkru: u32_,
    pub pad: u32_,
}
#[test]
fn bindgen_test_layout_pkru_state() {
    assert_eq!(
        ::std::mem::size_of::<pkru_state>(),
        8usize,
        concat!("Size of: ", stringify!(pkru_state))
    );
    assert_eq!(
        ::std::mem::align_of::<pkru_state>(),
        1usize,
        concat!("Alignment of ", stringify!(pkru_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkru_state>())).pkru as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkru_state),
            "::",
            stringify!(pkru)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkru_state>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pkru_state),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lbr_entry {
    pub from: u64_,
    pub to: u64_,
    pub info: u64_,
}
#[test]
fn bindgen_test_layout_lbr_entry() {
    assert_eq!(
        ::std::mem::size_of::<lbr_entry>(),
        24usize,
        concat!("Size of: ", stringify!(lbr_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<lbr_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(lbr_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lbr_entry>())).from as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lbr_entry),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lbr_entry>())).to as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lbr_entry),
            "::",
            stringify!(to)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lbr_entry>())).info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lbr_entry),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct arch_lbr_state {
    pub lbr_ctl: u64_,
    pub lbr_depth: u64_,
    pub ler_from: u64_,
    pub ler_to: u64_,
    pub ler_info: u64_,
    pub entries: __IncompleteArrayField<lbr_entry>,
}
#[test]
fn bindgen_test_layout_arch_lbr_state() {
    assert_eq!(
        ::std::mem::size_of::<arch_lbr_state>(),
        40usize,
        concat!("Size of: ", stringify!(arch_lbr_state))
    );
    assert_eq!(
        ::std::mem::align_of::<arch_lbr_state>(),
        8usize,
        concat!("Alignment of ", stringify!(arch_lbr_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_lbr_state>())).lbr_ctl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_lbr_state),
            "::",
            stringify!(lbr_ctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_lbr_state>())).lbr_depth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_lbr_state),
            "::",
            stringify!(lbr_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_lbr_state>())).ler_from as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_lbr_state),
            "::",
            stringify!(ler_from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_lbr_state>())).ler_to as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_lbr_state),
            "::",
            stringify!(ler_to)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_lbr_state>())).ler_info as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_lbr_state),
            "::",
            stringify!(ler_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_lbr_state>())).entries as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_lbr_state),
            "::",
            stringify!(entries)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct xtile_cfg {
    pub tcfg: [u64_; 8usize],
}
#[test]
fn bindgen_test_layout_xtile_cfg() {
    assert_eq!(
        ::std::mem::size_of::<xtile_cfg>(),
        64usize,
        concat!("Size of: ", stringify!(xtile_cfg))
    );
    assert_eq!(
        ::std::mem::align_of::<xtile_cfg>(),
        1usize,
        concat!("Alignment of ", stringify!(xtile_cfg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xtile_cfg>())).tcfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtile_cfg),
            "::",
            stringify!(tcfg)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct xtile_data {
    pub tmm: reg_1024_byte,
}
#[test]
fn bindgen_test_layout_xtile_data() {
    assert_eq!(
        ::std::mem::size_of::<xtile_data>(),
        1024usize,
        concat!("Size of: ", stringify!(xtile_data))
    );
    assert_eq!(
        ::std::mem::align_of::<xtile_data>(),
        1usize,
        concat!("Alignment of ", stringify!(xtile_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xtile_data>())).tmm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtile_data),
            "::",
            stringify!(tmm)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ia32_pasid_state {
    pub pasid: u64_,
}
#[test]
fn bindgen_test_layout_ia32_pasid_state() {
    assert_eq!(
        ::std::mem::size_of::<ia32_pasid_state>(),
        8usize,
        concat!("Size of: ", stringify!(ia32_pasid_state))
    );
    assert_eq!(
        ::std::mem::align_of::<ia32_pasid_state>(),
        1usize,
        concat!("Alignment of ", stringify!(ia32_pasid_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ia32_pasid_state>())).pasid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ia32_pasid_state),
            "::",
            stringify!(pasid)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct xstate_header {
    pub xfeatures: u64_,
    pub xcomp_bv: u64_,
    pub reserved: [u64_; 6usize],
}
#[test]
fn bindgen_test_layout_xstate_header() {
    assert_eq!(
        ::std::mem::size_of::<xstate_header>(),
        64usize,
        concat!("Size of: ", stringify!(xstate_header))
    );
    assert_eq!(
        ::std::mem::align_of::<xstate_header>(),
        1usize,
        concat!("Alignment of ", stringify!(xstate_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xstate_header>())).xfeatures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xstate_header),
            "::",
            stringify!(xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xstate_header>())).xcomp_bv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xstate_header),
            "::",
            stringify!(xcomp_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xstate_header>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xstate_header),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed(64))]
#[repr(align(64))]
pub struct xregs_state {
    pub i387: fxregs_state,
    pub header: xstate_header,
    pub extended_state_area: __IncompleteArrayField<u8_>,
}
#[test]
fn bindgen_test_layout_xregs_state() {
    assert_eq!(
        ::std::mem::size_of::<xregs_state>(),
        576usize,
        concat!("Size of: ", stringify!(xregs_state))
    );
    assert_eq!(
        ::std::mem::align_of::<xregs_state>(),
        64usize,
        concat!("Alignment of ", stringify!(xregs_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xregs_state>())).i387 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xregs_state),
            "::",
            stringify!(i387)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xregs_state>())).header as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(xregs_state),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xregs_state>())).extended_state_area as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(xregs_state),
            "::",
            stringify!(extended_state_area)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
pub struct fpregs_state {
    pub fsave: __BindgenUnionField<fregs_state>,
    pub fxsave: __BindgenUnionField<fxregs_state>,
    pub soft: __BindgenUnionField<swregs_state>,
    pub xsave: __BindgenUnionField<xregs_state>,
    pub __padding: __BindgenUnionField<[u8_; 4096usize]>,
    pub bindgen_union_field: [u8; 4096usize],
}
#[test]
fn bindgen_test_layout_fpregs_state() {
    assert_eq!(
        ::std::mem::size_of::<fpregs_state>(),
        4096usize,
        concat!("Size of: ", stringify!(fpregs_state))
    );
    assert_eq!(
        ::std::mem::align_of::<fpregs_state>(),
        64usize,
        concat!("Alignment of ", stringify!(fpregs_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs_state>())).fsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(fsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs_state>())).fxsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(fxsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs_state>())).soft as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(soft)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs_state>())).xsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(xsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs_state>())).__padding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(__padding)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
pub struct fpstate {
    pub size: ::std::os::raw::c_uint,
    pub user_size: ::std::os::raw::c_uint,
    pub xfeatures: u64_,
    pub user_xfeatures: u64_,
    pub xfd: u64_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u64; 3usize],
    pub regs: fpregs_state,
}
#[test]
fn bindgen_test_layout_fpstate() {
    assert_eq!(
        ::std::mem::size_of::<fpstate>(),
        4160usize,
        concat!("Size of: ", stringify!(fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<fpstate>(),
        64usize,
        concat!("Alignment of ", stringify!(fpstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpstate>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpstate),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpstate>())).user_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fpstate),
            "::",
            stringify!(user_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpstate>())).xfeatures as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpstate),
            "::",
            stringify!(xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpstate>())).user_xfeatures as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpstate),
            "::",
            stringify!(user_xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpstate>())).xfd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fpstate),
            "::",
            stringify!(xfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpstate>())).regs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fpstate),
            "::",
            stringify!(regs)
        )
    );
}
impl fpstate {
    #[inline]
    pub fn is_valloc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_valloc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_guest(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_guest(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_confidential(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_confidential(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_use(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_use(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_valloc: ::std::os::raw::c_uint,
        is_guest: ::std::os::raw::c_uint,
        is_confidential: ::std::os::raw::c_uint,
        in_use: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_valloc: u32 = unsafe { ::std::mem::transmute(is_valloc) };
            is_valloc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_guest: u32 = unsafe { ::std::mem::transmute(is_guest) };
            is_guest as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_confidential: u32 = unsafe { ::std::mem::transmute(is_confidential) };
            is_confidential as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let in_use: u32 = unsafe { ::std::mem::transmute(in_use) };
            in_use as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpu_state_perm {
    pub __state_perm: u64_,
    pub __state_size: ::std::os::raw::c_uint,
    pub __user_state_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_fpu_state_perm() {
    assert_eq!(
        ::std::mem::size_of::<fpu_state_perm>(),
        16usize,
        concat!("Size of: ", stringify!(fpu_state_perm))
    );
    assert_eq!(
        ::std::mem::align_of::<fpu_state_perm>(),
        8usize,
        concat!("Alignment of ", stringify!(fpu_state_perm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_state_perm>())).__state_perm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_perm),
            "::",
            stringify!(__state_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_state_perm>())).__state_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_perm),
            "::",
            stringify!(__state_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fpu_state_perm>())).__user_state_size as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_perm),
            "::",
            stringify!(__user_state_size)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
pub struct fpu {
    pub last_cpu: ::std::os::raw::c_uint,
    pub avx512_timestamp: ::std::os::raw::c_ulong,
    pub fpstate: *mut fpstate,
    pub __task_fpstate: *mut fpstate,
    pub perm: fpu_state_perm,
    pub guest_perm: fpu_state_perm,
    pub __fpstate: fpstate,
}
#[test]
fn bindgen_test_layout_fpu() {
    assert_eq!(
        ::std::mem::size_of::<fpu>(),
        4224usize,
        concat!("Size of: ", stringify!(fpu))
    );
    assert_eq!(
        ::std::mem::align_of::<fpu>(),
        64usize,
        concat!("Alignment of ", stringify!(fpu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).last_cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(last_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).avx512_timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(avx512_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).fpstate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).__task_fpstate as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(__task_fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).perm as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(fpu), "::", stringify!(perm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).guest_perm as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(guest_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).__fpstate as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(__fpstate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpu_guest {
    pub xfeatures: u64_,
    pub perm: u64_,
    pub xfd_err: u64_,
    pub uabi_size: ::std::os::raw::c_uint,
    pub fpstate: *mut fpstate,
}
#[test]
fn bindgen_test_layout_fpu_guest() {
    assert_eq!(
        ::std::mem::size_of::<fpu_guest>(),
        40usize,
        concat!("Size of: ", stringify!(fpu_guest))
    );
    assert_eq!(
        ::std::mem::align_of::<fpu_guest>(),
        8usize,
        concat!("Alignment of ", stringify!(fpu_guest))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_guest>())).xfeatures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_guest),
            "::",
            stringify!(xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_guest>())).perm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_guest),
            "::",
            stringify!(perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_guest>())).xfd_err as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_guest),
            "::",
            stringify!(xfd_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_guest>())).uabi_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_guest),
            "::",
            stringify!(uabi_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_guest>())).fpstate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_guest),
            "::",
            stringify!(fpstate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpu_state_config {
    pub max_size: ::std::os::raw::c_uint,
    pub default_size: ::std::os::raw::c_uint,
    pub max_features: u64_,
    pub default_features: u64_,
    pub legacy_features: u64_,
}
#[test]
fn bindgen_test_layout_fpu_state_config() {
    assert_eq!(
        ::std::mem::size_of::<fpu_state_config>(),
        32usize,
        concat!("Size of: ", stringify!(fpu_state_config))
    );
    assert_eq!(
        ::std::mem::align_of::<fpu_state_config>(),
        8usize,
        concat!("Alignment of ", stringify!(fpu_state_config))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_state_config>())).max_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_config),
            "::",
            stringify!(max_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_state_config>())).default_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_config),
            "::",
            stringify!(default_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_state_config>())).max_features as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_config),
            "::",
            stringify!(max_features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fpu_state_config>())).default_features as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_config),
            "::",
            stringify!(default_features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fpu_state_config>())).legacy_features as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_config),
            "::",
            stringify!(legacy_features)
        )
    );
}
extern "C" {
    pub static mut fpu_kernel_cfg: fpu_state_config;
}
extern "C" {
    pub static mut fpu_user_cfg: fpu_state_config;
}
pub const UNAME26: ::std::os::raw::c_uint = 131072;
pub const ADDR_NO_RANDOMIZE: ::std::os::raw::c_uint = 262144;
pub const FDPIC_FUNCPTRS: ::std::os::raw::c_uint = 524288;
pub const MMAP_PAGE_ZERO: ::std::os::raw::c_uint = 1048576;
pub const ADDR_COMPAT_LAYOUT: ::std::os::raw::c_uint = 2097152;
pub const READ_IMPLIES_EXEC: ::std::os::raw::c_uint = 4194304;
pub const ADDR_LIMIT_32BIT: ::std::os::raw::c_uint = 8388608;
pub const SHORT_INODE: ::std::os::raw::c_uint = 16777216;
pub const WHOLE_SECONDS: ::std::os::raw::c_uint = 33554432;
pub const STICKY_TIMEOUTS: ::std::os::raw::c_uint = 67108864;
pub const ADDR_LIMIT_3GB: ::std::os::raw::c_uint = 134217728;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const PER_LINUX: ::std::os::raw::c_uint = 0;
pub const PER_LINUX_32BIT: ::std::os::raw::c_uint = 8388608;
pub const PER_LINUX_FDPIC: ::std::os::raw::c_uint = 524288;
pub const PER_SVR4: ::std::os::raw::c_uint = 68157441;
pub const PER_SVR3: ::std::os::raw::c_uint = 83886082;
pub const PER_SCOSVR3: ::std::os::raw::c_uint = 117440515;
pub const PER_OSR5: ::std::os::raw::c_uint = 100663299;
pub const PER_WYSEV386: ::std::os::raw::c_uint = 83886084;
pub const PER_ISCR4: ::std::os::raw::c_uint = 67108869;
pub const PER_BSD: ::std::os::raw::c_uint = 6;
pub const PER_SUNOS: ::std::os::raw::c_uint = 67108870;
pub const PER_XENIX: ::std::os::raw::c_uint = 83886087;
pub const PER_LINUX32: ::std::os::raw::c_uint = 8;
pub const PER_LINUX32_3GB: ::std::os::raw::c_uint = 134217736;
pub const PER_IRIX32: ::std::os::raw::c_uint = 67108873;
pub const PER_IRIXN32: ::std::os::raw::c_uint = 67108874;
pub const PER_IRIX64: ::std::os::raw::c_uint = 67108875;
pub const PER_RISCOS: ::std::os::raw::c_uint = 12;
pub const PER_SOLARIS: ::std::os::raw::c_uint = 67108877;
pub const PER_UW7: ::std::os::raw::c_uint = 68157454;
pub const PER_OSF4: ::std::os::raw::c_uint = 15;
pub const PER_HPUX: ::std::os::raw::c_uint = 16;
pub const PER_MASK: ::std::os::raw::c_uint = 255;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(64))]
pub struct cacheline_padding {
    pub x: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_cacheline_padding() {
    assert_eq!(
        ::std::mem::size_of::<cacheline_padding>(),
        0usize,
        concat!("Size of: ", stringify!(cacheline_padding))
    );
    assert_eq!(
        ::std::mem::align_of::<cacheline_padding>(),
        64usize,
        concat!("Alignment of ", stringify!(cacheline_padding))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cacheline_padding>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cacheline_padding),
            "::",
            stringify!(x)
        )
    );
}
pub const tlb_infos_ENTRIES: tlb_infos = 0;
pub const tlb_infos_NR_INFO: tlb_infos = 1;
pub type tlb_infos = ::std::os::raw::c_uint;
extern "C" {
    pub static mut tlb_lli_4k: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lli_2m: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lli_4m: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lld_4k: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lld_2m: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lld_4m: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lld_1g: [u16_; 1usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpuinfo_x86 {
    pub x86: __u8,
    pub x86_vendor: __u8,
    pub x86_model: __u8,
    pub x86_stepping: __u8,
    pub x86_tlbsize: ::std::os::raw::c_int,
    pub vmx_capability: [__u32; 5usize],
    pub x86_virt_bits: __u8,
    pub x86_phys_bits: __u8,
    pub x86_coreid_bits: __u8,
    pub cu_id: __u8,
    pub extended_cpuid_level: __u32,
    pub cpuid_level: ::std::os::raw::c_int,
    pub __bindgen_anon_1: cpuinfo_x86__bindgen_ty_1,
    pub x86_vendor_id: [::std::os::raw::c_char; 16usize],
    pub x86_model_id: [::std::os::raw::c_char; 64usize],
    pub x86_cache_size: ::std::os::raw::c_uint,
    pub x86_cache_alignment: ::std::os::raw::c_int,
    pub x86_cache_max_rmid: ::std::os::raw::c_int,
    pub x86_cache_occ_scale: ::std::os::raw::c_int,
    pub x86_cache_mbm_width_offset: ::std::os::raw::c_int,
    pub x86_power: ::std::os::raw::c_int,
    pub loops_per_jiffy: ::std::os::raw::c_ulong,
    pub ppin: u64_,
    pub x86_max_cores: u16_,
    pub apicid: u16_,
    pub initial_apicid: u16_,
    pub x86_clflush_size: u16_,
    pub booted_cores: u16_,
    pub phys_proc_id: u16_,
    pub logical_proc_id: u16_,
    pub cpu_core_id: u16_,
    pub cpu_die_id: u16_,
    pub logical_die_id: u16_,
    pub cpu_index: u16_,
    pub smt_active: bool_,
    pub microcode: u32_,
    pub x86_cache_bits: u8_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpuinfo_x86__bindgen_ty_1 {
    pub x86_capability: [__u32; 21usize],
    pub x86_capability_alignment: ::std::os::raw::c_ulong,
    _bindgen_union_align: [u64; 11usize],
}
#[test]
fn bindgen_test_layout_cpuinfo_x86__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cpuinfo_x86__bindgen_ty_1>(),
        88usize,
        concat!("Size of: ", stringify!(cpuinfo_x86__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cpuinfo_x86__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cpuinfo_x86__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpuinfo_x86__bindgen_ty_1>())).x86_capability as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86__bindgen_ty_1),
            "::",
            stringify!(x86_capability)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpuinfo_x86__bindgen_ty_1>())).x86_capability_alignment
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86__bindgen_ty_1),
            "::",
            stringify!(x86_capability_alignment)
        )
    );
}
#[test]
fn bindgen_test_layout_cpuinfo_x86() {
    assert_eq!(
        ::std::mem::size_of::<cpuinfo_x86>(),
        280usize,
        concat!("Size of: ", stringify!(cpuinfo_x86))
    );
    assert_eq!(
        ::std::mem::align_of::<cpuinfo_x86>(),
        8usize,
        concat!("Alignment of ", stringify!(cpuinfo_x86))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_vendor as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_vendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_model as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_stepping as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_stepping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_tlbsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_tlbsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).vmx_capability as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(vmx_capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_virt_bits as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_virt_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_phys_bits as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_phys_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_coreid_bits as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_coreid_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).cu_id as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(cu_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpuinfo_x86>())).extended_cpuid_level as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(extended_cpuid_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).cpuid_level as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(cpuid_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_vendor_id as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_model_id as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_model_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_size as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_alignment as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_max_rmid as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_max_rmid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_occ_scale as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_occ_scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_mbm_width_offset as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_mbm_width_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_power as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_power)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).loops_per_jiffy as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(loops_per_jiffy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).ppin as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(ppin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_max_cores as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_max_cores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).apicid as *const _ as usize },
        250usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(apicid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).initial_apicid as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(initial_apicid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_clflush_size as *const _ as usize },
        254usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_clflush_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).booted_cores as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(booted_cores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).phys_proc_id as *const _ as usize },
        258usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(phys_proc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).logical_proc_id as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(logical_proc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).cpu_core_id as *const _ as usize },
        262usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(cpu_core_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).cpu_die_id as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(cpu_die_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).logical_die_id as *const _ as usize },
        266usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(logical_die_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).cpu_index as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(cpu_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).smt_active as *const _ as usize },
        270usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(smt_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).microcode as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(microcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_bits as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_bits)
        )
    );
}
impl cpuinfo_x86 {
    #[inline]
    pub fn initialized(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        initialized: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let initialized: u32 = unsafe { ::std::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpuid_regs {
    pub eax: u32_,
    pub ebx: u32_,
    pub ecx: u32_,
    pub edx: u32_,
}
#[test]
fn bindgen_test_layout_cpuid_regs() {
    assert_eq!(
        ::std::mem::size_of::<cpuid_regs>(),
        16usize,
        concat!("Size of: ", stringify!(cpuid_regs))
    );
    assert_eq!(
        ::std::mem::align_of::<cpuid_regs>(),
        4usize,
        concat!("Alignment of ", stringify!(cpuid_regs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuid_regs>())).eax as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_regs),
            "::",
            stringify!(eax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuid_regs>())).ebx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_regs),
            "::",
            stringify!(ebx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuid_regs>())).ecx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_regs),
            "::",
            stringify!(ecx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuid_regs>())).edx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_regs),
            "::",
            stringify!(edx)
        )
    );
}
pub const cpuid_regs_idx_CPUID_EAX: cpuid_regs_idx = 0;
pub const cpuid_regs_idx_CPUID_EBX: cpuid_regs_idx = 1;
pub const cpuid_regs_idx_CPUID_ECX: cpuid_regs_idx = 2;
pub const cpuid_regs_idx_CPUID_EDX: cpuid_regs_idx = 3;
pub type cpuid_regs_idx = ::std::os::raw::c_uint;
extern "C" {
    pub static mut boot_cpu_data: cpuinfo_x86;
}
extern "C" {
    pub static mut new_cpu_data: cpuinfo_x86;
}
extern "C" {
    pub static mut cpu_caps_cleared: [__u32; 21usize];
}
extern "C" {
    pub static mut cpu_caps_set: [__u32; 21usize];
}
extern "C" {
    pub static mut cpu_info: cpuinfo_x86;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seq_operations {
    _unused: [u8; 0],
}
extern "C" {
    pub static cpuinfo_op: seq_operations;
}
extern "C" {
    pub fn cpu_detect(c: *mut cpuinfo_x86);
}
extern "C" {
    pub fn early_cpu_init();
}
extern "C" {
    pub fn identify_boot_cpu();
}
extern "C" {
    pub fn identify_secondary_cpu(arg1: *mut cpuinfo_x86);
}
extern "C" {
    pub fn print_cpu_info(arg1: *mut cpuinfo_x86);
}
extern "C" {
    pub fn print_cpu_msr(arg1: *mut cpuinfo_x86);
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct x86_hw_tss {
    pub reserved1: u32_,
    pub sp0: u64_,
    pub sp1: u64_,
    pub sp2: u64_,
    pub reserved2: u64_,
    pub ist: [u64_; 7usize],
    pub reserved3: u32_,
    pub reserved4: u32_,
    pub reserved5: u16_,
    pub io_bitmap_base: u16_,
}
#[test]
fn bindgen_test_layout_x86_hw_tss() {
    assert_eq!(
        ::std::mem::size_of::<x86_hw_tss>(),
        104usize,
        concat!("Size of: ", stringify!(x86_hw_tss))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_hw_tss>(),
        1usize,
        concat!("Alignment of ", stringify!(x86_hw_tss))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).reserved1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).sp0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(sp0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).sp1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(sp1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).sp2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(sp2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).reserved2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).ist as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(ist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).reserved3 as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).reserved4 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).reserved5 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).io_bitmap_base as *const _ as usize },
        102usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(io_bitmap_base)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct entry_stack {
    pub stack: [::std::os::raw::c_char; 4096usize],
}
#[test]
fn bindgen_test_layout_entry_stack() {
    assert_eq!(
        ::std::mem::size_of::<entry_stack>(),
        4096usize,
        concat!("Size of: ", stringify!(entry_stack))
    );
    assert_eq!(
        ::std::mem::align_of::<entry_stack>(),
        1usize,
        concat!("Alignment of ", stringify!(entry_stack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<entry_stack>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(entry_stack),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[repr(align(4096))]
#[derive(Copy, Clone)]
pub struct entry_stack_page {
    pub stack: entry_stack,
}
#[test]
fn bindgen_test_layout_entry_stack_page() {
    assert_eq!(
        ::std::mem::size_of::<entry_stack_page>(),
        4096usize,
        concat!("Size of: ", stringify!(entry_stack_page))
    );
    assert_eq!(
        ::std::mem::align_of::<entry_stack_page>(),
        4096usize,
        concat!("Alignment of ", stringify!(entry_stack_page))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<entry_stack_page>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(entry_stack_page),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_io_bitmap {
    pub prev_sequence: u64_,
    pub prev_max: ::std::os::raw::c_uint,
    pub bitmap: [::std::os::raw::c_ulong; 1025usize],
    pub mapall: [::std::os::raw::c_ulong; 1025usize],
}
#[test]
fn bindgen_test_layout_x86_io_bitmap() {
    assert_eq!(
        ::std::mem::size_of::<x86_io_bitmap>(),
        16416usize,
        concat!("Size of: ", stringify!(x86_io_bitmap))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_io_bitmap>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_io_bitmap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_io_bitmap>())).prev_sequence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_io_bitmap),
            "::",
            stringify!(prev_sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_io_bitmap>())).prev_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_io_bitmap),
            "::",
            stringify!(prev_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_io_bitmap>())).bitmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_io_bitmap),
            "::",
            stringify!(bitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_io_bitmap>())).mapall as *const _ as usize },
        8216usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_io_bitmap),
            "::",
            stringify!(mapall)
        )
    );
}
#[repr(C)]
#[repr(align(4096))]
#[derive(Copy, Clone)]
pub struct tss_struct {
    pub x86_tss: x86_hw_tss,
    pub io_bitmap: x86_io_bitmap,
}
#[test]
fn bindgen_test_layout_tss_struct() {
    assert_eq!(
        ::std::mem::size_of::<tss_struct>(),
        20480usize,
        concat!("Size of: ", stringify!(tss_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<tss_struct>(),
        4096usize,
        concat!("Alignment of ", stringify!(tss_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tss_struct>())).x86_tss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(x86_tss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tss_struct>())).io_bitmap as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(io_bitmap)
        )
    );
}
extern "C" {
    pub static mut cpu_tss_rw: tss_struct;
}
#[repr(C)]
#[repr(align(32768))]
#[derive(Copy, Clone)]
pub struct irq_stack {
    pub stack: [::std::os::raw::c_char; 32768usize],
}
#[test]
fn bindgen_test_layout_irq_stack() {
    assert_eq!(
        ::std::mem::size_of::<irq_stack>(),
        32768usize,
        concat!("Size of: ", stringify!(irq_stack))
    );
    assert_eq!(
        ::std::mem::align_of::<irq_stack>(),
        32768usize,
        concat!("Alignment of ", stringify!(irq_stack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_stack>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_stack),
            "::",
            stringify!(stack)
        )
    );
}
extern "C" {
    pub static mut cpu_current_top_of_stack: ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fixed_percpu_data {
    pub gs_base: [::std::os::raw::c_char; 40usize],
    pub stack_canary: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_fixed_percpu_data() {
    assert_eq!(
        ::std::mem::size_of::<fixed_percpu_data>(),
        48usize,
        concat!("Size of: ", stringify!(fixed_percpu_data))
    );
    assert_eq!(
        ::std::mem::align_of::<fixed_percpu_data>(),
        8usize,
        concat!("Alignment of ", stringify!(fixed_percpu_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fixed_percpu_data>())).gs_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fixed_percpu_data),
            "::",
            stringify!(gs_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fixed_percpu_data>())).stack_canary as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fixed_percpu_data),
            "::",
            stringify!(stack_canary)
        )
    );
}
extern "C" {
    pub static mut fixed_percpu_data: fixed_percpu_data;
}
extern "C" {
    pub static mut init_per_cpu__fixed_percpu_data: fixed_percpu_data;
}
extern "C" {
    pub static mut hardirq_stack_ptr: *mut ::std::os::raw::c_void;
}
extern "C" {
    pub static mut hardirq_stack_inuse: bool;
}
extern "C" {
    pub fn ignore_sysret();
}
extern "C" {
    pub fn current_save_fsgs();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_event {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
pub struct thread_struct {
    pub tls_array: [desc_struct; 3usize],
    pub sp: ::std::os::raw::c_ulong,
    pub es: ::std::os::raw::c_ushort,
    pub ds: ::std::os::raw::c_ushort,
    pub fsindex: ::std::os::raw::c_ushort,
    pub gsindex: ::std::os::raw::c_ushort,
    pub fsbase: ::std::os::raw::c_ulong,
    pub gsbase: ::std::os::raw::c_ulong,
    pub ptrace_bps: [*mut perf_event; 4usize],
    pub virtual_dr6: ::std::os::raw::c_ulong,
    pub ptrace_dr7: ::std::os::raw::c_ulong,
    pub cr2: ::std::os::raw::c_ulong,
    pub trap_nr: ::std::os::raw::c_ulong,
    pub error_code: ::std::os::raw::c_ulong,
    pub io_bitmap: *mut io_bitmap,
    pub iopl_emul: ::std::os::raw::c_ulong,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub pkru: u32_,
    pub __bindgen_padding_0: [u64; 5usize],
    pub fpu: fpu,
}
#[test]
fn bindgen_test_layout_thread_struct() {
    assert_eq!(
        ::std::mem::size_of::<thread_struct>(),
        4416usize,
        concat!("Size of: ", stringify!(thread_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<thread_struct>(),
        64usize,
        concat!("Alignment of ", stringify!(thread_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).tls_array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(tls_array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).sp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).es as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).ds as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).fsindex as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fsindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).gsindex as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(gsindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).fsbase as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fsbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).gsbase as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(gsbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).ptrace_bps as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ptrace_bps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).virtual_dr6 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(virtual_dr6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).ptrace_dr7 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ptrace_dr7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).cr2 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).trap_nr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(trap_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).error_code as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).io_bitmap as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(io_bitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).iopl_emul as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(iopl_emul)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).pkru as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(pkru)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).fpu as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fpu)
        )
    );
}
impl thread_struct {
    #[inline]
    pub fn iopl_warn(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_iopl_warn(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_on_uaccess_err(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_on_uaccess_err(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        iopl_warn: ::std::os::raw::c_uint,
        sig_on_uaccess_err: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let iopl_warn: u32 = unsafe { ::std::mem::transmute(iopl_warn) };
            iopl_warn as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sig_on_uaccess_err: u32 = unsafe { ::std::mem::transmute(sig_on_uaccess_err) };
            sig_on_uaccess_err as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn fpu_thread_struct_whitelist(
        offset: *mut ::std::os::raw::c_ulong,
        size: *mut ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __get_wchan(p: *mut task_struct) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn select_idle_routine(c: *const cpuinfo_x86);
}
extern "C" {
    pub fn amd_e400_c1e_apic_setup();
}
extern "C" {
    pub static mut boot_option_idle_override: ::std::os::raw::c_ulong;
}
pub const idle_boot_override_IDLE_NO_OVERRIDE: idle_boot_override = 0;
pub const idle_boot_override_IDLE_HALT: idle_boot_override = 1;
pub const idle_boot_override_IDLE_NOMWAIT: idle_boot_override = 2;
pub const idle_boot_override_IDLE_POLL: idle_boot_override = 3;
pub type idle_boot_override = ::std::os::raw::c_uint;
extern "C" {
    pub fn enable_sep_cpu();
}
extern "C" {
    pub fn sysenter_setup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut early_gdt_descr: desc_ptr;
}
extern "C" {
    pub fn switch_to_new_gdt(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn load_direct_gdt(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn load_fixmap_gdt(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn load_percpu_segment(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cpu_init();
}
extern "C" {
    pub fn cpu_init_secondary();
}
extern "C" {
    pub fn cpu_init_exception_handling();
}
extern "C" {
    pub fn cr4_init();
}
extern "C" {
    pub fn set_task_blockstep(task: *mut task_struct, on: bool_);
}
extern "C" {
    pub static mut bootloader_type: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut bootloader_version: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut ignore_fpu_irq: ::std::os::raw::c_char;
}
extern "C" {
    pub fn KSTK_ESP(task: *mut task_struct) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn start_thread(
        regs: *mut pt_regs,
        new_ip: ::std::os::raw::c_ulong,
        new_sp: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn get_tsc_mode(adr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_tsc_mode(val: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut msr_misc_features_shadow: ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn get_llc_id(cpu: ::std::os::raw::c_uint) -> u16_;
}
extern "C" {
    pub fn amd_get_nodes_per_socket() -> u32_;
}
extern "C" {
    pub fn amd_get_highest_perf() -> u32_;
}
extern "C" {
    pub fn arch_align_stack(sp: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn free_init_pages(
        what: *const ::std::os::raw::c_char,
        begin: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn free_kernel_image_pages(
        what: *const ::std::os::raw::c_char,
        begin: *mut ::std::os::raw::c_void,
        end: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn default_idle();
}
extern "C" {
    pub fn stop_this_cpu(dummy: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn microcode_check();
}
pub const l1tf_mitigations_L1TF_MITIGATION_OFF: l1tf_mitigations = 0;
pub const l1tf_mitigations_L1TF_MITIGATION_FLUSH_NOWARN: l1tf_mitigations = 1;
pub const l1tf_mitigations_L1TF_MITIGATION_FLUSH: l1tf_mitigations = 2;
pub const l1tf_mitigations_L1TF_MITIGATION_FLUSH_NOSMT: l1tf_mitigations = 3;
pub const l1tf_mitigations_L1TF_MITIGATION_FULL: l1tf_mitigations = 4;
pub const l1tf_mitigations_L1TF_MITIGATION_FULL_FORCE: l1tf_mitigations = 5;
pub type l1tf_mitigations = ::std::os::raw::c_uint;
extern "C" {
    pub static mut l1tf_mitigation: l1tf_mitigations;
}
pub const mds_mitigations_MDS_MITIGATION_OFF: mds_mitigations = 0;
pub const mds_mitigations_MDS_MITIGATION_FULL: mds_mitigations = 1;
pub const mds_mitigations_MDS_MITIGATION_VMWERV: mds_mitigations = 2;
pub type mds_mitigations = ::std::os::raw::c_uint;
pub const cpuid_leafs_CPUID_1_EDX: cpuid_leafs = 0;
pub const cpuid_leafs_CPUID_8000_0001_EDX: cpuid_leafs = 1;
pub const cpuid_leafs_CPUID_8086_0001_EDX: cpuid_leafs = 2;
pub const cpuid_leafs_CPUID_LNX_1: cpuid_leafs = 3;
pub const cpuid_leafs_CPUID_1_ECX: cpuid_leafs = 4;
pub const cpuid_leafs_CPUID_C000_0001_EDX: cpuid_leafs = 5;
pub const cpuid_leafs_CPUID_8000_0001_ECX: cpuid_leafs = 6;
pub const cpuid_leafs_CPUID_LNX_2: cpuid_leafs = 7;
pub const cpuid_leafs_CPUID_LNX_3: cpuid_leafs = 8;
pub const cpuid_leafs_CPUID_7_0_EBX: cpuid_leafs = 9;
pub const cpuid_leafs_CPUID_D_1_EAX: cpuid_leafs = 10;
pub const cpuid_leafs_CPUID_LNX_4: cpuid_leafs = 11;
pub const cpuid_leafs_CPUID_7_1_EAX: cpuid_leafs = 12;
pub const cpuid_leafs_CPUID_8000_0008_EBX: cpuid_leafs = 13;
pub const cpuid_leafs_CPUID_6_EAX: cpuid_leafs = 14;
pub const cpuid_leafs_CPUID_8000_000A_EDX: cpuid_leafs = 15;
pub const cpuid_leafs_CPUID_7_ECX: cpuid_leafs = 16;
pub const cpuid_leafs_CPUID_8000_0007_EBX: cpuid_leafs = 17;
pub const cpuid_leafs_CPUID_7_EDX: cpuid_leafs = 18;
pub const cpuid_leafs_CPUID_8000_001F_EAX: cpuid_leafs = 19;
pub type cpuid_leafs = ::std::os::raw::c_uint;
extern "C" {
    pub static x86_cap_flags: [*const ::std::os::raw::c_char; 640usize];
}
extern "C" {
    pub static x86_power_flags: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub static x86_bug_flags: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub fn setup_clear_cpu_cap(bit: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn clear_cpu_cap(c: *mut cpuinfo_x86, bit: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_info {
    pub flags: ::std::os::raw::c_ulong,
    pub syscall_work: ::std::os::raw::c_ulong,
    pub status: u32_,
    pub cpu: u32_,
}
#[test]
fn bindgen_test_layout_thread_info() {
    assert_eq!(
        ::std::mem::size_of::<thread_info>(),
        24usize,
        concat!("Size of: ", stringify!(thread_info))
    );
    assert_eq!(
        ::std::mem::align_of::<thread_info>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_info>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_info>())).syscall_work as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(syscall_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_info>())).status as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_info>())).cpu as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(cpu)
        )
    );
}
extern "C" {
    pub fn arch_task_cache_init();
}
extern "C" {
    pub fn arch_dup_task_struct(
        dst: *mut task_struct,
        src: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_release_task_struct(tsk: *mut task_struct);
}
extern "C" {
    pub fn arch_setup_new_exec();
}
extern "C" {
    pub fn __bad_copy_from();
}
extern "C" {
    pub fn __bad_copy_to();
}
extern "C" {
    pub fn __copy_overflow(size: ::std::os::raw::c_int, count: ::std::os::raw::c_ulong);
}
extern "C" {
    pub static mut __preempt_count: ::std::os::raw::c_int;
}
extern "C" {
    pub fn preempt_schedule();
}
extern "C" {
    pub fn preempt_schedule_thunk();
}
extern "C" {
    pub fn preempt_schedule_notrace();
}
extern "C" {
    pub fn preempt_schedule_notrace_thunk();
}
extern "C" {
    pub static mut __SCK__preempt_schedule: static_call_key;
}
extern "C" {
    pub fn __SCT__preempt_schedule();
}
extern "C" {
    pub static mut __SCK__preempt_schedule_notrace: static_call_key;
}
extern "C" {
    pub fn __SCT__preempt_schedule_notrace();
}
extern "C" {
    pub fn preempt_count_add(val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn preempt_count_sub(val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn migrate_disable();
}
extern "C" {
    pub fn migrate_enable();
}
extern "C" {
    pub fn _local_bh_enable();
}
extern "C" {
    pub fn __local_bh_enable_ip(ip: ::std::os::raw::c_ulong, cnt: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llist_head {
    pub first: *mut llist_node,
}
#[test]
fn bindgen_test_layout_llist_head() {
    assert_eq!(
        ::std::mem::size_of::<llist_head>(),
        8usize,
        concat!("Size of: ", stringify!(llist_head))
    );
    assert_eq!(
        ::std::mem::align_of::<llist_head>(),
        8usize,
        concat!("Alignment of ", stringify!(llist_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llist_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llist_head),
            "::",
            stringify!(first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llist_node {
    pub next: *mut llist_node,
}
#[test]
fn bindgen_test_layout_llist_node() {
    assert_eq!(
        ::std::mem::size_of::<llist_node>(),
        8usize,
        concat!("Size of: ", stringify!(llist_node))
    );
    assert_eq!(
        ::std::mem::align_of::<llist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(llist_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llist_node),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn llist_add_batch(
        new_first: *mut llist_node,
        new_last: *mut llist_node,
        head: *mut llist_head,
    ) -> bool_;
}
extern "C" {
    pub fn llist_del_first(head: *mut llist_head) -> *mut llist_node;
}
extern "C" {
    pub fn llist_reverse_order(head: *mut llist_node) -> *mut llist_node;
}
pub const CSD_FLAG_LOCK: ::std::os::raw::c_uint = 1;
pub const IRQ_WORK_PENDING: ::std::os::raw::c_uint = 1;
pub const IRQ_WORK_BUSY: ::std::os::raw::c_uint = 2;
pub const IRQ_WORK_LAZY: ::std::os::raw::c_uint = 4;
pub const IRQ_WORK_HARD_IRQ: ::std::os::raw::c_uint = 8;
pub const IRQ_WORK_CLAIMED: ::std::os::raw::c_uint = 3;
pub const CSD_TYPE_ASYNC: ::std::os::raw::c_uint = 0;
pub const CSD_TYPE_SYNC: ::std::os::raw::c_uint = 16;
pub const CSD_TYPE_IRQ_WORK: ::std::os::raw::c_uint = 32;
pub const CSD_TYPE_TTWU: ::std::os::raw::c_uint = 48;
pub const CSD_FLAG_TYPE_MASK: ::std::os::raw::c_uint = 240;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_node {
    pub llist: llist_node,
    pub __bindgen_anon_1: __call_single_node__bindgen_ty_1,
    pub src: u16_,
    pub dst: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __call_single_node__bindgen_ty_1 {
    pub u_flags: ::std::os::raw::c_uint,
    pub a_flags: atomic_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___call_single_node__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__call_single_node__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__call_single_node__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__call_single_node__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__call_single_node__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__call_single_node__bindgen_ty_1>())).u_flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_node__bindgen_ty_1),
            "::",
            stringify!(u_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__call_single_node__bindgen_ty_1>())).a_flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_node__bindgen_ty_1),
            "::",
            stringify!(a_flags)
        )
    );
}
#[test]
fn bindgen_test_layout___call_single_node() {
    assert_eq!(
        ::std::mem::size_of::<__call_single_node>(),
        16usize,
        concat!("Size of: ", stringify!(__call_single_node))
    );
    assert_eq!(
        ::std::mem::align_of::<__call_single_node>(),
        8usize,
        concat!("Alignment of ", stringify!(__call_single_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_node>())).llist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_node),
            "::",
            stringify!(llist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_node>())).src as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_node),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_node>())).dst as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_node),
            "::",
            stringify!(dst)
        )
    );
}
pub type smp_call_func_t =
    ::std::option::Option<unsafe extern "C" fn(info: *mut ::std::os::raw::c_void)>;
pub type smp_cond_func_t = ::std::option::Option<
    unsafe extern "C" fn(cpu: ::std::os::raw::c_int, info: *mut ::std::os::raw::c_void) -> bool_,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_data {
    pub node: __call_single_node,
    pub func: smp_call_func_t,
    pub info: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___call_single_data() {
    assert_eq!(
        ::std::mem::size_of::<__call_single_data>(),
        32usize,
        concat!("Size of: ", stringify!(__call_single_data))
    );
    assert_eq!(
        ::std::mem::align_of::<__call_single_data>(),
        8usize,
        concat!("Alignment of ", stringify!(__call_single_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_data>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_data>())).func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_data>())).info as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(info)
        )
    );
}
pub type call_single_data_t = __call_single_data;
extern "C" {
    pub fn __smp_call_single_queue(cpu: ::std::os::raw::c_int, node: *mut llist_node);
}
extern "C" {
    pub static mut total_cpus: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn smp_call_function_single(
        cpuid: ::std::os::raw::c_int,
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_each_cpu_cond_mask(
        cond_func: smp_cond_func_t,
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: bool_,
        mask: *const cpumask,
    );
}
extern "C" {
    pub fn smp_call_function_single_async(
        cpu: ::std::os::raw::c_int,
        csd: *mut __call_single_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn panic_smp_self_stop();
}
extern "C" {
    pub fn nmi_panic_self_stop(regs: *mut pt_regs);
}
extern "C" {
    pub fn crash_smp_send_stop();
}
extern "C" {
    pub static mut smp_num_siblings: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut num_processors: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut cpu_sibling_map: [cpumask; 1usize];
}
extern "C" {
    pub static mut cpu_core_map: [cpumask; 1usize];
}
extern "C" {
    pub static mut cpu_die_map: [cpumask; 1usize];
}
extern "C" {
    pub static mut cpu_llc_shared_map: [cpumask; 1usize];
}
extern "C" {
    pub static mut cpu_l2c_shared_map: [cpumask; 1usize];
}
extern "C" {
    pub static mut cpu_llc_id: ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut cpu_l2c_id: ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut cpu_number: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut x86_cpu_to_apicid: ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut x86_cpu_to_apicid_early_ptr: *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut x86_cpu_to_apicid_early_map: [::std::os::raw::c_ushort; 0usize];
}
extern "C" {
    pub static mut x86_cpu_to_acpiid: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut x86_cpu_to_acpiid_early_ptr: *mut ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut x86_cpu_to_acpiid_early_map: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut x86_bios_cpu_apicid: ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut x86_bios_cpu_apicid_early_ptr: *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut x86_bios_cpu_apicid_early_map: [::std::os::raw::c_ushort; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct smp_ops {
    pub smp_prepare_boot_cpu: ::std::option::Option<unsafe extern "C" fn()>,
    pub smp_prepare_cpus:
        ::std::option::Option<unsafe extern "C" fn(max_cpus: ::std::os::raw::c_uint)>,
    pub smp_cpus_done:
        ::std::option::Option<unsafe extern "C" fn(max_cpus: ::std::os::raw::c_uint)>,
    pub stop_other_cpus: ::std::option::Option<unsafe extern "C" fn(wait: ::std::os::raw::c_int)>,
    pub crash_stop_other_cpus: ::std::option::Option<unsafe extern "C" fn()>,
    pub smp_send_reschedule:
        ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_int)>,
    pub cpu_up: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: ::std::os::raw::c_uint,
            tidle: *mut task_struct,
        ) -> ::std::os::raw::c_int,
    >,
    pub cpu_disable: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub cpu_die: ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_uint)>,
    pub play_dead: ::std::option::Option<unsafe extern "C" fn()>,
    pub send_call_func_ipi: ::std::option::Option<unsafe extern "C" fn(mask: *const cpumask)>,
    pub send_call_func_single_ipi:
        ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_int)>,
}
#[test]
fn bindgen_test_layout_smp_ops() {
    assert_eq!(
        ::std::mem::size_of::<smp_ops>(),
        96usize,
        concat!("Size of: ", stringify!(smp_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<smp_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(smp_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).smp_prepare_boot_cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(smp_prepare_boot_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).smp_prepare_cpus as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(smp_prepare_cpus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).smp_cpus_done as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(smp_cpus_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).stop_other_cpus as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(stop_other_cpus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).crash_stop_other_cpus as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(crash_stop_other_cpus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).smp_send_reschedule as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(smp_send_reschedule)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).cpu_up as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(cpu_up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).cpu_disable as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(cpu_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).cpu_die as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(cpu_die)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).play_dead as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(play_dead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).send_call_func_ipi as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(send_call_func_ipi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<smp_ops>())).send_call_func_single_ipi as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(send_call_func_single_ipi)
        )
    );
}
extern "C" {
    pub fn set_cpu_sibling_map(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub static mut smp_ops: smp_ops;
}
extern "C" {
    pub fn cpu_disable_common();
}
extern "C" {
    pub fn native_smp_prepare_boot_cpu();
}
extern "C" {
    pub fn smp_prepare_cpus_common();
}
extern "C" {
    pub fn native_smp_prepare_cpus(max_cpus: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn calculate_max_logical_packages();
}
extern "C" {
    pub fn native_smp_cpus_done(max_cpus: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn common_cpu_up(
        cpunum: ::std::os::raw::c_uint,
        tidle: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_cpu_up(
        cpunum: ::std::os::raw::c_uint,
        tidle: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_cpu_disable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn common_cpu_die(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_cpu_die(cpu: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hlt_play_dead();
}
extern "C" {
    pub fn native_play_dead();
}
extern "C" {
    pub fn play_dead_common();
}
extern "C" {
    pub fn wbinvd_on_cpu(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn wbinvd_on_all_cpus() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cond_wakeup_cpu0();
}
extern "C" {
    pub fn native_smp_send_reschedule(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn native_send_call_func_ipi(mask: *const cpumask);
}
extern "C" {
    pub fn native_send_call_func_single_ipi(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn x86_idle_thread_init(cpu: ::std::os::raw::c_uint, idle: *mut task_struct);
}
extern "C" {
    pub fn smp_store_boot_cpu_info();
}
extern "C" {
    pub fn smp_store_cpu_info(id: ::std::os::raw::c_int);
}
extern "C" {
    pub fn smp_reboot_interrupt();
}
extern "C" {
    pub fn smp_reschedule_interrupt(regs: *mut pt_regs);
}
extern "C" {
    pub fn smp_call_function_interrupt(regs: *mut pt_regs);
}
extern "C" {
    pub fn smp_call_function_single_interrupt(r: *mut pt_regs);
}
extern "C" {
    pub static mut disabled_cpus: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hard_smp_processor_id() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smp_call_function(
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn smp_call_function_many(
        mask: *const cpumask,
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: bool_,
    );
}
extern "C" {
    pub fn smp_call_function_any(
        mask: *const cpumask,
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kick_all_cpus_sync();
}
extern "C" {
    pub fn wake_up_all_idle_cpus();
}
extern "C" {
    pub fn call_function_init();
}
extern "C" {
    pub fn generic_smp_call_function_single_interrupt();
}
extern "C" {
    pub static mut setup_max_cpus: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn setup_nr_cpu_ids();
}
extern "C" {
    pub fn smp_init();
}
extern "C" {
    pub static mut __boot_cpu_id: ::std::os::raw::c_int;
}
extern "C" {
    pub fn debug_smp_processor_id() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn arch_disable_smp_support();
}
extern "C" {
    pub fn arch_thaw_secondary_cpus_begin();
}
extern "C" {
    pub fn arch_thaw_secondary_cpus_end();
}
extern "C" {
    pub fn smp_setup_processor_id();
}
extern "C" {
    pub fn smp_call_on_cpu(
        cpu: ::std::os::raw::c_uint,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        par: *mut ::std::os::raw::c_void,
        phys: bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smpcfd_prepare_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smpcfd_dead_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smpcfd_dying_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lock_is_held(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockdep_is_held(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
pub const xhlock_context_t_XHLOCK_HARD: xhlock_context_t = 0;
pub const xhlock_context_t_XHLOCK_SOFT: xhlock_context_t = 1;
pub const xhlock_context_t_XHLOCK_CTX_NR: xhlock_context_t = 2;
pub type xhlock_context_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spinlock {
    pub __bindgen_anon_1: spinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spinlock__bindgen_ty_1 {
    pub rlock: raw_spinlock,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_spinlock__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spinlock__bindgen_ty_1>())).rlock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spinlock__bindgen_ty_1),
            "::",
            stringify!(rlock)
        )
    );
}
#[test]
fn bindgen_test_layout_spinlock() {
    assert_eq!(
        ::std::mem::size_of::<spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock))
    );
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rwlock_t {
    pub raw_lock: arch_rwlock_t,
}
#[test]
fn bindgen_test_layout_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<rwlock_t>(),
        8usize,
        concat!("Size of: ", stringify!(rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rwlock_t>())).raw_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rwlock_t),
            "::",
            stringify!(raw_lock)
        )
    );
}
extern "C" {
    pub static mut virt_spin_lock_key: static_key_true;
}
extern "C" {
    pub fn native_pv_lock_init();
}
extern "C" {
    pub fn queued_spin_lock_slowpath(lock: *mut qspinlock, val: u32_);
}
extern "C" {
    pub fn queued_read_lock_slowpath(lock: *mut qrwlock);
}
extern "C" {
    pub fn queued_write_lock_slowpath(lock: *mut qrwlock);
}
extern "C" {
    pub fn in_lock_functions(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_spin_lock(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_nested(lock: *mut raw_spinlock_t, subclass: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _raw_spin_lock_nest_lock(lock: *mut raw_spinlock_t, map: *mut lockdep_map);
}
extern "C" {
    pub fn _raw_spin_lock_bh(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_irq(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_irqsave(lock: *mut raw_spinlock_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_spin_lock_irqsave_nested(
        lock: *mut raw_spinlock_t,
        subclass: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_spin_trylock(lock: *mut raw_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_spin_trylock_bh(lock: *mut raw_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_spin_unlock(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_bh(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_irq(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_irqrestore(lock: *mut raw_spinlock_t, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn _raw_read_lock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_nested(lock: *mut rwlock_t, subclass: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _raw_read_lock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_lock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_lock_irqsave(lock: *mut rwlock_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_write_lock_irqsave(lock: *mut rwlock_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_read_trylock(lock: *mut rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_write_trylock(lock: *mut rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_read_unlock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_irqrestore(lock: *mut rwlock_t, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn _raw_write_unlock_irqrestore(lock: *mut rwlock_t, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    #[doc = " atomic_dec_and_lock - lock on reaching reference count zero"]
    #[doc = " @atomic: the atomic counter"]
    #[doc = " @lock: the spinlock in question"]
    #[doc = ""]
    #[doc = " Decrements @atomic by 1.  If the result is 0, returns true and locks"]
    #[doc = " @lock.  Returns false for all other cases."]
    pub fn _atomic_dec_and_lock(
        atomic: *mut atomic_t,
        lock: *mut spinlock_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atomic_dec_and_lock_irqsave(
        atomic: *mut atomic_t,
        lock: *mut spinlock_t,
        flags: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __alloc_bucket_spinlocks(
        locks: *mut *mut spinlock_t,
        lock_mask: *mut ::std::os::raw::c_uint,
        max_size: size_t,
        cpu_mult: ::std::os::raw::c_uint,
        gfp: gfp_t,
        name: *const ::std::os::raw::c_char,
        key: *mut lock_class_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn free_bucket_spinlocks(locks: *mut spinlock_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_node {
    pub __rb_parent_color: ::std::os::raw::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_node() {
    assert_eq!(
        ::std::mem::size_of::<rb_node>(),
        24usize,
        concat!("Size of: ", stringify!(rb_node))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_node>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_node>())).__rb_parent_color as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(__rb_parent_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_node>())).rb_right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_node>())).rb_left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_left)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root {
    pub rb_node: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_root() {
    assert_eq!(
        ::std::mem::size_of::<rb_root>(),
        8usize,
        concat!("Size of: ", stringify!(rb_root))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_root>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_root))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_root>())).rb_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root),
            "::",
            stringify!(rb_node)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root_cached {
    pub rb_root: rb_root,
    pub rb_leftmost: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_root_cached() {
    assert_eq!(
        ::std::mem::size_of::<rb_root_cached>(),
        16usize,
        concat!("Size of: ", stringify!(rb_root_cached))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_root_cached>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_root_cached))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_root_cached>())).rb_root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root_cached),
            "::",
            stringify!(rb_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_root_cached>())).rb_leftmost as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root_cached),
            "::",
            stringify!(rb_leftmost)
        )
    );
}
extern "C" {
    pub fn ct_irq_enter();
}
extern "C" {
    pub fn ct_irq_exit();
}
extern "C" {
    pub fn ct_irq_enter_irqson();
}
extern "C" {
    pub fn ct_irq_exit_irqson();
}
extern "C" {
    pub fn ct_nmi_enter();
}
extern "C" {
    pub fn ct_nmi_exit();
}
extern "C" {
    pub fn call_rcu(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn rcu_barrier_tasks();
}
extern "C" {
    pub fn rcu_barrier_tasks_rude();
}
extern "C" {
    pub fn synchronize_rcu();
}
extern "C" {
    pub fn get_completed_synchronize_rcu() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn get_completed_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn __rcu_read_lock();
}
extern "C" {
    pub fn __rcu_read_unlock();
}
extern "C" {
    pub fn rcu_init();
}
extern "C" {
    pub static mut rcu_scheduler_active: ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcu_sched_clock_irq(user: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rcu_report_dead(cpu: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rcutree_migrate_callbacks(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rcu_init_tasks_generic();
}
extern "C" {
    pub fn rcu_sysrq_start();
}
extern "C" {
    pub fn rcu_sysrq_end();
}
extern "C" {
    pub fn call_rcu_tasks(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn synchronize_rcu_tasks();
}
extern "C" {
    pub fn exit_tasks_rcu_start();
}
extern "C" {
    pub fn exit_tasks_rcu_finish();
}
extern "C" {
    pub fn rcu_softirq_qs();
}
extern "C" {
    pub fn rcu_note_context_switch(preempt: bool_);
}
extern "C" {
    pub fn rcu_needs_cpu() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcu_cpu_stall_reset();
}
extern "C" {
    pub fn synchronize_rcu_expedited();
}
extern "C" {
    pub fn kvfree_call_rcu(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn rcu_barrier();
}
extern "C" {
    pub fn rcu_eqs_special_set(cpu: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn rcu_momentary_dyntick_idle();
}
extern "C" {
    pub fn kfree_rcu_scheduler_running();
}
extern "C" {
    pub fn rcu_gp_might_be_stalled() -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_gp_oldstate {
    pub rgos_norm: ::std::os::raw::c_ulong,
    pub rgos_exp: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_rcu_gp_oldstate() {
    assert_eq!(
        ::std::mem::size_of::<rcu_gp_oldstate>(),
        16usize,
        concat!("Size of: ", stringify!(rcu_gp_oldstate))
    );
    assert_eq!(
        ::std::mem::align_of::<rcu_gp_oldstate>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_gp_oldstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_gp_oldstate>())).rgos_norm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_gp_oldstate),
            "::",
            stringify!(rgos_norm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_gp_oldstate>())).rgos_exp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_gp_oldstate),
            "::",
            stringify!(rgos_exp)
        )
    );
}
extern "C" {
    pub fn start_poll_synchronize_rcu_expedited() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn start_poll_synchronize_rcu_expedited_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn cond_synchronize_rcu_expedited(oldstate: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn cond_synchronize_rcu_expedited_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn get_state_synchronize_rcu() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn get_state_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn start_poll_synchronize_rcu() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn start_poll_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn poll_state_synchronize_rcu(oldstate: ::std::os::raw::c_ulong) -> bool_;
}
extern "C" {
    pub fn poll_state_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate) -> bool_;
}
extern "C" {
    pub fn cond_synchronize_rcu(oldstate: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn cond_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn rcu_is_idle_cpu(cpu: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn rcu_preempt_deferred_qs(t: *mut task_struct);
}
extern "C" {
    pub fn exit_rcu();
}
extern "C" {
    pub fn rcu_scheduler_starting();
}
extern "C" {
    pub fn rcu_end_inkernel_boot();
}
extern "C" {
    pub fn rcu_inkernel_boot_has_ended() -> bool_;
}
extern "C" {
    pub fn rcu_is_watching() -> bool_;
}
extern "C" {
    pub fn rcutree_prepare_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcutree_online_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcutree_offline_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcutree_dead_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcutree_dying_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcu_cpu_starting(cpu: ::std::os::raw::c_uint);
}
extern "C" {
    pub static mut rcu_lock_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_bh_lock_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_sched_lock_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_callback_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_expedited: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut rcu_normal: ::std::os::raw::c_int;
}
extern "C" {
    pub fn rb_insert_color(arg1: *mut rb_node, arg2: *mut rb_root);
}
extern "C" {
    pub fn rb_erase(arg1: *mut rb_node, arg2: *mut rb_root);
}
extern "C" {
    pub fn rb_next(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_prev(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_first(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_last(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_first_postorder(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_next_postorder(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_replace_node(victim: *mut rb_node, new: *mut rb_node, root: *mut rb_root);
}
extern "C" {
    pub fn rb_replace_node_rcu(victim: *mut rb_node, new: *mut rb_node, root: *mut rb_root);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct notifier_block {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_struct {
    pub next: *mut vm_struct,
    pub addr: *mut ::std::os::raw::c_void,
    pub size: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub pages: *mut *mut page,
    pub page_order: ::std::os::raw::c_uint,
    pub nr_pages: ::std::os::raw::c_uint,
    pub phys_addr: phys_addr_t,
    pub caller: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vm_struct() {
    assert_eq!(
        ::std::mem::size_of::<vm_struct>(),
        64usize,
        concat!("Size of: ", stringify!(vm_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<vm_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).pages as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).page_order as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(page_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).nr_pages as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(nr_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).phys_addr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).caller as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(caller)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vmap_area {
    pub va_start: ::std::os::raw::c_ulong,
    pub va_end: ::std::os::raw::c_ulong,
    pub rb_node: rb_node,
    pub list: list_head,
    pub __bindgen_anon_1: vmap_area__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vmap_area__bindgen_ty_1 {
    pub subtree_max_size: ::std::os::raw::c_ulong,
    pub vm: *mut vm_struct,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_vmap_area__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vmap_area__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(vmap_area__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vmap_area__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vmap_area__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vmap_area__bindgen_ty_1>())).subtree_max_size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area__bindgen_ty_1),
            "::",
            stringify!(subtree_max_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area__bindgen_ty_1>())).vm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area__bindgen_ty_1),
            "::",
            stringify!(vm)
        )
    );
}
#[test]
fn bindgen_test_layout_vmap_area() {
    assert_eq!(
        ::std::mem::size_of::<vmap_area>(),
        64usize,
        concat!("Size of: ", stringify!(vmap_area))
    );
    assert_eq!(
        ::std::mem::align_of::<vmap_area>(),
        8usize,
        concat!("Alignment of ", stringify!(vmap_area))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).va_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(va_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).va_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(va_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).rb_node as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(rb_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).list as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(list)
        )
    );
}
extern "C" {
    pub fn vm_unmap_ram(mem: *const ::std::os::raw::c_void, count: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn vm_map_ram(
        pages: *mut *mut page,
        count: ::std::os::raw::c_uint,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vm_unmap_aliases();
}
extern "C" {
    pub fn vmalloc_init();
}
extern "C" {
    pub fn vmalloc_nr_pages() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn vmalloc(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vzalloc(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_user(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_node(
        size: ::std::os::raw::c_ulong,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vzalloc_node(
        size: ::std::os::raw::c_ulong,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_32(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_32_user(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __vmalloc(size: ::std::os::raw::c_ulong, gfp_mask: gfp_t)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __vmalloc_node_range(
        size: ::std::os::raw::c_ulong,
        align: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
        gfp_mask: gfp_t,
        prot: pgprot_t,
        vm_flags: ::std::os::raw::c_ulong,
        node: ::std::os::raw::c_int,
        caller: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __vmalloc_node(
        size: ::std::os::raw::c_ulong,
        align: ::std::os::raw::c_ulong,
        gfp_mask: gfp_t,
        node: ::std::os::raw::c_int,
        caller: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_huge(
        size: ::std::os::raw::c_ulong,
        gfp_mask: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __vmalloc_array(n: size_t, size: size_t, flags: gfp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_array(n: size_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __vcalloc(n: size_t, size: size_t, flags: gfp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcalloc(n: size_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vfree(addr: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn vfree_atomic(addr: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn vmap(
        pages: *mut *mut page,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_ulong,
        prot: pgprot_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmap_pfn(
        pfns: *mut ::std::os::raw::c_ulong,
        count: ::std::os::raw::c_uint,
        prot: pgprot_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vunmap(addr: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn remap_vmalloc_range_partial(
        vma: *mut vm_area_struct,
        uaddr: ::std::os::raw::c_ulong,
        kaddr: *mut ::std::os::raw::c_void,
        pgoff: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remap_vmalloc_range(
        vma: *mut vm_area_struct,
        addr: *mut ::std::os::raw::c_void,
        pgoff: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_sync_kernel_mappings(start: ::std::os::raw::c_ulong, end: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn get_vm_area(
        size: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> *mut vm_struct;
}
extern "C" {
    pub fn get_vm_area_caller(
        size: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
        caller: *const ::std::os::raw::c_void,
    ) -> *mut vm_struct;
}
extern "C" {
    pub fn __get_vm_area_caller(
        size: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
        caller: *const ::std::os::raw::c_void,
    ) -> *mut vm_struct;
}
extern "C" {
    pub fn free_vm_area(area: *mut vm_struct);
}
extern "C" {
    pub fn remove_vm_area(addr: *const ::std::os::raw::c_void) -> *mut vm_struct;
}
extern "C" {
    pub fn find_vm_area(addr: *const ::std::os::raw::c_void) -> *mut vm_struct;
}
extern "C" {
    pub fn find_vmap_area(addr: ::std::os::raw::c_ulong) -> *mut vmap_area;
}
extern "C" {
    pub fn vunmap_range(addr: ::std::os::raw::c_ulong, end: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn vread(
        buf: *mut ::std::os::raw::c_char,
        addr: *mut ::std::os::raw::c_char,
        count: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub static mut vmap_area_list: list_head;
}
extern "C" {
    pub fn vm_area_add_early(vm: *mut vm_struct);
}
extern "C" {
    pub fn vm_area_register_early(vm: *mut vm_struct, align: size_t);
}
extern "C" {
    pub fn pcpu_get_vm_areas(
        offsets: *const ::std::os::raw::c_ulong,
        sizes: *const size_t,
        nr_vms: ::std::os::raw::c_int,
        align: size_t,
    ) -> *mut *mut vm_struct;
}
extern "C" {
    pub fn pcpu_free_vm_areas(vms: *mut *mut vm_struct, nr_vms: ::std::os::raw::c_int);
}
extern "C" {
    pub fn register_vmap_purge_notifier(nb: *mut notifier_block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unregister_vmap_purge_notifier(nb: *mut notifier_block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vmalloc_dump_obj(object: *mut ::std::os::raw::c_void) -> bool_;
}
extern "C" {
    pub fn arch_phys_wc_index(handle: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_phys_wc_add(
        base: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_phys_wc_del(handle: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arch_io_reserve_memtype_wc(
        start: resource_size_t,
        size: resource_size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_io_free_memtype_wc(start: resource_size_t, size: resource_size_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct resource {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " __iowrite32_copy - copy data to MMIO space, in 32-bit units"]
    #[doc = " @to: destination, in MMIO space (must be 32-bit aligned)"]
    #[doc = " @from: source (must be 32-bit aligned)"]
    #[doc = " @count: number of 32-bit quantities to copy"]
    #[doc = ""]
    #[doc = " Copy data from kernel space to MMIO space, in units of 32 bits at a"]
    #[doc = " time.  Order of access is not guaranteed, nor is a memory barrier"]
    #[doc = " performed afterwards."]
    pub fn __iowrite32_copy(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        count: size_t,
    );
}
extern "C" {
    #[doc = " __ioread32_copy - copy data from MMIO space, in 32-bit units"]
    #[doc = " @to: destination (must be 32-bit aligned)"]
    #[doc = " @from: source, in MMIO space (must be 32-bit aligned)"]
    #[doc = " @count: number of 32-bit quantities to copy"]
    #[doc = ""]
    #[doc = " Copy data from MMIO space to kernel space, in units of 32 bits at a"]
    #[doc = " time.  Order of access is not guaranteed, nor is a memory barrier"]
    #[doc = " performed afterwards."]
    pub fn __ioread32_copy(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        count: size_t,
    );
}
extern "C" {
    #[doc = " __iowrite64_copy - copy data to MMIO space, in 64-bit or 32-bit units"]
    #[doc = " @to: destination, in MMIO space (must be 64-bit aligned)"]
    #[doc = " @from: source (must be 64-bit aligned)"]
    #[doc = " @count: number of 64-bit quantities to copy"]
    #[doc = ""]
    #[doc = " Copy data from kernel space to MMIO space, in units of 32 or 64 bits at a"]
    #[doc = " time.  Order of access is not guaranteed, nor is a memory barrier"]
    #[doc = " performed afterwards."]
    pub fn __iowrite64_copy(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        count: size_t,
    );
}
extern "C" {
    pub fn ioremap_page_range(
        addr: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
        phys_addr: phys_addr_t,
        prot: pgprot_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devm_ioport_map(
        dev: *mut device,
        port: ::std::os::raw::c_ulong,
        nr: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn devm_ioport_unmap(dev: *mut device, addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn devm_ioremap(
        dev: *mut device,
        offset: resource_size_t,
        size: resource_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn devm_ioremap_uc(
        dev: *mut device,
        offset: resource_size_t,
        size: resource_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn devm_ioremap_wc(
        dev: *mut device,
        offset: resource_size_t,
        size: resource_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn devm_iounmap(dev: *mut device, addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn check_signature(
        io_addr: *const ::std::os::raw::c_void,
        signature: *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devm_ioremap_release(dev: *mut device, res: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn devm_memremap(
        dev: *mut device,
        offset: resource_size_t,
        size: size_t,
        flags: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn devm_memunmap(dev: *mut device, addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn devm_arch_phys_wc_add(
        dev: *mut device,
        base: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
pub const MEMREMAP_WB: ::std::os::raw::c_uint = 1;
pub const MEMREMAP_WT: ::std::os::raw::c_uint = 2;
pub const MEMREMAP_WC: ::std::os::raw::c_uint = 4;
pub const MEMREMAP_ENC: ::std::os::raw::c_uint = 8;
pub const MEMREMAP_DEC: ::std::os::raw::c_uint = 16;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
extern "C" {
    pub fn memremap(
        offset: resource_size_t,
        size: size_t,
        flags: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memunmap(addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn devm_arch_io_reserve_memtype_wc(
        dev: *mut device,
        start: resource_size_t,
        size: resource_size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __kstrtab___iowrite32_copy: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut __kstrtabns___iowrite32_copy: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut __UNIQUE_ID___addressable___iowrite32_copy65: *mut ::std::os::raw::c_void;
}
extern "C" {
    pub static mut __kstrtab___ioread32_copy: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut __kstrtabns___ioread32_copy: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut __UNIQUE_ID___addressable___ioread32_copy66: *mut ::std::os::raw::c_void;
}
extern "C" {
    pub static mut __kstrtab___iowrite64_copy: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut __kstrtabns___iowrite64_copy: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut __UNIQUE_ID___addressable___iowrite64_copy67: *mut ::std::os::raw::c_void;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct static_key_mod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct static_call_mod {
    pub _address: u8,
}
pub type dev_dma_attr = i32;
