/* automatically generated by rust-bindgen 0.56.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const CONFIG_RING_BUFFER: u32 = 1;
pub const CONFIG_HAVE_ARCH_SECCOMP_FILTER: u32 = 1;
pub const CONFIG_SND_PROC_FS: u32 = 1;
pub const CONFIG_SCSI_DMA: u32 = 1;
pub const CONFIG_TCP_MD5SIG: u32 = 1;
pub const CONFIG_KERNEL_GZIP: u32 = 1;
pub const CONFIG_CC_HAS_SANCOV_TRACE_PC: u32 = 1;
pub const CONFIG_DEFAULT_INIT: &'static [u8; 1usize] = b"\0";
pub const CONFIG_MICROCODE: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_VM_PGTABLE: u32 = 1;
pub const CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK: u32 = 1;
pub const CONFIG_INPUT_KEYBOARD: u32 = 1;
pub const CONFIG_INET_TABLE_PERTURB_ORDER: u32 = 16;
pub const CONFIG_ARCH_SUPPORTS_INT128: u32 = 1;
pub const CONFIG_SLUB_CPU_PARTIAL: u32 = 1;
pub const CONFIG_RFS_ACCEL: u32 = 1;
pub const CONFIG_ARCH_WANTS_THP_SWAP: u32 = 1;
pub const CONFIG_CRC32: u32 = 1;
pub const CONFIG_I2C_BOARDINFO: u32 = 1;
pub const CONFIG_X86_MCE: u32 = 1;
pub const CONFIG_SECCOMP: u32 = 1;
pub const CONFIG_HIGH_RES_TIMERS: u32 = 1;
pub const CONFIG_ARCH_HAS_SET_MEMORY: u32 = 1;
pub const CONFIG_BLK_DEV_DM: u32 = 1;
pub const CONFIG_IP_MULTIPLE_TABLES: u32 = 1;
pub const CONFIG_ACPI_BGRT: u32 = 1;
pub const CONFIG_FIRMWARE_MEMMAP: u32 = 1;
pub const CONFIG_FIX_EARLYCON_MEM: u32 = 1;
pub const CONFIG_XZ_DEC_IA64: u32 = 1;
pub const CONFIG_INOTIFY_USER: u32 = 1;
pub const CONFIG_HDMI: u32 = 1;
pub const CONFIG_SAMPLES: u32 = 1;
pub const CONFIG_NETWORK_FILESYSTEMS: u32 = 1;
pub const CONFIG_MODULE_FORCE_UNLOAD: u32 = 1;
pub const CONFIG_X86_MINIMUM_CPU_FAMILY: u32 = 64;
pub const CONFIG_CPU_FREQ_GOV_ONDEMAND: u32 = 1;
pub const CONFIG_GLOB: u32 = 1;
pub const CONFIG_ARCH_WANT_LD_ORPHAN_WARN: u32 = 1;
pub const CONFIG_SND_INTEL_SOUNDWIRE_ACPI: u32 = 1;
pub const CONFIG_CGROUP_DEVICE: u32 = 1;
pub const CONFIG_X86_TSC: u32 = 1;
pub const CONFIG_ARCH_SUSPEND_POSSIBLE: u32 = 1;
pub const CONFIG_MAC80211_STA_HASH_MAX_SIZE: u32 = 0;
pub const CONFIG_HAVE_ARCH_MMAP_RND_BITS: u32 = 1;
pub const CONFIG_HIBERNATION: u32 = 1;
pub const CONFIG_PNPACPI: u32 = 1;
pub const CONFIG_KASAN_STACK: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_ATTR_SET: u32 = 1;
pub const CONFIG_EXT4_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_ZSTD_COMPRESS: u32 = 1;
pub const CONFIG_DRM_I915: u32 = 1;
pub const CONFIG_BINFMT_MISC: u32 = 1;
pub const CONFIG_SSB_POSSIBLE: u32 = 1;
pub const CONFIG_NF_NAT_SIP: u32 = 1;
pub const CONFIG_HAVE_OBJTOOL: u32 = 1;
pub const CONFIG_MMU_NOTIFIER: u32 = 1;
pub const CONFIG_ASYMMETRIC_KEY_TYPE: u32 = 1;
pub const CONFIG_ACPI_PRMT: u32 = 1;
pub const CONFIG_ARCH_CORRECT_STACKTRACE_ON_KRETPROBE: u32 = 1;
pub const CONFIG_IP_NF_NAT_MODULE: u32 = 1;
pub const CONFIG_USB_OHCI_LITTLE_ENDIAN: u32 = 1;
pub const CONFIG_NET_SCH_FIFO: u32 = 1;
pub const CONFIG_SWPHY: u32 = 1;
pub const CONFIG_FSNOTIFY: u32 = 1;
pub const CONFIG_BLK_DEV_LOOP_MIN_COUNT: u32 = 8;
pub const CONFIG_NF_CONNTRACK_SIP: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER_DISABLE_TESTS: u32 = 1;
pub const CONFIG_HIDRAW: u32 = 1;
pub const CONFIG_HAVE_KERNEL_LZMA: u32 = 1;
pub const CONFIG_NET_PTP_CLASSIFY: u32 = 1;
pub const CONFIG_GENERIC_SMP_IDLE_THREAD: u32 = 1;
pub const CONFIG_NET_VENDOR_QUALCOMM: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_NUMA_BALANCING: u32 = 1;
pub const CONFIG_DYNAMIC_DEBUG: u32 = 1;
pub const CONFIG_NET_VENDOR_EZCHIP: u32 = 1;
pub const CONFIG_LDISC_AUTOLOAD: u32 = 1;
pub const CONFIG_SERIAL_8250_RSA: u32 = 1;
pub const CONFIG_FIB_RULES: u32 = 1;
pub const CONFIG_USB_AUTOSUSPEND_DELAY: u32 = 2;
pub const CONFIG_IP6_NF_MANGLE: u32 = 1;
pub const CONFIG_SCSI_CONSTANTS: u32 = 1;
pub const CONFIG_HAVE_IRQ_TIME_ACCOUNTING: u32 = 1;
pub const CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED: u32 = 1;
pub const CONFIG_IPV6: u32 = 1;
pub const CONFIG_HAVE_STACKPROTECTOR: u32 = 1;
pub const CONFIG_NET_9P: u32 = 1;
pub const CONFIG_CRYPTO_AEAD: u32 = 1;
pub const CONFIG_AUDIT_ARCH: u32 = 1;
pub const CONFIG_COMPAT: u32 = 1;
pub const CONFIG_MAGIC_SYSRQ_SERIAL: u32 = 1;
pub const CONFIG_BQL: u32 = 1;
pub const CONFIG_HAVE_KERNEL_BZIP2: u32 = 1;
pub const CONFIG_DEFAULT_TCP_CONG: &'static [u8; 6usize] = b"cubic\0";
pub const CONFIG_DEVTMPFS: u32 = 1;
pub const CONFIG_X86_INTEL_TSX_MODE_OFF: u32 = 1;
pub const CONFIG_TIGON3_HWMON: u32 = 1;
pub const CONFIG_BLK_CGROUP_IOLATENCY: u32 = 1;
pub const CONFIG_HSU_DMA: u32 = 1;
pub const CONFIG_YENTA_RICOH: u32 = 1;
pub const CONFIG_MOUSE_PS2_SMBUS: u32 = 1;
pub const CONFIG_IP6_NF_TARGET_REJECT: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX: u32 = 16;
pub const CONFIG_UPROBES: u32 = 1;
pub const CONFIG_ARCH_SPARSEMEM_ENABLE: u32 = 1;
pub const CONFIG_SAMPLE_TRACE_CUSTOM_EVENTS_MODULE: u32 = 1;
pub const CONFIG_HOTPLUG_CPU: u32 = 1;
pub const CONFIG_PM_SLEEP_DEBUG: u32 = 1;
pub const CONFIG_WLAN: u32 = 1;
pub const CONFIG_NAMESPACES: u32 = 1;
pub const CONFIG_BLK_RQ_ALLOC_TIME: u32 = 1;
pub const CONFIG_HAVE_CMPXCHG_DOUBLE: u32 = 1;
pub const CONFIG_ARCH_USE_MEMREMAP_PROT: u32 = 1;
pub const CONFIG_HAVE_ARCH_HUGE_VMAP: u32 = 1;
pub const CONFIG_IA32_EMULATION: u32 = 1;
pub const CONFIG_BLK_DEV_BSG: u32 = 1;
pub const CONFIG_CONNECTOR: u32 = 1;
pub const CONFIG_INTEGRITY: u32 = 1;
pub const CONFIG_EISA_PCI_EISA: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_MENU: u32 = 1;
pub const CONFIG_CRYPTO_RNG2: u32 = 1;
pub const CONFIG_THERMAL_WRITABLE_TRIPS: u32 = 1;
pub const CONFIG_MSDOS_FS: u32 = 1;
pub const CONFIG_NET_CLS_CGROUP: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MICROCHIP: u32 = 1;
pub const CONFIG_NET_VENDOR_DAVICOM: u32 = 1;
pub const CONFIG_SOFTIRQ_ON_OWN_STACK: u32 = 1;
pub const CONFIG_CFG80211: u32 = 1;
pub const CONFIG_PAGE_SIZE_LESS_THAN_256KB: u32 = 1;
pub const CONFIG_SAMPLE_TRACE_PRINTK_MODULE: u32 = 1;
pub const CONFIG_CPU_IBPB_ENTRY: u32 = 1;
pub const CONFIG_SERIAL_8250: u32 = 1;
pub const CONFIG_RANDOM_TRUST_CPU: u32 = 1;
pub const CONFIG_LZO_DECOMPRESS: u32 = 1;
pub const CONFIG_IOMMU_SUPPORT: u32 = 1;
pub const CONFIG_HID_BELKIN: u32 = 1;
pub const CONFIG_WLAN_VENDOR_CISCO: u32 = 1;
pub const CONFIG_COMPAT_BINFMT_ELF: u32 = 1;
pub const CONFIG_X86_DIRECT_GBPAGES: u32 = 1;
pub const CONFIG_RD_LZMA: u32 = 1;
pub const CONFIG_USB: u32 = 1;
pub const CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK: u32 = 1;
pub const CONFIG_PRINTK_CALLER: u32 = 1;
pub const CONFIG_MODULES_USE_ELF_RELA: u32 = 1;
pub const CONFIG_CRYPTO_HMAC: u32 = 1;
pub const CONFIG_WLAN_VENDOR_REALTEK: u32 = 1;
pub const CONFIG_ETHERNET: u32 = 1;
pub const CONFIG_SCHED_OMIT_FRAME_POINTER: u32 = 1;
pub const CONFIG_BRANCH_PROFILE_NONE: u32 = 1;
pub const CONFIG_X86_IOPL_IOPERM: u32 = 1;
pub const CONFIG_SND_HRTIMER: u32 = 1;
pub const CONFIG_HAVE_DMA_CONTIGUOUS: u32 = 1;
pub const CONFIG_DQL: u32 = 1;
pub const CONFIG_DM_ZERO: u32 = 1;
pub const CONFIG_X86_SUPPORTS_MEMORY_FAILURE: u32 = 1;
pub const CONFIG_SND_SEQUENCER: u32 = 1;
pub const CONFIG_SOCK_CGROUP_DATA: u32 = 1;
pub const CONFIG_COREDUMP: u32 = 1;
pub const CONFIG_EXT4_DEBUG: u32 = 1;
pub const CONFIG_HID_CHERRY: u32 = 1;
pub const CONFIG_USE_PERCPU_NUMA_NODE_ID: u32 = 1;
pub const CONFIG_HID_SUNPLUS: u32 = 1;
pub const CONFIG_PREEMPT_DYNAMIC: u32 = 1;
pub const CONFIG_BCMA_POSSIBLE: u32 = 1;
pub const CONFIG_NF_LOG_IPV4_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_CIRRUS: u32 = 1;
pub const CONFIG_VGA_ARB: u32 = 1;
pub const CONFIG_SATA_HOST: u32 = 1;
pub const CONFIG_SCSI_COMMON: u32 = 1;
pub const CONFIG_SURFACE_PLATFORMS: u32 = 1;
pub const CONFIG_DRM_NOMODESET: u32 = 1;
pub const CONFIG_NET_POLL_CONTROLLER: u32 = 1;
pub const CONFIG_PRINTK: u32 = 1;
pub const CONFIG_FORCEDETH: u32 = 1;
pub const CONFIG_ACPI_LPIT: u32 = 1;
pub const CONFIG_TIMERFD: u32 = 1;
pub const CONFIG_DNS_RESOLVER: u32 = 1;
pub const CONFIG_TRACEPOINTS: u32 = 1;
pub const CONFIG_MTD_CFI_I2: u32 = 1;
pub const CONFIG_CRYPTO_AUTHENC: u32 = 1;
pub const CONFIG_YENTA: u32 = 1;
pub const CONFIG_NET_EMATCH_STACK: u32 = 32;
pub const CONFIG_DRM_I915_PREEMPT_TIMEOUT: u32 = 640;
pub const CONFIG_ARCH_HAS_SYSCALL_WRAPPER: u32 = 1;
pub const CONFIG_COMPAT_32BIT_TIME: u32 = 1;
pub const CONFIG_SHMEM: u32 = 1;
pub const CONFIG_MTD: u32 = 1;
pub const CONFIG_MIGRATION: u32 = 1;
pub const CONFIG_HAVE_ARCH_JUMP_LABEL: u32 = 1;
pub const CONFIG_BUILD_SALT: &'static [u8; 1usize] = b"\0";
pub const CONFIG_HAVE_ARCH_PREL32_RELOCATIONS: u32 = 1;
pub const CONFIG_DECOMPRESS_LZMA: u32 = 1;
pub const CONFIG_DEVTMPFS_MOUNT: u32 = 1;
pub const CONFIG_EXCLUSIVE_SYSTEM_RAM: u32 = 1;
pub const CONFIG_HAVE_PREEMPT_DYNAMIC: u32 = 1;
pub const CONFIG_DNOTIFY: u32 = 1;
pub const CONFIG_X86_VMX_FEATURE_NAMES: u32 = 1;
pub const CONFIG_EFI_CUSTOM_SSDT_OVERLAYS: u32 = 1;
pub const CONFIG_GENERIC_NET_UTILS: u32 = 1;
pub const CONFIG_ATA: u32 = 1;
pub const CONFIG_HAVE_ARCH_KMSAN: u32 = 1;
pub const CONFIG_NLS_CODEPAGE_437: u32 = 1;
pub const CONFIG_HAVE_ARCH_SOFT_DIRTY: u32 = 1;
pub const CONFIG_PATA_TIMINGS: u32 = 1;
pub const CONFIG_ARCH_PROC_KCORE_TEXT: u32 = 1;
pub const CONFIG_EXPORTFS: u32 = 1;
pub const CONFIG_I2C_SLAVE_EEPROM: u32 = 1;
pub const CONFIG_IP_MROUTE_COMMON: u32 = 1;
pub const CONFIG_NET_INGRESS: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_ERROR_INJECTION: u32 = 1;
pub const CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT: u32 = 1;
pub const CONFIG_OLD_SIGSUSPEND3: u32 = 1;
pub const CONFIG_SERIO: u32 = 1;
pub const CONFIG_SCHEDSTATS: u32 = 1;
pub const CONFIG_INPUT_MOUSE: u32 = 1;
pub const CONFIG_HOTPLUG_SMT: u32 = 1;
pub const CONFIG_X86: u32 = 1;
pub const CONFIG_SUNRPC_GSS: u32 = 1;
pub const CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS: u32 = 1;
pub const CONFIG_TIGON3: u32 = 1;
pub const CONFIG_KCMP: u32 = 1;
pub const CONFIG_NETCONSOLE: u32 = 1;
pub const CONFIG_RTC_INTF_SYSFS: u32 = 1;
pub const CONFIG_I2C_SLAVE_TESTUNIT: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_COMMON: u32 = 1;
pub const CONFIG_BLK_DEV_INITRD: u32 = 1;
pub const CONFIG_X86_MCE_AMD: u32 = 1;
pub const CONFIG_PCPU_DEV_REFCNT: u32 = 1;
pub const CONFIG_DRM_VIRTIO_GPU: u32 = 1;
pub const CONFIG_EFI_DXE_MEM_ATTRIBUTES: u32 = 1;
pub const CONFIG_GDB_SCRIPTS: u32 = 1;
pub const CONFIG_ZLIB_INFLATE: u32 = 1;
pub const CONFIG_NET_VENDOR_SYNOPSYS: u32 = 1;
pub const CONFIG_HWMON: u32 = 1;
pub const CONFIG_INTEL_GTT: u32 = 1;
pub const CONFIG_NET_VENDOR_DLINK: u32 = 1;
pub const CONFIG_AUDITSYSCALL: u32 = 1;
pub const CONFIG_X86_ACPI_CPUFREQ_CPB: u32 = 1;
pub const CONFIG_IP_PNP: u32 = 1;
pub const CONFIG_CLKBLD_I8253: u32 = 1;
pub const CONFIG_RTC_INTF_PROC: u32 = 1;
pub const CONFIG_DRM_DISPLAY_HDCP_HELPER: u32 = 1;
pub const CONFIG_DYNAMIC_DEBUG_CORE: u32 = 1;
pub const CONFIG_ARCH_USE_BUILTIN_BSWAP: u32 = 1;
pub const CONFIG_PERF_EVENTS_INTEL_RAPL: u32 = 1;
pub const CONFIG_CC_IMPLICIT_FALLTHROUGH: &'static [u8; 25usize] = b"-Wimplicit-fallthrough=5\0";
pub const CONFIG_CPU_IDLE_GOV_MENU: u32 = 1;
pub const CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL: u32 = 1;
pub const CONFIG_SERIAL_8250_LPSS: u32 = 1;
pub const CONFIG_ACPI_FAN: u32 = 1;
pub const CONFIG_STACKTRACE_SUPPORT: u32 = 1;
pub const CONFIG_RCU_TRACE: u32 = 1;
pub const CONFIG_OUTPUT_FORMAT: &'static [u8; 13usize] = b"elf64-x86-64\0";
pub const CONFIG_ACPI: u32 = 1;
pub const CONFIG_USB_UHCI_HCD: u32 = 1;
pub const CONFIG_NVRAM: u32 = 1;
pub const CONFIG_LOCKD: u32 = 1;
pub const CONFIG_ARCH_MIGHT_HAVE_ACPI_PDC: u32 = 1;
pub const CONFIG_CRYPTO_LIB_ARC4: u32 = 1;
pub const CONFIG_CRYPTO_LIB_AES: u32 = 1;
pub const CONFIG_WLAN_VENDOR_RALINK: u32 = 1;
pub const CONFIG_CRYPTO_KPP2: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROCHIP: u32 = 1;
pub const CONFIG_HAVE_UACCESS_VALIDATION: u32 = 1;
pub const CONFIG_MTRR: u32 = 1;
pub const CONFIG_NO_HZ_IDLE: u32 = 1;
pub const CONFIG_NET_VENDOR_ADAPTEC: u32 = 1;
pub const CONFIG_CFG80211_REQUIRE_SIGNED_REGDB: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_NO_PATCHABLE: u32 = 1;
pub const CONFIG_MOUSE_PS2_BYD: u32 = 1;
pub const CONFIG_BSD_PROCESS_ACCT: u32 = 1;
pub const CONFIG_INPUT_TABLET: u32 = 1;
pub const CONFIG_SOCK_RX_QUEUE_MAPPING: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_HMAC: u32 = 1;
pub const CONFIG_DRM_BRIDGE: u32 = 1;
pub const CONFIG_HPET_EMULATE_RTC: u32 = 1;
pub const CONFIG_X86_MPPARSE: u32 = 1;
pub const CONFIG_NET_VENDOR_SILAN: u32 = 1;
pub const CONFIG_EEEPC_LAPTOP: u32 = 1;
pub const CONFIG_USB_STORAGE: u32 = 1;
pub const CONFIG_NET_VENDOR_BROADCOM: u32 = 1;
pub const CONFIG_NETFILTER_SKIP_EGRESS: u32 = 1;
pub const CONFIG_GENERIC_CPU_AUTOPROBE: u32 = 1;
pub const CONFIG_STANDALONE: u32 = 1;
pub const CONFIG_SCHED_MC: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_PERFORMANCE: u32 = 1;
pub const CONFIG_EFI: u32 = 1;
pub const CONFIG_RATIONAL: u32 = 1;
pub const CONFIG_I2C_MUX: u32 = 1;
pub const CONFIG_AGP_AMD64: u32 = 1;
pub const CONFIG_WLAN_VENDOR_INTEL: u32 = 1;
pub const CONFIG_HAVE_SETUP_PER_CPU_AREA: u32 = 1;
pub const CONFIG_DRM_I915_USERPTR: u32 = 1;
pub const CONFIG_SYSTEM_TRUSTED_KEYRING: u32 = 1;
pub const CONFIG_GENERIC_EARLY_IOREMAP: u32 = 1;
pub const CONFIG_NET_VENDOR_WANGXUN: u32 = 1;
pub const CONFIG_BLOCK: u32 = 1;
pub const CONFIG_ARCH_STACKWALK: u32 = 1;
pub const CONFIG_HID_APPLE: u32 = 1;
pub const CONFIG_INIT_ENV_ARG_LIMIT: u32 = 32;
pub const CONFIG_SAMPLE_TRACE_ARRAY_MODULE: u32 = 1;
pub const CONFIG_ROOT_NFS: u32 = 1;
pub const CONFIG_SAMPLE_KPROBES_MODULE: u32 = 1;
pub const CONFIG_AF_UNIX_OOB: u32 = 1;
pub const CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH: u32 = 1;
pub const CONFIG_CPU_SUP_INTEL: u32 = 1;
pub const CONFIG_TMPFS_POSIX_ACL: u32 = 1;
pub const CONFIG_STRICT_KERNEL_RWX: u32 = 1;
pub const CONFIG_HAVE_ARCH_KCSAN: u32 = 1;
pub const CONFIG_PROVIDE_OHCI1394_DMA_INIT: u32 = 1;
pub const CONFIG_BUG: u32 = 1;
pub const CONFIG_CONTEXT_SWITCH_TRACER: u32 = 1;
pub const CONFIG_MAC80211_HAS_RC: u32 = 1;
pub const CONFIG_LOGIWHEELS_FF: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_WX: u32 = 1;
pub const CONFIG_PANTHERLORD_FF: u32 = 1;
pub const CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE: u32 = 1;
pub const CONFIG_PM: u32 = 1;
pub const CONFIG_PPS: u32 = 1;
pub const CONFIG_NETFILTER_XTABLES_COMPAT: u32 = 1;
pub const CONFIG_GENERIC_ISA_DMA: u32 = 1;
pub const CONFIG_RTC_SYSTOHC_DEVICE: &'static [u8; 5usize] = b"rtc0\0";
pub const CONFIG_NF_CONNTRACK_IRC: u32 = 1;
pub const CONFIG_NET_FAILOVER: u32 = 1;
pub const CONFIG_WLAN_VENDOR_PURELIFI: u32 = 1;
pub const CONFIG_PSAMPLE: u32 = 1;
pub const CONFIG_IO_URING: u32 = 1;
pub const CONFIG_VT: u32 = 1;
pub const CONFIG_HAVE_KERNEL_ZSTD: u32 = 1;
pub const CONFIG_VMAP_PFN: u32 = 1;
pub const CONFIG_HID_REDRAGON: u32 = 1;
pub const CONFIG_SECRETMEM: u32 = 1;
pub const CONFIG_PCI_ATS: u32 = 1;
pub const CONFIG_DMA_ACPI: u32 = 1;
pub const CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED: u32 = 1;
pub const CONFIG_SPLIT_PTLOCK_CPUS: u32 = 4;
pub const CONFIG_SBITMAP: u32 = 1;
pub const CONFIG_POWER_SUPPLY: u32 = 1;
pub const CONFIG_CRYPTO_ZSTD: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_BOOTPARAM: u32 = 1;
pub const CONFIG_ARCH_HAS_UACCESS_FLUSHCACHE: u32 = 1;
pub const CONFIG_CRYPTO_SKCIPHER2: u32 = 1;
pub const CONFIG_NETLABEL: u32 = 1;
pub const CONFIG_NLS: u32 = 1;
pub const CONFIG_ARCH_WANTS_NO_INSTR: u32 = 1;
pub const CONFIG_AS_IS_GNU: u32 = 1;
pub const CONFIG_KASAN_GENERIC: u32 = 1;
pub const CONFIG_SAMPLE_WATCHDOG: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_SECMARK: u32 = 1;
pub const CONFIG_X86_INTEL_PSTATE: u32 = 1;
pub const CONFIG_ZONE_DMA: u32 = 1;
pub const CONFIG_ACPI_I2C_OPREGION: u32 = 1;
pub const CONFIG_SAMPLE_KFIFO_MODULE: u32 = 1;
pub const CONFIG_SND_SEQ_DEVICE: u32 = 1;
pub const CONFIG_SYN_COOKIES: u32 = 1;
pub const CONFIG_HAVE_NOINSTR_VALIDATION: u32 = 1;
pub const CONFIG_IRQ_WORK: u32 = 1;
pub const CONFIG_PCI_MSI: u32 = 1;
pub const CONFIG_IP_ADVANCED_ROUTER: u32 = 1;
pub const CONFIG_HAVE_ARCH_RANDOMIZE_KSTACK_OFFSET: u32 = 1;
pub const CONFIG_X86_64_SMP: u32 = 1;
pub const CONFIG_USB_EHCI_PCI: u32 = 1;
pub const CONFIG_NET_VENDOR_FUJITSU: u32 = 1;
pub const CONFIG_SPARSEMEM_EXTREME: u32 = 1;
pub const CONFIG_USB_COMMON: u32 = 1;
pub const CONFIG_TASK_XACCT: u32 = 1;
pub const CONFIG_DRM_DISPLAY_HDMI_HELPER: u32 = 1;
pub const CONFIG_IP6_NF_IPTABLES: u32 = 1;
pub const CONFIG_LZ4_COMPRESS: u32 = 1;
pub const CONFIG_VIRTIO_ANCHOR: u32 = 1;
pub const CONFIG_SAMPLE_AUXDISPLAY: u32 = 1;
pub const CONFIG_FIXED_PHY: u32 = 1;
pub const CONFIG_ARCH_HAS_SYNC_CORE_BEFORE_USERMODE: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_USERSPACE: u32 = 1;
pub const CONFIG_AS_TPAUSE: u32 = 1;
pub const CONFIG_LOG_CPU_MAX_BUF_SHIFT: u32 = 12;
pub const CONFIG_BLK_DEV_DM_BUILTIN: u32 = 1;
pub const CONFIG_TASKS_RCU: u32 = 1;
pub const CONFIG_VGA_ARB_MAX_GPUS: u32 = 16;
pub const CONFIG_PCMCIA: u32 = 1;
pub const CONFIG_EVENT_TRACING: u32 = 1;
pub const CONFIG_PAGE_TABLE_ISOLATION: u32 = 1;
pub const CONFIG_AS_SHA1_NI: u32 = 1;
pub const CONFIG_HID_CYPRESS: u32 = 1;
pub const CONFIG_SG_POOL: u32 = 1;
pub const CONFIG_DRM_KMS_HELPER: u32 = 1;
pub const CONFIG_NET_VENDOR_PACKET_ENGINES: u32 = 1;
pub const CONFIG_BLK_MQ_PCI: u32 = 1;
pub const CONFIG_PREEMPT_VOLUNTARY: u32 = 1;
pub const CONFIG_NLS_ISO8859_1: u32 = 1;
pub const CONFIG_MACINTOSH_DRIVERS: u32 = 1;
pub const CONFIG_R8169: u32 = 1;
pub const CONFIG_HID_KENSINGTON: u32 = 1;
pub const CONFIG_USB_EHCI_HCD: u32 = 1;
pub const CONFIG_FS_IOMAP: u32 = 1;
pub const CONFIG_8139TOO: u32 = 1;
pub const CONFIG_HAVE_EISA: u32 = 1;
pub const CONFIG_COMPACT_UNEVICTABLE_DEFAULT: u32 = 1;
pub const CONFIG_RD_ZSTD: u32 = 1;
pub const CONFIG_RFKILL: u32 = 1;
pub const CONFIG_NETDEVICES: u32 = 1;
pub const CONFIG_ARCH_HAS_KCOV: u32 = 1;
pub const CONFIG_CGROUP_FREEZER: u32 = 1;
pub const CONFIG_HAVE_ARCH_STACKLEAK: u32 = 1;
pub const CONFIG_EVENTFD: u32 = 1;
pub const CONFIG_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_IPV6_SIT: u32 = 1;
pub const CONFIG_XFRM: u32 = 1;
pub const CONFIG_ARCH_HAS_PMEM_API: u32 = 1;
pub const CONFIG_HAVE_KPROBES_ON_FTRACE: u32 = 1;
pub const CONFIG_YENTA_TOSHIBA: u32 = 1;
pub const CONFIG_SERIAL_8250_CONSOLE: u32 = 1;
pub const CONFIG_DRM_BUDDY: u32 = 1;
pub const CONFIG_USB_ANNOUNCE_NEW_DEVICES: u32 = 1;
pub const CONFIG_JUMP_LABEL: u32 = 1;
pub const CONFIG_IP_NF_TARGET_MASQUERADE_MODULE: u32 = 1;
pub const CONFIG_USERMODE_DRIVER: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_DISABLE: u32 = 1;
pub const CONFIG_HAVE_EBPF_JIT: u32 = 1;
pub const CONFIG_CRYPTO_LZ4: u32 = 1;
pub const CONFIG_PROC_PAGE_MONITOR: u32 = 1;
pub const CONFIG_SERIAL_8250_EXTENDED: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_MASQUERADE_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_DETECT_IRQ: u32 = 1;
pub const CONFIG_IGB_HWMON: u32 = 1;
pub const CONFIG_BPF: u32 = 1;
pub const CONFIG_DRM_USE_DYNAMIC_DEBUG: u32 = 1;
pub const CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK: u32 = 1;
pub const CONFIG_X86_CMOV: u32 = 1;
pub const CONFIG_ACPI_HOTPLUG_CPU: u32 = 1;
pub const CONFIG_PM_TRACE_RTC: u32 = 1;
pub const CONFIG_RD_LZO: u32 = 1;
pub const CONFIG_KPROBE_EVENTS: u32 = 1;
pub const CONFIG_SCSI_SPI_ATTRS: u32 = 1;
pub const CONFIG_ARCH_HAS_COPY_MC: u32 = 1;
pub const CONFIG_MICROCODE_AMD: u32 = 1;
pub const CONFIG_NF_CONNTRACK_SECMARK: u32 = 1;
pub const CONFIG_INSTRUCTION_DECODER: u32 = 1;
pub const CONFIG_CRYPTO_SHA512: u32 = 1;
pub const CONFIG_BACKLIGHT_CLASS_DEVICE: u32 = 1;
pub const CONFIG_CC_HAS_ASM_INLINE: u32 = 1;
pub const CONFIG_CRYPTO_NULL: u32 = 1;
pub const CONFIG_NET_VENDOR_SEEQ: u32 = 1;
pub const CONFIG_NF_DEFRAG_IPV4: u32 = 1;
pub const CONFIG_INTEL_IOMMU_FLOPPY_WA: u32 = 1;
pub const CONFIG_VIRTIO_CONSOLE: u32 = 1;
pub const CONFIG_ARCH_CLOCKSOURCE_INIT: u32 = 1;
pub const CONFIG_BFS_FS: u32 = 1;
pub const CONFIG_PM_DEBUG: u32 = 1;
pub const CONFIG_CRYPTO_DEFLATE: u32 = 1;
pub const CONFIG_GENERIC_STRNLEN_USER: u32 = 1;
pub const CONFIG_IGB: u32 = 1;
pub const CONFIG_WLAN_VENDOR_RSI: u32 = 1;
pub const CONFIG_CRYPTO_JITTERENTROPY: u32 = 1;
pub const CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION: u32 = 1;
pub const CONFIG_CRYPTO_GCM: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK_LOG: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE: u32 = 1;
pub const CONFIG_CDROM: u32 = 1;
pub const CONFIG_MAGIC_SYSRQ: u32 = 1;
pub const CONFIG_E100: u32 = 1;
pub const CONFIG_IO_DELAY_0X80: u32 = 1;
pub const CONFIG_DMI: u32 = 1;
pub const CONFIG_NET_VENDOR_RDC: u32 = 1;
pub const CONFIG_PGTABLE_LEVELS: u32 = 5;
pub const CONFIG_CPUSETS: u32 = 1;
pub const CONFIG_MAC80211_RC_DEFAULT_MINSTREL: u32 = 1;
pub const CONFIG_SPARSE_IRQ: u32 = 1;
pub const CONFIG_IP_NF_MANGLE: u32 = 1;
pub const CONFIG_RCU_STALL_COMMON: u32 = 1;
pub const CONFIG_CPU_SUP_AMD: u32 = 1;
pub const CONFIG_PCIEPORTBUS: u32 = 1;
pub const CONFIG_DEBUG_BUGVERBOSE: u32 = 1;
pub const CONFIG_I2C_DEBUG_BUS: u32 = 1;
pub const CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK: u32 = 1;
pub const CONFIG_IP_NF_FILTER: u32 = 1;
pub const CONFIG_DYNAMIC_MEMORY_LAYOUT: u32 = 1;
pub const CONFIG_HAVE_BUILDTIME_MCOUNT_SORT: u32 = 1;
pub const CONFIG_MODULES_TREE_LOOKUP: u32 = 1;
pub const CONFIG_FAT_FS: u32 = 1;
pub const CONFIG_SND_HDA_INTEL: u32 = 1;
pub const CONFIG_BUILDTIME_TABLE_SORT: u32 = 1;
pub const CONFIG_NVMEM: u32 = 1;
pub const CONFIG_INET_TUNNEL: u32 = 1;
pub const CONFIG_X86_INTERNODE_CACHE_SHIFT: u32 = 6;
pub const CONFIG_NF_LOG_ARP_MODULE: u32 = 1;
pub const CONFIG_NET_9P_VIRTIO: u32 = 1;
pub const CONFIG_X86_CHECK_BIOS_CORRUPTION: u32 = 1;
pub const CONFIG_BLOCK_HOLDER_DEPRECATED: u32 = 1;
pub const CONFIG_RETHUNK: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS: u32 = 1;
pub const CONFIG_OID_REGISTRY: u32 = 1;
pub const CONFIG_AS_SHA256_NI: u32 = 1;
pub const CONFIG_HAVE_KERNEL_XZ: u32 = 1;
pub const CONFIG_GCC12_NO_ARRAY_BOUNDS: u32 = 1;
pub const CONFIG_X86_PKG_TEMP_THERMAL_MODULE: u32 = 1;
pub const CONFIG_RFKILL_LEDS: u32 = 1;
pub const CONFIG_CONSOLE_TRANSLATIONS: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_ATOMIC_RMW: u32 = 1;
pub const CONFIG_STACKTRACE_BUILD_ID: u32 = 1;
pub const CONFIG_SND_X86: u32 = 1;
pub const CONFIG_PCMCIA_LOAD_CIS: u32 = 1;
pub const CONFIG_SERIAL_EARLYCON: u32 = 1;
pub const CONFIG_NET_VENDOR_NI: u32 = 1;
pub const CONFIG_DEBUG_DEVRES: u32 = 1;
pub const CONFIG_CRYPTO_AKCIPHER: u32 = 1;
pub const CONFIG_ETHTOOL_NETLINK: u32 = 1;
pub const CONFIG_ACPI_CPU_FREQ_PSS: u32 = 1;
pub const CONFIG_CPU_FREQ: u32 = 1;
pub const CONFIG_USB_OHCI_HCD: u32 = 1;
pub const CONFIG_NR_CPUS_DEFAULT: u32 = 64;
pub const CONFIG_DM_MIRROR: u32 = 1;
pub const CONFIG_ARCH_CPUIDLE_HALTPOLL: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE: u32 = 1;
pub const CONFIG_MMU_GATHER_MERGE_VMAS: u32 = 1;
pub const CONFIG_USB_PCI: u32 = 1;
pub const CONFIG_NLS_ASCII: u32 = 1;
pub const CONFIG_NF_REJECT_IPV4: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS_MAX: u32 = 32;
pub const CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE: u32 = 1;
pub const CONFIG_TRACE_IRQFLAGS_SUPPORT: u32 = 1;
pub const CONFIG_NFS_V3_ACL: u32 = 1;
pub const CONFIG_CRYPTO_CCM: u32 = 1;
pub const CONFIG_TCP_CONG_ADVANCED: u32 = 1;
pub const CONFIG_KASAN_SHADOW_OFFSET: i64 = -2305847407260205056;
pub const CONFIG_KVM_GUEST: u32 = 1;
pub const CONFIG_FONT_AUTOSELECT: u32 = 1;
pub const CONFIG_QFMT_V2: u32 = 1;
pub const CONFIG_BLK_CGROUP: u32 = 1;
pub const CONFIG_LEDS_TRIGGERS: u32 = 1;
pub const CONFIG_CRYPTO_RNG: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN: u32 = 8;
pub const CONFIG_CRYPTO_LIB_UTILS: u32 = 1;
pub const CONFIG_SND_USB: u32 = 1;
pub const CONFIG_RD_GZIP: u32 = 1;
pub const CONFIG_ARCH_HAS_CPU_RELAX: u32 = 1;
pub const CONFIG_HAVE_REGS_AND_STACK_ACCESS_API: u32 = 1;
pub const CONFIG_BLK_PM: u32 = 1;
pub const CONFIG_BLK_CGROUP_IOPRIO: u32 = 1;
pub const CONFIG_MDIO_BUS: u32 = 1;
pub const CONFIG_TREE_RCU: u32 = 1;
pub const CONFIG_ALLOW_DEV_COREDUMP: u32 = 1;
pub const CONFIG_SWIOTLB: u32 = 1;
pub const CONFIG_EXT4_FS_SECURITY: u32 = 1;
pub const CONFIG_GRO_CELLS: u32 = 1;
pub const CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN: u32 = 1;
pub const CONFIG_PCI_MSI_IRQ_DOMAIN: u32 = 1;
pub const CONFIG_CRYPTO_MD5: u32 = 1;
pub const CONFIG_CLOCKSOURCE_VALIDATE_LAST_CYCLE: u32 = 1;
pub const CONFIG_ATA_ACPI: u32 = 1;
pub const CONFIG_X86_EXTENDED_PLATFORM: u32 = 1;
pub const CONFIG_P2SB: u32 = 1;
pub const CONFIG_NET_VENDOR_CORTINA: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR: u32 = 1;
pub const CONFIG_ELFCORE: u32 = 1;
pub const CONFIG_HIBERNATION_SNAPSHOT_DEV: u32 = 1;
pub const CONFIG_HAVE_KVM: u32 = 1;
pub const CONFIG_PCCARD: u32 = 1;
pub const CONFIG_INIT_STACK_NONE: u32 = 1;
pub const CONFIG_BINFMT_ELF: u32 = 1;
pub const CONFIG_SCSI_PROC_FS: u32 = 1;
pub const CONFIG_HAVE_PERF_REGS: u32 = 1;
pub const CONFIG_DRM_I915_USERFAULT_AUTOSUSPEND: u32 = 250;
pub const CONFIG_IP_PIMSM_V1: u32 = 1;
pub const CONFIG_INET6_AH: u32 = 1;
pub const CONFIG_NET_VENDOR_ALTEON: u32 = 1;
pub const CONFIG_USB_MON: u32 = 1;
pub const CONFIG_NET_VENDOR_RENESAS: u32 = 1;
pub const CONFIG_KEYS: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR_CSTATE: u32 = 1;
pub const CONFIG_SND_VMASTER: u32 = 1;
pub const CONFIG_NETFILTER_XT_MARK_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XTABLES: u32 = 1;
pub const CONFIG_DRM_PANEL_ORIENTATION_QUIRKS: u32 = 1;
pub const CONFIG_CRYPTO_ECHAINIV: u32 = 1;
pub const CONFIG_HAVE_ARCH_AUDITSYSCALL: u32 = 1;
pub const CONFIG_BOOT_PRINTK_DELAY: u32 = 1;
pub const CONFIG_PM_SLEEP_SMP: u32 = 1;
pub const CONFIG_X86_16BIT: u32 = 1;
pub const CONFIG_CRYPTO_HW: u32 = 1;
pub const CONFIG_X86_VERBOSE_BOOTUP: u32 = 1;
pub const CONFIG_PCSPKR_PLATFORM: u32 = 1;
pub const CONFIG_HAVE_LIVEPATCH: u32 = 1;
pub const CONFIG_CARDBUS: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_WITH_ARGS: u32 = 1;
pub const CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE: u32 = 1;
pub const CONFIG_KALLSYMS_ABSOLUTE_PERCPU: u32 = 1;
pub const CONFIG_CPU_IBRS_ENTRY: u32 = 1;
pub const CONFIG_ACPI_AC: u32 = 1;
pub const CONFIG_HARDIRQS_SW_RESEND: u32 = 1;
pub const CONFIG_ACPI_HOTPLUG_IOAPIC: u32 = 1;
pub const CONFIG_HID_GYRATION: u32 = 1;
pub const CONFIG_THERMAL_HWMON: u32 = 1;
pub const CONFIG_CRYPTO_SKCIPHER: u32 = 1;
pub const CONFIG_XZ_DEC_X86: u32 = 1;
pub const CONFIG_MAC80211_LEDS: u32 = 1;
pub const CONFIG_HIBERNATE_CALLBACKS: u32 = 1;
pub const CONFIG_EISA: u32 = 1;
pub const CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS: u32 = 0;
pub const CONFIG_CONSOLE_LOGLEVEL_QUIET: u32 = 4;
pub const CONFIG_CRC16: u32 = 1;
pub const CONFIG_GENERIC_CALIBRATE_DELAY: u32 = 1;
pub const CONFIG_CRYPTO_GF128MUL: u32 = 1;
pub const CONFIG_UPROBE_EVENTS: u32 = 1;
pub const CONFIG_NET_CLS: u32 = 1;
pub const CONFIG_TMPFS: u32 = 1;
pub const CONFIG_NET_VENDOR_NETERION: u32 = 1;
pub const CONFIG_RANDSTRUCT_NONE: u32 = 1;
pub const CONFIG_FUTEX: u32 = 1;
pub const CONFIG_IP_PNP_DHCP: u32 = 1;
pub const CONFIG_VIRTIO_PCI: u32 = 1;
pub const CONFIG_UNIX_SCM: u32 = 1;
pub const CONFIG_CONSOLE_LOGLEVEL_DEFAULT: u32 = 7;
pub const CONFIG_ARCH_HAS_FAST_MULTIPLIER: u32 = 1;
pub const CONFIG_NET_VENDOR_REALTEK: u32 = 1;
pub const CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG: u32 = 1;
pub const CONFIG_DRM_I915_CAPTURE_ERROR: u32 = 1;
pub const CONFIG_SECURITY_NETWORK: u32 = 1;
pub const CONFIG_SERIAL_CORE_CONSOLE: u32 = 1;
pub const CONFIG_ACPI_CPPC_LIB: u32 = 1;
pub const CONFIG_HUGETLB_PAGE: u32 = 1;
pub const CONFIG_NET_VENDOR_EMULEX: u32 = 1;
pub const CONFIG_USB_HID: u32 = 1;
pub const CONFIG_USER_STACKTRACE_SUPPORT: u32 = 1;
pub const CONFIG_SLUB_DEBUG: u32 = 1;
pub const CONFIG_BLK_DEV_MD: u32 = 1;
pub const CONFIG_UCS2_STRING: u32 = 1;
pub const CONFIG_MAC_EMUMOUSEBTN: u32 = 1;
pub const CONFIG_DMADEVICES: u32 = 1;
pub const CONFIG_PAHOLE_VERSION: u32 = 0;
pub const CONFIG_ARCH_SUPPORTS_CFI_CLANG: u32 = 1;
pub const CONFIG_IPV6_NDISC_NODETYPE: u32 = 1;
pub const CONFIG_PCI_LABEL: u32 = 1;
pub const CONFIG_HAVE_OBJTOOL_MCOUNT: u32 = 1;
pub const CONFIG_ARCH_WANT_DEFAULT_BPF_JIT: u32 = 1;
pub const CONFIG_SGETMASK_SYSCALL: u32 = 1;
pub const CONFIG_CGROUP_SCHED: u32 = 1;
pub const CONFIG_QUEUED_RWLOCKS: u32 = 1;
pub const CONFIG_SYSVIPC: u32 = 1;
pub const CONFIG_ARCH_HAS_GIGANTIC_PAGE: u32 = 1;
pub const CONFIG_HAVE_DEBUG_KMEMLEAK: u32 = 1;
pub const CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT: u32 = 13;
pub const CONFIG_NF_CONNTRACK_FTP: u32 = 1;
pub const CONFIG_PAGE_SIZE_LESS_THAN_64KB: u32 = 1;
pub const CONFIG_MODULES: u32 = 1;
pub const CONFIG_CONTEXT_TRACKING: u32 = 1;
pub const CONFIG_MQ_IOSCHED_DEADLINE: u32 = 1;
pub const CONFIG_USB_HIDDEV: u32 = 1;
pub const CONFIG_IOMMU_IOVA: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE_COLUMNS: u32 = 80;
pub const CONFIG_XXHASH: u32 = 1;
pub const CONFIG_SOUND: u32 = 1;
pub const CONFIG_JOLIET: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE: u32 = 1;
pub const CONFIG_ARCH_HIBERNATION_POSSIBLE: u32 = 1;
pub const CONFIG_ARCH_USE_SYM_ANNOTATIONS: u32 = 1;
pub const CONFIG_IA32_FEAT_CTL: u32 = 1;
pub const CONFIG_UNIX: u32 = 1;
pub const CONFIG_USB_NET_DRIVERS: u32 = 1;
pub const CONFIG_CC_CAN_LINK: u32 = 1;
pub const CONFIG_QNX6FS_FS: u32 = 1;
pub const CONFIG_LD_IS_BFD: u32 = 1;
pub const CONFIG_NO_HZ_COMMON: u32 = 1;
pub const CONFIG_DRM_MIPI_DSI: u32 = 1;
pub const CONFIG_CRYPTO_HASH2: u32 = 1;
pub const CONFIG_NET_VENDOR_VERTEXCOM: u32 = 1;
pub const CONFIG_CRYPTO_LZ4HC: u32 = 1;
pub const CONFIG_THERMAL_GOV_STEP_WISE: u32 = 1;
pub const CONFIG_DEFAULT_HOSTNAME: &'static [u8; 7usize] = b"(none)\0";
pub const CONFIG_SRCU: u32 = 1;
pub const CONFIG_CC_HAS_NO_PROFILE_FN_ATTR: u32 = 1;
pub const CONFIG_NFS_FS: u32 = 1;
pub const CONFIG_CRASH_DUMP: u32 = 1;
pub const CONFIG_MEMBARRIER: u32 = 1;
pub const CONFIG_BLK_DEV_IO_TRACE: u32 = 1;
pub const CONFIG_XPS: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_DEVELOP: u32 = 1;
pub const CONFIG_SGL_ALLOC: u32 = 1;
pub const CONFIG_HPET_TIMER: u32 = 1;
pub const CONFIG_LZ4_DECOMPRESS: u32 = 1;
pub const CONFIG_HSI: u32 = 1;
pub const CONFIG_EFI_RUNTIME_MAP: u32 = 1;
pub const CONFIG_FONT_SUPPORT: u32 = 1;
pub const CONFIG_ADVISE_SYSCALLS: u32 = 1;
pub const CONFIG_MD: u32 = 1;
pub const CONFIG_CRYPTO_ALGAPI: u32 = 1;
pub const CONFIG_DRM_I915_MAX_REQUEST_BUSYWAIT: u32 = 8000;
pub const CONFIG_NET_VENDOR_WIZNET: u32 = 1;
pub const CONFIG_SERIAL_8250_MID: u32 = 1;
pub const CONFIG_RD_BZIP2: u32 = 1;
pub const CONFIG_SKB_EXTENSIONS: u32 = 1;
pub const CONFIG_CC_VERSION_TEXT: &'static [u8; 42usize] =
    b"gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0\0";
pub const CONFIG_KEYBOARD_ATKBD: u32 = 1;
pub const CONFIG_X86_PLATFORM_DEVICES: u32 = 1;
pub const CONFIG_NET_IP_TUNNEL: u32 = 1;
pub const CONFIG_MTD_CFI_I1: u32 = 1;
pub const CONFIG_NF_NAT: u32 = 1;
pub const CONFIG_BLOCK_LEGACY_AUTOLOAD: u32 = 1;
pub const CONFIG_NET_VENDOR_OKI: u32 = 1;
pub const CONFIG_CPU_IDLE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_INTERSIL: u32 = 1;
pub const CONFIG_NFS_COMMON: u32 = 1;
pub const CONFIG_FAIR_GROUP_SCHED: u32 = 1;
pub const CONFIG_CRYPTO_HASH: u32 = 1;
pub const CONFIG_HAVE_STACK_VALIDATION: u32 = 1;
pub const CONFIG_EFI_PARTITION: u32 = 1;
pub const CONFIG_PROBE_EVENTS: u32 = 1;
pub const CONFIG_TRACE_CLOCK: u32 = 1;
pub const CONFIG_LOG_BUF_SHIFT: u32 = 18;
pub const CONFIG_WLAN_VENDOR_ATH: u32 = 1;
pub const CONFIG_HZ_1000: u32 = 1;
pub const CONFIG_HPET: u32 = 1;
pub const CONFIG_ACPI_WMI: u32 = 1;
pub const CONFIG_EXTRA_FIRMWARE: &'static [u8; 1usize] = b"\0";
pub const CONFIG_NET_VENDOR_8390: u32 = 1;
pub const CONFIG_PROC_EVENTS: u32 = 1;
pub const CONFIG_ACPI_VIDEO: u32 = 1;
pub const CONFIG_HAVE_KCSAN_COMPILER: u32 = 1;
pub const CONFIG_VFAT_FS: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE: u32 = 0;
pub const CONFIG_ARCH_SUPPORTS_ACPI: u32 = 1;
pub const CONFIG_PID_NS: u32 = 1;
pub const CONFIG_BLK_CGROUP_IOCOST: u32 = 1;
pub const CONFIG_KEXEC: u32 = 1;
pub const CONFIG_CRC32_SLICEBY8: u32 = 1;
pub const CONFIG_BLK_DEV_SR: u32 = 1;
pub const CONFIG_CPU_RMAP: u32 = 1;
pub const CONFIG_SND_HWDEP: u32 = 1;
pub const CONFIG_GENERIC_CPU: u32 = 1;
pub const CONFIG_GENERIC_IRQ_MATRIX_ALLOCATOR: u32 = 1;
pub const CONFIG_BLK_DEV_LOOP: u32 = 1;
pub const CONFIG_VIRTIO_PCI_LEGACY: u32 = 1;
pub const CONFIG_ARCH_HIBERNATION_HEADER: u32 = 1;
pub const CONFIG_HAVE_OPTPROBES: u32 = 1;
pub const CONFIG_HAVE_FENTRY: u32 = 1;
pub const CONFIG_RUST_IS_AVAILABLE: u32 = 1;
pub const CONFIG_DRM_I915_HEARTBEAT_INTERVAL: u32 = 2500;
pub const CONFIG_NF_NAT_IRC: u32 = 1;
pub const CONFIG_INPUT_MISC: u32 = 1;
pub const CONFIG_E1000E: u32 = 1;
pub const CONFIG_INPUT_VIVALDIFMAP: u32 = 1;
pub const CONFIG_MULTIUSER: u32 = 1;
pub const CONFIG_SUSPEND: u32 = 1;
pub const CONFIG_GENERIC_VDSO_TIME_NS: u32 = 1;
pub const CONFIG_CROSS_MEMORY_ATTACH: u32 = 1;
pub const CONFIG_CRYPTO_CBC: u32 = 1;
pub const CONFIG_I8253_LOCK: u32 = 1;
pub const CONFIG_SERIAL_8250_RUNTIME_UARTS: u32 = 4;
pub const CONFIG_PREEMPT_BUILD: u32 = 1;
pub const CONFIG_ARCH_HAS_NONLEAF_PMD_YOUNG: u32 = 1;
pub const CONFIG_CLANG_VERSION: u32 = 0;
pub const CONFIG_KPROBES: u32 = 1;
pub const CONFIG_FS_MBCACHE: u32 = 1;
pub const CONFIG_RTC_CLASS: u32 = 1;
pub const CONFIG_CRYPTO_RNG_DEFAULT: u32 = 1;
pub const CONFIG_TMPFS_XATTR: u32 = 1;
pub const CONFIG_EXT4_USE_FOR_EXT2: u32 = 1;
pub const CONFIG_I2C_I801: u32 = 1;
pub const CONFIG_DRM_I915_STOP_TIMEOUT: u32 = 100;
pub const CONFIG_GENERIC_TRACER: u32 = 1;
pub const CONFIG_CFG80211_USE_KERNEL_REGDB_KEYS: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_TRACER: u32 = 1;
pub const CONFIG_CPU_ISOLATION: u32 = 1;
pub const CONFIG_NR_CPUS_RANGE_END: u32 = 512;
pub const CONFIG_DRM_DISPLAY_DP_HELPER: u32 = 1;
pub const CONFIG_EFI_MIXED: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER2: u32 = 1;
pub const CONFIG_SERIAL_8250_DEPRECATED_OPTIONS: u32 = 1;
pub const CONFIG_ARCH_HAS_PTE_SPECIAL: u32 = 1;
pub const CONFIG_NET_VENDOR_MYRI: u32 = 1;
pub const CONFIG_NF_NAT_MASQUERADE: u32 = 1;
pub const CONFIG_CLZ_TAB: u32 = 1;
pub const CONFIG_GENERIC_PCI_IOMAP: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_LOG_MODULE: u32 = 1;
pub const CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS: u32 = 1;
pub const CONFIG_SLUB: u32 = 1;
pub const CONFIG_XZ_DEC_BCJ: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_LTO_CLANG_THIN: u32 = 1;
pub const CONFIG_PM_SLEEP: u32 = 1;
pub const CONFIG_I2C: u32 = 1;
pub const CONFIG_MMU_GATHER_TABLE_FREE: u32 = 1;
pub const CONFIG_BINFMT_SCRIPT: u32 = 1;
pub const CONFIG_EFI_STUB: u32 = 1;
pub const CONFIG_EISA_NAMES: u32 = 1;
pub const CONFIG_MOUSE_PS2_CYPRESS: u32 = 1;
pub const CONFIG_GENERIC_PENDING_IRQ: u32 = 1;
pub const CONFIG_DRM_I915_FENCE_TIMEOUT: u32 = 10000;
pub const CONFIG_EARLY_PRINTK_DBGP: u32 = 1;
pub const CONFIG_CC_HAS_RETURN_THUNK: u32 = 1;
pub const CONFIG_MOUSE_PS2_LOGIPS2PP: u32 = 1;
pub const CONFIG_TICK_CPU_ACCOUNTING: u32 = 1;
pub const CONFIG_VM_EVENT_COUNTERS: u32 = 1;
pub const CONFIG_RELAY: u32 = 1;
pub const CONFIG_HAVE_MMIOTRACE_SUPPORT: u32 = 1;
pub const CONFIG_ACPI_SYSTEM_POWER_STATES_SUPPORT: u32 = 1;
pub const CONFIG_WLAN_VENDOR_BROADCOM: u32 = 1;
pub const CONFIG_PM_STD_PARTITION: &'static [u8; 1usize] = b"\0";
pub const CONFIG_NET_VENDOR_XIRCOM: u32 = 1;
pub const CONFIG_I2C_SLAVE: u32 = 1;
pub const CONFIG_DEBUG_FS: u32 = 1;
pub const CONFIG_NET_VENDOR_AMD: u32 = 1;
pub const CONFIG_HAVE_KERNEL_LZ4: u32 = 1;
pub const CONFIG_DRM_TTM: u32 = 1;
pub const CONFIG_BASE_FULL: u32 = 1;
pub const CONFIG_ZLIB_DEFLATE: u32 = 1;
pub const CONFIG_SUNRPC: u32 = 1;
pub const CONFIG_ACPI_TABLE_UPGRADE: u32 = 1;
pub const CONFIG_ARCH_USES_HIGH_VMA_FLAGS: u32 = 1;
pub const CONFIG_RSEQ: u32 = 1;
pub const CONFIG_FW_LOADER: u32 = 1;
pub const CONFIG_SECURITY_WRITABLE_HOOKS: u32 = 1;
pub const CONFIG_KALLSYMS: u32 = 1;
pub const CONFIG_STACKPROTECTOR_STRONG: u32 = 1;
pub const CONFIG_PCI: u32 = 1;
pub const CONFIG_NET_VENDOR_FUNGIBLE: u32 = 1;
pub const CONFIG_DEBUG_INFO_COMPRESSED: u32 = 1;
pub const CONFIG_NET_VENDOR_ASIX: u32 = 1;
pub const CONFIG_DECOMPRESS_XZ: u32 = 1;
pub const CONFIG_PCI_QUIRKS: u32 = 1;
pub const CONFIG_MII: u32 = 1;
pub const CONFIG_SIGNALFD: u32 = 1;
pub const CONFIG_NET_CORE: u32 = 1;
pub const CONFIG_MOUSE_PS2_ALPS: u32 = 1;
pub const CONFIG_KEXEC_CORE: u32 = 1;
pub const CONFIG_HAVE_UNSTABLE_SCHED_CLOCK: u32 = 1;
pub const CONFIG_EXT4_FS: u32 = 1;
pub const CONFIG_UNINLINE_SPIN_UNLOCK: u32 = 1;
pub const CONFIG_HAVE_HW_BREAKPOINT: u32 = 1;
pub const CONFIG_KRETPROBES: u32 = 1;
pub const CONFIG_SND_JACK_INPUT_DEV: u32 = 1;
pub const CONFIG_CPU_UNRET_ENTRY: u32 = 1;
pub const CONFIG_HSI_BOARDINFO: u32 = 1;
pub const CONFIG_ARCH_WANT_GENERAL_HUGETLB: u32 = 1;
pub const CONFIG_HAVE_SAMPLE_FTRACE_DIRECT: u32 = 1;
pub const CONFIG_SATA_PMP: u32 = 1;
pub const CONFIG_XZ_DEC: u32 = 1;
pub const CONFIG_NET_VENDOR_TI: u32 = 1;
pub const CONFIG_LOCKD_V4: u32 = 1;
pub const CONFIG_NET_VENDOR_ALACRITECH: u32 = 1;
pub const CONFIG_WATCHDOG: u32 = 1;
pub const CONFIG_HAS_IOMEM: u32 = 1;
pub const CONFIG_NF_LOG_IPV6_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_RSA: u32 = 1;
pub const CONFIG_GENERIC_IRQ_PROBE: u32 = 1;
pub const CONFIG_HAVE_MOVE_PUD: u32 = 1;
pub const CONFIG_CRYPTO_ACOMP2: u32 = 1;
pub const CONFIG_PCI_MMCONFIG: u32 = 1;
pub const CONFIG_PM_TRACE: u32 = 1;
pub const CONFIG_HAVE_ARCH_KASAN_VMALLOC: u32 = 1;
pub const CONFIG_PROC_KCORE: u32 = 1;
pub const CONFIG_RETPOLINE: u32 = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_1: u32 = 1;
pub const CONFIG_NUMA: u32 = 1;
pub const CONFIG_SCHED_HRTICK: u32 = 1;
pub const CONFIG_CONSTRUCTORS: u32 = 1;
pub const CONFIG_EPOLL: u32 = 1;
pub const CONFIG_NET_IFE: u32 = 1;
pub const CONFIG_CRYPTO_LZO: u32 = 1;
pub const CONFIG_SND_PCM: u32 = 1;
pub const CONFIG_SATA_MOBILE_LPM_POLICY: u32 = 0;
pub const CONFIG_APERTURE_HELPERS: u32 = 1;
pub const CONFIG_FAILOVER: u32 = 1;
pub const CONFIG_CGROUP_HUGETLB: u32 = 1;
pub const CONFIG_GENERIC_PTDUMP: u32 = 1;
pub const CONFIG_NET: u32 = 1;
pub const CONFIG_SAMPLE_HW_BREAKPOINT_MODULE: u32 = 1;
pub const CONFIG_SAMPLE_KRETPROBES_MODULE: u32 = 1;
pub const CONFIG_USB_OHCI_HCD_PCI: u32 = 1;
pub const CONFIG_INPUT_EVDEV: u32 = 1;
pub const CONFIG_SND_JACK: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_TCPMSS: u32 = 1;
pub const CONFIG_ACPI_SLEEP: u32 = 1;
pub const CONFIG_VIRTIO_DMA_SHARED_BUFFER: u32 = 1;
pub const CONFIG_X86_ESPFIX64: u32 = 1;
pub const CONFIG_CRYPTO_LIB_BLAKE2S_GENERIC: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNTRACK: u32 = 1;
pub const CONFIG_BLOCK_COMPAT: u32 = 1;
pub const CONFIG_QUOTA_TREE: u32 = 1;
pub const CONFIG_IRQ_DOMAIN_HIERARCHY: u32 = 1;
pub const CONFIG_ATA_FORCE: u32 = 1;
pub const CONFIG_MPILIB: u32 = 1;
pub const CONFIG_PACKET: u32 = 1;
pub const CONFIG_XFRM_ALGO: u32 = 1;
pub const CONFIG_CRYPTO_AKCIPHER2: u32 = 1;
pub const CONFIG_NODES_SHIFT: u32 = 6;
pub const CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE: u32 = 1;
pub const CONFIG_SND_CTL_FAST_LOOKUP: u32 = 1;
pub const CONFIG_SND_HDA_CORE: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE_ROWS: u32 = 25;
pub const CONFIG_NFS_V3: u32 = 1;
pub const CONFIG_NOP_TRACER: u32 = 1;
pub const CONFIG_INET: u32 = 1;
pub const CONFIG_IP_ROUTE_VERBOSE: u32 = 1;
pub const CONFIG_XZ_DEC_POWERPC: u32 = 1;
pub const CONFIG_IP_PNP_BOOTP: u32 = 1;
pub const CONFIG_VIRTIO_NET: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_ADDRTYPE_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_HUAWEI: u32 = 1;
pub const CONFIG_PREVENT_FIRMWARE_BUILD: u32 = 1;
pub const CONFIG_SERIAL_8250_PNP: u32 = 1;
pub const CONFIG_FREEZER: u32 = 1;
pub const CONFIG_HAVE_HARDLOCKUP_DETECTOR_PERF: u32 = 1;
pub const CONFIG_PCI_DOMAINS: u32 = 1;
pub const CONFIG_NET_CLS_ACT: u32 = 1;
pub const CONFIG_NET_VENDOR_CHELSIO: u32 = 1;
pub const CONFIG_LZ4HC_COMPRESS: u32 = 1;
pub const CONFIG_EFIVAR_FS_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_VMAP_STACK: u32 = 1;
pub const CONFIG_X86_DEBUGCTLMSR: u32 = 1;
pub const CONFIG_8139TOO_PIO: u32 = 1;
pub const CONFIG_SND_PCMCIA: u32 = 1;
pub const CONFIG_RTC_LIB: u32 = 1;
pub const CONFIG_X86_LOCAL_APIC: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_POLICY: u32 = 1;
pub const CONFIG_HAVE_KPROBES: u32 = 1;
pub const CONFIG_MOUSE_PS2_SYNAPTICS_SMBUS: u32 = 1;
pub const CONFIG_X86_UMIP: u32 = 1;
pub const CONFIG_CRYPTO_AES: u32 = 1;
pub const CONFIG_HAVE_GENERIC_VDSO: u32 = 1;
pub const CONFIG_FUTEX_PI: u32 = 1;
pub const CONFIG_I2C_STUB_MODULE: u32 = 1;
pub const CONFIG_GENERIC_CPU_VULNERABILITIES: u32 = 1;
pub const CONFIG_HAVE_ARCH_WITHIN_STACK_FRAMES: u32 = 1;
pub const CONFIG_HID_PID: u32 = 1;
pub const CONFIG_AUTOFS_FS: u32 = 1;
pub const CONFIG_ISO9660_FS: u32 = 1;
pub const CONFIG_SKY2: u32 = 1;
pub const CONFIG_NETFILTER_XT_NAT_MODULE: u32 = 1;
pub const CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR: u32 = 1;
pub const CONFIG_WERROR: u32 = 1;
pub const CONFIG_NET_VENDOR_AQUANTIA: u32 = 1;
pub const CONFIG_SCSI_VIRTIO: u32 = 1;
pub const CONFIG_HVC_DRIVER: u32 = 1;
pub const CONFIG_NETFILTER: u32 = 1;
pub const CONFIG_X86_MSR: u32 = 1;
pub const CONFIG_HAVE_ARCH_KASAN: u32 = 1;
pub const CONFIG_NET_VENDOR_SMSC: u32 = 1;
pub const CONFIG_NFS_DISABLE_UDP_SUPPORT: u32 = 1;
pub const CONFIG_SERIO_SERPORT: u32 = 1;
pub const CONFIG_HAVE_NMI: u32 = 1;
pub const CONFIG_RD_XZ: u32 = 1;
pub const CONFIG_AUXILIARY_BUS: u32 = 1;
pub const CONFIG_IP_MROUTE: u32 = 1;
pub const CONFIG_PREEMPT_RCU: u32 = 1;
pub const CONFIG_VGA_CONSOLE: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS: u32 = 1;
pub const CONFIG_ATA_VERBOSE_ERROR: u32 = 1;
pub const CONFIG_SND_DRIVERS: u32 = 1;
pub const CONFIG_NET_FLOW_LIMIT: u32 = 1;
pub const CONFIG_LOCKDEP_SUPPORT: u32 = 1;
pub const CONFIG_ACPI_PROCESSOR_IDLE: u32 = 1;
pub const CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION: u32 = 1;
pub const CONFIG_NO_HZ: u32 = 1;
pub const CONFIG_ARCH_WANT_HUGE_PMD_SHARE: u32 = 1;
pub const CONFIG_POSIX_MQUEUE: u32 = 1;
pub const CONFIG_CC_HAS_WORKING_NOSANITIZE_ADDRESS: u32 = 1;
pub const CONFIG_NETFILTER_INGRESS: u32 = 1;
pub const CONFIG_ARCH_WANTS_DYNAMIC_TASK_STRUCT: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE: u32 = 256;
pub const CONFIG_ARCH_MIGHT_HAVE_PC_SERIO: u32 = 1;
pub const CONFIG_GENERIC_STRNCPY_FROM_USER: u32 = 1;
pub const CONFIG_HAVE_RSEQ: u32 = 1;
pub const CONFIG_CONTEXT_TRACKING_IDLE: u32 = 1;
pub const CONFIG_CRASH_CORE: u32 = 1;
pub const CONFIG_NET_VENDOR_DEC: u32 = 1;
pub const CONFIG_INET6_ESP: u32 = 1;
pub const CONFIG_AUTOFS4_FS: u32 = 1;
pub const CONFIG_NET_NSH: u32 = 1;
pub const CONFIG_ACPI_BUTTON: u32 = 1;
pub const CONFIG_ILLEGAL_POINTER_VALUE: i64 = -2401263026318606336;
pub const CONFIG_GENERIC_GETTIMEOFDAY: u32 = 1;
pub const CONFIG_ARCH_USE_MEMTEST: u32 = 1;
pub const CONFIG_TASKSTATS: u32 = 1;
pub const CONFIG_MCB: u32 = 1;
pub const CONFIG_NET_VENDOR_PENSANDO: u32 = 1;
pub const CONFIG_IP6_NF_FILTER: u32 = 1;
pub const CONFIG_SYSTEM_DATA_VERIFICATION: u32 = 1;
pub const CONFIG_EFI_ESRT: u32 = 1;
pub const CONFIG_NEED_DMA_MAP_STATE: u32 = 1;
pub const CONFIG_SND_HDA: u32 = 1;
pub const CONFIG_SND_HDA_PREALLOC_SIZE: u32 = 0;
pub const CONFIG_YENTA_ENE_TUNE: u32 = 1;
pub const CONFIG_MOUSE_PS2_LIFEBOOK: u32 = 1;
pub const CONFIG_SERIO_LIBPS2: u32 = 1;
pub const CONFIG_X86_CPUID: u32 = 1;
pub const CONFIG_USB_PRINTER: u32 = 1;
pub const CONFIG_ACPI_PCC: u32 = 1;
pub const CONFIG_NET_VENDOR_ATHEROS: u32 = 1;
pub const CONFIG_EFI_GENERIC_STUB_INITRD_CMDLINE_LOADER: u32 = 1;
pub const CONFIG_RELOCATABLE: u32 = 1;
pub const CONFIG_QUEUED_SPINLOCKS: u32 = 1;
pub const CONFIG_TIME_NS: u32 = 1;
pub const CONFIG_NET_VENDOR_SUN: u32 = 1;
pub const CONFIG_DMIID: u32 = 1;
pub const CONFIG_ARCH_HAS_MEM_ENCRYPT: u32 = 1;
pub const CONFIG_PANIC_TIMEOUT: u32 = 0;
pub const CONFIG_QUOTA_NETLINK_INTERFACE: u32 = 1;
pub const CONFIG_INPUT_JOYSTICK: u32 = 1;
pub const CONFIG_QNX4FS_FS: u32 = 1;
pub const CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT: u32 = 1;
pub const CONFIG_HAVE_ARCH_SECCOMP: u32 = 1;
pub const CONFIG_STACKDEPOT: u32 = 1;
pub const CONFIG_CFG80211_DEFAULT_PS: u32 = 1;
pub const CONFIG_GENERIC_IOMAP: u32 = 1;
pub const CONFIG_NET_VENDOR_XILINX: u32 = 1;
pub const CONFIG_DECOMPRESS_LZ4: u32 = 1;
pub const CONFIG_DMI_SCAN_MACHINE_NON_EFI_FALLBACK: u32 = 1;
pub const CONFIG_SMP: u32 = 1;
pub const CONFIG_NET_VENDOR_CADENCE: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROSOFT: u32 = 1;
pub const CONFIG_TTY: u32 = 1;
pub const CONFIG_HAVE_KERNEL_GZIP: u32 = 1;
pub const CONFIG_NET_VENDOR_I825XX: u32 = 1;
pub const CONFIG_PNP: u32 = 1;
pub const CONFIG_IOMMU_DMA: u32 = 1;
pub const CONFIG_RCU_EXP_CPU_STALL_TIMEOUT: u32 = 0;
pub const CONFIG_DW_DMAC_CORE: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_NFLOG: u32 = 1;
pub const CONFIG_GENERIC_ALLOCATOR: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_WITH_DIRECT_CALLS: u32 = 1;
pub const CONFIG_SAMPLE_KOBJECT: u32 = 1;
pub const CONFIG_KALLSYMS_ALL: u32 = 1;
pub const CONFIG_ARCH_NR_GPIO: u32 = 1024;
pub const CONFIG_GENERIC_BUG: u32 = 1;
pub const CONFIG_CRYPTO_SHA256: u32 = 1;
pub const CONFIG_HAVE_FTRACE_MCOUNT_RECORD: u32 = 1;
pub const CONFIG_POSIX_TIMERS: u32 = 1;
pub const CONFIG_HID_SONY: u32 = 1;
pub const CONFIG_PCI_PASID: u32 = 1;
pub const CONFIG_HW_CONSOLE: u32 = 1;
pub const CONFIG_RAS: u32 = 1;
pub const CONFIG_DEVMEM: u32 = 1;
pub const CONFIG_MOUSE_PS2_FOCALTECH: u32 = 1;
pub const CONFIG_CRYPTO_LIB_SHA1: u32 = 1;
pub const CONFIG_HID_MONTEREY: u32 = 1;
pub const CONFIG_CGROUP_RDMA: u32 = 1;
pub const CONFIG_HID_EZKEY: u32 = 1;
pub const CONFIG_THERMAL_GOV_USER_SPACE: u32 = 1;
pub const CONFIG_HAVE_UID16: u32 = 1;
pub const CONFIG_SERIAL_NONSTANDARD: u32 = 1;
pub const CONFIG_COMPAT_OLD_SIGACTION: u32 = 1;
pub const CONFIG_SAMPLE_TRACE_EVENTS_MODULE: u32 = 1;
pub const CONFIG_IRQ_MSI_IOMMU: u32 = 1;
pub const CONFIG_RTC_NVMEM: u32 = 1;
pub const CONFIG_X86_FEATURE_NAMES: u32 = 1;
pub const CONFIG_QUOTACTL: u32 = 1;
pub const CONFIG_PARAVIRT: u32 = 1;
pub const CONFIG_LEGACY_VSYSCALL_XONLY: u32 = 1;
pub const CONFIG_ZSTD_COMMON: u32 = 1;
pub const CONFIG_HAVE_IOREMAP_PROT: u32 = 1;
pub const CONFIG_CC_HAS_KASAN_GENERIC: u32 = 1;
pub const CONFIG_DEBUG_KERNEL: u32 = 1;
pub const CONFIG_KASAN: u32 = 1;
pub const CONFIG_LOCALVERSION: &'static [u8; 1usize] = b"\0";
pub const CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_PAGE_TABLE_CHECK: u32 = 1;
pub const CONFIG_HAVE_PCSPKR_PLATFORM: u32 = 1;
pub const CONFIG_SYMBOLIC_ERRNAME: u32 = 1;
pub const CONFIG_CRYPTO: u32 = 1;
pub const CONFIG_NET_VENDOR_BROCADE: u32 = 1;
pub const CONFIG_DEFAULT_MMAP_MIN_ADDR: u32 = 4096;
pub const CONFIG_SYSTEM_TRUSTED_KEYS: &'static [u8; 1usize] = b"\0";
pub const CONFIG_PERF_EVENTS_INTEL_UNCORE: u32 = 1;
pub const CONFIG_SND_HDA_HWDEP: u32 = 1;
pub const CONFIG_IP_NF_IPTABLES: u32 = 1;
pub const CONFIG_NET_VENDOR_QLOGIC: u32 = 1;
pub const CONFIG_RUNTIME_TESTING_MENU: u32 = 1;
pub const CONFIG_USB_XHCI_HCD: u32 = 1;
pub const CONFIG_VIRTIO: u32 = 1;
pub const CONFIG_DEFAULT_CUBIC: u32 = 1;
pub const CONFIG_YENTA_TI: u32 = 1;
pub const CONFIG_HID_SAMSUNG: u32 = 1;
pub const CONFIG_IP_PIMSM_V2: u32 = 1;
pub const CONFIG_NET_SELFTESTS: u32 = 1;
pub const CONFIG_X86_MCE_THRESHOLD: u32 = 1;
pub const CONFIG_DMA_VIRTUAL_CHANNELS: u32 = 1;
pub const CONFIG_YENTA_O2: u32 = 1;
pub const CONFIG_GENERIC_MSI_IRQ_DOMAIN: u32 = 1;
pub const CONFIG_SND_SEQ_HRTIMER_DEFAULT: u32 = 1;
pub const CONFIG_USB_ARCH_HAS_HCD: u32 = 1;
pub const CONFIG_STRICT_DEVMEM: u32 = 1;
pub const CONFIG_PATA_OLDPIIX: u32 = 1;
pub const CONFIG_GENERIC_IRQ_SHOW: u32 = 1;
pub const CONFIG_NVMEM_SYSFS: u32 = 1;
pub const CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE: u32 = 1;
pub const CONFIG_ARCH_HAS_ELF_RANDOMIZE: u32 = 1;
pub const CONFIG_9P_FS: u32 = 1;
pub const CONFIG_NETFS_SUPPORT: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_ARG_ACCESS_API: u32 = 1;
pub const CONFIG_MD_AUTODETECT: u32 = 1;
pub const CONFIG_PANIC_ON_OOPS_VALUE: u32 = 0;
pub const CONFIG_NET_VENDOR_SAMSUNG: u32 = 1;
pub const CONFIG_INITRAMFS_PRESERVE_MTIME: u32 = 1;
pub const CONFIG_SCSI_MOD: u32 = 1;
pub const CONFIG_NET_VENDOR_MICREL: u32 = 1;
pub const CONFIG_ARCH_HAS_ADD_PAGES: u32 = 1;
pub const CONFIG_HID_ITE: u32 = 1;
pub const CONFIG_IOMMU_DEFAULT_DMA_LAZY: u32 = 1;
pub const CONFIG_CRYPTO_CRC32C: u32 = 1;
pub const CONFIG_SERIAL_CORE: u32 = 1;
pub const CONFIG_UID16: u32 = 1;
pub const CONFIG_DEBUG_PREEMPT: u32 = 1;
pub const CONFIG_HID_MICROSOFT: u32 = 1;
pub const CONFIG_PCC: u32 = 1;
pub const CONFIG_HAVE_KRETPROBES: u32 = 1;
pub const CONFIG_OBJTOOL: u32 = 1;
pub const CONFIG_ASSOCIATIVE_ARRAY: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_KMAP_LOCAL_FORCE_MAP: u32 = 1;
pub const CONFIG_NF_DEFRAG_IPV6: u32 = 1;
pub const CONFIG_MODULE_COMPRESS_NONE: u32 = 1;
pub const CONFIG_CC_HAS_ZERO_CALL_USED_REGS: u32 = 1;
pub const CONFIG_NFS_V4: u32 = 1;
pub const CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE: u32 = 1;
pub const CONFIG_MAILBOX: u32 = 1;
pub const CONFIG_INPUT_LEDS: u32 = 1;
pub const CONFIG_RCU_NEED_SEGCBLIST: u32 = 1;
pub const CONFIG_DEBUG_WX: u32 = 1;
pub const CONFIG_HAS_DMA: u32 = 1;
pub const CONFIG_DEBUG_BOOT_PARAMS: u32 = 1;
pub const CONFIG_SCSI: u32 = 1;
pub const CONFIG_HID_CHICONY: u32 = 1;
pub const CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST: u32 = 1;
pub const CONFIG_HID: u32 = 1;
pub const CONFIG_CGROUP_NET_PRIO: u32 = 1;
pub const CONFIG_RANDOM_TRUST_BOOTLOADER: u32 = 1;
pub const CONFIG_I2C_SMBUS: u32 = 1;
pub const CONFIG_FONT_8x16: u32 = 1;
pub const CONFIG_NET_VENDOR_MELLANOX: u32 = 1;
pub const CONFIG_SERIAL_8250_MANY_PORTS: u32 = 1;
pub const CONFIG_VT_CONSOLE_SLEEP: u32 = 1;
pub const CONFIG_X86_MCE_INTEL: u32 = 1;
pub const CONFIG_X86_64: u32 = 1;
pub const CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG: u32 = 1;
pub const CONFIG_RTC_DRV_CMOS: u32 = 1;
pub const CONFIG_PCI_LOCKLESS_CONFIG: u32 = 1;
pub const CONFIG_ARCH_HAS_CURRENT_STACK_POINTER: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK: u32 = 1;
pub const CONFIG_PATA_AMD: u32 = 1;
pub const CONFIG_DEBUG_STACK_USAGE: u32 = 1;
pub const CONFIG_ARCH_HAS_CACHE_LINE_SIZE: u32 = 1;
pub const CONFIG_JBD2: u32 = 1;
pub const CONFIG_SPARSEMEM_VMEMMAP: u32 = 1;
pub const CONFIG_X86_5LEVEL: u32 = 1;
pub const CONFIG_NET_VENDOR_MARVELL: u32 = 1;
pub const CONFIG_PHYLIB: u32 = 1;
pub const CONFIG_NET_VENDOR_NVIDIA: u32 = 1;
pub const CONFIG_FB_CMDLINE: u32 = 1;
pub const CONFIG_IRQ_DOMAIN: u32 = 1;
pub const CONFIG_LSM_MMAP_MIN_ADDR: u32 = 65536;
pub const CONFIG_LOCALVERSION_AUTO: u32 = 1;
pub const CONFIG_INTEGRITY_AUDIT: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_VIRTUAL: u32 = 1;
pub const CONFIG_NET_TULIP: u32 = 1;
pub const CONFIG_HAVE_ASM_MODVERSIONS: u32 = 1;
pub const CONFIG_IPC_NS: u32 = 1;
pub const CONFIG_MISC_FILESYSTEMS: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS_MIN: u32 = 28;
pub const CONFIG_FTRACE: u32 = 1;
pub const CONFIG_X86_THERMAL_VECTOR: u32 = 1;
pub const CONFIG_PERF_EVENTS_AMD_UNCORE: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_LTO_CLANG: u32 = 1;
pub const CONFIG_COMPAT_32: u32 = 1;
pub const CONFIG_I2C_DEBUG_CORE: u32 = 1;
pub const CONFIG_CLOCKSOURCE_WATCHDOG: u32 = 1;
pub const CONFIG_HID_TOPSEED: u32 = 1;
pub const CONFIG_DECOMPRESS_BZIP2: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_UPROBES: u32 = 1;
pub const CONFIG_NET_VENDOR_STMICRO: u32 = 1;
pub const CONFIG_XZ_DEC_SPARC: u32 = 1;
pub const CONFIG_ARCH_SPARSEMEM_DEFAULT: u32 = 1;
pub const CONFIG_REALTEK_PHY: u32 = 1;
pub const CONFIG_PROC_VMCORE: u32 = 1;
pub const CONFIG_HID_A4TECH: u32 = 1;
pub const CONFIG_RTC_MC146818_LIB: u32 = 1;
pub const CONFIG_I2C_DEBUG_ALGO: u32 = 1;
pub const CONFIG_DST_CACHE: u32 = 1;
pub const CONFIG_UNWINDER_ORC: u32 = 1;
pub const CONFIG_NF_REJECT_IPV6: u32 = 1;
pub const CONFIG_RCU_CPU_STALL_TIMEOUT: u32 = 21;
pub const CONFIG_842_COMPRESS: u32 = 1;
pub const CONFIG_POSIX_CPU_TIMERS_TASK_WORK: u32 = 1;
pub const CONFIG_SND_VERBOSE_PROCFS: u32 = 1;
pub const CONFIG_HAVE_ARCH_COMPAT_MMAP_BASES: u32 = 1;
pub const CONFIG_LAPB: u32 = 1;
pub const CONFIG_IP_ROUTE_MULTIPATH: u32 = 1;
pub const CONFIG_INPUT_FF_MEMLESS: u32 = 1;
pub const CONFIG_PARAVIRT_CLOCK: u32 = 1;
pub const CONFIG_CHR_DEV_SG: u32 = 1;
pub const CONFIG_LLD_VERSION: u32 = 0;
pub const CONFIG_SECTION_MISMATCH_WARN_ONLY: u32 = 1;
pub const CONFIG_NETFILTER_EGRESS: u32 = 1;
pub const CONFIG_MDIO_DEVICE: u32 = 1;
pub const CONFIG_NEED_SG_DMA_LENGTH: u32 = 1;
pub const CONFIG_MODPROBE_PATH: &'static [u8; 15usize] = b"/sbin/modprobe\0";
pub const CONFIG_DRM_DISPLAY_HELPER: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_IPV6HEADER: u32 = 1;
pub const CONFIG_MMCONF_FAM10H: u32 = 1;
pub const CONFIG_PCIEASPM_DEFAULT: u32 = 1;
pub const CONFIG_PROFILING: u32 = 1;
pub const CONFIG_INTERVAL_TREE: u32 = 1;
pub const CONFIG_IOSF_MBI: u32 = 1;
pub const CONFIG_NET_VENDOR_AMAZON: u32 = 1;
pub const CONFIG_SPARSEMEM: u32 = 1;
pub const CONFIG_BLK_MQ_STACKING: u32 = 1;
pub const CONFIG_DRM_GEM_SHMEM_HELPER: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ATMEL: u32 = 1;
pub const CONFIG_GRACE_PERIOD: u32 = 1;
pub const CONFIG_NET_VENDOR_TEHUTI: u32 = 1;
pub const CONFIG_E1000E_HWTS: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER: u32 = 1;
pub const CONFIG_SCHED_SMT: u32 = 1;
pub const CONFIG_EDAC_SUPPORT: u32 = 1;
pub const CONFIG_RT_MUTEXES: u32 = 1;
pub const CONFIG_LOCK_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_KRETPROBE_ON_RETHOOK: u32 = 1;
pub const CONFIG_HUGETLBFS: u32 = 1;
pub const CONFIG_CHECK_SIGNATURE: u32 = 1;
pub const CONFIG_SLAB_MERGE_DEFAULT: u32 = 1;
pub const CONFIG_KERNFS: u32 = 1;
pub const CONFIG_I2C_ALGOBIT: u32 = 1;
pub const CONFIG_PAGE_COUNTER: u32 = 1;
pub const CONFIG_HAVE_STATIC_CALL_INLINE: u32 = 1;
pub const CONFIG_SND_PCI: u32 = 1;
pub const CONFIG_DMAR_TABLE: u32 = 1;
pub const CONFIG_ARCH_WANT_HUGETLB_PAGE_OPTIMIZE_VMEMMAP: u32 = 1;
pub const CONFIG_CFG80211_CRDA_SUPPORT: u32 = 1;
pub const CONFIG_BPFILTER: u32 = 1;
pub const CONFIG_WIRELESS: u32 = 1;
pub const CONFIG_CGROUP_MISC: u32 = 1;
pub const CONFIG_X86_IO_APIC: u32 = 1;
pub const CONFIG_ARCH_HAS_STRICT_KERNEL_RWX: u32 = 1;
pub const CONFIG_LOCK_DEBUGGING_SUPPORT: u32 = 1;
pub const CONFIG_PKCS7_MESSAGE_PARSER: u32 = 1;
pub const CONFIG_CC_HAS_SANE_STACKPROTECTOR: u32 = 1;
pub const CONFIG_TASK_IO_ACCOUNTING: u32 = 1;
pub const CONFIG_NF_LOG_SYSLOG_MODULE: u32 = 1;
pub const CONFIG_FAT_DEFAULT_IOCHARSET: &'static [u8; 10usize] = b"iso8859-1\0";
pub const CONFIG_HAVE_RUST: u32 = 1;
pub const CONFIG_FRAME_WARN: u32 = 2048;
pub const CONFIG_NET_VENDOR_AGERE: u32 = 1;
pub const CONFIG_HID_GENERIC: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS: u32 = 28;
pub const CONFIG_X86_VSYSCALL_EMULATION: u32 = 1;
pub const CONFIG_PATA_SCH: u32 = 1;
pub const CONFIG_INITRAMFS_SOURCE: &'static [u8; 1usize] = b"\0";
pub const CONFIG_RTL_CARDS: u32 = 1;
pub const CONFIG_ARCH_MHP_MEMMAP_ON_MEMORY_ENABLE: u32 = 1;
pub const CONFIG_CGROUPS: u32 = 1;
pub const CONFIG_LZO_COMPRESS: u32 = 1;
pub const CONFIG_VIRTIO_INPUT: u32 = 1;
pub const CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS: u32 = 1;
pub const CONFIG_CRYPTO_SEQIV: u32 = 1;
pub const CONFIG_ACPI_SPCR_TABLE: u32 = 1;
pub const CONFIG_SND_HDA_POWER_SAVE_DEFAULT: u32 = 0;
pub const CONFIG_HID_LOGITECH: u32 = 1;
pub const CONFIG_HAVE_GCC_PLUGINS: u32 = 1;
pub const CONFIG_DYNAMIC_EVENTS: u32 = 1;
pub const CONFIG_STACKTRACE: u32 = 1;
pub const CONFIG_HAVE_PCI: u32 = 1;
pub const CONFIG_HAVE_ACPI_APEI: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC: u32 = 1;
pub const CONFIG_CRYPTO_DRBG: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ADMTEK: u32 = 1;
pub const CONFIG_CGROUP_CPUACCT: u32 = 1;
pub const CONFIG_SND_HDA_COMPONENT: u32 = 1;
pub const CONFIG_HAS_IOPORT_MAP: u32 = 1;
pub const CONFIG_X86_CMPXCHG64: u32 = 1;
pub const CONFIG_HAVE_FAST_GUP: u32 = 1;
pub const CONFIG_VIRTIO_PCI_LIB: u32 = 1;
pub const CONFIG_NET_VENDOR_VIA: u32 = 1;
pub const CONFIG_ISA_DMA_API: u32 = 1;
pub const CONFIG_HZ: u32 = 1000;
pub const CONFIG_SERIAL_8250_SHARE_IRQ: u32 = 1;
pub const CONFIG_I2C_HELPER_AUTO: u32 = 1;
pub const CONFIG_AGP_INTEL: u32 = 1;
pub const CONFIG_SERIAL_8250_PERICOM: u32 = 1;
pub const CONFIG_SERIAL_8250_NR_UARTS: u32 = 32;
pub const CONFIG_ARCH_HAS_STRICT_MODULE_RWX: u32 = 1;
pub const CONFIG_CC_IS_GCC: u32 = 1;
pub const CONFIG_CPU_SUP_HYGON: u32 = 1;
pub const CONFIG_DMA_OPS: u32 = 1;
pub const CONFIG_NET_EGRESS: u32 = 1;
pub const CONFIG_NET_VENDOR_ARC: u32 = 1;
pub const CONFIG_SCHED_MC_PRIO: u32 = 1;
pub const CONFIG_RANDOMIZE_KSTACK_OFFSET: u32 = 1;
pub const CONFIG_HAVE_USER_RETURN_NOTIFIER: u32 = 1;
pub const CONFIG_HAVE_PERF_USER_STACK_DUMP: u32 = 1;
pub const CONFIG_CGROUP_PERF: u32 = 1;
pub const CONFIG_NLATTR: u32 = 1;
pub const CONFIG_HOTPLUG_PCI: u32 = 1;
pub const CONFIG_TCP_CONG_CUBIC: u32 = 1;
pub const CONFIG_NR_CPUS: u32 = 64;
pub const CONFIG_SUSPEND_FREEZER: u32 = 1;
pub const CONFIG_HAVE_EXIT_THREAD: u32 = 1;
pub const CONFIG_SND_SUPPORT_OLD_API: u32 = 1;
pub const CONFIG_NR_CPUS_RANGE_BEGIN: u32 = 2;
pub const CONFIG_LOGITECH_FF: u32 = 1;
pub const CONFIG_MOUSE_PS2_TRACKPOINT: u32 = 1;
pub const CONFIG_SYSFS: u32 = 1;
pub const CONFIG_USB_DEFAULT_PERSIST: u32 = 1;
pub const CONFIG_ARCH_HAS_PARANOID_L1D_FLUSH: u32 = 1;
pub const CONFIG_AS_HAS_NON_CONST_LEB128: u32 = 1;
pub const CONFIG_INPUT_TOUCHSCREEN: u32 = 1;
pub const CONFIG_DRM_PANEL_BRIDGE: u32 = 1;
pub const CONFIG_BLK_DEV_BSG_COMMON: u32 = 1;
pub const CONFIG_ASN1: u32 = 1;
pub const CONFIG_XZ_DEC_ARM: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK_OPTIONAL: u32 = 1;
pub const CONFIG_CRYPTO_HASH_INFO: u32 = 1;
pub const CONFIG_HAVE_SYSCALL_TRACEPOINTS: u32 = 1;
pub const CONFIG_HAVE_ARCH_HUGE_VMALLOC: u32 = 1;
pub const CONFIG_ACPI_BATTERY: u32 = 1;
pub const CONFIG_IO_WQ: u32 = 1;
pub const CONFIG_DECOMPRESS_ZSTD: u32 = 1;
pub const CONFIG_TRACING: u32 = 1;
pub const CONFIG_BLK_MQ_VIRTIO: u32 = 1;
pub const CONFIG_I2C_COMPAT: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ZYDAS: u32 = 1;
pub const CONFIG_SPARSEMEM_VMEMMAP_ENABLE: u32 = 1;
pub const CONFIG_HALTPOLL_CPUIDLE: u32 = 1;
pub const CONFIG_VIRTUALIZATION: u32 = 1;
pub const CONFIG_MSDOS_PARTITION: u32 = 1;
pub const CONFIG_RTC_I2C_AND_SPI: u32 = 1;
pub const CONFIG_HAVE_CONTEXT_TRACKING_USER_OFFSTACK: u32 = 1;
pub const CONFIG_HAVE_POSIX_CPU_TIMERS_TASK_WORK: u32 = 1;
pub const CONFIG_CPU_SUP_ZHAOXIN: u32 = 1;
pub const CONFIG_THERMAL: u32 = 1;
pub const CONFIG_SYNC_FILE: u32 = 1;
pub const CONFIG_USB_XHCI_PCI: u32 = 1;
pub const CONFIG_AMD_IOMMU: u32 = 1;
pub const CONFIG_IP_PNP_RARP: u32 = 1;
pub const CONFIG_NET_VENDOR_3COM: u32 = 1;
pub const CONFIG_HID_PETALYNX: u32 = 1;
pub const CONFIG_AMD_NUMA: u32 = 1;
pub const CONFIG_STACKPROTECTOR: u32 = 1;
pub const CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK: u32 = 1;
pub const CONFIG_HAVE_ARCH_KGDB: u32 = 1;
pub const CONFIG_JBD2_DEBUG: u32 = 1;
pub const CONFIG_ARCH_USE_QUEUED_SPINLOCKS: u32 = 1;
pub const CONFIG_BLK_DEBUG_FS: u32 = 1;
pub const CONFIG_X86_PM_TIMER: u32 = 1;
pub const CONFIG_X86_DEBUG_FPU: u32 = 1;
pub const CONFIG_CPU_FREQ_GOV_SCHEDUTIL: u32 = 1;
pub const CONFIG_NET_VENDOR_INTEL: u32 = 1;
pub const CONFIG_HAVE_SOFTIRQ_ON_OWN_STACK: u32 = 1;
pub const CONFIG_RPS: u32 = 1;
pub const CONFIG_SERIAL_8250_EXAR: u32 = 1;
pub const CONFIG_PROC_PID_CPUSET: u32 = 1;
pub const CONFIG_GENERIC_CSUM: u32 = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_2: u32 = 1;
pub const CONFIG_HYPERVISOR_GUEST: u32 = 1;
pub const CONFIG_ZISOFS: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MEDIATEK: u32 = 1;
pub const CONFIG_IP_MULTICAST: u32 = 1;
pub const CONFIG_GENERIC_CMOS_UPDATE: u32 = 1;
pub const CONFIG_NET_VENDOR_CISCO: u32 = 1;
pub const CONFIG_ARCH_HAS_PTE_DEVMAP: u32 = 1;
pub const CONFIG_TICK_ONESHOT: u32 = 1;
pub const CONFIG_CRYPTO_CTR: u32 = 1;
pub const CONFIG_COMPAT_FOR_U64_ALIGNMENT: u32 = 1;
pub const CONFIG_XARRAY_MULTI: u32 = 1;
pub const CONFIG_CGROUP_DEBUG: u32 = 1;
pub const CONFIG_SND_INTEL_DSP_CONFIG: u32 = 1;
pub const CONFIG_HW_RANDOM: u32 = 1;
pub const CONFIG_MUTEX_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_DYNAMIC_SIGFRAME: u32 = 1;
pub const CONFIG_RETHOOK: u32 = 1;
pub const CONFIG_EARLY_PRINTK: u32 = 1;
pub const CONFIG_CGROUP_NET_CLASSID: u32 = 1;
pub const CONFIG_HW_RANDOM_VIA: u32 = 1;
pub const CONFIG_HAVE_CMPXCHG_LOCAL: u32 = 1;
pub const CONFIG_INTEL_IOMMU_SCALABLE_MODE_DEFAULT_ON: u32 = 1;
pub const CONFIG_TREE_SRCU: u32 = 1;
pub const CONFIG_CRYPTO_NULL2: u32 = 1;
pub const CONFIG_ACPI_THERMAL: u32 = 1;
pub const CONFIG_ACPI_MDIO: u32 = 1;
pub const CONFIG_ARCH_HAS_ACPI_TABLE_UPGRADE: u32 = 1;
pub const CONFIG_HUGETLB_PAGE_OPTIMIZE_VMEMMAP: u32 = 1;
pub const CONFIG_SERIAL_8250_DMA: u32 = 1;
pub const CONFIG_BASE_SMALL: u32 = 0;
pub const CONFIG_SECURITY_SELINUX_AVC_STATS: u32 = 1;
pub const CONFIG_SND_SEQ_DUMMY: u32 = 1;
pub const CONFIG_COMPACTION: u32 = 1;
pub const CONFIG_NFS_V2: u32 = 1;
pub const CONFIG_SND_INTEL_NHLT: u32 = 1;
pub const CONFIG_PROC_FS: u32 = 1;
pub const CONFIG_GENERIC_BUG_RELATIVE_POINTERS: u32 = 1;
pub const CONFIG_MMU_GATHER_RCU_TABLE_FREE: u32 = 1;
pub const CONFIG_NET_VENDOR_ROCKER: u32 = 1;
pub const CONFIG_XFRM_AH: u32 = 1;
pub const CONFIG_SCSI_LOWLEVEL: u32 = 1;
pub const CONFIG_MEMFD_CREATE: u32 = 1;
pub const CONFIG_IRQ_FORCED_THREADING: u32 = 1;
pub const CONFIG_EDAC_ATOMIC_SCRUB: u32 = 1;
pub const CONFIG_CRYPTO_CMAC: u32 = 1;
pub const CONFIG_HID_PANTHERLORD: u32 = 1;
pub const CONFIG_SND: u32 = 1;
pub const CONFIG_LD_ORPHAN_WARN: u32 = 1;
pub const CONFIG_RFKILL_INPUT: u32 = 1;
pub const CONFIG_NET_VENDOR_NATSEMI: u32 = 1;
pub const CONFIG_VIRTIO_PCI_LIB_LEGACY: u32 = 1;
pub const CONFIG_NET_VENDOR_GOOGLE: u32 = 1;
pub const CONFIG_GENERIC_IRQ_MIGRATION: u32 = 1;
pub const CONFIG_NET_VENDOR_NETRONOME: u32 = 1;
pub const CONFIG_NFS_USE_KERNEL_DNS: u32 = 1;
pub const CONFIG_ARCH_HAS_FORTIFY_SOURCE: u32 = 1;
pub const CONFIG_GCC_VERSION: u32 = 110400;
pub const CONFIG_SND_HDA_I915: u32 = 1;
pub const CONFIG_CRYPTO_LIB_POLY1305_RSIZE: u32 = 11;
pub const CONFIG_SYSCTL: u32 = 1;
pub const CONFIG_CC_CAN_LINK_STATIC: u32 = 1;
pub const CONFIG_842_DECOMPRESS: u32 = 1;
pub const CONFIG_ARCH_HAS_GCOV_PROFILE_ALL: u32 = 1;
pub const CONFIG_PHYS_ADDR_T_64BIT: u32 = 1;
pub const CONFIG_THREAD_INFO_IN_TASK: u32 = 1;
pub const CONFIG_NET_VENDOR_LITEX: u32 = 1;
pub const CONFIG_CRYPTO_842: u32 = 1;
pub const CONFIG_HAVE_C_RECORDMCOUNT: u32 = 1;
pub const CONFIG_GENERIC_MSI_IRQ: u32 = 1;
pub const CONFIG_HAVE_ARCH_TRACEHOOK: u32 = 1;
pub const CONFIG_XFRM_USER: u32 = 1;
pub const CONFIG_DRM_I915_REQUEST_TIMEOUT: u32 = 20000;
pub const CONFIG_TASK_DELAY_ACCT: u32 = 1;
pub const CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE: u32 = 1;
pub const CONFIG_NET_NS: u32 = 1;
pub const CONFIG_HAVE_PERF_EVENTS: u32 = 1;
pub const CONFIG_ATA_SFF: u32 = 1;
pub const CONFIG_HAVE_ALIGNED_STRUCT_PAGE: u32 = 1;
pub const CONFIG_NET_VENDOR_SOLARFLARE: u32 = 1;
pub const CONFIG_CC_HAS_IBT: u32 = 1;
pub const CONFIG_DEBUG_MEMORY_INIT: u32 = 1;
pub const CONFIG_XFRM_ESP: u32 = 1;
pub const CONFIG_AUDIT: u32 = 1;
pub const CONFIG_INTEL_IOMMU: u32 = 1;
pub const CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE: u32 = 1;
pub const CONFIG_HAVE_RETHOOK: u32 = 1;
pub const CONFIG_NET_9P_FD: u32 = 1;
pub const CONFIG_LTO_NONE: u32 = 1;
pub const CONFIG_PCIEASPM: u32 = 1;
pub const CONFIG_DEBUG_FS_ALLOW_ALL: u32 = 1;
pub const CONFIG_ATA_PIIX: u32 = 1;
pub const CONFIG_KASAN_OUTLINE: u32 = 1;
pub const CONFIG_SATA_AHCI: u32 = 1;
pub const CONFIG_HAVE_STATIC_CALL: u32 = 1;
pub const CONFIG_SECURITY: u32 = 1;
pub const CONFIG_OPTPROBES: u32 = 1;
pub const CONFIG_ACPI_NUMA: u32 = 1;
pub const CONFIG_SND_TIMER: u32 = 1;
pub const CONFIG_USB_EHCI_TT_NEWSCHED: u32 = 1;
pub const CONFIG_FAT_DEFAULT_CODEPAGE: u32 = 437;
pub const CONFIG_BLK_DEV: u32 = 1;
pub const CONFIG_SERIO_I8042: u32 = 1;
pub const CONFIG_MAC80211_RC_DEFAULT: &'static [u8; 12usize] = b"minstrel_ht\0";
pub const CONFIG_NFS_ACL_SUPPORT: u32 = 1;
pub const CONFIG_CC_HAS_ASM_GOTO_TIED_OUTPUT: u32 = 1;
pub const CONFIG_HAVE_ARCH_KFENCE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_SILABS: u32 = 1;
pub const CONFIG_IOMMU_API: u32 = 1;
pub const CONFIG_TRACING_SUPPORT: u32 = 1;
pub const CONFIG_UNIX98_PTYS: u32 = 1;
pub const CONFIG_NET_RX_BUSY_POLL: u32 = 1;
pub const CONFIG_NET_VENDOR_SOCIONEXT: u32 = 1;
pub const CONFIG_SECURITY_SELINUX: u32 = 1;
pub const CONFIG_ZONE_DMA32: u32 = 1;
pub const CONFIG_NET_SCHED: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_CONNSECMARK: u32 = 1;
pub const CONFIG_DRM_PANEL: u32 = 1;
pub const CONFIG_PRINTK_TIME: u32 = 1;
pub const CONFIG_TRACE_IRQFLAGS_NMI_SUPPORT: u32 = 1;
pub const CONFIG_TASKS_RCU_GENERIC: u32 = 1;
pub const CONFIG_SECCOMP_FILTER: u32 = 1;
pub const CONFIG_ARCH_MAY_HAVE_PC_FDC: u32 = 1;
pub const CONFIG_HAVE_KERNEL_LZO: u32 = 1;
pub const CONFIG_CRYPTO_GHASH: u32 = 1;
pub const CONFIG_GENERIC_ENTRY: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_SIDTAB_HASH_BITS: u32 = 9;
pub const CONFIG_NF_NAT_FTP: u32 = 1;
pub const CONFIG_MAC80211_RC_MINSTREL: u32 = 1;
pub const CONFIG_ELF_CORE: u32 = 1;
pub const CONFIG_ACPI_DOCK: u32 = 1;
pub const CONFIG_HAVE_CONTEXT_TRACKING_USER: u32 = 1;
pub const CONFIG_USB_SUPPORT: u32 = 1;
pub const CONFIG_MODIFY_LDT_SYSCALL: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ST: u32 = 1;
pub const CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS: u32 = 1;
pub const CONFIG_NET_VENDOR_SIS: u32 = 1;
pub const CONFIG_VT_CONSOLE: u32 = 1;
pub const CONFIG_SCHED_INFO: u32 = 1;
pub const CONFIG_MQ_IOSCHED_KYBER: u32 = 1;
pub const CONFIG_AS_VERSION: u32 = 23800;
pub const CONFIG_CC_HAS_INT128: u32 = 1;
pub const CONFIG_EFI_EARLYCON: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MARVELL: u32 = 1;
pub const CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE: u32 = 1;
pub const CONFIG_SERIAL_8250_DWLIB: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS: u32 = 8;
pub const CONFIG_NETFILTER_XT_MATCH_STATE: u32 = 1;
pub const CONFIG_PCI_DIRECT: u32 = 1;
pub const CONFIG_DRM: u32 = 1;
pub const CONFIG_DRM_I915_FORCE_PROBE: &'static [u8; 1usize] = b"\0";
pub const CONFIG_POSIX_MQUEUE_SYSCTL: u32 = 1;
pub const CONFIG_DRM_I915_TIMESLICE_DURATION: u32 = 1;
pub const CONFIG_VHOST_MENU: u32 = 1;
pub const CONFIG_DEBUG_MISC: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROSEMI: u32 = 1;
pub const CONFIG_BINARY_PRINTF: u32 = 1;
pub const CONFIG_ACPI_REV_OVERRIDE_POSSIBLE: u32 = 1;
pub const CONFIG_HAVE_PREEMPT_DYNAMIC_CALL: u32 = 1;
pub const CONFIG_AS_AVX512: u32 = 1;
pub const CONFIG_HARDLOCKUP_CHECK_TIMESTAMP: u32 = 1;
pub const CONFIG_SCHED_CLUSTER: u32 = 1;
pub const CONFIG_ZSTD_DECOMPRESS: u32 = 1;
pub const CONFIG_INPUT_SPARSEKMAP: u32 = 1;
pub const CONFIG_PTDUMP_CORE: u32 = 1;
pub const CONFIG_SYSFS_SYSCALL: u32 = 1;
pub const CONFIG_WLAN_VENDOR_QUANTENNA: u32 = 1;
pub const CONFIG_SND_PCM_TIMER: u32 = 1;
pub const CONFIG_ARCH_HAS_SET_DIRECT_MAP: u32 = 1;
pub const CONFIG_SYSVIPC_SYSCTL: u32 = 1;
pub const CONFIG_WLAN_VENDOR_TI: u32 = 1;
pub const CONFIG_HID_NTRIG: u32 = 1;
pub const CONFIG_X86_64_ACPI_NUMA: u32 = 1;
pub const CONFIG_DMA_SHARED_BUFFER: u32 = 1;
pub const CONFIG_RTC_SYSTOHC: u32 = 1;
pub const CONFIG_DECOMPRESS_GZIP: u32 = 1;
pub const CONFIG_VIRTIO_MENU: u32 = 1;
pub const CONFIG_VIRTIO_BLK: u32 = 1;
pub const CONFIG_DECOMPRESS_LZO: u32 = 1;
pub const CONFIG_64BIT: u32 = 1;
pub const CONFIG_QUOTA: u32 = 1;
pub const CONFIG_I2C_CHARDEV: u32 = 1;
pub const CONFIG_HAVE_JUMP_LABEL_HACK: u32 = 1;
pub const CONFIG_ARCH_USE_QUEUED_RWLOCKS: u32 = 1;
pub const CONFIG_ARCH_HAS_PKEYS: u32 = 1;
pub const CONFIG_NETWORK_SECMARK: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS_BROADCAST: u32 = 1;
pub const CONFIG_POWER_SUPPLY_HWMON: u32 = 1;
pub const CONFIG_ARCH_HAS_ELFCORE_COMPAT: u32 = 1;
pub const CONFIG_SERIAL_8250_PCI: u32 = 1;
pub const CONFIG_HAVE_MIXED_BREAKPOINTS_REGS: u32 = 1;
pub const CONFIG_MOUSE_PS2_SYNAPTICS: u32 = 1;
pub const CONFIG_ATA_BMDMA: u32 = 1;
pub const CONFIG_XZ_DEC_ARMTHUMB: u32 = 1;
pub const CONFIG_ARCH_USE_CMPXCHG_LOCKREF: u32 = 1;
pub const CONFIG_REGMAP: u32 = 1;
pub const CONFIG_NLS_UTF8: u32 = 1;
pub const CONFIG_PCIE_PME: u32 = 1;
pub const CONFIG_HAVE_MOD_ARCH_SPECIFIC: u32 = 1;
pub const CONFIG_STRICT_MODULE_RWX: u32 = 1;
pub const CONFIG_PCCARD_NONSTATIC: u32 = 1;
pub const CONFIG_PROC_PID_ARCH_STATUS: u32 = 1;
pub const CONFIG_CPU_SUP_CENTAUR: u32 = 1;
pub const CONFIG_HAVE_INTEL_TXT: u32 = 1;
pub const CONFIG_SYSCTL_EXCEPTION_TRACE: u32 = 1;
pub const CONFIG_SYSVIPC_COMPAT: u32 = 1;
pub const CONFIG_FHANDLE: u32 = 1;
pub const CONFIG_HAVE_SAMPLE_FTRACE_DIRECT_MULTI: u32 = 1;
pub const CONFIG_WATCHDOG_OPEN_TIMEOUT: u32 = 0;
pub const CONFIG_BPFILTER_UMH_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LIB_SHA256: u32 = 1;
pub const CONFIG_NEW_LEDS: u32 = 1;
pub const CONFIG_SWAP: u32 = 1;
pub const CONFIG_FW_CACHE: u32 = 1;
pub const CONFIG_MICROCODE_INTEL: u32 = 1;
pub const CONFIG_MAC80211: u32 = 1;
pub const CONFIG_ARCH_USES_PG_UNCACHED: u32 = 1;
pub const CONFIG_CRC_CCITT: u32 = 1;
pub const CONFIG_NET_VENDOR_CAVIUM: u32 = 1;
pub const CONFIG_IGBVF: u32 = 1;
pub const CONFIG_BLK_DEV_SD: u32 = 1;
pub const CONFIG_PHYSICAL_ALIGN: u32 = 2097152;
pub const CONFIG_ACPI_LEGACY_TABLES_LOOKUP: u32 = 1;
pub const CONFIG_NETFILTER_NETLINK: u32 = 1;
pub const CONFIG_MODULE_UNLOAD: u32 = 1;
pub const CONFIG_CLOCKSOURCE_WATCHDOG_MAX_SKEW_US: u32 = 100;
pub const CONFIG_PREEMPT_COUNT: u32 = 1;
pub const CONFIG_NET_VENDOR_ENGLEDER: u32 = 1;
pub const CONFIG_HAVE_ACPI_APEI_NMI: u32 = 1;
pub const CONFIG_ARCH_WANT_OLD_COMPAT_IPC: u32 = 1;
pub const CONFIG_STACKDEPOT_ALWAYS_INIT: u32 = 1;
pub const CONFIG_RWSEM_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_HAVE_RELIABLE_STACKTRACE: u32 = 1;
pub const CONFIG_HAVE_NOINSTR_HACK: u32 = 1;
pub const CONFIG_CC_HAS_ASM_GOTO_OUTPUT: u32 = 1;
pub const CONFIG_BITREVERSE: u32 = 1;
pub const CONFIG_DEVPORT: u32 = 1;
pub const CONFIG_PREEMPTION: u32 = 1;
pub const CONFIG_DRM_I915_COMPRESS_ERROR: u32 = 1;
pub const CONFIG_X509_CERTIFICATE_PARSER: u32 = 1;
pub const CONFIG_EARLY_PRINTK_USB: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK_KVM: u32 = 1;
pub const CONFIG_SPECULATION_MITIGATIONS: u32 = 1;
pub const CONFIG_PCI_PRI: u32 = 1;
pub const CONFIG_X86_L1_CACHE_SHIFT: u32 = 6;
pub const CONFIG_X86_PAT: u32 = 1;
pub const CONFIG_PNP_DEBUG_MESSAGES: u32 = 1;
pub const CONFIG_NF_CONNTRACK: u32 = 1;
pub const CONFIG_IOASID: u32 = 1;
pub const CONFIG_EFI_RUNTIME_WRAPPERS: u32 = 1;
pub const CONFIG_MDIO_DEVRES: u32 = 1;
pub const CONFIG_LSM: &'static [u8; 85usize] =
    b"landlock,lockdown,yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor,bpf\0";
pub const CONFIG_ARCH_DMA_ADDR_T_64BIT: u32 = 1;
pub const CONFIG_FILE_LOCKING: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST: u32 = 1;
pub const CONFIG_NETPOLL: u32 = 1;
pub const CONFIG_AIO: u32 = 1;
pub const CONFIG_CLKEVT_I8253: u32 = 1;
pub const CONFIG_NET_EMATCH: u32 = 1;
pub const CONFIG_PERF_EVENTS: u32 = 1;
pub const CONFIG_GENERIC_TIME_VSYSCALL: u32 = 1;
pub const CONFIG_IP_NF_TARGET_REJECT: u32 = 1;
pub const CONFIG_HAVE_MOVE_PMD: u32 = 1;
pub const CONFIG_IOMMU_IO_PGTABLE: u32 = 1;
pub const CONFIG_LEDS_CLASS: u32 = 1;
pub const CONFIG_PERF_EVENTS_INTEL_CSTATE: u32 = 1;
pub const CONFIG_KALLSYMS_BASE_RELATIVE: u32 = 1;
pub const CONFIG_RTC_INTF_DEV: u32 = 1;
pub const CONFIG_MTD_MAP_BANK_WIDTH_4: u32 = 1;
pub const CONFIG_EISA_VIRTUAL_ROOT: u32 = 1;
pub const CONFIG_DCACHE_WORD_ACCESS: u32 = 1;
pub const CONFIG_MAGIC_SYSRQ_SERIAL_SEQUENCE: &'static [u8; 1usize] = b"\0";
pub const CONFIG_MESSAGE_LOGLEVEL_DEFAULT: u32 = 4;
pub const CONFIG_AMD_NB: u32 = 1;
pub const CONFIG_NLS_DEFAULT: &'static [u8; 5usize] = b"utf8\0";
pub const CONFIG_ACPI_CONTAINER: u32 = 1;
pub const CONFIG_SND_DMA_SGBUF: u32 = 1;
pub const CONFIG_UTS_NS: u32 = 1;
pub const CONFIG_WMI_BMOF: u32 = 1;
pub const CONFIG_NF_CT_NETLINK: u32 = 1;
pub const CONFIG_EFS_FS: u32 = 1;
pub const CONFIG_DMA_ENGINE: u32 = 1;
pub const CONFIG_X86_ACPI_CPUFREQ: u32 = 1;
pub const CONFIG_DEFAULT_SECURITY_SELINUX: u32 = 1;
pub const CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD: u32 = 1;
pub const CONFIG_CGROUP_PIDS: u32 = 1;
pub const CONFIG_DEBUG_INFO: u32 = 1;
pub const CONFIG_CRYPTO_AEAD2: u32 = 1;
pub const CONFIG_X86_HV_CALLBACK_VECTOR: u32 = 1;
pub const CONFIG_MOUSE_PS2: u32 = 1;
pub const CONFIG_CRYPTO_ALGAPI2: u32 = 1;
pub const CONFIG_PHYSICAL_START: u32 = 16777216;
pub const CONFIG_GENERIC_IRQ_RESERVATION_MODE: u32 = 1;
pub const CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS: u32 = 1;
pub const CONFIG_INPUT: u32 = 1;
pub const CONFIG_SIOX: u32 = 1;
pub const CONFIG_PROC_SYSCTL: u32 = 1;
pub const CONFIG_FWNODE_MDIO: u32 = 1;
pub const CONFIG_HAVE_PERF_EVENTS_NMI: u32 = 1;
pub const CONFIG_RD_LZ4: u32 = 1;
pub const CONFIG_MMU: u32 = 1;
pub const CONFIG_LD_VERSION: u32 = 23800;
pub const CONFIG_AGP: u32 = 1;
pub const CONFIG_CC_HAS_SLS: u32 = 1;
pub const CONFIG_E1000: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __ARG_PLACEHOLDER_1: u32 = 0;
pub const KASAN_ABI_VERSION: u32 = 5;
pub const __BITS_PER_LONG: u32 = 64;
pub const BITS_PER_LONG: u32 = 64;
pub const BITS_PER_LONG_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const KCSAN_ACCESS_WRITE: u32 = 1;
pub const KCSAN_ACCESS_COMPOUND: u32 = 2;
pub const KCSAN_ACCESS_ATOMIC: u32 = 4;
pub const KCSAN_ACCESS_ASSERT: u32 = 8;
pub const KCSAN_ACCESS_SCOPED: u32 = 16;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ERESTARTSYS: u32 = 512;
pub const ERESTARTNOINTR: u32 = 513;
pub const ERESTARTNOHAND: u32 = 514;
pub const ENOIOCTLCMD: u32 = 515;
pub const ERESTART_RESTARTBLOCK: u32 = 516;
pub const EPROBE_DEFER: u32 = 517;
pub const EOPENSTALE: u32 = 518;
pub const ENOPARAM: u32 = 519;
pub const EBADHANDLE: u32 = 521;
pub const ENOTSYNC: u32 = 522;
pub const EBADCOOKIE: u32 = 523;
pub const ENOTSUPP: u32 = 524;
pub const ETOOSMALL: u32 = 525;
pub const ESERVERFAULT: u32 = 526;
pub const EBADTYPE: u32 = 527;
pub const EJUKEBOX: u32 = 528;
pub const EIOCBQUEUED: u32 = 529;
pub const ERECALLCONFLICT: u32 = 530;
pub const ENOGRACE: u32 = 531;
pub const EX_DATA_REG_SHIFT: u32 = 8;
pub const EX_DATA_FLAG_SHIFT: u32 = 12;
pub const EX_DATA_IMM_SHIFT: u32 = 16;
pub const EX_TYPE_NONE: u32 = 0;
pub const EX_TYPE_DEFAULT: u32 = 1;
pub const EX_TYPE_FAULT: u32 = 2;
pub const EX_TYPE_UACCESS: u32 = 3;
pub const EX_TYPE_COPY: u32 = 4;
pub const EX_TYPE_CLEAR_FS: u32 = 5;
pub const EX_TYPE_FPU_RESTORE: u32 = 6;
pub const EX_TYPE_BPF: u32 = 7;
pub const EX_TYPE_WRMSR: u32 = 8;
pub const EX_TYPE_RDMSR: u32 = 9;
pub const EX_TYPE_WRMSR_SAFE: u32 = 10;
pub const EX_TYPE_RDMSR_SAFE: u32 = 11;
pub const EX_TYPE_WRMSR_IN_MCE: u32 = 12;
pub const EX_TYPE_RDMSR_IN_MCE: u32 = 13;
pub const EX_TYPE_DEFAULT_MCE_SAFE: u32 = 14;
pub const EX_TYPE_FAULT_MCE_SAFE: u32 = 15;
pub const EX_TYPE_POP_REG: u32 = 16;
pub const EX_TYPE_IMM_REG: u32 = 17;
pub const EX_TYPE_FAULT_SGX: u32 = 18;
pub const EX_TYPE_UCOPY_LEN: u32 = 19;
pub const EX_TYPE_ZEROPAD: u32 = 20;
pub const DEFINE_EXTABLE_TYPE_REG : & 'static [u8 ; 533usize] = b".macro extable_type_reg type:req reg:req\n.set .Lfound, 0\n.set .Lregnr, 0\n.irp rs,rax,rcx,rdx,rbx,rsp,rbp,rsi,rdi,r8,r9,r10,r11,r12,r13,r14,r15\n.ifc \\reg, %%\\rs\n.set .Lfound, .Lfound+1\n.long \\type + (.Lregnr << 8)\n.endif\n.set .Lregnr, .Lregnr+1\n.endr\n.set .Lregnr, 0\n.irp rs,eax,ecx,edx,ebx,esp,ebp,esi,edi,r8d,r9d,r10d,r11d,r12d,r13d,r14d,r15d\n.ifc \\reg, %%\\rs\n.set .Lfound, .Lfound+1\n.long \\type + (.Lregnr << 8)\n.endif\n.set .Lregnr, .Lregnr+1\n.endr\n.if (.Lfound != 1)\n.error \"extable_type_reg: bad register argument\"\n.endif\n.endm\n\0" ;
pub const UNDEFINE_EXTABLE_TYPE_REG: &'static [u8; 26usize] = b".purgem extable_type_reg\n\0";
pub const BYTES_NOP1: u32 = 144;
pub const ASM_NOP_MAX: u32 = 8;
pub const JUMP_TYPE_FALSE: u32 = 0;
pub const JUMP_TYPE_TRUE: u32 = 1;
pub const JUMP_TYPE_LINKED: u32 = 2;
pub const JUMP_TYPE_MASK: u32 = 3;
pub const __HAVE_ARCH_MEMCPY: u32 = 1;
pub const __HAVE_ARCH_MEMCPY_FLUSHCACHE: u32 = 1;
pub const LZ4_MEMORY_USAGE: u32 = 14;
pub const LZ4_MAX_INPUT_SIZE: u32 = 2113929216;
pub const LZ4_ACCELERATION_DEFAULT: u32 = 1;
pub const LZ4_HASHLOG: u32 = 12;
pub const LZ4_HASHTABLESIZE: u32 = 16384;
pub const LZ4_HASH_SIZE_U32: u32 = 4096;
pub const LZ4HC_MIN_CLEVEL: u32 = 3;
pub const LZ4HC_DEFAULT_CLEVEL: u32 = 9;
pub const LZ4HC_MAX_CLEVEL: u32 = 16;
pub const LZ4HC_DICTIONARY_LOGSIZE: u32 = 16;
pub const LZ4HC_MAXD: u32 = 65536;
pub const LZ4HC_MAXD_MASK: u32 = 65535;
pub const LZ4HC_HASH_LOG: u32 = 15;
pub const LZ4HC_HASHTABLESIZE: u32 = 32768;
pub const LZ4HC_HASH_MASK: u32 = 32767;
pub const LZ4_STREAMSIZE_U64: u32 = 2052;
pub const LZ4_STREAMHCSIZE: u32 = 262192;
pub const LZ4_STREAMDECODESIZE_U64: u32 = 4;
pub const LZ4HC_MEM_COMPRESS: u32 = 262192;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const UINT_MAX: i32 = -1;
pub const ULONG_MAX: i32 = -1;
pub const ULLONG_MAX: i32 = -1;
pub const UINTPTR_MAX: i32 = -1;
pub const HAS_KERNEL_IBT: u32 = 0;
pub const ENDBR_INSN_SIZE: u32 = 0;
pub const ASM_RET: &'static [u8; 25usize] = b"jmp __x86_return_thunk\n\t\0";
pub const __ALIGN_STR: &'static [u8; 14usize] = b".align 4,0x90\0";
pub const MAX_ERRNO: u32 = 4095;
pub const BITS_PER_BYTE: u32 = 8;
pub const SI_LOAD_SHIFT: u32 = 16;
pub const ALTINSTR_FLAG_INV: u32 = 32768;
pub const LOCK_PREFIX_HERE: &'static [u8; 70usize] =
    b".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\0";
pub const LOCK_PREFIX: &'static [u8; 78usize] =
    b".pushsection .smp_locks,\"a\"\n.balign 4\n.long 671f - .\n.popsection\n671:\n\tlock; \0";
pub const ANNOTATE_IGNORE_ALTERNATIVE: &'static [u8; 71usize] =
    b"999:\n\t.pushsection .discard.ignore_alts\n\t.long 999b - .\n\t.popsection\n\t\0";
pub const alt_end_marker: &'static [u8; 4usize] = b"663\0";
pub const alt_slen: &'static [u8; 10usize] = b"662b-661b\0";
pub const alt_total_slen: &'static [u8; 10usize] = b"663b-661b\0";
pub const _BITOPS_LONG_SHIFT: u32 = 6;
pub const NEED_3DNOW: u32 = 0;
pub const NEED_MOVBE: u32 = 0;
pub const REQUIRED_MASK2: u32 = 0;
pub const REQUIRED_MASK4: u32 = 0;
pub const REQUIRED_MASK5: u32 = 0;
pub const REQUIRED_MASK6: u32 = 0;
pub const REQUIRED_MASK7: u32 = 0;
pub const REQUIRED_MASK8: u32 = 0;
pub const REQUIRED_MASK9: u32 = 0;
pub const REQUIRED_MASK10: u32 = 0;
pub const REQUIRED_MASK11: u32 = 0;
pub const REQUIRED_MASK12: u32 = 0;
pub const REQUIRED_MASK13: u32 = 0;
pub const REQUIRED_MASK14: u32 = 0;
pub const REQUIRED_MASK15: u32 = 0;
pub const REQUIRED_MASK16: u32 = 0;
pub const REQUIRED_MASK17: u32 = 0;
pub const REQUIRED_MASK18: u32 = 0;
pub const REQUIRED_MASK19: u32 = 0;
pub const DISABLE_UMIP: u32 = 0;
pub const DISABLE_PCID: u32 = 0;
pub const DISABLE_PKU: u32 = 0;
pub const DISABLE_OSPKE: u32 = 0;
pub const DISABLE_LA57: u32 = 0;
pub const DISABLE_PTI: u32 = 0;
pub const DISABLE_RETPOLINE: u32 = 0;
pub const DISABLE_RETHUNK: u32 = 0;
pub const DISABLE_UNRET: u32 = 0;
pub const DISABLED_MASK1: u32 = 0;
pub const DISABLED_MASK2: u32 = 0;
pub const DISABLED_MASK4: u32 = 0;
pub const DISABLED_MASK5: u32 = 0;
pub const DISABLED_MASK6: u32 = 0;
pub const DISABLED_MASK7: u32 = 0;
pub const DISABLED_MASK10: u32 = 0;
pub const DISABLED_MASK11: u32 = 0;
pub const DISABLED_MASK12: u32 = 0;
pub const DISABLED_MASK13: u32 = 0;
pub const DISABLED_MASK14: u32 = 0;
pub const DISABLED_MASK15: u32 = 0;
pub const DISABLED_MASK17: u32 = 0;
pub const DISABLED_MASK18: u32 = 0;
pub const DISABLED_MASK19: u32 = 0;
pub const NCAPINTS: u32 = 20;
pub const NBUGINTS: u32 = 1;
pub const X86_FEATURE_FPU: u32 = 0;
pub const X86_FEATURE_VME: u32 = 1;
pub const X86_FEATURE_DE: u32 = 2;
pub const X86_FEATURE_PSE: u32 = 3;
pub const X86_FEATURE_TSC: u32 = 4;
pub const X86_FEATURE_MSR: u32 = 5;
pub const X86_FEATURE_PAE: u32 = 6;
pub const X86_FEATURE_MCE: u32 = 7;
pub const X86_FEATURE_CX8: u32 = 8;
pub const X86_FEATURE_APIC: u32 = 9;
pub const X86_FEATURE_SEP: u32 = 11;
pub const X86_FEATURE_MTRR: u32 = 12;
pub const X86_FEATURE_PGE: u32 = 13;
pub const X86_FEATURE_MCA: u32 = 14;
pub const X86_FEATURE_CMOV: u32 = 15;
pub const X86_FEATURE_PAT: u32 = 16;
pub const X86_FEATURE_PSE36: u32 = 17;
pub const X86_FEATURE_PN: u32 = 18;
pub const X86_FEATURE_CLFLUSH: u32 = 19;
pub const X86_FEATURE_DS: u32 = 21;
pub const X86_FEATURE_ACPI: u32 = 22;
pub const X86_FEATURE_MMX: u32 = 23;
pub const X86_FEATURE_FXSR: u32 = 24;
pub const X86_FEATURE_XMM: u32 = 25;
pub const X86_FEATURE_XMM2: u32 = 26;
pub const X86_FEATURE_SELFSNOOP: u32 = 27;
pub const X86_FEATURE_HT: u32 = 28;
pub const X86_FEATURE_ACC: u32 = 29;
pub const X86_FEATURE_IA64: u32 = 30;
pub const X86_FEATURE_PBE: u32 = 31;
pub const X86_FEATURE_SYSCALL: u32 = 43;
pub const X86_FEATURE_MP: u32 = 51;
pub const X86_FEATURE_NX: u32 = 52;
pub const X86_FEATURE_MMXEXT: u32 = 54;
pub const X86_FEATURE_FXSR_OPT: u32 = 57;
pub const X86_FEATURE_GBPAGES: u32 = 58;
pub const X86_FEATURE_RDTSCP: u32 = 59;
pub const X86_FEATURE_LM: u32 = 61;
pub const X86_FEATURE_3DNOWEXT: u32 = 62;
pub const X86_FEATURE_3DNOW: u32 = 63;
pub const X86_FEATURE_RECOVERY: u32 = 64;
pub const X86_FEATURE_LONGRUN: u32 = 65;
pub const X86_FEATURE_LRTI: u32 = 67;
pub const X86_FEATURE_CXMMX: u32 = 96;
pub const X86_FEATURE_K6_MTRR: u32 = 97;
pub const X86_FEATURE_CYRIX_ARR: u32 = 98;
pub const X86_FEATURE_CENTAUR_MCR: u32 = 99;
pub const X86_FEATURE_K8: u32 = 100;
pub const X86_FEATURE_P3: u32 = 102;
pub const X86_FEATURE_P4: u32 = 103;
pub const X86_FEATURE_CONSTANT_TSC: u32 = 104;
pub const X86_FEATURE_UP: u32 = 105;
pub const X86_FEATURE_ART: u32 = 106;
pub const X86_FEATURE_ARCH_PERFMON: u32 = 107;
pub const X86_FEATURE_PEBS: u32 = 108;
pub const X86_FEATURE_BTS: u32 = 109;
pub const X86_FEATURE_SYSCALL32: u32 = 110;
pub const X86_FEATURE_SYSENTER32: u32 = 111;
pub const X86_FEATURE_REP_GOOD: u32 = 112;
pub const X86_FEATURE_AMD_LBR_V2: u32 = 113;
pub const X86_FEATURE_LFENCE_RDTSC: u32 = 114;
pub const X86_FEATURE_ACC_POWER: u32 = 115;
pub const X86_FEATURE_NOPL: u32 = 116;
pub const X86_FEATURE_ALWAYS: u32 = 117;
pub const X86_FEATURE_XTOPOLOGY: u32 = 118;
pub const X86_FEATURE_TSC_RELIABLE: u32 = 119;
pub const X86_FEATURE_NONSTOP_TSC: u32 = 120;
pub const X86_FEATURE_CPUID: u32 = 121;
pub const X86_FEATURE_EXTD_APICID: u32 = 122;
pub const X86_FEATURE_AMD_DCM: u32 = 123;
pub const X86_FEATURE_APERFMPERF: u32 = 124;
pub const X86_FEATURE_RAPL: u32 = 125;
pub const X86_FEATURE_NONSTOP_TSC_S3: u32 = 126;
pub const X86_FEATURE_TSC_KNOWN_FREQ: u32 = 127;
pub const X86_FEATURE_XMM3: u32 = 128;
pub const X86_FEATURE_PCLMULQDQ: u32 = 129;
pub const X86_FEATURE_DTES64: u32 = 130;
pub const X86_FEATURE_MWAIT: u32 = 131;
pub const X86_FEATURE_DSCPL: u32 = 132;
pub const X86_FEATURE_VMX: u32 = 133;
pub const X86_FEATURE_SMX: u32 = 134;
pub const X86_FEATURE_EST: u32 = 135;
pub const X86_FEATURE_TM2: u32 = 136;
pub const X86_FEATURE_SSSE3: u32 = 137;
pub const X86_FEATURE_CID: u32 = 138;
pub const X86_FEATURE_SDBG: u32 = 139;
pub const X86_FEATURE_FMA: u32 = 140;
pub const X86_FEATURE_CX16: u32 = 141;
pub const X86_FEATURE_XTPR: u32 = 142;
pub const X86_FEATURE_PDCM: u32 = 143;
pub const X86_FEATURE_PCID: u32 = 145;
pub const X86_FEATURE_DCA: u32 = 146;
pub const X86_FEATURE_XMM4_1: u32 = 147;
pub const X86_FEATURE_XMM4_2: u32 = 148;
pub const X86_FEATURE_X2APIC: u32 = 149;
pub const X86_FEATURE_MOVBE: u32 = 150;
pub const X86_FEATURE_POPCNT: u32 = 151;
pub const X86_FEATURE_TSC_DEADLINE_TIMER: u32 = 152;
pub const X86_FEATURE_AES: u32 = 153;
pub const X86_FEATURE_XSAVE: u32 = 154;
pub const X86_FEATURE_OSXSAVE: u32 = 155;
pub const X86_FEATURE_AVX: u32 = 156;
pub const X86_FEATURE_F16C: u32 = 157;
pub const X86_FEATURE_RDRAND: u32 = 158;
pub const X86_FEATURE_HYPERVISOR: u32 = 159;
pub const X86_FEATURE_XSTORE: u32 = 162;
pub const X86_FEATURE_XSTORE_EN: u32 = 163;
pub const X86_FEATURE_XCRYPT: u32 = 166;
pub const X86_FEATURE_XCRYPT_EN: u32 = 167;
pub const X86_FEATURE_ACE2: u32 = 168;
pub const X86_FEATURE_ACE2_EN: u32 = 169;
pub const X86_FEATURE_PHE: u32 = 170;
pub const X86_FEATURE_PHE_EN: u32 = 171;
pub const X86_FEATURE_PMM: u32 = 172;
pub const X86_FEATURE_PMM_EN: u32 = 173;
pub const X86_FEATURE_LAHF_LM: u32 = 192;
pub const X86_FEATURE_CMP_LEGACY: u32 = 193;
pub const X86_FEATURE_SVM: u32 = 194;
pub const X86_FEATURE_EXTAPIC: u32 = 195;
pub const X86_FEATURE_CR8_LEGACY: u32 = 196;
pub const X86_FEATURE_ABM: u32 = 197;
pub const X86_FEATURE_SSE4A: u32 = 198;
pub const X86_FEATURE_MISALIGNSSE: u32 = 199;
pub const X86_FEATURE_3DNOWPREFETCH: u32 = 200;
pub const X86_FEATURE_OSVW: u32 = 201;
pub const X86_FEATURE_IBS: u32 = 202;
pub const X86_FEATURE_XOP: u32 = 203;
pub const X86_FEATURE_SKINIT: u32 = 204;
pub const X86_FEATURE_WDT: u32 = 205;
pub const X86_FEATURE_LWP: u32 = 207;
pub const X86_FEATURE_FMA4: u32 = 208;
pub const X86_FEATURE_TCE: u32 = 209;
pub const X86_FEATURE_NODEID_MSR: u32 = 211;
pub const X86_FEATURE_TBM: u32 = 213;
pub const X86_FEATURE_TOPOEXT: u32 = 214;
pub const X86_FEATURE_PERFCTR_CORE: u32 = 215;
pub const X86_FEATURE_PERFCTR_NB: u32 = 216;
pub const X86_FEATURE_BPEXT: u32 = 218;
pub const X86_FEATURE_PTSC: u32 = 219;
pub const X86_FEATURE_PERFCTR_LLC: u32 = 220;
pub const X86_FEATURE_MWAITX: u32 = 221;
pub const X86_FEATURE_RING3MWAIT: u32 = 224;
pub const X86_FEATURE_CPUID_FAULT: u32 = 225;
pub const X86_FEATURE_CPB: u32 = 226;
pub const X86_FEATURE_EPB: u32 = 227;
pub const X86_FEATURE_CAT_L3: u32 = 228;
pub const X86_FEATURE_CAT_L2: u32 = 229;
pub const X86_FEATURE_CDP_L3: u32 = 230;
pub const X86_FEATURE_INVPCID_SINGLE: u32 = 231;
pub const X86_FEATURE_HW_PSTATE: u32 = 232;
pub const X86_FEATURE_PROC_FEEDBACK: u32 = 233;
pub const X86_FEATURE_XCOMPACTED: u32 = 234;
pub const X86_FEATURE_PTI: u32 = 235;
pub const X86_FEATURE_KERNEL_IBRS: u32 = 236;
pub const X86_FEATURE_RSB_VMEXIT: u32 = 237;
pub const X86_FEATURE_INTEL_PPIN: u32 = 238;
pub const X86_FEATURE_CDP_L2: u32 = 239;
pub const X86_FEATURE_MSR_SPEC_CTRL: u32 = 240;
pub const X86_FEATURE_SSBD: u32 = 241;
pub const X86_FEATURE_MBA: u32 = 242;
pub const X86_FEATURE_RSB_CTXSW: u32 = 243;
pub const X86_FEATURE_PERFMON_V2: u32 = 244;
pub const X86_FEATURE_USE_IBPB: u32 = 245;
pub const X86_FEATURE_USE_IBRS_FW: u32 = 246;
pub const X86_FEATURE_SPEC_STORE_BYPASS_DISABLE: u32 = 247;
pub const X86_FEATURE_LS_CFG_SSBD: u32 = 248;
pub const X86_FEATURE_IBRS: u32 = 249;
pub const X86_FEATURE_IBPB: u32 = 250;
pub const X86_FEATURE_STIBP: u32 = 251;
pub const X86_FEATURE_ZEN: u32 = 252;
pub const X86_FEATURE_L1TF_PTEINV: u32 = 253;
pub const X86_FEATURE_IBRS_ENHANCED: u32 = 254;
pub const X86_FEATURE_MSR_IA32_FEAT_CTL: u32 = 255;
pub const X86_FEATURE_TPR_SHADOW: u32 = 256;
pub const X86_FEATURE_VNMI: u32 = 257;
pub const X86_FEATURE_FLEXPRIORITY: u32 = 258;
pub const X86_FEATURE_EPT: u32 = 259;
pub const X86_FEATURE_VPID: u32 = 260;
pub const X86_FEATURE_VMMCALL: u32 = 271;
pub const X86_FEATURE_XENPV: u32 = 272;
pub const X86_FEATURE_EPT_AD: u32 = 273;
pub const X86_FEATURE_VMCALL: u32 = 274;
pub const X86_FEATURE_VMW_VMMCALL: u32 = 275;
pub const X86_FEATURE_PVUNLOCK: u32 = 276;
pub const X86_FEATURE_VCPUPREEMPT: u32 = 277;
pub const X86_FEATURE_TDX_GUEST: u32 = 278;
pub const X86_FEATURE_FSGSBASE: u32 = 288;
pub const X86_FEATURE_TSC_ADJUST: u32 = 289;
pub const X86_FEATURE_SGX: u32 = 290;
pub const X86_FEATURE_BMI1: u32 = 291;
pub const X86_FEATURE_HLE: u32 = 292;
pub const X86_FEATURE_AVX2: u32 = 293;
pub const X86_FEATURE_FDP_EXCPTN_ONLY: u32 = 294;
pub const X86_FEATURE_SMEP: u32 = 295;
pub const X86_FEATURE_BMI2: u32 = 296;
pub const X86_FEATURE_ERMS: u32 = 297;
pub const X86_FEATURE_INVPCID: u32 = 298;
pub const X86_FEATURE_RTM: u32 = 299;
pub const X86_FEATURE_CQM: u32 = 300;
pub const X86_FEATURE_ZERO_FCS_FDS: u32 = 301;
pub const X86_FEATURE_MPX: u32 = 302;
pub const X86_FEATURE_RDT_A: u32 = 303;
pub const X86_FEATURE_AVX512F: u32 = 304;
pub const X86_FEATURE_AVX512DQ: u32 = 305;
pub const X86_FEATURE_RDSEED: u32 = 306;
pub const X86_FEATURE_ADX: u32 = 307;
pub const X86_FEATURE_SMAP: u32 = 308;
pub const X86_FEATURE_AVX512IFMA: u32 = 309;
pub const X86_FEATURE_CLFLUSHOPT: u32 = 311;
pub const X86_FEATURE_CLWB: u32 = 312;
pub const X86_FEATURE_INTEL_PT: u32 = 313;
pub const X86_FEATURE_AVX512PF: u32 = 314;
pub const X86_FEATURE_AVX512ER: u32 = 315;
pub const X86_FEATURE_AVX512CD: u32 = 316;
pub const X86_FEATURE_SHA_NI: u32 = 317;
pub const X86_FEATURE_AVX512BW: u32 = 318;
pub const X86_FEATURE_AVX512VL: u32 = 319;
pub const X86_FEATURE_XSAVEOPT: u32 = 320;
pub const X86_FEATURE_XSAVEC: u32 = 321;
pub const X86_FEATURE_XGETBV1: u32 = 322;
pub const X86_FEATURE_XSAVES: u32 = 323;
pub const X86_FEATURE_XFD: u32 = 324;
pub const X86_FEATURE_CQM_LLC: u32 = 352;
pub const X86_FEATURE_CQM_OCCUP_LLC: u32 = 353;
pub const X86_FEATURE_CQM_MBM_TOTAL: u32 = 354;
pub const X86_FEATURE_CQM_MBM_LOCAL: u32 = 355;
pub const X86_FEATURE_FENCE_SWAPGS_USER: u32 = 356;
pub const X86_FEATURE_FENCE_SWAPGS_KERNEL: u32 = 357;
pub const X86_FEATURE_SPLIT_LOCK_DETECT: u32 = 358;
pub const X86_FEATURE_PER_THREAD_MBA: u32 = 359;
pub const X86_FEATURE_SGX1: u32 = 360;
pub const X86_FEATURE_SGX2: u32 = 361;
pub const X86_FEATURE_ENTRY_IBPB: u32 = 362;
pub const X86_FEATURE_RRSBA_CTRL: u32 = 363;
pub const X86_FEATURE_RETPOLINE: u32 = 364;
pub const X86_FEATURE_RETPOLINE_LFENCE: u32 = 365;
pub const X86_FEATURE_RETHUNK: u32 = 366;
pub const X86_FEATURE_UNRET: u32 = 367;
pub const X86_FEATURE_USE_IBPB_FW: u32 = 368;
pub const X86_FEATURE_RSB_VMEXIT_LITE: u32 = 369;
pub const X86_FEATURE_MSR_TSX_CTRL: u32 = 372;
pub const X86_FEATURE_AVX_VNNI: u32 = 388;
pub const X86_FEATURE_AVX512_BF16: u32 = 389;
pub const X86_FEATURE_CLZERO: u32 = 416;
pub const X86_FEATURE_IRPERF: u32 = 417;
pub const X86_FEATURE_XSAVEERPTR: u32 = 418;
pub const X86_FEATURE_RDPRU: u32 = 420;
pub const X86_FEATURE_WBNOINVD: u32 = 425;
pub const X86_FEATURE_AMD_IBPB: u32 = 428;
pub const X86_FEATURE_AMD_IBRS: u32 = 430;
pub const X86_FEATURE_AMD_STIBP: u32 = 431;
pub const X86_FEATURE_AMD_STIBP_ALWAYS_ON: u32 = 433;
pub const X86_FEATURE_AMD_PPIN: u32 = 439;
pub const X86_FEATURE_AMD_SSBD: u32 = 440;
pub const X86_FEATURE_VIRT_SSBD: u32 = 441;
pub const X86_FEATURE_AMD_SSB_NO: u32 = 442;
pub const X86_FEATURE_CPPC: u32 = 443;
pub const X86_FEATURE_BTC_NO: u32 = 445;
pub const X86_FEATURE_BRS: u32 = 447;
pub const X86_FEATURE_DTHERM: u32 = 448;
pub const X86_FEATURE_IDA: u32 = 449;
pub const X86_FEATURE_ARAT: u32 = 450;
pub const X86_FEATURE_PLN: u32 = 452;
pub const X86_FEATURE_PTS: u32 = 454;
pub const X86_FEATURE_HWP: u32 = 455;
pub const X86_FEATURE_HWP_NOTIFY: u32 = 456;
pub const X86_FEATURE_HWP_ACT_WINDOW: u32 = 457;
pub const X86_FEATURE_HWP_EPP: u32 = 458;
pub const X86_FEATURE_HWP_PKG_REQ: u32 = 459;
pub const X86_FEATURE_HFI: u32 = 467;
pub const X86_FEATURE_NPT: u32 = 480;
pub const X86_FEATURE_LBRV: u32 = 481;
pub const X86_FEATURE_SVML: u32 = 482;
pub const X86_FEATURE_NRIPS: u32 = 483;
pub const X86_FEATURE_TSCRATEMSR: u32 = 484;
pub const X86_FEATURE_VMCBCLEAN: u32 = 485;
pub const X86_FEATURE_FLUSHBYASID: u32 = 486;
pub const X86_FEATURE_DECODEASSISTS: u32 = 487;
pub const X86_FEATURE_PAUSEFILTER: u32 = 490;
pub const X86_FEATURE_PFTHRESHOLD: u32 = 492;
pub const X86_FEATURE_AVIC: u32 = 493;
pub const X86_FEATURE_V_VMSAVE_VMLOAD: u32 = 495;
pub const X86_FEATURE_VGIF: u32 = 496;
pub const X86_FEATURE_X2AVIC: u32 = 498;
pub const X86_FEATURE_V_SPEC_CTRL: u32 = 500;
pub const X86_FEATURE_SVME_ADDR_CHK: u32 = 508;
pub const X86_FEATURE_AVX512VBMI: u32 = 513;
pub const X86_FEATURE_UMIP: u32 = 514;
pub const X86_FEATURE_PKU: u32 = 515;
pub const X86_FEATURE_OSPKE: u32 = 516;
pub const X86_FEATURE_WAITPKG: u32 = 517;
pub const X86_FEATURE_AVX512_VBMI2: u32 = 518;
pub const X86_FEATURE_GFNI: u32 = 520;
pub const X86_FEATURE_VAES: u32 = 521;
pub const X86_FEATURE_VPCLMULQDQ: u32 = 522;
pub const X86_FEATURE_AVX512_VNNI: u32 = 523;
pub const X86_FEATURE_AVX512_BITALG: u32 = 524;
pub const X86_FEATURE_TME: u32 = 525;
pub const X86_FEATURE_AVX512_VPOPCNTDQ: u32 = 526;
pub const X86_FEATURE_LA57: u32 = 528;
pub const X86_FEATURE_RDPID: u32 = 534;
pub const X86_FEATURE_BUS_LOCK_DETECT: u32 = 536;
pub const X86_FEATURE_CLDEMOTE: u32 = 537;
pub const X86_FEATURE_MOVDIRI: u32 = 539;
pub const X86_FEATURE_MOVDIR64B: u32 = 540;
pub const X86_FEATURE_ENQCMD: u32 = 541;
pub const X86_FEATURE_SGX_LC: u32 = 542;
pub const X86_FEATURE_OVERFLOW_RECOV: u32 = 544;
pub const X86_FEATURE_SUCCOR: u32 = 545;
pub const X86_FEATURE_SMCA: u32 = 547;
pub const X86_FEATURE_AVX512_4VNNIW: u32 = 578;
pub const X86_FEATURE_AVX512_4FMAPS: u32 = 579;
pub const X86_FEATURE_FSRM: u32 = 580;
pub const X86_FEATURE_AVX512_VP2INTERSECT: u32 = 584;
pub const X86_FEATURE_SRBDS_CTRL: u32 = 585;
pub const X86_FEATURE_MD_CLEAR: u32 = 586;
pub const X86_FEATURE_RTM_ALWAYS_ABORT: u32 = 587;
pub const X86_FEATURE_TSX_FORCE_ABORT: u32 = 589;
pub const X86_FEATURE_SERIALIZE: u32 = 590;
pub const X86_FEATURE_HYBRID_CPU: u32 = 591;
pub const X86_FEATURE_TSXLDTRK: u32 = 592;
pub const X86_FEATURE_PCONFIG: u32 = 594;
pub const X86_FEATURE_ARCH_LBR: u32 = 595;
pub const X86_FEATURE_IBT: u32 = 596;
pub const X86_FEATURE_AMX_BF16: u32 = 598;
pub const X86_FEATURE_AVX512_FP16: u32 = 599;
pub const X86_FEATURE_AMX_TILE: u32 = 600;
pub const X86_FEATURE_AMX_INT8: u32 = 601;
pub const X86_FEATURE_SPEC_CTRL: u32 = 602;
pub const X86_FEATURE_INTEL_STIBP: u32 = 603;
pub const X86_FEATURE_FLUSH_L1D: u32 = 604;
pub const X86_FEATURE_ARCH_CAPABILITIES: u32 = 605;
pub const X86_FEATURE_CORE_CAPABILITIES: u32 = 606;
pub const X86_FEATURE_SPEC_CTRL_SSBD: u32 = 607;
pub const X86_FEATURE_SME: u32 = 608;
pub const X86_FEATURE_SEV: u32 = 609;
pub const X86_FEATURE_VM_PAGE_FLUSH: u32 = 610;
pub const X86_FEATURE_SEV_ES: u32 = 611;
pub const X86_FEATURE_V_TSC_AUX: u32 = 617;
pub const X86_FEATURE_SME_COHERENT: u32 = 618;
pub const REG_IN: &'static [u8; 2usize] = b"D\0";
pub const REG_OUT: &'static [u8; 2usize] = b"a\0";
pub const BITOP_LE_SWIZZLE: u32 = 0;
pub const PANIC_CPU_INVALID: i32 = -1;
pub const TAINT_PROPRIETARY_MODULE: u32 = 0;
pub const TAINT_FORCED_MODULE: u32 = 1;
pub const TAINT_CPU_OUT_OF_SPEC: u32 = 2;
pub const TAINT_FORCED_RMMOD: u32 = 3;
pub const TAINT_MACHINE_CHECK: u32 = 4;
pub const TAINT_BAD_PAGE: u32 = 5;
pub const TAINT_USER: u32 = 6;
pub const TAINT_DIE: u32 = 7;
pub const TAINT_OVERRIDDEN_ACPI_TABLE: u32 = 8;
pub const TAINT_WARN: u32 = 9;
pub const TAINT_CRAP: u32 = 10;
pub const TAINT_FIRMWARE_WORKAROUND: u32 = 11;
pub const TAINT_OOT_MODULE: u32 = 12;
pub const TAINT_UNSIGNED_MODULE: u32 = 13;
pub const TAINT_SOFTLOCKUP: u32 = 14;
pub const TAINT_LIVEPATCH: u32 = 15;
pub const TAINT_AUX: u32 = 16;
pub const TAINT_RANDSTRUCT: u32 = 17;
pub const TAINT_TEST: u32 = 18;
pub const TAINT_FLAGS_COUNT: u32 = 19;
pub const TAINT_FLAGS_MAX: u32 = 524287;
pub const KERN_SOH: &'static [u8; 2usize] = b"\x01\0";
pub const KERN_SOH_ASCII: u8 = 1u8;
pub const KERN_EMERG: &'static [u8; 3usize] = b"\x010\0";
pub const KERN_ALERT: &'static [u8; 3usize] = b"\x011\0";
pub const KERN_CRIT: &'static [u8; 3usize] = b"\x012\0";
pub const KERN_ERR: &'static [u8; 3usize] = b"\x013\0";
pub const KERN_WARNING: &'static [u8; 3usize] = b"\x014\0";
pub const KERN_NOTICE: &'static [u8; 3usize] = b"\x015\0";
pub const KERN_INFO: &'static [u8; 3usize] = b"\x016\0";
pub const KERN_DEBUG: &'static [u8; 3usize] = b"\x017\0";
pub const KERN_DEFAULT: &'static [u8; 1usize] = b"\0";
pub const KERN_CONT: &'static [u8; 3usize] = b"\x01c\0";
pub const LOGLEVEL_SCHED: i32 = -2;
pub const LOGLEVEL_DEFAULT: i32 = -1;
pub const LOGLEVEL_EMERG: u32 = 0;
pub const LOGLEVEL_ALERT: u32 = 1;
pub const LOGLEVEL_CRIT: u32 = 2;
pub const LOGLEVEL_ERR: u32 = 3;
pub const LOGLEVEL_WARNING: u32 = 4;
pub const LOGLEVEL_NOTICE: u32 = 5;
pub const LOGLEVEL_INFO: u32 = 6;
pub const LOGLEVEL_DEBUG: u32 = 7;
pub const HZ: u32 = 100;
pub const EXEC_PAGESIZE: u32 = 4096;
pub const NOGROUP: i32 = -1;
pub const MAXHOSTNAMELEN: u32 = 64;
pub const USER_HZ: u32 = 100;
pub const CLOCKS_PER_SEC: u32 = 100;
pub const _Q_LOCKED_OFFSET: u32 = 0;
pub const _Q_LOCKED_BITS: u32 = 8;
pub const _Q_PENDING_OFFSET: u32 = 8;
pub const _Q_PENDING_BITS: u32 = 8;
pub const _Q_TAIL_IDX_OFFSET: u32 = 16;
pub const _Q_TAIL_IDX_BITS: u32 = 2;
pub const _Q_TAIL_CPU_OFFSET: u32 = 18;
pub const _Q_TAIL_CPU_BITS: u32 = 14;
pub const _Q_TAIL_OFFSET: u32 = 16;
pub const _Q_LOCKED_VAL: u32 = 1;
pub const _Q_PENDING_VAL: u32 = 256;
pub const MAX_LOCKDEP_SUBCLASSES: u32 = 8;
pub const SPINLOCK_MAGIC: u32 = 3735899821;
pub const DEFAULT_RATELIMIT_INTERVAL: u32 = 5000;
pub const DEFAULT_RATELIMIT_BURST: u32 = 10;
pub const PRINTK_MAX_SINGLE_HEADER_LEN: u32 = 2;
pub const CONSOLE_EXT_LOG_MAX: u32 = 8192;
pub const MESSAGE_LOGLEVEL_DEFAULT: u32 = 4;
pub const CONSOLE_LOGLEVEL_SILENT: u32 = 0;
pub const CONSOLE_LOGLEVEL_MIN: u32 = 1;
pub const CONSOLE_LOGLEVEL_DEBUG: u32 = 10;
pub const CONSOLE_LOGLEVEL_MOTORMOUTH: u32 = 15;
pub const CONSOLE_LOGLEVEL_DEFAULT: u32 = 7;
pub const CONSOLE_LOGLEVEL_QUIET: u32 = 4;
pub const DEVKMSG_STR_MAX_SIZE: u32 = 10;
pub const FW_BUG: &'static [u8; 17usize] = b"[Firmware Bug]: \0";
pub const FW_WARN: &'static [u8; 18usize] = b"[Firmware Warn]: \0";
pub const FW_INFO: &'static [u8; 18usize] = b"[Firmware Info]: \0";
pub const HW_ERR: &'static [u8; 19usize] = b"[Hardware Error]: \0";
pub const DEPRECATED: &'static [u8; 15usize] = b"[Deprecated]: \0";
pub const CLS_BITS: u32 = 6;
pub const _DPRINTK_CLASS_DFLT: u32 = 63;
pub const _DPRINTK_FLAGS_NONE: u32 = 0;
pub const _DPRINTK_FLAGS_PRINT: u32 = 1;
pub const _DPRINTK_FLAGS_INCL_MODNAME: u32 = 2;
pub const _DPRINTK_FLAGS_INCL_FUNCNAME: u32 = 4;
pub const _DPRINTK_FLAGS_INCL_LINENO: u32 = 8;
pub const _DPRINTK_FLAGS_INCL_TID: u32 = 16;
pub const _DPRINTK_FLAGS_INCL_ANY: u32 = 30;
pub const _DPRINTK_FLAGS_DEFAULT: u32 = 0;
pub const STATIC_CALL_SITE_TAIL: u32 = 1;
pub const STATIC_CALL_SITE_INIT: u32 = 2;
pub const STATIC_CALL_SITE_FLAGS: u32 = 3;
pub const STACK_MAGIC: u32 = 3735928559;
pub const READ: u32 = 0;
pub const WRITE: u32 = 1;
pub const PAGE_POISON: u32 = 170;
pub const RED_INACTIVE: u64 = 718624318471594843;
pub const RED_ACTIVE: i64 = -2863912482255763264;
pub const SLUB_RED_INACTIVE: u32 = 187;
pub const SLUB_RED_ACTIVE: u32 = 204;
pub const POISON_INUSE: u32 = 90;
pub const POISON_FREE: u32 = 107;
pub const POISON_END: u32 = 165;
pub const POISON_FREE_INITMEM: u32 = 204;
pub const JBD_POISON_FREE: u32 = 91;
pub const JBD2_POISON_FREE: u32 = 92;
pub const POOL_POISON_FREED: u32 = 167;
pub const POOL_POISON_ALLOCATED: u32 = 169;
pub const ATM_POISON_FREE: u32 = 18;
pub const ATM_POISON: u32 = 3735928559;
pub const MUTEX_DEBUG_INIT: u32 = 17;
pub const MUTEX_DEBUG_FREE: u32 = 34;
pub const KEY_DESTROY: u32 = 189;
pub const PREEMPT_BITS: u32 = 8;
pub const SOFTIRQ_BITS: u32 = 8;
pub const HARDIRQ_BITS: u32 = 4;
pub const NMI_BITS: u32 = 4;
pub const PREEMPT_SHIFT: u32 = 0;
pub const SOFTIRQ_SHIFT: u32 = 8;
pub const HARDIRQ_SHIFT: u32 = 16;
pub const NMI_SHIFT: u32 = 20;
pub const PREEMPT_OFFSET: u32 = 1;
pub const SOFTIRQ_OFFSET: u32 = 256;
pub const HARDIRQ_OFFSET: u32 = 65536;
pub const NMI_OFFSET: u32 = 1048576;
pub const SOFTIRQ_DISABLE_OFFSET: u32 = 512;
pub const INIT_PREEMPT_COUNT: u32 = 1;
pub const NR_CPUS: u32 = 64;
pub const MIN_THREADS_LEFT_FOR_ROOT: u32 = 4;
pub const PIDS_PER_CPU_DEFAULT: u32 = 1024;
pub const PIDS_PER_CPU_MIN: u32 = 8;
pub const PER_CPU_SHARED_ALIGNED_SECTION: &'static [u8; 17usize] = b"..shared_aligned\0";
pub const PER_CPU_ALIGNED_SECTION: &'static [u8; 17usize] = b"..shared_aligned\0";
pub const PER_CPU_FIRST_SECTION: &'static [u8; 8usize] = b"..first\0";
pub const PER_CPU_BASE_SECTION: &'static [u8; 14usize] = b".data..percpu\0";
pub const UNWIND_HINT_TYPE_CALL: u32 = 0;
pub const UNWIND_HINT_TYPE_REGS: u32 = 1;
pub const UNWIND_HINT_TYPE_REGS_PARTIAL: u32 = 2;
pub const UNWIND_HINT_TYPE_FUNC: u32 = 3;
pub const UNWIND_HINT_TYPE_ENTRY: u32 = 4;
pub const UNWIND_HINT_TYPE_SAVE: u32 = 5;
pub const UNWIND_HINT_TYPE_RESTORE: u32 = 6;
pub const ASM_REACHABLE: &'static [u8; 69usize] =
    b"998:\n\t.pushsection .discard.reachable\n\t.long 998b - .\n\t.popsection\n\t\0";
pub const ASM_UD2: &'static [u8; 17usize] = b".byte 0x0f, 0x0b\0";
pub const INSN_UD2: u32 = 2831;
pub const LEN_UD2: u32 = 2;
pub const CUT_HERE: &'static [u8; 38usize] = b"------------[ cut here ]------------\n\0";
pub const BUGFLAG_WARNING: u32 = 1;
pub const BUGFLAG_ONCE: u32 = 2;
pub const BUGFLAG_DONE: u32 = 4;
pub const BUGFLAG_NO_CUT_HERE: u32 = 8;
pub const MSEC_PER_SEC: u32 = 1000;
pub const USEC_PER_MSEC: u32 = 1000;
pub const NSEC_PER_USEC: u32 = 1000;
pub const NSEC_PER_MSEC: u32 = 1000000;
pub const USEC_PER_SEC: u32 = 1000000;
pub const NSEC_PER_SEC: u32 = 1000000000;
pub const PSEC_PER_SEC: u64 = 1000000000000;
pub const FSEC_PER_SEC: u64 = 1000000000000000;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_SGI_CYCLE: u32 = 10;
pub const CLOCK_TAI: u32 = 11;
pub const MAX_CLOCKS: u32 = 16;
pub const CLOCKS_MASK: u32 = 1;
pub const CLOCKS_MONO: u32 = 1;
pub const TIMER_ABSTIME: u32 = 1;
pub const PSEC_PER_NSEC: u32 = 1000;
pub const TIME_UPTIME_SEC_MAX: u32 = 946080000;
pub const SETUP_NONE: u32 = 0;
pub const SETUP_E820_EXT: u32 = 1;
pub const SETUP_DTB: u32 = 2;
pub const SETUP_PCI: u32 = 3;
pub const SETUP_EFI: u32 = 4;
pub const SETUP_APPLE_PROPERTIES: u32 = 5;
pub const SETUP_JAILHOUSE: u32 = 6;
pub const SETUP_CC_BLOB: u32 = 7;
pub const SETUP_IMA: u32 = 8;
pub const SETUP_RNG_SEED: u32 = 9;
pub const SETUP_ENUM_MAX: u32 = 9;
pub const SETUP_INDIRECT: u32 = 2147483648;
pub const SETUP_TYPE_MAX: u32 = 2147483657;
pub const RAMDISK_IMAGE_START_MASK: u32 = 2047;
pub const RAMDISK_PROMPT_FLAG: u32 = 32768;
pub const RAMDISK_LOAD_FLAG: u32 = 16384;
pub const LOADED_HIGH: u32 = 1;
pub const KASLR_FLAG: u32 = 2;
pub const QUIET_FLAG: u32 = 32;
pub const KEEP_SEGMENTS: u32 = 64;
pub const CAN_USE_HEAP: u32 = 128;
pub const XLF_KERNEL_64: u32 = 1;
pub const XLF_CAN_BE_LOADED_ABOVE_4G: u32 = 2;
pub const XLF_EFI_HANDOVER_32: u32 = 4;
pub const XLF_EFI_HANDOVER_64: u32 = 8;
pub const XLF_EFI_KEXEC: u32 = 16;
pub const XLF_5LEVEL: u32 = 32;
pub const XLF_5LEVEL_ENABLED: u32 = 64;
pub const VIDEO_TYPE_MDA: u32 = 16;
pub const VIDEO_TYPE_CGA: u32 = 17;
pub const VIDEO_TYPE_EGAM: u32 = 32;
pub const VIDEO_TYPE_EGAC: u32 = 33;
pub const VIDEO_TYPE_VGAC: u32 = 34;
pub const VIDEO_TYPE_VLFB: u32 = 35;
pub const VIDEO_TYPE_PICA_S3: u32 = 48;
pub const VIDEO_TYPE_MIPS_G364: u32 = 49;
pub const VIDEO_TYPE_SGI: u32 = 51;
pub const VIDEO_TYPE_TGAC: u32 = 64;
pub const VIDEO_TYPE_SUN: u32 = 80;
pub const VIDEO_TYPE_SUNPCI: u32 = 81;
pub const VIDEO_TYPE_PMAC: u32 = 96;
pub const VIDEO_TYPE_EFI: u32 = 112;
pub const VIDEO_FLAGS_NOCURSOR: u32 = 1;
pub const VIDEO_CAPABILITY_SKIP_QUIRKS: u32 = 1;
pub const VIDEO_CAPABILITY_64BIT_BASE: u32 = 2;
pub const APM_STATE_READY: u32 = 0;
pub const APM_STATE_STANDBY: u32 = 1;
pub const APM_STATE_SUSPEND: u32 = 2;
pub const APM_STATE_OFF: u32 = 3;
pub const APM_STATE_BUSY: u32 = 4;
pub const APM_STATE_REJECT: u32 = 5;
pub const APM_STATE_OEM_SYS: u32 = 32;
pub const APM_STATE_OEM_DEV: u32 = 64;
pub const APM_STATE_DISABLE: u32 = 0;
pub const APM_STATE_ENABLE: u32 = 1;
pub const APM_STATE_DISENGAGE: u32 = 0;
pub const APM_STATE_ENGAGE: u32 = 1;
pub const APM_SYS_STANDBY: u32 = 1;
pub const APM_SYS_SUSPEND: u32 = 2;
pub const APM_NORMAL_RESUME: u32 = 3;
pub const APM_CRITICAL_RESUME: u32 = 4;
pub const APM_LOW_BATTERY: u32 = 5;
pub const APM_POWER_STATUS_CHANGE: u32 = 6;
pub const APM_UPDATE_TIME: u32 = 7;
pub const APM_CRITICAL_SUSPEND: u32 = 8;
pub const APM_USER_STANDBY: u32 = 9;
pub const APM_USER_SUSPEND: u32 = 10;
pub const APM_STANDBY_RESUME: u32 = 11;
pub const APM_CAPABILITY_CHANGE: u32 = 12;
pub const APM_USER_HIBERNATION: u32 = 13;
pub const APM_HIBERNATION_RESUME: u32 = 14;
pub const APM_SUCCESS: u32 = 0;
pub const APM_DISABLED: u32 = 1;
pub const APM_CONNECTED: u32 = 2;
pub const APM_NOT_CONNECTED: u32 = 3;
pub const APM_16_CONNECTED: u32 = 5;
pub const APM_16_UNSUPPORTED: u32 = 6;
pub const APM_32_CONNECTED: u32 = 7;
pub const APM_32_UNSUPPORTED: u32 = 8;
pub const APM_BAD_DEVICE: u32 = 9;
pub const APM_BAD_PARAM: u32 = 10;
pub const APM_NOT_ENGAGED: u32 = 11;
pub const APM_BAD_FUNCTION: u32 = 12;
pub const APM_RESUME_DISABLED: u32 = 13;
pub const APM_NO_ERROR: u32 = 83;
pub const APM_BAD_STATE: u32 = 96;
pub const APM_NO_EVENTS: u32 = 128;
pub const APM_NOT_PRESENT: u32 = 134;
pub const APM_DEVICE_BIOS: u32 = 0;
pub const APM_DEVICE_ALL: u32 = 1;
pub const APM_DEVICE_DISPLAY: u32 = 256;
pub const APM_DEVICE_STORAGE: u32 = 512;
pub const APM_DEVICE_PARALLEL: u32 = 768;
pub const APM_DEVICE_SERIAL: u32 = 1024;
pub const APM_DEVICE_NETWORK: u32 = 1280;
pub const APM_DEVICE_PCMCIA: u32 = 1536;
pub const APM_DEVICE_BATTERY: u32 = 32768;
pub const APM_DEVICE_OEM: u32 = 57344;
pub const APM_DEVICE_OLD_ALL: u32 = 65535;
pub const APM_DEVICE_CLASS: u32 = 255;
pub const APM_DEVICE_MASK: u32 = 65280;
pub const APM_MAX_BATTERIES: u32 = 2;
pub const APM_CAP_GLOBAL_STANDBY: u32 = 1;
pub const APM_CAP_GLOBAL_SUSPEND: u32 = 2;
pub const APM_CAP_RESUME_STANDBY_TIMER: u32 = 4;
pub const APM_CAP_RESUME_SUSPEND_TIMER: u32 = 8;
pub const APM_CAP_RESUME_STANDBY_RING: u32 = 16;
pub const APM_CAP_RESUME_SUSPEND_RING: u32 = 32;
pub const APM_CAP_RESUME_STANDBY_PCMCIA: u32 = 64;
pub const APM_CAP_RESUME_SUSPEND_PCMCIA: u32 = 128;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const APM_16_BIT_SUPPORT: u32 = 1;
pub const APM_32_BIT_SUPPORT: u32 = 2;
pub const APM_IDLE_SLOWS_CLOCK: u32 = 4;
pub const APM_BIOS_DISABLED: u32 = 8;
pub const APM_BIOS_DISENGAGED: u32 = 16;
pub const APM_FUNC_INST_CHECK: u32 = 21248;
pub const APM_FUNC_REAL_CONN: u32 = 21249;
pub const APM_FUNC_16BIT_CONN: u32 = 21250;
pub const APM_FUNC_32BIT_CONN: u32 = 21251;
pub const APM_FUNC_DISCONN: u32 = 21252;
pub const APM_FUNC_IDLE: u32 = 21253;
pub const APM_FUNC_BUSY: u32 = 21254;
pub const APM_FUNC_SET_STATE: u32 = 21255;
pub const APM_FUNC_ENABLE_PM: u32 = 21256;
pub const APM_FUNC_RESTORE_BIOS: u32 = 21257;
pub const APM_FUNC_GET_STATUS: u32 = 21258;
pub const APM_FUNC_GET_EVENT: u32 = 21259;
pub const APM_FUNC_GET_STATE: u32 = 21260;
pub const APM_FUNC_ENABLE_DEV_PM: u32 = 21261;
pub const APM_FUNC_VERSION: u32 = 21262;
pub const APM_FUNC_ENGAGE_PM: u32 = 21263;
pub const APM_FUNC_GET_CAP: u32 = 21264;
pub const APM_FUNC_RESUME_TIMER: u32 = 21265;
pub const APM_FUNC_RESUME_ON_RING: u32 = 21266;
pub const APM_FUNC_TIMER: u32 = 21267;
pub const APM_FUNC_DISABLE_TIMER: u32 = 0;
pub const APM_FUNC_GET_TIMER: u32 = 1;
pub const APM_FUNC_SET_TIMER: u32 = 2;
pub const APM_FUNC_DISABLE_RING: u32 = 0;
pub const APM_FUNC_ENABLE_RING: u32 = 1;
pub const APM_FUNC_GET_RING: u32 = 2;
pub const APM_FUNC_TIMER_DISABLE: u32 = 0;
pub const APM_FUNC_TIMER_ENABLE: u32 = 1;
pub const APM_FUNC_TIMER_GET: u32 = 2;
pub const EDDNR: u32 = 489;
pub const EDDBUF: u32 = 3328;
pub const EDDMAXNR: u32 = 6;
pub const EDDEXTSIZE: u32 = 8;
pub const EDDPARMSIZE: u32 = 74;
pub const CHECKEXTENSIONSPRESENT: u32 = 65;
pub const GETDEVICEPARAMETERS: u32 = 72;
pub const LEGACYGETDEVICEPARAMETERS: u32 = 8;
pub const EDDMAGIC1: u32 = 21930;
pub const EDDMAGIC2: u32 = 43605;
pub const READ_SECTORS: u32 = 2;
pub const EDD_MBR_SIG_OFFSET: u32 = 440;
pub const EDD_MBR_SIG_BUF: u32 = 656;
pub const EDD_MBR_SIG_MAX: u32 = 16;
pub const EDD_MBR_SIG_NR_BUF: u32 = 490;
pub const EDD_EXT_FIXED_DISK_ACCESS: u32 = 1;
pub const EDD_EXT_DEVICE_LOCKING_AND_EJECTING: u32 = 2;
pub const EDD_EXT_ENHANCED_DISK_DRIVE_SUPPORT: u32 = 4;
pub const EDD_EXT_64BIT_EXTENSIONS: u32 = 8;
pub const EDD_INFO_DMA_BOUNDARY_ERROR_TRANSPARENT: u32 = 1;
pub const EDD_INFO_GEOMETRY_VALID: u32 = 2;
pub const EDD_INFO_REMOVABLE: u32 = 4;
pub const EDD_INFO_WRITE_VERIFY: u32 = 8;
pub const EDD_INFO_MEDIA_CHANGE_NOTIFICATION: u32 = 16;
pub const EDD_INFO_LOCKABLE: u32 = 32;
pub const EDD_INFO_NO_MEDIA_PRESENT: u32 = 64;
pub const EDD_INFO_USE_INT13_FN50: u32 = 128;
pub const E820_MAX_ENTRIES_ZEROPAGE: u32 = 128;
pub const JAILHOUSE_SETUP_REQUIRED_VERSION: u32 = 1;
pub const sme_me_mask: u32 = 0;
pub const PAGE_SHIFT: u32 = 12;
pub const HUGE_MAX_HSTATE: u32 = 2;
pub const KASAN_STACK_ORDER: u32 = 1;
pub const THREAD_SIZE_ORDER: u32 = 3;
pub const EXCEPTION_STACK_ORDER: u32 = 2;
pub const IRQ_STACK_ORDER: u32 = 3;
pub const IST_INDEX_DF: u32 = 0;
pub const IST_INDEX_NMI: u32 = 1;
pub const IST_INDEX_DB: u32 = 2;
pub const IST_INDEX_MCE: u32 = 3;
pub const IST_INDEX_VC: u32 = 4;
pub const __PHYSICAL_MASK_SHIFT: u32 = 52;
pub const KERNEL_IMAGE_SIZE: u32 = 536870912;
pub const __HAVE_ARCH_GATE_AREA: u32 = 1;
pub const TOP_OF_KERNEL_STACK_PADDING: u32 = 0;
pub const X86_EFLAGS_CF_BIT: u32 = 0;
pub const X86_EFLAGS_FIXED_BIT: u32 = 1;
pub const X86_EFLAGS_PF_BIT: u32 = 2;
pub const X86_EFLAGS_AF_BIT: u32 = 4;
pub const X86_EFLAGS_ZF_BIT: u32 = 6;
pub const X86_EFLAGS_SF_BIT: u32 = 7;
pub const X86_EFLAGS_TF_BIT: u32 = 8;
pub const X86_EFLAGS_IF_BIT: u32 = 9;
pub const X86_EFLAGS_DF_BIT: u32 = 10;
pub const X86_EFLAGS_OF_BIT: u32 = 11;
pub const X86_EFLAGS_IOPL_BIT: u32 = 12;
pub const X86_EFLAGS_NT_BIT: u32 = 14;
pub const X86_EFLAGS_RF_BIT: u32 = 16;
pub const X86_EFLAGS_VM_BIT: u32 = 17;
pub const X86_EFLAGS_AC_BIT: u32 = 18;
pub const X86_EFLAGS_VIF_BIT: u32 = 19;
pub const X86_EFLAGS_VIP_BIT: u32 = 20;
pub const X86_EFLAGS_ID_BIT: u32 = 21;
pub const X86_CR0_PE_BIT: u32 = 0;
pub const X86_CR0_MP_BIT: u32 = 1;
pub const X86_CR0_EM_BIT: u32 = 2;
pub const X86_CR0_TS_BIT: u32 = 3;
pub const X86_CR0_ET_BIT: u32 = 4;
pub const X86_CR0_NE_BIT: u32 = 5;
pub const X86_CR0_WP_BIT: u32 = 16;
pub const X86_CR0_AM_BIT: u32 = 18;
pub const X86_CR0_NW_BIT: u32 = 29;
pub const X86_CR0_CD_BIT: u32 = 30;
pub const X86_CR0_PG_BIT: u32 = 31;
pub const X86_CR3_PWT_BIT: u32 = 3;
pub const X86_CR3_PCD_BIT: u32 = 4;
pub const X86_CR3_PCID_BITS: u32 = 12;
pub const X86_CR3_PCID_NOFLUSH_BIT: u32 = 63;
pub const X86_CR4_VME_BIT: u32 = 0;
pub const X86_CR4_PVI_BIT: u32 = 1;
pub const X86_CR4_TSD_BIT: u32 = 2;
pub const X86_CR4_DE_BIT: u32 = 3;
pub const X86_CR4_PSE_BIT: u32 = 4;
pub const X86_CR4_PAE_BIT: u32 = 5;
pub const X86_CR4_MCE_BIT: u32 = 6;
pub const X86_CR4_PGE_BIT: u32 = 7;
pub const X86_CR4_PCE_BIT: u32 = 8;
pub const X86_CR4_OSFXSR_BIT: u32 = 9;
pub const X86_CR4_OSXMMEXCPT_BIT: u32 = 10;
pub const X86_CR4_UMIP_BIT: u32 = 11;
pub const X86_CR4_LA57_BIT: u32 = 12;
pub const X86_CR4_VMXE_BIT: u32 = 13;
pub const X86_CR4_SMXE_BIT: u32 = 14;
pub const X86_CR4_FSGSBASE_BIT: u32 = 16;
pub const X86_CR4_PCIDE_BIT: u32 = 17;
pub const X86_CR4_OSXSAVE_BIT: u32 = 18;
pub const X86_CR4_SMEP_BIT: u32 = 20;
pub const X86_CR4_SMAP_BIT: u32 = 21;
pub const X86_CR4_PKE_BIT: u32 = 22;
pub const X86_CR4_CET_BIT: u32 = 23;
pub const CX86_PCR0: u32 = 32;
pub const CX86_GCR: u32 = 184;
pub const CX86_CCR0: u32 = 192;
pub const CX86_CCR1: u32 = 193;
pub const CX86_CCR2: u32 = 194;
pub const CX86_CCR3: u32 = 195;
pub const CX86_CCR4: u32 = 232;
pub const CX86_CCR5: u32 = 233;
pub const CX86_CCR6: u32 = 234;
pub const CX86_CCR7: u32 = 235;
pub const CX86_PCR1: u32 = 240;
pub const CX86_DIR0: u32 = 254;
pub const CX86_DIR1: u32 = 255;
pub const CX86_ARR_BASE: u32 = 196;
pub const CX86_RCR_BASE: u32 = 220;
pub const X86_VM_MASK: u32 = 0;
pub const CR3_PCID_MASK: u32 = 4095;
pub const X86_CR3_PTI_PCID_USER_BIT: u32 = 11;
pub const GDT_ENTRY_BOOT_CS: u32 = 2;
pub const GDT_ENTRY_BOOT_DS: u32 = 3;
pub const GDT_ENTRY_BOOT_TSS: u32 = 4;
pub const __BOOT_CS: u32 = 16;
pub const __BOOT_DS: u32 = 24;
pub const __BOOT_TSS: u32 = 32;
pub const SEGMENT_RPL_MASK: u32 = 3;
pub const USER_SEGMENT_RPL_MASK: u32 = 2;
pub const USER_RPL: u32 = 3;
pub const SEGMENT_TI_MASK: u32 = 4;
pub const SEGMENT_LDT: u32 = 4;
pub const SEGMENT_GDT: u32 = 0;
pub const GDT_ENTRY_INVALID_SEG: u32 = 0;
pub const L1_CACHE_SHIFT: u32 = 6;
pub const L1_CACHE_BYTES: u32 = 64;
pub const INTERNODE_CACHE_SHIFT: u32 = 6;
pub const INTERNODE_CACHE_BYTES: u32 = 64;
pub const GDT_ENTRY_KERNEL32_CS: u32 = 1;
pub const GDT_ENTRY_KERNEL_CS: u32 = 2;
pub const GDT_ENTRY_KERNEL_DS: u32 = 3;
pub const GDT_ENTRY_DEFAULT_USER32_CS: u32 = 4;
pub const GDT_ENTRY_DEFAULT_USER_DS: u32 = 5;
pub const GDT_ENTRY_DEFAULT_USER_CS: u32 = 6;
pub const GDT_ENTRY_TSS: u32 = 8;
pub const GDT_ENTRY_LDT: u32 = 10;
pub const GDT_ENTRY_TLS_MIN: u32 = 12;
pub const GDT_ENTRY_TLS_MAX: u32 = 14;
pub const GDT_ENTRY_CPUNODE: u32 = 15;
pub const GDT_ENTRIES: u32 = 16;
pub const __KERNEL32_CS: u32 = 8;
pub const __KERNEL_CS: u32 = 16;
pub const __KERNEL_DS: u32 = 24;
pub const __USER32_CS: u32 = 35;
pub const __USER_DS: u32 = 43;
pub const __USER32_DS: u32 = 43;
pub const __USER_CS: u32 = 51;
pub const __CPUNODE_SEG: u32 = 123;
pub const IDT_ENTRIES: u32 = 256;
pub const NUM_EXCEPTION_VECTORS: u32 = 32;
pub const EXCEPTION_ERRCODE_MASK: u32 = 537033984;
pub const GDT_SIZE: u32 = 128;
pub const GDT_ENTRY_TLS_ENTRIES: u32 = 3;
pub const TLS_SIZE: u32 = 24;
pub const VDSO_CPUNODE_BITS: u32 = 12;
pub const VDSO_CPUNODE_MASK: u32 = 4095;
pub const EARLY_IDT_HANDLER_SIZE: u32 = 9;
pub const XEN_EARLY_IDT_HANDLER_SIZE: u32 = 8;
pub const FRAME_SIZE: u32 = 168;
pub const PTRACE_GETREGS: u32 = 12;
pub const PTRACE_SETREGS: u32 = 13;
pub const PTRACE_GETFPREGS: u32 = 14;
pub const PTRACE_SETFPREGS: u32 = 15;
pub const PTRACE_GETFPXREGS: u32 = 18;
pub const PTRACE_SETFPXREGS: u32 = 19;
pub const PTRACE_OLDSETOPTIONS: u32 = 21;
pub const PTRACE_GET_THREAD_AREA: u32 = 25;
pub const PTRACE_SET_THREAD_AREA: u32 = 26;
pub const PTRACE_ARCH_PRCTL: u32 = 30;
pub const PTRACE_SYSEMU: u32 = 31;
pub const PTRACE_SYSEMU_SINGLESTEP: u32 = 32;
pub const PTRACE_SINGLEBLOCK: u32 = 33;
pub const CLBR_EAX: u32 = 1;
pub const CLBR_ECX: u32 = 2;
pub const CLBR_EDX: u32 = 4;
pub const CLBR_EDI: u32 = 8;
pub const CLBR_RAX: u32 = 1;
pub const CLBR_RCX: u32 = 2;
pub const CLBR_RDX: u32 = 4;
pub const CLBR_RDI: u32 = 8;
pub const CLBR_RSI: u32 = 16;
pub const CLBR_R8: u32 = 32;
pub const CLBR_R9: u32 = 64;
pub const CLBR_R10: u32 = 128;
pub const CLBR_R11: u32 = 256;
pub const CLBR_ANY: u32 = 511;
pub const CLBR_ARG_REGS: u32 = 126;
pub const CLBR_RET_REG: u32 = 1;
pub const BOOT_IDT_ENTRIES: u32 = 32;
pub const AR_TYPE_RODATA: u32 = 0;
pub const AR_TYPE_RWDATA: u32 = 512;
pub const AR_TYPE_RODATA_EXPDOWN: u32 = 1024;
pub const AR_TYPE_RWDATA_EXPDOWN: u32 = 1536;
pub const AR_TYPE_XOCODE: u32 = 2048;
pub const AR_TYPE_XRCODE: u32 = 2560;
pub const AR_TYPE_XOCODE_CONF: u32 = 3072;
pub const AR_TYPE_XRCODE_CONF: u32 = 3584;
pub const AR_TYPE_MASK: u32 = 3584;
pub const AR_DPL0: u32 = 0;
pub const AR_DPL3: u32 = 24576;
pub const AR_DPL_MASK: u32 = 24576;
pub const AR_A: u32 = 256;
pub const AR_S: u32 = 4096;
pub const AR_P: u32 = 32768;
pub const AR_AVL: u32 = 1048576;
pub const AR_L: u32 = 2097152;
pub const AR_DB: u32 = 4194304;
pub const AR_G: u32 = 8388608;
pub const _PAGE_BIT_PRESENT: u32 = 0;
pub const _PAGE_BIT_RW: u32 = 1;
pub const _PAGE_BIT_USER: u32 = 2;
pub const _PAGE_BIT_PWT: u32 = 3;
pub const _PAGE_BIT_PCD: u32 = 4;
pub const _PAGE_BIT_ACCESSED: u32 = 5;
pub const _PAGE_BIT_DIRTY: u32 = 6;
pub const _PAGE_BIT_PSE: u32 = 7;
pub const _PAGE_BIT_PAT: u32 = 7;
pub const _PAGE_BIT_GLOBAL: u32 = 8;
pub const _PAGE_BIT_SOFTW1: u32 = 9;
pub const _PAGE_BIT_SOFTW2: u32 = 10;
pub const _PAGE_BIT_SOFTW3: u32 = 11;
pub const _PAGE_BIT_PAT_LARGE: u32 = 12;
pub const _PAGE_BIT_SOFTW4: u32 = 58;
pub const _PAGE_BIT_PKEY_BIT0: u32 = 59;
pub const _PAGE_BIT_PKEY_BIT1: u32 = 60;
pub const _PAGE_BIT_PKEY_BIT2: u32 = 61;
pub const _PAGE_BIT_PKEY_BIT3: u32 = 62;
pub const _PAGE_BIT_NX: u32 = 63;
pub const _PAGE_BIT_SPECIAL: u32 = 9;
pub const _PAGE_BIT_CPA_TEST: u32 = 9;
pub const _PAGE_BIT_UFFD_WP: u32 = 10;
pub const _PAGE_BIT_SOFT_DIRTY: u32 = 11;
pub const _PAGE_BIT_DEVMAP: u32 = 58;
pub const _PAGE_BIT_PROTNONE: u32 = 8;
pub const SECTION_SIZE_BITS: u32 = 27;
pub const SHARED_KERNEL_PMD: u32 = 0;
pub const PTRS_PER_PGD: u32 = 512;
pub const P4D_SHIFT: u32 = 39;
pub const MAX_PTRS_PER_P4D: u32 = 512;
pub const MAX_POSSIBLE_PHYSMEM_BITS: u32 = 52;
pub const PUD_SHIFT: u32 = 30;
pub const PTRS_PER_PUD: u32 = 512;
pub const PMD_SHIFT: u32 = 21;
pub const PTRS_PER_PMD: u32 = 512;
pub const PTRS_PER_PTE: u32 = 512;
pub const GUARD_HOLE_PGD_ENTRY: i32 = -256;
pub const LDT_PGD_ENTRY: i32 = -240;
pub const __VMALLOC_BASE_L4: i64 = -60473139527680;
pub const __VMALLOC_BASE_L5: i64 = -27021597764222976;
pub const VMALLOC_SIZE_TB_L4: u32 = 32;
pub const VMALLOC_SIZE_TB_L5: u32 = 12800;
pub const __VMEMMAP_BASE_L4: i64 = -24189255811072;
pub const __VMEMMAP_BASE_L5: i64 = -12384898975268864;
pub const EARLY_DYNAMIC_PAGE_TABLES: u32 = 64;
pub const PGD_ALLOWED_BITS: i32 = -1;
pub const MSR_EFER: u32 = 3221225600;
pub const MSR_STAR: u32 = 3221225601;
pub const MSR_LSTAR: u32 = 3221225602;
pub const MSR_CSTAR: u32 = 3221225603;
pub const MSR_SYSCALL_MASK: u32 = 3221225604;
pub const MSR_FS_BASE: u32 = 3221225728;
pub const MSR_GS_BASE: u32 = 3221225729;
pub const MSR_KERNEL_GS_BASE: u32 = 3221225730;
pub const MSR_TSC_AUX: u32 = 3221225731;
pub const _EFER_SCE: u32 = 0;
pub const _EFER_LME: u32 = 8;
pub const _EFER_LMA: u32 = 10;
pub const _EFER_NX: u32 = 11;
pub const _EFER_SVME: u32 = 12;
pub const _EFER_LMSLE: u32 = 13;
pub const _EFER_FFXSR: u32 = 14;
pub const EFER_SCE: u32 = 1;
pub const EFER_LME: u32 = 256;
pub const EFER_LMA: u32 = 1024;
pub const EFER_NX: u32 = 2048;
pub const EFER_SVME: u32 = 4096;
pub const EFER_LMSLE: u32 = 8192;
pub const EFER_FFXSR: u32 = 16384;
pub const MSR_TEST_CTRL: u32 = 51;
pub const MSR_TEST_CTRL_SPLIT_LOCK_DETECT_BIT: u32 = 29;
pub const MSR_IA32_SPEC_CTRL: u32 = 72;
pub const SPEC_CTRL_STIBP_SHIFT: u32 = 1;
pub const SPEC_CTRL_SSBD_SHIFT: u32 = 2;
pub const SPEC_CTRL_RRSBA_DIS_S_SHIFT: u32 = 6;
pub const MSR_IA32_PRED_CMD: u32 = 73;
pub const MSR_PPIN_CTL: u32 = 78;
pub const MSR_PPIN: u32 = 79;
pub const MSR_IA32_PERFCTR0: u32 = 193;
pub const MSR_IA32_PERFCTR1: u32 = 194;
pub const MSR_FSB_FREQ: u32 = 205;
pub const MSR_PLATFORM_INFO: u32 = 206;
pub const MSR_PLATFORM_INFO_CPUID_FAULT_BIT: u32 = 31;
pub const MSR_IA32_UMWAIT_CONTROL: u32 = 225;
pub const MSR_IA32_UMWAIT_CONTROL_TIME_MASK: i32 = -4;
pub const MSR_IA32_CORE_CAPS: u32 = 207;
pub const MSR_IA32_CORE_CAPS_INTEGRITY_CAPS_BIT: u32 = 2;
pub const MSR_IA32_CORE_CAPS_SPLIT_LOCK_DETECT_BIT: u32 = 5;
pub const MSR_PKG_CST_CONFIG_CONTROL: u32 = 226;
pub const NHM_C3_AUTO_DEMOTE: u32 = 33554432;
pub const NHM_C1_AUTO_DEMOTE: u32 = 67108864;
pub const ATM_LNC_C6_AUTO_DEMOTE: u32 = 33554432;
pub const SNB_C3_AUTO_UNDEMOTE: u32 = 134217728;
pub const SNB_C1_AUTO_UNDEMOTE: u32 = 268435456;
pub const MSR_MTRRcap: u32 = 254;
pub const MSR_IA32_ARCH_CAPABILITIES: u32 = 266;
pub const MSR_IA32_FLUSH_CMD: u32 = 267;
pub const MSR_IA32_BBL_CR_CTL: u32 = 281;
pub const MSR_IA32_BBL_CR_CTL3: u32 = 286;
pub const MSR_IA32_TSX_CTRL: u32 = 290;
pub const MSR_IA32_MCU_OPT_CTRL: u32 = 291;
pub const MSR_IA32_SYSENTER_CS: u32 = 372;
pub const MSR_IA32_SYSENTER_ESP: u32 = 373;
pub const MSR_IA32_SYSENTER_EIP: u32 = 374;
pub const MSR_IA32_MCG_CAP: u32 = 377;
pub const MSR_IA32_MCG_STATUS: u32 = 378;
pub const MSR_IA32_MCG_CTL: u32 = 379;
pub const MSR_ERROR_CONTROL: u32 = 383;
pub const MSR_IA32_MCG_EXT_CTL: u32 = 1232;
pub const MSR_OFFCORE_RSP_0: u32 = 422;
pub const MSR_OFFCORE_RSP_1: u32 = 423;
pub const MSR_TURBO_RATIO_LIMIT: u32 = 429;
pub const MSR_TURBO_RATIO_LIMIT1: u32 = 430;
pub const MSR_TURBO_RATIO_LIMIT2: u32 = 431;
pub const MSR_LBR_SELECT: u32 = 456;
pub const MSR_LBR_TOS: u32 = 457;
pub const MSR_IA32_POWER_CTL: u32 = 508;
pub const MSR_IA32_POWER_CTL_BIT_EE: u32 = 19;
pub const MSR_INTEGRITY_CAPS: u32 = 729;
pub const MSR_INTEGRITY_CAPS_PERIODIC_BIST_BIT: u32 = 4;
pub const MSR_LBR_NHM_FROM: u32 = 1664;
pub const MSR_LBR_NHM_TO: u32 = 1728;
pub const MSR_LBR_CORE_FROM: u32 = 64;
pub const MSR_LBR_CORE_TO: u32 = 96;
pub const MSR_LBR_INFO_0: u32 = 3520;
pub const LBR_INFO_CYCLES: u32 = 65535;
pub const LBR_INFO_BR_TYPE_OFFSET: u32 = 56;
pub const LBR_INFO_BR_TYPE: u64 = 1080863910568919040;
pub const MSR_ARCH_LBR_CTL: u32 = 5326;
pub const ARCH_LBR_CTL_CPL_OFFSET: u32 = 1;
pub const ARCH_LBR_CTL_CPL: u32 = 6;
pub const ARCH_LBR_CTL_STACK_OFFSET: u32 = 3;
pub const ARCH_LBR_CTL_STACK: u32 = 8;
pub const ARCH_LBR_CTL_FILTER_OFFSET: u32 = 16;
pub const ARCH_LBR_CTL_FILTER: u32 = 8323072;
pub const MSR_ARCH_LBR_DEPTH: u32 = 5327;
pub const MSR_ARCH_LBR_FROM_0: u32 = 5376;
pub const MSR_ARCH_LBR_TO_0: u32 = 5632;
pub const MSR_ARCH_LBR_INFO_0: u32 = 4608;
pub const MSR_IA32_PEBS_ENABLE: u32 = 1009;
pub const MSR_PEBS_DATA_CFG: u32 = 1010;
pub const MSR_IA32_DS_AREA: u32 = 1536;
pub const MSR_IA32_PERF_CAPABILITIES: u32 = 837;
pub const PERF_CAP_METRICS_IDX: u32 = 15;
pub const PERF_CAP_PT_IDX: u32 = 16;
pub const MSR_PEBS_LD_LAT_THRESHOLD: u32 = 1014;
pub const PERF_CAP_PEBS_FORMAT: u32 = 3840;
pub const MSR_IA32_RTIT_CTL: u32 = 1392;
pub const RTIT_CTL_MTC_RANGE_OFFSET: u32 = 14;
pub const RTIT_CTL_MTC_RANGE: u32 = 245760;
pub const RTIT_CTL_CYC_THRESH_OFFSET: u32 = 19;
pub const RTIT_CTL_CYC_THRESH: u32 = 7864320;
pub const RTIT_CTL_PSB_FREQ_OFFSET: u32 = 24;
pub const RTIT_CTL_PSB_FREQ: u32 = 251658240;
pub const RTIT_CTL_ADDR0_OFFSET: u32 = 32;
pub const RTIT_CTL_ADDR0: u64 = 64424509440;
pub const RTIT_CTL_ADDR1_OFFSET: u32 = 36;
pub const RTIT_CTL_ADDR1: u64 = 1030792151040;
pub const RTIT_CTL_ADDR2_OFFSET: u32 = 40;
pub const RTIT_CTL_ADDR2: u64 = 16492674416640;
pub const RTIT_CTL_ADDR3_OFFSET: u32 = 44;
pub const RTIT_CTL_ADDR3: u64 = 263882790666240;
pub const MSR_IA32_RTIT_STATUS: u32 = 1393;
pub const RTIT_STATUS_BYTECNT_OFFSET: u32 = 32;
pub const RTIT_STATUS_BYTECNT: u64 = 562945658454016;
pub const MSR_IA32_RTIT_ADDR0_A: u32 = 1408;
pub const MSR_IA32_RTIT_ADDR0_B: u32 = 1409;
pub const MSR_IA32_RTIT_ADDR1_A: u32 = 1410;
pub const MSR_IA32_RTIT_ADDR1_B: u32 = 1411;
pub const MSR_IA32_RTIT_ADDR2_A: u32 = 1412;
pub const MSR_IA32_RTIT_ADDR2_B: u32 = 1413;
pub const MSR_IA32_RTIT_ADDR3_A: u32 = 1414;
pub const MSR_IA32_RTIT_ADDR3_B: u32 = 1415;
pub const MSR_IA32_RTIT_CR3_MATCH: u32 = 1394;
pub const MSR_IA32_RTIT_OUTPUT_BASE: u32 = 1376;
pub const MSR_IA32_RTIT_OUTPUT_MASK: u32 = 1377;
pub const MSR_MTRRfix64K_00000: u32 = 592;
pub const MSR_MTRRfix16K_80000: u32 = 600;
pub const MSR_MTRRfix16K_A0000: u32 = 601;
pub const MSR_MTRRfix4K_C0000: u32 = 616;
pub const MSR_MTRRfix4K_C8000: u32 = 617;
pub const MSR_MTRRfix4K_D0000: u32 = 618;
pub const MSR_MTRRfix4K_D8000: u32 = 619;
pub const MSR_MTRRfix4K_E0000: u32 = 620;
pub const MSR_MTRRfix4K_E8000: u32 = 621;
pub const MSR_MTRRfix4K_F0000: u32 = 622;
pub const MSR_MTRRfix4K_F8000: u32 = 623;
pub const MSR_MTRRdefType: u32 = 767;
pub const MSR_IA32_CR_PAT: u32 = 631;
pub const MSR_IA32_DEBUGCTLMSR: u32 = 473;
pub const MSR_IA32_LASTBRANCHFROMIP: u32 = 475;
pub const MSR_IA32_LASTBRANCHTOIP: u32 = 476;
pub const MSR_IA32_LASTINTFROMIP: u32 = 477;
pub const MSR_IA32_LASTINTTOIP: u32 = 478;
pub const MSR_IA32_PASID: u32 = 3475;
pub const DEBUGCTLMSR_LBR: u32 = 1;
pub const DEBUGCTLMSR_BTF_SHIFT: u32 = 1;
pub const DEBUGCTLMSR_BTF: u32 = 2;
pub const DEBUGCTLMSR_BUS_LOCK_DETECT: u32 = 4;
pub const DEBUGCTLMSR_TR: u32 = 64;
pub const DEBUGCTLMSR_BTS: u32 = 128;
pub const DEBUGCTLMSR_BTINT: u32 = 256;
pub const DEBUGCTLMSR_BTS_OFF_OS: u32 = 512;
pub const DEBUGCTLMSR_BTS_OFF_USR: u32 = 1024;
pub const DEBUGCTLMSR_FREEZE_LBRS_ON_PMI: u32 = 2048;
pub const DEBUGCTLMSR_FREEZE_PERFMON_ON_PMI: u32 = 4096;
pub const DEBUGCTLMSR_FREEZE_IN_SMM_BIT: u32 = 14;
pub const DEBUGCTLMSR_FREEZE_IN_SMM: u32 = 16384;
pub const MSR_PEBS_FRONTEND: u32 = 1015;
pub const MSR_IA32_MC0_CTL: u32 = 1024;
pub const MSR_IA32_MC0_STATUS: u32 = 1025;
pub const MSR_IA32_MC0_ADDR: u32 = 1026;
pub const MSR_IA32_MC0_MISC: u32 = 1027;
pub const MSR_PKG_C3_RESIDENCY: u32 = 1016;
pub const MSR_PKG_C6_RESIDENCY: u32 = 1017;
pub const MSR_ATOM_PKG_C6_RESIDENCY: u32 = 1018;
pub const MSR_PKG_C7_RESIDENCY: u32 = 1018;
pub const MSR_CORE_C3_RESIDENCY: u32 = 1020;
pub const MSR_CORE_C6_RESIDENCY: u32 = 1021;
pub const MSR_CORE_C7_RESIDENCY: u32 = 1022;
pub const MSR_KNL_CORE_C6_RESIDENCY: u32 = 1023;
pub const MSR_PKG_C2_RESIDENCY: u32 = 1549;
pub const MSR_PKG_C8_RESIDENCY: u32 = 1584;
pub const MSR_PKG_C9_RESIDENCY: u32 = 1585;
pub const MSR_PKG_C10_RESIDENCY: u32 = 1586;
pub const MSR_PKGC3_IRTL: u32 = 1546;
pub const MSR_PKGC6_IRTL: u32 = 1547;
pub const MSR_PKGC7_IRTL: u32 = 1548;
pub const MSR_PKGC8_IRTL: u32 = 1587;
pub const MSR_PKGC9_IRTL: u32 = 1588;
pub const MSR_PKGC10_IRTL: u32 = 1589;
pub const MSR_VR_CURRENT_CONFIG: u32 = 1537;
pub const MSR_RAPL_POWER_UNIT: u32 = 1542;
pub const MSR_PKG_POWER_LIMIT: u32 = 1552;
pub const MSR_PKG_ENERGY_STATUS: u32 = 1553;
pub const MSR_PKG_PERF_STATUS: u32 = 1555;
pub const MSR_PKG_POWER_INFO: u32 = 1556;
pub const MSR_DRAM_POWER_LIMIT: u32 = 1560;
pub const MSR_DRAM_ENERGY_STATUS: u32 = 1561;
pub const MSR_DRAM_PERF_STATUS: u32 = 1563;
pub const MSR_DRAM_POWER_INFO: u32 = 1564;
pub const MSR_PP0_POWER_LIMIT: u32 = 1592;
pub const MSR_PP0_ENERGY_STATUS: u32 = 1593;
pub const MSR_PP0_POLICY: u32 = 1594;
pub const MSR_PP0_PERF_STATUS: u32 = 1595;
pub const MSR_PP1_POWER_LIMIT: u32 = 1600;
pub const MSR_PP1_ENERGY_STATUS: u32 = 1601;
pub const MSR_PP1_POLICY: u32 = 1602;
pub const MSR_AMD_RAPL_POWER_UNIT: u32 = 3221291673;
pub const MSR_AMD_CORE_ENERGY_STATUS: u32 = 3221291674;
pub const MSR_AMD_PKG_ENERGY_STATUS: u32 = 3221291675;
pub const MSR_CONFIG_TDP_NOMINAL: u32 = 1608;
pub const MSR_CONFIG_TDP_LEVEL_1: u32 = 1609;
pub const MSR_CONFIG_TDP_LEVEL_2: u32 = 1610;
pub const MSR_CONFIG_TDP_CONTROL: u32 = 1611;
pub const MSR_TURBO_ACTIVATION_RATIO: u32 = 1612;
pub const MSR_PLATFORM_ENERGY_STATUS: u32 = 1613;
pub const MSR_SECONDARY_TURBO_RATIO_LIMIT: u32 = 1616;
pub const MSR_PKG_WEIGHTED_CORE_C0_RES: u32 = 1624;
pub const MSR_PKG_ANY_CORE_C0_RES: u32 = 1625;
pub const MSR_PKG_ANY_GFXE_C0_RES: u32 = 1626;
pub const MSR_PKG_BOTH_CORE_GFXE_C0_RES: u32 = 1627;
pub const MSR_CORE_C1_RES: u32 = 1632;
pub const MSR_MODULE_C6_RES_MS: u32 = 1636;
pub const MSR_CC6_DEMOTION_POLICY_CONFIG: u32 = 1640;
pub const MSR_MC6_DEMOTION_POLICY_CONFIG: u32 = 1641;
pub const MSR_ATOM_CORE_RATIOS: u32 = 1642;
pub const MSR_ATOM_CORE_VIDS: u32 = 1643;
pub const MSR_ATOM_CORE_TURBO_RATIOS: u32 = 1644;
pub const MSR_ATOM_CORE_TURBO_VIDS: u32 = 1645;
pub const MSR_CORE_PERF_LIMIT_REASONS: u32 = 1680;
pub const MSR_GFX_PERF_LIMIT_REASONS: u32 = 1712;
pub const MSR_RING_PERF_LIMIT_REASONS: u32 = 1713;
pub const MSR_IA32_U_CET: u32 = 1696;
pub const MSR_IA32_S_CET: u32 = 1698;
pub const MSR_IA32_PL0_SSP: u32 = 1700;
pub const MSR_IA32_PL1_SSP: u32 = 1701;
pub const MSR_IA32_PL2_SSP: u32 = 1702;
pub const MSR_IA32_PL3_SSP: u32 = 1703;
pub const MSR_IA32_INT_SSP_TAB: u32 = 1704;
pub const MSR_PPERF: u32 = 1614;
pub const MSR_PERF_LIMIT_REASONS: u32 = 1615;
pub const MSR_PM_ENABLE: u32 = 1904;
pub const MSR_HWP_CAPABILITIES: u32 = 1905;
pub const MSR_HWP_REQUEST_PKG: u32 = 1906;
pub const MSR_HWP_INTERRUPT: u32 = 1907;
pub const MSR_HWP_REQUEST: u32 = 1908;
pub const MSR_HWP_STATUS: u32 = 1911;
pub const HWP_BASE_BIT: u32 = 128;
pub const HWP_NOTIFICATIONS_BIT: u32 = 256;
pub const HWP_ACTIVITY_WINDOW_BIT: u32 = 512;
pub const HWP_ENERGY_PERF_PREFERENCE_BIT: u32 = 1024;
pub const HWP_PACKAGE_LEVEL_REQUEST_BIT: u32 = 2048;
pub const HWP_EPP_PERFORMANCE: u32 = 0;
pub const HWP_EPP_BALANCE_PERFORMANCE: u32 = 128;
pub const HWP_EPP_BALANCE_POWERSAVE: u32 = 192;
pub const HWP_EPP_POWERSAVE: u32 = 255;
pub const MSR_AMD64_MC0_MASK: u32 = 3221291076;
pub const MSR_IA32_MC0_CTL2: u32 = 640;
pub const MSR_P6_PERFCTR0: u32 = 193;
pub const MSR_P6_PERFCTR1: u32 = 194;
pub const MSR_P6_EVNTSEL0: u32 = 390;
pub const MSR_P6_EVNTSEL1: u32 = 391;
pub const MSR_KNC_PERFCTR0: u32 = 32;
pub const MSR_KNC_PERFCTR1: u32 = 33;
pub const MSR_KNC_EVNTSEL0: u32 = 40;
pub const MSR_KNC_EVNTSEL1: u32 = 41;
pub const MSR_IA32_PMC0: u32 = 1217;
pub const MSR_RELOAD_PMC0: u32 = 5313;
pub const MSR_RELOAD_FIXED_CTR0: u32 = 4873;
pub const MSR_AMD64_PATCH_LEVEL: u32 = 139;
pub const MSR_AMD64_TSC_RATIO: u32 = 3221225732;
pub const MSR_AMD64_NB_CFG: u32 = 3221291039;
pub const MSR_AMD64_PATCH_LOADER: u32 = 3221291040;
pub const MSR_AMD_PERF_CTL: u32 = 3221291106;
pub const MSR_AMD_PERF_STATUS: u32 = 3221291107;
pub const MSR_AMD_PSTATE_DEF_BASE: u32 = 3221291108;
pub const MSR_AMD64_OSVW_ID_LENGTH: u32 = 3221291328;
pub const MSR_AMD64_OSVW_STATUS: u32 = 3221291329;
pub const MSR_AMD_PPIN_CTL: u32 = 3221291760;
pub const MSR_AMD_PPIN: u32 = 3221291761;
pub const MSR_AMD64_CPUID_FN_1: u32 = 3221295108;
pub const MSR_AMD64_LS_CFG: u32 = 3221295136;
pub const MSR_AMD64_DC_CFG: u32 = 3221295138;
pub const MSR_AMD64_DE_CFG: u32 = 3221295145;
pub const MSR_AMD64_DE_CFG_LFENCE_SERIALIZE_BIT: u32 = 1;
pub const MSR_AMD64_BU_CFG2: u32 = 3221295146;
pub const MSR_AMD64_IBSFETCHCTL: u32 = 3221295152;
pub const MSR_AMD64_IBSFETCHLINAD: u32 = 3221295153;
pub const MSR_AMD64_IBSFETCHPHYSAD: u32 = 3221295154;
pub const MSR_AMD64_IBSFETCH_REG_COUNT: u32 = 3;
pub const MSR_AMD64_IBSFETCH_REG_MASK: u32 = 7;
pub const MSR_AMD64_IBSOPCTL: u32 = 3221295155;
pub const MSR_AMD64_IBSOPRIP: u32 = 3221295156;
pub const MSR_AMD64_IBSOPDATA: u32 = 3221295157;
pub const MSR_AMD64_IBSOPDATA2: u32 = 3221295158;
pub const MSR_AMD64_IBSOPDATA3: u32 = 3221295159;
pub const MSR_AMD64_IBSDCLINAD: u32 = 3221295160;
pub const MSR_AMD64_IBSDCPHYSAD: u32 = 3221295161;
pub const MSR_AMD64_IBSOP_REG_COUNT: u32 = 7;
pub const MSR_AMD64_IBSOP_REG_MASK: u32 = 127;
pub const MSR_AMD64_IBSCTL: u32 = 3221295162;
pub const MSR_AMD64_IBSBRTARGET: u32 = 3221295163;
pub const MSR_AMD64_ICIBSEXTDCTL: u32 = 3221295164;
pub const MSR_AMD64_IBSOPDATA4: u32 = 3221295165;
pub const MSR_AMD64_IBS_REG_COUNT_MAX: u32 = 8;
pub const MSR_AMD64_SVM_AVIC_DOORBELL: u32 = 3221291291;
pub const MSR_AMD64_VM_PAGE_FLUSH: u32 = 3221291294;
pub const MSR_AMD64_SEV_ES_GHCB: u32 = 3221291312;
pub const MSR_AMD64_SEV: u32 = 3221291313;
pub const MSR_AMD64_SEV_ENABLED_BIT: u32 = 0;
pub const MSR_AMD64_SEV_ES_ENABLED_BIT: u32 = 1;
pub const MSR_AMD64_SEV_SNP_ENABLED_BIT: u32 = 2;
pub const MSR_AMD64_VIRT_SPEC_CTRL: u32 = 3221291295;
pub const MSR_AMD_CPPC_CAP1: u32 = 3221291696;
pub const MSR_AMD_CPPC_ENABLE: u32 = 3221291697;
pub const MSR_AMD_CPPC_CAP2: u32 = 3221291698;
pub const MSR_AMD_CPPC_REQ: u32 = 3221291699;
pub const MSR_AMD_CPPC_STATUS: u32 = 3221291700;
pub const MSR_AMD64_PERF_CNTR_GLOBAL_STATUS: u32 = 3221226240;
pub const MSR_AMD64_PERF_CNTR_GLOBAL_CTL: u32 = 3221226241;
pub const MSR_AMD64_PERF_CNTR_GLOBAL_STATUS_CLR: u32 = 3221226242;
pub const MSR_AMD64_LBR_SELECT: u32 = 3221225742;
pub const MSR_F17H_IRPERF: u32 = 3221225705;
pub const MSR_ZEN2_SPECTRAL_CHICKEN: u32 = 3221295331;
pub const MSR_F16H_L2I_PERF_CTL: u32 = 3221291568;
pub const MSR_F16H_L2I_PERF_CTR: u32 = 3221291569;
pub const MSR_F16H_DR1_ADDR_MASK: u32 = 3221295129;
pub const MSR_F16H_DR2_ADDR_MASK: u32 = 3221295130;
pub const MSR_F16H_DR3_ADDR_MASK: u32 = 3221295131;
pub const MSR_F16H_DR0_ADDR_MASK: u32 = 3221295143;
pub const MSR_F15H_CU_PWR_ACCUMULATOR: u32 = 3221291130;
pub const MSR_F15H_CU_MAX_PWR_ACCUMULATOR: u32 = 3221291131;
pub const MSR_F15H_PERF_CTL: u32 = 3221291520;
pub const MSR_F15H_PERF_CTL0: u32 = 3221291520;
pub const MSR_F15H_PERF_CTL1: u32 = 3221291522;
pub const MSR_F15H_PERF_CTL2: u32 = 3221291524;
pub const MSR_F15H_PERF_CTL3: u32 = 3221291526;
pub const MSR_F15H_PERF_CTL4: u32 = 3221291528;
pub const MSR_F15H_PERF_CTL5: u32 = 3221291530;
pub const MSR_F15H_PERF_CTR: u32 = 3221291521;
pub const MSR_F15H_PERF_CTR0: u32 = 3221291521;
pub const MSR_F15H_PERF_CTR1: u32 = 3221291523;
pub const MSR_F15H_PERF_CTR2: u32 = 3221291525;
pub const MSR_F15H_PERF_CTR3: u32 = 3221291527;
pub const MSR_F15H_PERF_CTR4: u32 = 3221291529;
pub const MSR_F15H_PERF_CTR5: u32 = 3221291531;
pub const MSR_F15H_NB_PERF_CTL: u32 = 3221291584;
pub const MSR_F15H_NB_PERF_CTR: u32 = 3221291585;
pub const MSR_F15H_PTSC: u32 = 3221291648;
pub const MSR_F15H_IC_CFG: u32 = 3221295137;
pub const MSR_F15H_EX_CFG: u32 = 3221295148;
pub const MSR_FAM10H_MMIO_CONF_BASE: u32 = 3221291096;
pub const FAM10H_MMIO_CONF_ENABLE: u32 = 1;
pub const FAM10H_MMIO_CONF_BUSRANGE_MASK: u32 = 15;
pub const FAM10H_MMIO_CONF_BUSRANGE_SHIFT: u32 = 2;
pub const FAM10H_MMIO_CONF_BASE_MASK: u32 = 268435455;
pub const FAM10H_MMIO_CONF_BASE_SHIFT: u32 = 20;
pub const MSR_FAM10H_NODE_ID: u32 = 3221295116;
pub const MSR_K8_TOP_MEM1: u32 = 3221291034;
pub const MSR_K8_TOP_MEM2: u32 = 3221291037;
pub const MSR_AMD64_SYSCFG: u32 = 3221291024;
pub const MSR_AMD64_SYSCFG_MEM_ENCRYPT_BIT: u32 = 23;
pub const MSR_K8_INT_PENDING_MSG: u32 = 3221291093;
pub const K8_INTP_C1E_ACTIVE_MASK: u32 = 402653184;
pub const MSR_K8_TSEG_ADDR: u32 = 3221291282;
pub const MSR_K8_TSEG_MASK: u32 = 3221291283;
pub const K8_MTRRFIXRANGE_DRAM_ENABLE: u32 = 262144;
pub const K8_MTRRFIXRANGE_DRAM_MODIFY: u32 = 524288;
pub const K8_MTRR_RDMEM_WRMEM_MASK: u32 = 404232216;
pub const MSR_K7_EVNTSEL0: u32 = 3221291008;
pub const MSR_K7_PERFCTR0: u32 = 3221291012;
pub const MSR_K7_EVNTSEL1: u32 = 3221291009;
pub const MSR_K7_PERFCTR1: u32 = 3221291013;
pub const MSR_K7_EVNTSEL2: u32 = 3221291010;
pub const MSR_K7_PERFCTR2: u32 = 3221291014;
pub const MSR_K7_EVNTSEL3: u32 = 3221291011;
pub const MSR_K7_PERFCTR3: u32 = 3221291015;
pub const MSR_K7_CLK_CTL: u32 = 3221291035;
pub const MSR_K7_HWCR: u32 = 3221291029;
pub const MSR_K7_HWCR_SMMLOCK_BIT: u32 = 0;
pub const MSR_K7_HWCR_IRPERF_EN_BIT: u32 = 30;
pub const MSR_K7_FID_VID_CTL: u32 = 3221291073;
pub const MSR_K7_FID_VID_STATUS: u32 = 3221291074;
pub const MSR_K6_WHCR: u32 = 3221225602;
pub const MSR_K6_UWCCR: u32 = 3221225605;
pub const MSR_K6_EPMR: u32 = 3221225606;
pub const MSR_K6_PSOR: u32 = 3221225607;
pub const MSR_K6_PFIR: u32 = 3221225608;
pub const MSR_IDT_FCR1: u32 = 263;
pub const MSR_IDT_FCR2: u32 = 264;
pub const MSR_IDT_FCR3: u32 = 265;
pub const MSR_IDT_FCR4: u32 = 266;
pub const MSR_IDT_MCR0: u32 = 272;
pub const MSR_IDT_MCR1: u32 = 273;
pub const MSR_IDT_MCR2: u32 = 274;
pub const MSR_IDT_MCR3: u32 = 275;
pub const MSR_IDT_MCR4: u32 = 276;
pub const MSR_IDT_MCR5: u32 = 277;
pub const MSR_IDT_MCR6: u32 = 278;
pub const MSR_IDT_MCR7: u32 = 279;
pub const MSR_IDT_MCR_CTRL: u32 = 288;
pub const MSR_VIA_FCR: u32 = 4359;
pub const MSR_VIA_LONGHAUL: u32 = 4362;
pub const MSR_VIA_RNG: u32 = 4363;
pub const MSR_VIA_BCR2: u32 = 4423;
pub const MSR_TMTA_LONGRUN_CTRL: u32 = 2156298256;
pub const MSR_TMTA_LONGRUN_FLAGS: u32 = 2156298257;
pub const MSR_TMTA_LRTI_READOUT: u32 = 2156298264;
pub const MSR_TMTA_LRTI_VOLT_MHZ: u32 = 2156298266;
pub const MSR_IA32_P5_MC_ADDR: u32 = 0;
pub const MSR_IA32_P5_MC_TYPE: u32 = 1;
pub const MSR_IA32_TSC: u32 = 16;
pub const MSR_IA32_PLATFORM_ID: u32 = 23;
pub const MSR_IA32_EBL_CR_POWERON: u32 = 42;
pub const MSR_EBC_FREQUENCY_ID: u32 = 44;
pub const MSR_SMI_COUNT: u32 = 52;
pub const MSR_IA32_FEAT_CTL: u32 = 58;
pub const MSR_IA32_TSC_ADJUST: u32 = 59;
pub const MSR_IA32_BNDCFGS: u32 = 3472;
pub const MSR_IA32_BNDCFGS_RSVD: u32 = 4092;
pub const MSR_IA32_XFD: u32 = 452;
pub const MSR_IA32_XFD_ERR: u32 = 453;
pub const MSR_IA32_XSS: u32 = 3488;
pub const MSR_IA32_APICBASE: u32 = 27;
pub const MSR_IA32_APICBASE_BSP: u32 = 256;
pub const MSR_IA32_APICBASE_ENABLE: u32 = 2048;
pub const MSR_IA32_APICBASE_BASE: u32 = 4294963200;
pub const MSR_IA32_UCODE_WRITE: u32 = 121;
pub const MSR_IA32_UCODE_REV: u32 = 139;
pub const MSR_IA32_SGXLEPUBKEYHASH0: u32 = 140;
pub const MSR_IA32_SGXLEPUBKEYHASH1: u32 = 141;
pub const MSR_IA32_SGXLEPUBKEYHASH2: u32 = 142;
pub const MSR_IA32_SGXLEPUBKEYHASH3: u32 = 143;
pub const MSR_IA32_SMM_MONITOR_CTL: u32 = 155;
pub const MSR_IA32_SMBASE: u32 = 158;
pub const MSR_IA32_PERF_STATUS: u32 = 408;
pub const MSR_IA32_PERF_CTL: u32 = 409;
pub const INTEL_PERF_CTL_MASK: u32 = 65535;
pub const MSR_AMD_DBG_EXTN_CFG: u32 = 3221225743;
pub const MSR_AMD_SAMP_BR_FROM: u32 = 3221291776;
pub const MSR_IA32_MPERF: u32 = 231;
pub const MSR_IA32_APERF: u32 = 232;
pub const MSR_IA32_THERM_CONTROL: u32 = 410;
pub const MSR_IA32_THERM_INTERRUPT: u32 = 411;
pub const THERM_INT_HIGH_ENABLE: u32 = 1;
pub const THERM_INT_LOW_ENABLE: u32 = 2;
pub const THERM_INT_PLN_ENABLE: u32 = 16777216;
pub const MSR_IA32_THERM_STATUS: u32 = 412;
pub const THERM_STATUS_PROCHOT: u32 = 1;
pub const THERM_STATUS_POWER_LIMIT: u32 = 1024;
pub const MSR_THERM2_CTL: u32 = 413;
pub const MSR_THERM2_CTL_TM_SELECT: u32 = 65536;
pub const MSR_IA32_MISC_ENABLE: u32 = 416;
pub const MSR_IA32_TEMPERATURE_TARGET: u32 = 418;
pub const MSR_MISC_FEATURE_CONTROL: u32 = 420;
pub const MSR_MISC_PWR_MGMT: u32 = 426;
pub const MSR_IA32_ENERGY_PERF_BIAS: u32 = 432;
pub const ENERGY_PERF_BIAS_PERFORMANCE: u32 = 0;
pub const ENERGY_PERF_BIAS_BALANCE_PERFORMANCE: u32 = 4;
pub const ENERGY_PERF_BIAS_NORMAL: u32 = 6;
pub const ENERGY_PERF_BIAS_BALANCE_POWERSAVE: u32 = 8;
pub const ENERGY_PERF_BIAS_POWERSAVE: u32 = 15;
pub const MSR_IA32_PACKAGE_THERM_STATUS: u32 = 433;
pub const PACKAGE_THERM_STATUS_PROCHOT: u32 = 1;
pub const PACKAGE_THERM_STATUS_POWER_LIMIT: u32 = 1024;
pub const PACKAGE_THERM_STATUS_HFI_UPDATED: u32 = 67108864;
pub const MSR_IA32_PACKAGE_THERM_INTERRUPT: u32 = 434;
pub const PACKAGE_THERM_INT_HIGH_ENABLE: u32 = 1;
pub const PACKAGE_THERM_INT_LOW_ENABLE: u32 = 2;
pub const PACKAGE_THERM_INT_PLN_ENABLE: u32 = 16777216;
pub const PACKAGE_THERM_INT_HFI_ENABLE: u32 = 33554432;
pub const THERM_INT_THRESHOLD0_ENABLE: u32 = 32768;
pub const THERM_SHIFT_THRESHOLD0: u32 = 8;
pub const THERM_MASK_THRESHOLD0: u32 = 32512;
pub const THERM_INT_THRESHOLD1_ENABLE: u32 = 8388608;
pub const THERM_SHIFT_THRESHOLD1: u32 = 16;
pub const THERM_MASK_THRESHOLD1: u32 = 8323072;
pub const THERM_STATUS_THRESHOLD0: u32 = 64;
pub const THERM_LOG_THRESHOLD0: u32 = 128;
pub const THERM_STATUS_THRESHOLD1: u32 = 256;
pub const THERM_LOG_THRESHOLD1: u32 = 512;
pub const MSR_IA32_MISC_ENABLE_FAST_STRING_BIT: u32 = 0;
pub const MSR_IA32_MISC_ENABLE_FAST_STRING: u32 = 1;
pub const MSR_IA32_MISC_ENABLE_TCC_BIT: u32 = 1;
pub const MSR_IA32_MISC_ENABLE_TCC: u32 = 2;
pub const MSR_IA32_MISC_ENABLE_EMON_BIT: u32 = 7;
pub const MSR_IA32_MISC_ENABLE_EMON: u32 = 128;
pub const MSR_IA32_MISC_ENABLE_BTS_UNAVAIL_BIT: u32 = 11;
pub const MSR_IA32_MISC_ENABLE_BTS_UNAVAIL: u32 = 2048;
pub const MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL_BIT: u32 = 12;
pub const MSR_IA32_MISC_ENABLE_PEBS_UNAVAIL: u32 = 4096;
pub const MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP_BIT: u32 = 16;
pub const MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP: u32 = 65536;
pub const MSR_IA32_MISC_ENABLE_MWAIT_BIT: u32 = 18;
pub const MSR_IA32_MISC_ENABLE_MWAIT: u32 = 262144;
pub const MSR_IA32_MISC_ENABLE_LIMIT_CPUID_BIT: u32 = 22;
pub const MSR_IA32_MISC_ENABLE_LIMIT_CPUID: u32 = 4194304;
pub const MSR_IA32_MISC_ENABLE_XTPR_DISABLE_BIT: u32 = 23;
pub const MSR_IA32_MISC_ENABLE_XTPR_DISABLE: u32 = 8388608;
pub const MSR_IA32_MISC_ENABLE_XD_DISABLE_BIT: u32 = 34;
pub const MSR_IA32_MISC_ENABLE_XD_DISABLE: u64 = 17179869184;
pub const MSR_IA32_MISC_ENABLE_X87_COMPAT_BIT: u32 = 2;
pub const MSR_IA32_MISC_ENABLE_X87_COMPAT: u32 = 4;
pub const MSR_IA32_MISC_ENABLE_TM1_BIT: u32 = 3;
pub const MSR_IA32_MISC_ENABLE_TM1: u32 = 8;
pub const MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE_BIT: u32 = 4;
pub const MSR_IA32_MISC_ENABLE_SPLIT_LOCK_DISABLE: u32 = 16;
pub const MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE_BIT: u32 = 6;
pub const MSR_IA32_MISC_ENABLE_L3CACHE_DISABLE: u32 = 64;
pub const MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK_BIT: u32 = 8;
pub const MSR_IA32_MISC_ENABLE_SUPPRESS_LOCK: u32 = 256;
pub const MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE_BIT: u32 = 9;
pub const MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE: u32 = 512;
pub const MSR_IA32_MISC_ENABLE_FERR_BIT: u32 = 10;
pub const MSR_IA32_MISC_ENABLE_FERR: u32 = 1024;
pub const MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX_BIT: u32 = 10;
pub const MSR_IA32_MISC_ENABLE_FERR_MULTIPLEX: u32 = 1024;
pub const MSR_IA32_MISC_ENABLE_TM2_BIT: u32 = 13;
pub const MSR_IA32_MISC_ENABLE_TM2: u32 = 8192;
pub const MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE_BIT: u32 = 19;
pub const MSR_IA32_MISC_ENABLE_ADJ_PREF_DISABLE: u32 = 524288;
pub const MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK_BIT: u32 = 20;
pub const MSR_IA32_MISC_ENABLE_SPEEDSTEP_LOCK: u32 = 1048576;
pub const MSR_IA32_MISC_ENABLE_L1D_CONTEXT_BIT: u32 = 24;
pub const MSR_IA32_MISC_ENABLE_L1D_CONTEXT: u32 = 16777216;
pub const MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE_BIT: u32 = 37;
pub const MSR_IA32_MISC_ENABLE_DCU_PREF_DISABLE: u64 = 137438953472;
pub const MSR_IA32_MISC_ENABLE_TURBO_DISABLE_BIT: u32 = 38;
pub const MSR_IA32_MISC_ENABLE_TURBO_DISABLE: u64 = 274877906944;
pub const MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE_BIT: u32 = 39;
pub const MSR_IA32_MISC_ENABLE_IP_PREF_DISABLE: u64 = 549755813888;
pub const MSR_MISC_FEATURES_ENABLES: u32 = 320;
pub const MSR_MISC_FEATURES_ENABLES_CPUID_FAULT_BIT: u32 = 0;
pub const MSR_MISC_FEATURES_ENABLES_RING3MWAIT_BIT: u32 = 1;
pub const MSR_IA32_TSC_DEADLINE: u32 = 1760;
pub const MSR_TSX_FORCE_ABORT: u32 = 271;
pub const MSR_TFA_RTM_FORCE_ABORT_BIT: u32 = 0;
pub const MSR_TFA_TSX_CPUID_CLEAR_BIT: u32 = 1;
pub const MSR_TFA_SDV_ENABLE_RTM_BIT: u32 = 2;
pub const MSR_IA32_MCG_EAX: u32 = 384;
pub const MSR_IA32_MCG_EBX: u32 = 385;
pub const MSR_IA32_MCG_ECX: u32 = 386;
pub const MSR_IA32_MCG_EDX: u32 = 387;
pub const MSR_IA32_MCG_ESI: u32 = 388;
pub const MSR_IA32_MCG_EDI: u32 = 389;
pub const MSR_IA32_MCG_EBP: u32 = 390;
pub const MSR_IA32_MCG_ESP: u32 = 391;
pub const MSR_IA32_MCG_EFLAGS: u32 = 392;
pub const MSR_IA32_MCG_EIP: u32 = 393;
pub const MSR_IA32_MCG_RESERVED: u32 = 394;
pub const MSR_P4_BPU_PERFCTR0: u32 = 768;
pub const MSR_P4_BPU_PERFCTR1: u32 = 769;
pub const MSR_P4_BPU_PERFCTR2: u32 = 770;
pub const MSR_P4_BPU_PERFCTR3: u32 = 771;
pub const MSR_P4_MS_PERFCTR0: u32 = 772;
pub const MSR_P4_MS_PERFCTR1: u32 = 773;
pub const MSR_P4_MS_PERFCTR2: u32 = 774;
pub const MSR_P4_MS_PERFCTR3: u32 = 775;
pub const MSR_P4_FLAME_PERFCTR0: u32 = 776;
pub const MSR_P4_FLAME_PERFCTR1: u32 = 777;
pub const MSR_P4_FLAME_PERFCTR2: u32 = 778;
pub const MSR_P4_FLAME_PERFCTR3: u32 = 779;
pub const MSR_P4_IQ_PERFCTR0: u32 = 780;
pub const MSR_P4_IQ_PERFCTR1: u32 = 781;
pub const MSR_P4_IQ_PERFCTR2: u32 = 782;
pub const MSR_P4_IQ_PERFCTR3: u32 = 783;
pub const MSR_P4_IQ_PERFCTR4: u32 = 784;
pub const MSR_P4_IQ_PERFCTR5: u32 = 785;
pub const MSR_P4_BPU_CCCR0: u32 = 864;
pub const MSR_P4_BPU_CCCR1: u32 = 865;
pub const MSR_P4_BPU_CCCR2: u32 = 866;
pub const MSR_P4_BPU_CCCR3: u32 = 867;
pub const MSR_P4_MS_CCCR0: u32 = 868;
pub const MSR_P4_MS_CCCR1: u32 = 869;
pub const MSR_P4_MS_CCCR2: u32 = 870;
pub const MSR_P4_MS_CCCR3: u32 = 871;
pub const MSR_P4_FLAME_CCCR0: u32 = 872;
pub const MSR_P4_FLAME_CCCR1: u32 = 873;
pub const MSR_P4_FLAME_CCCR2: u32 = 874;
pub const MSR_P4_FLAME_CCCR3: u32 = 875;
pub const MSR_P4_IQ_CCCR0: u32 = 876;
pub const MSR_P4_IQ_CCCR1: u32 = 877;
pub const MSR_P4_IQ_CCCR2: u32 = 878;
pub const MSR_P4_IQ_CCCR3: u32 = 879;
pub const MSR_P4_IQ_CCCR4: u32 = 880;
pub const MSR_P4_IQ_CCCR5: u32 = 881;
pub const MSR_P4_ALF_ESCR0: u32 = 970;
pub const MSR_P4_ALF_ESCR1: u32 = 971;
pub const MSR_P4_BPU_ESCR0: u32 = 946;
pub const MSR_P4_BPU_ESCR1: u32 = 947;
pub const MSR_P4_BSU_ESCR0: u32 = 928;
pub const MSR_P4_BSU_ESCR1: u32 = 929;
pub const MSR_P4_CRU_ESCR0: u32 = 952;
pub const MSR_P4_CRU_ESCR1: u32 = 953;
pub const MSR_P4_CRU_ESCR2: u32 = 972;
pub const MSR_P4_CRU_ESCR3: u32 = 973;
pub const MSR_P4_CRU_ESCR4: u32 = 992;
pub const MSR_P4_CRU_ESCR5: u32 = 993;
pub const MSR_P4_DAC_ESCR0: u32 = 936;
pub const MSR_P4_DAC_ESCR1: u32 = 937;
pub const MSR_P4_FIRM_ESCR0: u32 = 932;
pub const MSR_P4_FIRM_ESCR1: u32 = 933;
pub const MSR_P4_FLAME_ESCR0: u32 = 934;
pub const MSR_P4_FLAME_ESCR1: u32 = 935;
pub const MSR_P4_FSB_ESCR0: u32 = 930;
pub const MSR_P4_FSB_ESCR1: u32 = 931;
pub const MSR_P4_IQ_ESCR0: u32 = 954;
pub const MSR_P4_IQ_ESCR1: u32 = 955;
pub const MSR_P4_IS_ESCR0: u32 = 948;
pub const MSR_P4_IS_ESCR1: u32 = 949;
pub const MSR_P4_ITLB_ESCR0: u32 = 950;
pub const MSR_P4_ITLB_ESCR1: u32 = 951;
pub const MSR_P4_IX_ESCR0: u32 = 968;
pub const MSR_P4_IX_ESCR1: u32 = 969;
pub const MSR_P4_MOB_ESCR0: u32 = 938;
pub const MSR_P4_MOB_ESCR1: u32 = 939;
pub const MSR_P4_MS_ESCR0: u32 = 960;
pub const MSR_P4_MS_ESCR1: u32 = 961;
pub const MSR_P4_PMH_ESCR0: u32 = 940;
pub const MSR_P4_PMH_ESCR1: u32 = 941;
pub const MSR_P4_RAT_ESCR0: u32 = 956;
pub const MSR_P4_RAT_ESCR1: u32 = 957;
pub const MSR_P4_SAAT_ESCR0: u32 = 942;
pub const MSR_P4_SAAT_ESCR1: u32 = 943;
pub const MSR_P4_SSU_ESCR0: u32 = 958;
pub const MSR_P4_SSU_ESCR1: u32 = 959;
pub const MSR_P4_TBPU_ESCR0: u32 = 962;
pub const MSR_P4_TBPU_ESCR1: u32 = 963;
pub const MSR_P4_TC_ESCR0: u32 = 964;
pub const MSR_P4_TC_ESCR1: u32 = 965;
pub const MSR_P4_U2L_ESCR0: u32 = 944;
pub const MSR_P4_U2L_ESCR1: u32 = 945;
pub const MSR_P4_PEBS_MATRIX_VERT: u32 = 1010;
pub const MSR_CORE_PERF_FIXED_CTR0: u32 = 777;
pub const MSR_CORE_PERF_FIXED_CTR1: u32 = 778;
pub const MSR_CORE_PERF_FIXED_CTR2: u32 = 779;
pub const MSR_CORE_PERF_FIXED_CTR3: u32 = 780;
pub const MSR_CORE_PERF_FIXED_CTR_CTRL: u32 = 909;
pub const MSR_CORE_PERF_GLOBAL_STATUS: u32 = 910;
pub const MSR_CORE_PERF_GLOBAL_CTRL: u32 = 911;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL: u32 = 912;
pub const MSR_PERF_METRICS: u32 = 809;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_TRACE_TOPA_PMI_BIT: u32 = 55;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_TRACE_TOPA_PMI: u64 = 36028797018963968;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_OVF_BUF_BIT: u32 = 62;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_OVF_BUF: u64 = 4611686018427387904;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_COND_CHGD_BIT: u32 = 63;
pub const MSR_CORE_PERF_GLOBAL_OVF_CTRL_COND_CHGD: i64 = -9223372036854775808;
pub const MSR_GEODE_BUSCONT_CONF0: u32 = 6400;
pub const MSR_IA32_VMX_BASIC: u32 = 1152;
pub const MSR_IA32_VMX_PINBASED_CTLS: u32 = 1153;
pub const MSR_IA32_VMX_PROCBASED_CTLS: u32 = 1154;
pub const MSR_IA32_VMX_EXIT_CTLS: u32 = 1155;
pub const MSR_IA32_VMX_ENTRY_CTLS: u32 = 1156;
pub const MSR_IA32_VMX_MISC: u32 = 1157;
pub const MSR_IA32_VMX_CR0_FIXED0: u32 = 1158;
pub const MSR_IA32_VMX_CR0_FIXED1: u32 = 1159;
pub const MSR_IA32_VMX_CR4_FIXED0: u32 = 1160;
pub const MSR_IA32_VMX_CR4_FIXED1: u32 = 1161;
pub const MSR_IA32_VMX_VMCS_ENUM: u32 = 1162;
pub const MSR_IA32_VMX_PROCBASED_CTLS2: u32 = 1163;
pub const MSR_IA32_VMX_EPT_VPID_CAP: u32 = 1164;
pub const MSR_IA32_VMX_TRUE_PINBASED_CTLS: u32 = 1165;
pub const MSR_IA32_VMX_TRUE_PROCBASED_CTLS: u32 = 1166;
pub const MSR_IA32_VMX_TRUE_EXIT_CTLS: u32 = 1167;
pub const MSR_IA32_VMX_TRUE_ENTRY_CTLS: u32 = 1168;
pub const MSR_IA32_VMX_VMFUNC: u32 = 1169;
pub const MSR_IA32_VMX_PROCBASED_CTLS3: u32 = 1170;
pub const VMX_BASIC_VMCS_SIZE_SHIFT: u32 = 32;
pub const VMX_BASIC_TRUE_CTLS: u64 = 36028797018963968;
pub const VMX_BASIC_64: u64 = 281474976710656;
pub const VMX_BASIC_MEM_TYPE_SHIFT: u32 = 50;
pub const VMX_BASIC_MEM_TYPE_MASK: u64 = 16888498602639360;
pub const VMX_BASIC_MEM_TYPE_WB: u32 = 6;
pub const VMX_BASIC_INOUT: u64 = 18014398509481984;
pub const MSR_IA32_VMX_MISC_INTEL_PT: u32 = 16384;
pub const MSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS: u32 = 536870912;
pub const MSR_IA32_VMX_MISC_PREEMPTION_TIMER_SCALE: u32 = 31;
pub const MSR_VM_CR: u32 = 3221291284;
pub const MSR_VM_IGNNE: u32 = 3221291285;
pub const MSR_VM_HSAVE_PA: u32 = 3221291287;
pub const MSR_IA32_HW_FEEDBACK_PTR: u32 = 6096;
pub const MSR_IA32_HW_FEEDBACK_CONFIG: u32 = 6097;
pub const MSR_IA32_XAPIC_DISABLE_STATUS: u32 = 189;
pub const ORC_REG_UNDEFINED: u32 = 0;
pub const ORC_REG_PREV_SP: u32 = 1;
pub const ORC_REG_DX: u32 = 2;
pub const ORC_REG_DI: u32 = 3;
pub const ORC_REG_BP: u32 = 4;
pub const ORC_REG_SP: u32 = 5;
pub const ORC_REG_R10: u32 = 6;
pub const ORC_REG_R13: u32 = 7;
pub const ORC_REG_BP_INDIRECT: u32 = 8;
pub const ORC_REG_SP_INDIRECT: u32 = 9;
pub const ORC_REG_MAX: u32 = 15;
pub const RETPOLINE_THUNK_SIZE: u32 = 32;
pub const RSB_CLEAR_LOOPS: u32 = 32;
pub const LDT_ENTRIES: u32 = 8192;
pub const LDT_ENTRY_SIZE: u32 = 8;
pub const MODIFY_LDT_CONTENTS_DATA: u32 = 0;
pub const MODIFY_LDT_CONTENTS_STACK: u32 = 1;
pub const MODIFY_LDT_CONTENTS_CODE: u32 = 2;
pub const NR_REG_ARGUMENTS: u32 = 6;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const X86_FXSR_MAGIC: u32 = 0;
pub const BITMAP_MEM_ALIGNMENT: u32 = 8;
pub const BITMAP_MEM_MASK: u32 = 7;
pub const __X86_CASE_B: u32 = 1;
pub const __X86_CASE_W: u32 = 2;
pub const __X86_CASE_L: u32 = 4;
pub const __X86_CASE_Q: u32 = 8;
pub const ___GFP_DMA: u32 = 1;
pub const ___GFP_HIGHMEM: u32 = 2;
pub const ___GFP_DMA32: u32 = 4;
pub const ___GFP_MOVABLE: u32 = 8;
pub const ___GFP_RECLAIMABLE: u32 = 16;
pub const ___GFP_HIGH: u32 = 32;
pub const ___GFP_IO: u32 = 64;
pub const ___GFP_FS: u32 = 128;
pub const ___GFP_ZERO: u32 = 256;
pub const ___GFP_ATOMIC: u32 = 512;
pub const ___GFP_DIRECT_RECLAIM: u32 = 1024;
pub const ___GFP_KSWAPD_RECLAIM: u32 = 2048;
pub const ___GFP_WRITE: u32 = 4096;
pub const ___GFP_NOWARN: u32 = 8192;
pub const ___GFP_RETRY_MAYFAIL: u32 = 16384;
pub const ___GFP_NOFAIL: u32 = 32768;
pub const ___GFP_NORETRY: u32 = 65536;
pub const ___GFP_MEMALLOC: u32 = 131072;
pub const ___GFP_COMP: u32 = 262144;
pub const ___GFP_NOMEMALLOC: u32 = 524288;
pub const ___GFP_HARDWALL: u32 = 1048576;
pub const ___GFP_THISNODE: u32 = 2097152;
pub const ___GFP_ACCOUNT: u32 = 4194304;
pub const ___GFP_ZEROTAGS: u32 = 8388608;
pub const ___GFP_SKIP_ZERO: u32 = 0;
pub const ___GFP_SKIP_KASAN_UNPOISON: u32 = 0;
pub const ___GFP_SKIP_KASAN_POISON: u32 = 0;
pub const ___GFP_NOLOCKDEP: u32 = 0;
pub const NODES_SHIFT: u32 = 6;
pub const MAX_NUMNODES: u32 = 64;
pub const NUMA_NO_NODE: i32 = -1;
pub const TRACEPOINT_DEFS_H: u32 = 1;
pub const MXCSR_DEFAULT: u32 = 8064;
pub const NVMXINTS: u32 = 5;
pub const VMX_FEATURE_INTR_EXITING: u32 = 0;
pub const VMX_FEATURE_NMI_EXITING: u32 = 3;
pub const VMX_FEATURE_VIRTUAL_NMIS: u32 = 5;
pub const VMX_FEATURE_PREEMPTION_TIMER: u32 = 6;
pub const VMX_FEATURE_POSTED_INTR: u32 = 7;
pub const VMX_FEATURE_INVVPID: u32 = 16;
pub const VMX_FEATURE_EPT_EXECUTE_ONLY: u32 = 17;
pub const VMX_FEATURE_EPT_AD: u32 = 18;
pub const VMX_FEATURE_EPT_1GB: u32 = 19;
pub const VMX_FEATURE_FLEXPRIORITY: u32 = 24;
pub const VMX_FEATURE_APICV: u32 = 25;
pub const VMX_FEATURE_EPTP_SWITCHING: u32 = 28;
pub const VMX_FEATURE_INTR_WINDOW_EXITING: u32 = 34;
pub const VMX_FEATURE_USE_TSC_OFFSETTING: u32 = 35;
pub const VMX_FEATURE_HLT_EXITING: u32 = 39;
pub const VMX_FEATURE_INVLPG_EXITING: u32 = 41;
pub const VMX_FEATURE_MWAIT_EXITING: u32 = 42;
pub const VMX_FEATURE_RDPMC_EXITING: u32 = 43;
pub const VMX_FEATURE_RDTSC_EXITING: u32 = 44;
pub const VMX_FEATURE_CR3_LOAD_EXITING: u32 = 47;
pub const VMX_FEATURE_CR3_STORE_EXITING: u32 = 48;
pub const VMX_FEATURE_TERTIARY_CONTROLS: u32 = 49;
pub const VMX_FEATURE_CR8_LOAD_EXITING: u32 = 51;
pub const VMX_FEATURE_CR8_STORE_EXITING: u32 = 52;
pub const VMX_FEATURE_VIRTUAL_TPR: u32 = 53;
pub const VMX_FEATURE_NMI_WINDOW_EXITING: u32 = 54;
pub const VMX_FEATURE_MOV_DR_EXITING: u32 = 55;
pub const VMX_FEATURE_UNCOND_IO_EXITING: u32 = 56;
pub const VMX_FEATURE_USE_IO_BITMAPS: u32 = 57;
pub const VMX_FEATURE_MONITOR_TRAP_FLAG: u32 = 59;
pub const VMX_FEATURE_USE_MSR_BITMAPS: u32 = 60;
pub const VMX_FEATURE_MONITOR_EXITING: u32 = 61;
pub const VMX_FEATURE_PAUSE_EXITING: u32 = 62;
pub const VMX_FEATURE_SEC_CONTROLS: u32 = 63;
pub const VMX_FEATURE_VIRT_APIC_ACCESSES: u32 = 64;
pub const VMX_FEATURE_EPT: u32 = 65;
pub const VMX_FEATURE_DESC_EXITING: u32 = 66;
pub const VMX_FEATURE_RDTSCP: u32 = 67;
pub const VMX_FEATURE_VIRTUAL_X2APIC: u32 = 68;
pub const VMX_FEATURE_VPID: u32 = 69;
pub const VMX_FEATURE_WBINVD_EXITING: u32 = 70;
pub const VMX_FEATURE_UNRESTRICTED_GUEST: u32 = 71;
pub const VMX_FEATURE_APIC_REGISTER_VIRT: u32 = 72;
pub const VMX_FEATURE_VIRT_INTR_DELIVERY: u32 = 73;
pub const VMX_FEATURE_PAUSE_LOOP_EXITING: u32 = 74;
pub const VMX_FEATURE_RDRAND_EXITING: u32 = 75;
pub const VMX_FEATURE_INVPCID: u32 = 76;
pub const VMX_FEATURE_VMFUNC: u32 = 77;
pub const VMX_FEATURE_SHADOW_VMCS: u32 = 78;
pub const VMX_FEATURE_ENCLS_EXITING: u32 = 79;
pub const VMX_FEATURE_RDSEED_EXITING: u32 = 80;
pub const VMX_FEATURE_PAGE_MOD_LOGGING: u32 = 81;
pub const VMX_FEATURE_EPT_VIOLATION_VE: u32 = 82;
pub const VMX_FEATURE_PT_CONCEAL_VMX: u32 = 83;
pub const VMX_FEATURE_XSAVES: u32 = 84;
pub const VMX_FEATURE_MODE_BASED_EPT_EXEC: u32 = 86;
pub const VMX_FEATURE_PT_USE_GPA: u32 = 88;
pub const VMX_FEATURE_TSC_SCALING: u32 = 89;
pub const VMX_FEATURE_USR_WAIT_PAUSE: u32 = 90;
pub const VMX_FEATURE_ENCLV_EXITING: u32 = 92;
pub const VMX_FEATURE_BUS_LOCK_DETECTION: u32 = 94;
pub const VMX_FEATURE_NOTIFY_VM_EXITING: u32 = 95;
pub const VMX_FEATURE_IPI_VIRT: u32 = 100;
pub const SMP_CACHE_BYTES: u32 = 64;
pub const NET_IP_ALIGN: u32 = 0;
pub const HBP_NUM: u32 = 4;
pub const ARCH_MIN_MMSTRUCT_ALIGN: u32 = 0;
pub const X86_VENDOR_INTEL: u32 = 0;
pub const X86_VENDOR_CYRIX: u32 = 1;
pub const X86_VENDOR_AMD: u32 = 2;
pub const X86_VENDOR_UMC: u32 = 3;
pub const X86_VENDOR_CENTAUR: u32 = 5;
pub const X86_VENDOR_TRANSMETA: u32 = 7;
pub const X86_VENDOR_NSC: u32 = 8;
pub const X86_VENDOR_HYGON: u32 = 9;
pub const X86_VENDOR_ZHAOXIN: u32 = 10;
pub const X86_VENDOR_VORTEX: u32 = 11;
pub const X86_VENDOR_NUM: u32 = 12;
pub const X86_VENDOR_UNKNOWN: u32 = 255;
pub const IO_BITMAP_BITS: u32 = 65536;
pub const IO_BITMAP_BYTES: u32 = 8192;
pub const HAVE_ARCH_PICK_MMAP_LAYOUT: u32 = 1;
pub const BASE_PREFETCH: &'static [u8; 15usize] = b"prefetcht0 %P1\0";
pub const xen_set_default_idle: u32 = 0;
pub const X86_CAP_FMT_NUM: &'static [u8; 6usize] = b"%d:%d\0";
pub const X86_CAP_FMT: &'static [u8; 3usize] = b"%s\0";
pub const MAX_CPU_FEATURES: u32 = 640;
pub const CPU_FEATURE_TYPEFMT: &'static [u8; 26usize] = b"x86,ven%04Xfam%04Xmod%04X\0";
pub const TIF_NOTIFY_RESUME: u32 = 1;
pub const TIF_SIGPENDING: u32 = 2;
pub const TIF_NEED_RESCHED: u32 = 3;
pub const TIF_SINGLESTEP: u32 = 4;
pub const TIF_SSBD: u32 = 5;
pub const TIF_SPEC_IB: u32 = 9;
pub const TIF_SPEC_L1D_FLUSH: u32 = 10;
pub const TIF_USER_RETURN_NOTIFY: u32 = 11;
pub const TIF_UPROBE: u32 = 12;
pub const TIF_PATCH_PENDING: u32 = 13;
pub const TIF_NEED_FPU_LOAD: u32 = 14;
pub const TIF_NOCPUID: u32 = 15;
pub const TIF_NOTSC: u32 = 16;
pub const TIF_NOTIFY_SIGNAL: u32 = 17;
pub const TIF_MEMDIE: u32 = 20;
pub const TIF_POLLING_NRFLAG: u32 = 21;
pub const TIF_IO_BITMAP: u32 = 22;
pub const TIF_SPEC_FORCE_UPDATE: u32 = 23;
pub const TIF_FORCED_TF: u32 = 24;
pub const TIF_BLOCKSTEP: u32 = 25;
pub const TIF_LAZY_MMU_UPDATES: u32 = 27;
pub const TIF_ADDR32: u32 = 29;
pub const _TIF_NOTIFY_RESUME: u32 = 2;
pub const _TIF_SIGPENDING: u32 = 4;
pub const _TIF_NEED_RESCHED: u32 = 8;
pub const _TIF_SINGLESTEP: u32 = 16;
pub const _TIF_SSBD: u32 = 32;
pub const _TIF_SPEC_IB: u32 = 512;
pub const _TIF_SPEC_L1D_FLUSH: u32 = 1024;
pub const _TIF_USER_RETURN_NOTIFY: u32 = 2048;
pub const _TIF_UPROBE: u32 = 4096;
pub const _TIF_PATCH_PENDING: u32 = 8192;
pub const _TIF_NEED_FPU_LOAD: u32 = 16384;
pub const _TIF_NOCPUID: u32 = 32768;
pub const _TIF_NOTSC: u32 = 65536;
pub const _TIF_NOTIFY_SIGNAL: u32 = 131072;
pub const _TIF_POLLING_NRFLAG: u32 = 2097152;
pub const _TIF_IO_BITMAP: u32 = 4194304;
pub const _TIF_SPEC_FORCE_UPDATE: u32 = 8388608;
pub const _TIF_FORCED_TF: u32 = 16777216;
pub const _TIF_BLOCKSTEP: u32 = 33554432;
pub const _TIF_LAZY_MMU_UPDATES: u32 = 134217728;
pub const _TIF_ADDR32: u32 = 536870912;
pub const _TIF_WORK_CTXSW_BASE: u32 = 42041376;
pub const _TIF_WORK_CTXSW: u32 = 42041888;
pub const _TIF_WORK_CTXSW_PREV: u32 = 46238240;
pub const _TIF_WORK_CTXSW_NEXT: u32 = 42041888;
pub const TS_COMPAT: u32 = 2;
pub const TS_I386_REGS_POKED: u32 = 4;
pub const PREEMPT_NEED_RESCHED: u32 = 2147483648;
pub const PREEMPT_ENABLED: u32 = 2147483648;
pub const PREEMPT_DISABLE_OFFSET: u32 = 1;
pub const PREEMPT_LOCK_OFFSET: u32 = 1;
pub const SOFTIRQ_LOCK_OFFSET: u32 = 513;
pub const force_read_lock_recursive: u32 = 0;
pub const SINGLE_DEPTH_NESTING: u32 = 1;
pub const LOCK_SECTION_NAME: &'static [u8; 13usize] = b".text..lock.\0";
pub const LOCK_SECTION_END: &'static [u8; 12usize] = b".previous\n\t\0";
pub const RWLOCK_MAGIC: u32 = 3736018669;
pub const FRAME_OFFSET: u32 = 0;
pub const PV_SAVE_ALL_CALLER_REGS: &'static [u8; 79usize] =
    b"push %rcx;push %rdx;push %rsi;push %rdi;push %r8;push %r9;push %r10;push %r11;\0";
pub const PV_RESTORE_ALL_CALLER_REGS: &'static [u8; 71usize] =
    b"pop %r11;pop %r10;pop %r9;pop %r8;pop %rdi;pop %rsi;pop %rdx;pop %rcx;\0";
pub const SPIN_THRESHOLD: u32 = 32768;
pub const _Q_PENDING_LOOPS: u32 = 512;
pub const _QW_WAITING: u32 = 256;
pub const _QW_LOCKED: u32 = 255;
pub const _QW_WMASK: u32 = 511;
pub const _QR_SHIFT: u32 = 9;
pub const _QR_BIAS: u32 = 512;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const P_ALL: u32 = 0;
pub const P_PID: u32 = 1;
pub const P_PGID: u32 = 2;
pub const P_PIDFD: u32 = 3;
pub const WQ_FLAG_EXCLUSIVE: u32 = 1;
pub const WQ_FLAG_WOKEN: u32 = 2;
pub const WQ_FLAG_BOOKMARK: u32 = 4;
pub const WQ_FLAG_CUSTOM: u32 = 8;
pub const WQ_FLAG_DONE: u32 = 16;
pub const WQ_FLAG_PRIORITY: u32 = 32;
pub const MINORBITS: u32 = 20;
pub const MINORMASK: u32 = 1048575;
pub const NUM_ACTIVE_RCU_POLL_OLDSTATE: u32 = 2;
pub const NUM_ACTIVE_RCU_POLL_FULL_OLDSTATE: u32 = 4;
pub const LIST_BL_LOCKMASK: u32 = 1;
pub const OSQ_UNLOCKED_VAL: u32 = 0;
pub const KCSAN_SEQLOCK_REGION_MAX: u32 = 1000;
pub const NR_PAGEFLAGS: u32 = 24;
pub const MAX_NR_ZONES: u32 = 4;
pub const NR_CPUS_BITS: u32 = 6;
pub const SPINLOCK_SIZE: u32 = 4;
pub const LRU_GEN_WIDTH: u32 = 0;
pub const __LRU_REFS_WIDTH: u32 = 0;
pub const GOLDEN_RATIO_32: u32 = 1640531527;
pub const GOLDEN_RATIO_64: u64 = 7046029254386353131;
pub const DNAME_INLINE_LEN: u32 = 32;
pub const DCACHE_OP_HASH: u32 = 1;
pub const DCACHE_OP_COMPARE: u32 = 2;
pub const DCACHE_OP_REVALIDATE: u32 = 4;
pub const DCACHE_OP_DELETE: u32 = 8;
pub const DCACHE_OP_PRUNE: u32 = 16;
pub const DCACHE_DISCONNECTED: u32 = 32;
pub const DCACHE_REFERENCED: u32 = 64;
pub const DCACHE_DONTCACHE: u32 = 128;
pub const DCACHE_CANT_MOUNT: u32 = 256;
pub const DCACHE_GENOCIDE: u32 = 512;
pub const DCACHE_SHRINK_LIST: u32 = 1024;
pub const DCACHE_OP_WEAK_REVALIDATE: u32 = 2048;
pub const DCACHE_NFSFS_RENAMED: u32 = 4096;
pub const DCACHE_COOKIE: u32 = 8192;
pub const DCACHE_FSNOTIFY_PARENT_WATCHED: u32 = 16384;
pub const DCACHE_DENTRY_KILLED: u32 = 32768;
pub const DCACHE_MOUNTED: u32 = 65536;
pub const DCACHE_NEED_AUTOMOUNT: u32 = 131072;
pub const DCACHE_MANAGE_TRANSIT: u32 = 262144;
pub const DCACHE_MANAGED_DENTRY: u32 = 458752;
pub const DCACHE_LRU_LIST: u32 = 524288;
pub const DCACHE_ENTRY_TYPE: u32 = 7340032;
pub const DCACHE_MISS_TYPE: u32 = 0;
pub const DCACHE_WHITEOUT_TYPE: u32 = 1048576;
pub const DCACHE_DIRECTORY_TYPE: u32 = 2097152;
pub const DCACHE_AUTODIR_TYPE: u32 = 3145728;
pub const DCACHE_REGULAR_TYPE: u32 = 4194304;
pub const DCACHE_SPECIAL_TYPE: u32 = 5242880;
pub const DCACHE_SYMLINK_TYPE: u32 = 6291456;
pub const DCACHE_MAY_FREE: u32 = 8388608;
pub const DCACHE_FALLTHRU: u32 = 16777216;
pub const DCACHE_NOKEY_NAME: u32 = 33554432;
pub const DCACHE_OP_REAL: u32 = 67108864;
pub const DCACHE_PAR_LOOKUP: u32 = 268435456;
pub const DCACHE_DENTRY_CURSOR: u32 = 536870912;
pub const DCACHE_NORCU: u32 = 1073741824;
pub const STAT_HAVE_NSEC: u32 = 1;
pub const S_IFMT: u32 = 61440;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFLNK: u32 = 40960;
pub const S_IFREG: u32 = 32768;
pub const S_IFBLK: u32 = 24576;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFIFO: u32 = 4096;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const STATX_TYPE: u32 = 1;
pub const STATX_MODE: u32 = 2;
pub const STATX_NLINK: u32 = 4;
pub const STATX_UID: u32 = 8;
pub const STATX_GID: u32 = 16;
pub const STATX_ATIME: u32 = 32;
pub const STATX_MTIME: u32 = 64;
pub const STATX_CTIME: u32 = 128;
pub const STATX_INO: u32 = 256;
pub const STATX_SIZE: u32 = 512;
pub const STATX_BLOCKS: u32 = 1024;
pub const STATX_BASIC_STATS: u32 = 2047;
pub const STATX_BTIME: u32 = 2048;
pub const STATX_MNT_ID: u32 = 4096;
pub const STATX_DIOALIGN: u32 = 8192;
pub const STATX__RESERVED: u32 = 2147483648;
pub const STATX_ATTR_COMPRESSED: u32 = 4;
pub const STATX_ATTR_IMMUTABLE: u32 = 16;
pub const STATX_ATTR_APPEND: u32 = 32;
pub const STATX_ATTR_NODUMP: u32 = 64;
pub const STATX_ATTR_ENCRYPTED: u32 = 2048;
pub const STATX_ATTR_AUTOMOUNT: u32 = 4096;
pub const STATX_ATTR_MOUNT_ROOT: u32 = 8192;
pub const STATX_ATTR_VERITY: u32 = 1048576;
pub const STATX_ATTR_DAX: u32 = 2097152;
pub const S_IRWXUGO: u32 = 511;
pub const S_IALLUGO: u32 = 4095;
pub const S_IRUGO: u32 = 292;
pub const S_IWUGO: u32 = 146;
pub const S_IXUGO: u32 = 73;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const NTP_API: u32 = 4;
pub const ADJ_OFFSET: u32 = 1;
pub const ADJ_FREQUENCY: u32 = 2;
pub const ADJ_MAXERROR: u32 = 4;
pub const ADJ_ESTERROR: u32 = 8;
pub const ADJ_STATUS: u32 = 16;
pub const ADJ_TIMECONST: u32 = 32;
pub const ADJ_TAI: u32 = 128;
pub const ADJ_SETOFFSET: u32 = 256;
pub const ADJ_MICRO: u32 = 4096;
pub const ADJ_NANO: u32 = 8192;
pub const ADJ_TICK: u32 = 16384;
pub const MOD_OFFSET: u32 = 1;
pub const MOD_FREQUENCY: u32 = 2;
pub const MOD_MAXERROR: u32 = 4;
pub const MOD_ESTERROR: u32 = 8;
pub const MOD_STATUS: u32 = 16;
pub const MOD_TIMECONST: u32 = 32;
pub const MOD_TAI: u32 = 128;
pub const MOD_MICRO: u32 = 4096;
pub const MOD_NANO: u32 = 8192;
pub const STA_PLL: u32 = 1;
pub const STA_PPSFREQ: u32 = 2;
pub const STA_PPSTIME: u32 = 4;
pub const STA_FLL: u32 = 8;
pub const STA_INS: u32 = 16;
pub const STA_DEL: u32 = 32;
pub const STA_UNSYNC: u32 = 64;
pub const STA_FREQHOLD: u32 = 128;
pub const STA_PPSSIGNAL: u32 = 256;
pub const STA_PPSJITTER: u32 = 512;
pub const STA_PPSWANDER: u32 = 1024;
pub const STA_PPSERROR: u32 = 2048;
pub const STA_CLOCKERR: u32 = 4096;
pub const STA_NANO: u32 = 8192;
pub const STA_MODE: u32 = 16384;
pub const STA_CLK: u32 = 32768;
pub const STA_RONLY: u32 = 65280;
pub const TIME_OK: u32 = 0;
pub const TIME_INS: u32 = 1;
pub const TIME_DEL: u32 = 2;
pub const TIME_OOP: u32 = 3;
pub const TIME_WAIT: u32 = 4;
pub const TIME_ERROR: u32 = 5;
pub const TIME_BAD: u32 = 5;
pub const ADJ_ADJTIME: u32 = 32768;
pub const ADJ_OFFSET_SINGLESHOT: u32 = 1;
pub const ADJ_OFFSET_READONLY: u32 = 8192;
pub const SHIFT_PLL: u32 = 2;
pub const SHIFT_FLL: u32 = 2;
pub const MAXTC: u32 = 10;
pub const SHIFT_USEC: u32 = 16;
pub const PPM_SCALE_INV_SHIFT: u32 = 19;
pub const MAXPHASE: u32 = 500000000;
pub const MAXFREQ: u32 = 500000;
pub const MINSEC: u32 = 256;
pub const MAXSEC: u32 = 2048;
pub const NTP_PHASE_LIMIT: u32 = 16000000;
pub const NTP_SCALE_SHIFT: u32 = 32;
pub const NTP_INTERVAL_FREQ: u32 = 1000;
pub const NTP_INTERVAL_LENGTH: u32 = 1000000;
pub const PIT_TICK_RATE: u32 = 1193182;
pub const DEFAULT_OVERFLOWUID: u32 = 65534;
pub const DEFAULT_OVERFLOWGID: u32 = 65534;
pub const DEFAULT_FS_OVERFLOWUID: u32 = 65534;
pub const DEFAULT_FS_OVERFLOWGID: u32 = 65534;
pub const KSTAT_ATTR_FS_IOC_FLAGS: u32 = 1050740;
pub const KSTAT_ATTR_VFS_FLAGS: u32 = 48;
pub const GRND_NONBLOCK: u32 = 1;
pub const GRND_RANDOM: u32 = 2;
pub const GRND_INSECURE: u32 = 4;
pub const CANARY_MASK: i32 = -256;
pub const LINUX_MM_DEBUG_H: u32 = 1;
pub const PERCPU_MODULE_RESERVE: u32 = 8192;
pub const PCPU_MIN_ALLOC_SHIFT: u32 = 2;
pub const PCPU_MIN_ALLOC_SIZE: u32 = 4;
pub const PERCPU_DYNAMIC_EARLY_SLOTS: u32 = 128;
pub const PERCPU_DYNAMIC_EARLY_SIZE: u32 = 12288;
pub const PERCPU_DYNAMIC_RESERVE: u32 = 28672;
pub const RDRAND_RETRY_LOOPS: u32 = 10;
pub const SHRINK_STOP: i32 = -1;
pub const SHRINK_EMPTY: i32 = -2;
pub const DEFAULT_SEEKS: u32 = 2;
pub const SHRINKER_REGISTERED: u32 = 1;
pub const SHRINKER_NUMA_AWARE: u32 = 2;
pub const SHRINKER_MEMCG_AWARE: u32 = 4;
pub const SHRINKER_NONSLAB: u32 = 8;
pub const PB_migratetype_bits: u32 = 3;
pub const ZONES_SHIFT: u32 = 2;
pub const ZONES_WIDTH: u32 = 2;
pub const SECTIONS_WIDTH: u32 = 0;
pub const NODES_WIDTH: u32 = 6;
pub const KASAN_TAG_WIDTH: u32 = 0;
pub const LAST_CPUPID_SHIFT: u32 = 0;
pub const LAST_CPUPID_WIDTH: u32 = 0;
pub const AT_SYSINFO_EHDR: u32 = 33;
pub const AT_VECTOR_SIZE_ARCH: u32 = 3;
pub const AT_NULL: u32 = 0;
pub const AT_IGNORE: u32 = 1;
pub const AT_EXECFD: u32 = 2;
pub const AT_PHDR: u32 = 3;
pub const AT_PHENT: u32 = 4;
pub const AT_PHNUM: u32 = 5;
pub const AT_PAGESZ: u32 = 6;
pub const AT_BASE: u32 = 7;
pub const AT_FLAGS: u32 = 8;
pub const AT_ENTRY: u32 = 9;
pub const AT_NOTELF: u32 = 10;
pub const AT_UID: u32 = 11;
pub const AT_EUID: u32 = 12;
pub const AT_GID: u32 = 13;
pub const AT_EGID: u32 = 14;
pub const AT_PLATFORM: u32 = 15;
pub const AT_HWCAP: u32 = 16;
pub const AT_CLKTCK: u32 = 17;
pub const AT_SECURE: u32 = 23;
pub const AT_BASE_PLATFORM: u32 = 24;
pub const AT_RANDOM: u32 = 25;
pub const AT_HWCAP2: u32 = 26;
pub const AT_EXECFN: u32 = 31;
pub const AT_MINSIGSTKSZ: u32 = 51;
pub const AT_VECTOR_SIZE_BASE: u32 = 20;
pub const MAPLE_NODE_SLOTS: u32 = 31;
pub const MAPLE_RANGE64_SLOTS: u32 = 16;
pub const MAPLE_ARANGE64_SLOTS: u32 = 10;
pub const MAPLE_ARANGE64_META_MAX: u32 = 15;
pub const MAPLE_ALLOC_SLOTS: u32 = 30;
pub const MAPLE_NODE_MASK: u32 = 255;
pub const MT_FLAGS_ALLOC_RANGE: u32 = 1;
pub const MT_FLAGS_USE_RCU: u32 = 2;
pub const MT_FLAGS_HEIGHT_OFFSET: u32 = 2;
pub const MT_FLAGS_HEIGHT_MASK: u32 = 124;
pub const MT_FLAGS_LOCK_MASK: u32 = 768;
pub const MT_FLAGS_LOCK_IRQ: u32 = 256;
pub const MT_FLAGS_LOCK_BH: u32 = 512;
pub const MT_FLAGS_LOCK_EXTERN: u32 = 768;
pub const MAPLE_HEIGHT_MAX: u32 = 31;
pub const MAPLE_NODE_TYPE_MASK: u32 = 15;
pub const MAPLE_NODE_TYPE_SHIFT: u32 = 3;
pub const MAPLE_RESERVED_RANGE: u32 = 4096;
pub const RWSEM_UNLOCKED_VALUE: u32 = 0;
pub const UPROBE_HANDLER_REMOVE: u32 = 1;
pub const UPROBE_HANDLER_MASK: u32 = 1;
pub const MAX_URETPROBE_DEPTH: u32 = 64;
pub const TICK_NSEC: u32 = 1000000;
pub const HZ_TO_MSEC_SHR32: u32 = 31;
pub const MSEC_TO_HZ_SHR32: u32 = 31;
pub const HZ_TO_MSEC_NUM: u32 = 1;
pub const HZ_TO_MSEC_DEN: u32 = 1;
pub const MSEC_TO_HZ_NUM: u32 = 1;
pub const MSEC_TO_HZ_DEN: u32 = 1;
pub const HZ_TO_USEC_SHR32: u32 = 22;
pub const USEC_TO_HZ_SHR32: u32 = 41;
pub const HZ_TO_USEC_NUM: u32 = 1000;
pub const HZ_TO_USEC_DEN: u32 = 1;
pub const USEC_TO_HZ_NUM: u32 = 1;
pub const USEC_TO_HZ_DEN: u32 = 1000;
pub const HZ_TO_NSEC_NUM: u32 = 1000000;
pub const HZ_TO_NSEC_DEN: u32 = 1;
pub const NSEC_TO_HZ_NUM: u32 = 1;
pub const NSEC_TO_HZ_DEN: u32 = 1000000;
pub const SHIFT_HZ: u32 = 10;
pub const TICK_USEC: u32 = 1000;
pub const USER_TICK_USEC: u32 = 10000;
pub const SEC_JIFFIE_SC: u32 = 21;
pub const NSEC_JIFFIE_SC: u32 = 51;
pub const TIMESTAMP_SIZE: u32 = 30;
pub const LOW_RES_NSEC: u32 = 1000000;
pub const KTIME_LOW_RES: u32 = 1000000;
pub const TIMER_CPUMASK: u32 = 262143;
pub const TIMER_MIGRATING: u32 = 262144;
pub const TIMER_BASEMASK: u32 = 524287;
pub const TIMER_DEFERRABLE: u32 = 524288;
pub const TIMER_PINNED: u32 = 1048576;
pub const TIMER_IRQSAFE: u32 = 2097152;
pub const TIMER_INIT_FLAGS: u32 = 3670016;
pub const TIMER_ARRAYSHIFT: u32 = 22;
pub const TIMER_ARRAYMASK: u32 = 4290772992;
pub const TIMER_TRACE_FLAGMASK: u32 = 3932160;
pub const NEXT_TIMER_MAX_DELTA: u32 = 1073741823;
pub const RCU_DONE_TAIL: u32 = 0;
pub const RCU_WAIT_TAIL: u32 = 1;
pub const RCU_NEXT_READY_TAIL: u32 = 2;
pub const RCU_NEXT_TAIL: u32 = 3;
pub const RCU_CBLIST_NSEGS: u32 = 4;
pub const RCU_FANOUT: u32 = 64;
pub const RCU_FANOUT_LEAF: u32 = 16;
pub const RCU_FANOUT_1: u32 = 16;
pub const RCU_FANOUT_2: u32 = 1024;
pub const RCU_FANOUT_3: u32 = 65536;
pub const RCU_FANOUT_4: u32 = 4194304;
pub const RCU_NUM_LVLS: u32 = 2;
pub const NUM_RCU_LVL_0: u32 = 1;
pub const SRCU_SIZE_SMALL: u32 = 0;
pub const SRCU_SIZE_ALLOC: u32 = 1;
pub const SRCU_SIZE_WAIT_BARRIER: u32 = 2;
pub const SRCU_SIZE_WAIT_CALL: u32 = 3;
pub const SRCU_SIZE_WAIT_CBS1: u32 = 4;
pub const SRCU_SIZE_WAIT_CBS2: u32 = 5;
pub const SRCU_SIZE_WAIT_CBS3: u32 = 6;
pub const SRCU_SIZE_WAIT_CBS4: u32 = 7;
pub const SRCU_SIZE_BIG: u32 = 8;
pub const SRCU_STATE_IDLE: u32 = 0;
pub const SRCU_STATE_SCAN1: u32 = 1;
pub const SRCU_STATE_SCAN2: u32 = 2;
pub const NOTIFY_DONE: u32 = 0;
pub const NOTIFY_OK: u32 = 1;
pub const NOTIFY_STOP_MASK: u32 = 32768;
pub const NOTIFY_BAD: u32 = 32770;
pub const NOTIFY_STOP: u32 = 32769;
pub const NETLINK_URELEASE: u32 = 1;
pub const KBD_KEYCODE: u32 = 1;
pub const KBD_UNBOUND_KEYCODE: u32 = 2;
pub const KBD_UNICODE: u32 = 3;
pub const KBD_KEYSYM: u32 = 4;
pub const KBD_POST_KEYSYM: u32 = 5;
pub const MAX_UINSN_BYTES: u32 = 16;
pub const UPROBE_XOL_SLOT_BYTES: u32 = 128;
pub const UPROBE_SWBP_INSN: u32 = 204;
pub const UPROBE_SWBP_INSN_SIZE: u32 = 1;
pub const AT_VECTOR_SIZE: u32 = 48;
pub const INIT_PASID: u32 = 0;
pub const MM_MT_FLAGS: u32 = 769;
pub const PAGEFLAGS_MASK: u32 = 16777215;
pub const PAGE_POISON_PATTERN: i32 = -1;
pub const FOLIO_PF_ANY: u32 = 0;
pub const FOLIO_PF_HEAD: u32 = 0;
pub const FOLIO_PF_ONLY_HEAD: u32 = 0;
pub const FOLIO_PF_NO_TAIL: u32 = 0;
pub const FOLIO_PF_NO_COMPOUND: u32 = 0;
pub const FOLIO_PF_SECOND: u32 = 1;
pub const __PG_HWPOISON: u32 = 0;
pub const PAGE_MAPPING_ANON: u32 = 1;
pub const PAGE_MAPPING_MOVABLE: u32 = 2;
pub const PAGE_MAPPING_KSM: u32 = 3;
pub const PAGE_MAPPING_FLAGS: u32 = 3;
pub const PAGE_MAPPING_DAX_COW: u32 = 1;
pub const PAGE_TYPE_BASE: u32 = 4026531840;
pub const PAGE_MAPCOUNT_RESERVE: i32 = -128;
pub const PG_buddy: u32 = 128;
pub const PG_offline: u32 = 256;
pub const PG_table: u32 = 512;
pub const PG_guard: u32 = 1024;
pub const MAX_ORDER: u32 = 11;
pub const MAX_ORDER_NR_PAGES: u32 = 1024;
pub const PAGE_ALLOC_COSTLY_ORDER: u32 = 3;
pub const MIGRATETYPE_MASK: u32 = 7;
pub const LRU_BASE: u32 = 0;
pub const LRU_ACTIVE: u32 = 1;
pub const LRU_FILE: u32 = 2;
pub const WORKINGSET_ANON: u32 = 0;
pub const WORKINGSET_FILE: u32 = 1;
pub const ANON_AND_FILE: u32 = 2;
pub const MIN_NR_GENS: u32 = 2;
pub const MAX_NR_GENS: u32 = 4;
pub const MAX_NR_TIERS: u32 = 4;
pub const NR_PCP_THP: u32 = 0;
pub const ASYNC_AND_SYNC: u32 = 2;
pub const ZONEID_SHIFT: u32 = 8;
pub const ZONES_MASK: u32 = 3;
pub const NODES_MASK: u32 = 63;
pub const SECTIONS_MASK: u32 = 0;
pub const LAST_CPUPID_MASK: u32 = 0;
pub const KASAN_TAG_MASK: u32 = 0;
pub const ZONEID_MASK: u32 = 255;
pub const DEF_PRIORITY: u32 = 12;
pub const MAX_ZONES_PER_ZONELIST: u32 = 256;
pub const NUMA_ZONELIST_ORDER_LEN: u32 = 16;
pub const PA_SECTION_SHIFT: u32 = 27;
pub const PFN_SECTION_SHIFT: u32 = 15;
pub const PAGES_PER_SECTION: u32 = 32768;
pub const PAGE_SECTION_MASK: i32 = -32768;
pub const SUBSECTION_SHIFT: u32 = 21;
pub const SUBSECTION_SIZE: u32 = 2097152;
pub const PFN_SUBSECTION_SHIFT: u32 = 9;
pub const PAGES_PER_SUBSECTION: u32 = 512;
pub const PAGE_SUBSECTION_MASK: i32 = -512;
pub const SUBSECTIONS_PER_SECTION: u32 = 64;
pub const MPC_SIGNATURE: &'static [u8; 5usize] = b"PCMP\0";
pub const MP_PROCESSOR: u32 = 0;
pub const MP_BUS: u32 = 1;
pub const MP_IOAPIC: u32 = 2;
pub const MP_INTSRC: u32 = 3;
pub const MP_LINTSRC: u32 = 4;
pub const MP_TRANSLATION: u32 = 192;
pub const CPU_ENABLED: u32 = 1;
pub const CPU_BOOTPROCESSOR: u32 = 2;
pub const CPU_STEPPING_MASK: u32 = 15;
pub const CPU_MODEL_MASK: u32 = 240;
pub const CPU_FAMILY_MASK: u32 = 3840;
pub const BUSTYPE_EISA: &'static [u8; 5usize] = b"EISA\0";
pub const BUSTYPE_ISA: &'static [u8; 4usize] = b"ISA\0";
pub const BUSTYPE_INTERN: &'static [u8; 7usize] = b"INTERN\0";
pub const BUSTYPE_MCA: &'static [u8; 4usize] = b"MCA\0";
pub const BUSTYPE_VL: &'static [u8; 3usize] = b"VL\0";
pub const BUSTYPE_PCI: &'static [u8; 4usize] = b"PCI\0";
pub const BUSTYPE_PCMCIA: &'static [u8; 7usize] = b"PCMCIA\0";
pub const BUSTYPE_CBUS: &'static [u8; 5usize] = b"CBUS\0";
pub const BUSTYPE_CBUSII: &'static [u8; 7usize] = b"CBUSII\0";
pub const BUSTYPE_FUTURE: &'static [u8; 7usize] = b"FUTURE\0";
pub const BUSTYPE_MBI: &'static [u8; 4usize] = b"MBI\0";
pub const BUSTYPE_MBII: &'static [u8; 5usize] = b"MBII\0";
pub const BUSTYPE_MPI: &'static [u8; 4usize] = b"MPI\0";
pub const BUSTYPE_MPSA: &'static [u8; 5usize] = b"MPSA\0";
pub const BUSTYPE_NUBUS: &'static [u8; 6usize] = b"NUBUS\0";
pub const BUSTYPE_TC: &'static [u8; 3usize] = b"TC\0";
pub const BUSTYPE_VME: &'static [u8; 4usize] = b"VME\0";
pub const BUSTYPE_XPRESS: &'static [u8; 7usize] = b"XPRESS\0";
pub const MPC_APIC_USABLE: u32 = 1;
pub const MP_IRQPOL_DEFAULT: u32 = 0;
pub const MP_IRQPOL_ACTIVE_HIGH: u32 = 1;
pub const MP_IRQPOL_RESERVED: u32 = 2;
pub const MP_IRQPOL_ACTIVE_LOW: u32 = 3;
pub const MP_IRQPOL_MASK: u32 = 3;
pub const MP_IRQTRIG_DEFAULT: u32 = 0;
pub const MP_IRQTRIG_EDGE: u32 = 4;
pub const MP_IRQTRIG_RESERVED: u32 = 8;
pub const MP_IRQTRIG_LEVEL: u32 = 12;
pub const MP_IRQTRIG_MASK: u32 = 12;
pub const MP_APIC_ALL: u32 = 255;
pub const MPC_OEM_SIGNATURE: &'static [u8; 5usize] = b"_OEM\0";
pub const IO_APIC_DEFAULT_PHYS_BASE: u32 = 4273995776;
pub const APIC_DEFAULT_PHYS_BASE: u32 = 4276092928;
pub const IO_APIC_SLOT_SIZE: u32 = 1024;
pub const APIC_ID: u32 = 32;
pub const APIC_LVR: u32 = 48;
pub const APIC_LVR_MASK: u32 = 16711935;
pub const APIC_LVR_DIRECTED_EOI: u32 = 16777216;
pub const APIC_TASKPRI: u32 = 128;
pub const APIC_TPRI_MASK: u32 = 255;
pub const APIC_ARBPRI: u32 = 144;
pub const APIC_ARBPRI_MASK: u32 = 255;
pub const APIC_PROCPRI: u32 = 160;
pub const APIC_EOI: u32 = 176;
pub const APIC_EOI_ACK: u32 = 0;
pub const APIC_RRR: u32 = 192;
pub const APIC_LDR: u32 = 208;
pub const APIC_LDR_MASK: u32 = 4278190080;
pub const APIC_ALL_CPUS: u32 = 255;
pub const APIC_DFR: u32 = 224;
pub const APIC_DFR_CLUSTER: u32 = 268435455;
pub const APIC_DFR_FLAT: u32 = 4294967295;
pub const APIC_SPIV: u32 = 240;
pub const APIC_SPIV_DIRECTED_EOI: u32 = 4096;
pub const APIC_SPIV_FOCUS_DISABLED: u32 = 512;
pub const APIC_SPIV_APIC_ENABLED: u32 = 256;
pub const APIC_ISR: u32 = 256;
pub const APIC_ISR_NR: u32 = 8;
pub const APIC_TMR: u32 = 384;
pub const APIC_IRR: u32 = 512;
pub const APIC_ESR: u32 = 640;
pub const APIC_ESR_SEND_CS: u32 = 1;
pub const APIC_ESR_RECV_CS: u32 = 2;
pub const APIC_ESR_SEND_ACC: u32 = 4;
pub const APIC_ESR_RECV_ACC: u32 = 8;
pub const APIC_ESR_SENDILL: u32 = 32;
pub const APIC_ESR_RECVILL: u32 = 64;
pub const APIC_ESR_ILLREGA: u32 = 128;
pub const APIC_LVTCMCI: u32 = 752;
pub const APIC_ICR: u32 = 768;
pub const APIC_DEST_SELF: u32 = 262144;
pub const APIC_DEST_ALLINC: u32 = 524288;
pub const APIC_DEST_ALLBUT: u32 = 786432;
pub const APIC_ICR_RR_MASK: u32 = 196608;
pub const APIC_ICR_RR_INVALID: u32 = 0;
pub const APIC_ICR_RR_INPROG: u32 = 65536;
pub const APIC_ICR_RR_VALID: u32 = 131072;
pub const APIC_INT_LEVELTRIG: u32 = 32768;
pub const APIC_INT_ASSERT: u32 = 16384;
pub const APIC_ICR_BUSY: u32 = 4096;
pub const APIC_DEST_LOGICAL: u32 = 2048;
pub const APIC_DEST_PHYSICAL: u32 = 0;
pub const APIC_DM_FIXED: u32 = 0;
pub const APIC_DM_FIXED_MASK: u32 = 1792;
pub const APIC_DM_LOWEST: u32 = 256;
pub const APIC_DM_SMI: u32 = 512;
pub const APIC_DM_REMRD: u32 = 768;
pub const APIC_DM_NMI: u32 = 1024;
pub const APIC_DM_INIT: u32 = 1280;
pub const APIC_DM_STARTUP: u32 = 1536;
pub const APIC_DM_EXTINT: u32 = 1792;
pub const APIC_VECTOR_MASK: u32 = 255;
pub const APIC_ICR2: u32 = 784;
pub const APIC_LVTT: u32 = 800;
pub const APIC_LVTTHMR: u32 = 816;
pub const APIC_LVTPC: u32 = 832;
pub const APIC_LVT0: u32 = 848;
pub const APIC_LVT_TIMER_ONESHOT: u32 = 0;
pub const APIC_LVT_TIMER_PERIODIC: u32 = 131072;
pub const APIC_LVT_TIMER_TSCDEADLINE: u32 = 262144;
pub const APIC_LVT_MASKED: u32 = 65536;
pub const APIC_LVT_LEVEL_TRIGGER: u32 = 32768;
pub const APIC_LVT_REMOTE_IRR: u32 = 16384;
pub const APIC_INPUT_POLARITY: u32 = 8192;
pub const APIC_SEND_PENDING: u32 = 4096;
pub const APIC_MODE_MASK: u32 = 1792;
pub const APIC_MODE_FIXED: u32 = 0;
pub const APIC_MODE_NMI: u32 = 4;
pub const APIC_MODE_EXTINT: u32 = 7;
pub const APIC_LVT1: u32 = 864;
pub const APIC_LVTERR: u32 = 880;
pub const APIC_TMICT: u32 = 896;
pub const APIC_TMCCT: u32 = 912;
pub const APIC_TDCR: u32 = 992;
pub const APIC_SELF_IPI: u32 = 1008;
pub const APIC_TDR_DIV_TMBASE: u32 = 4;
pub const APIC_TDR_DIV_1: u32 = 11;
pub const APIC_TDR_DIV_2: u32 = 0;
pub const APIC_TDR_DIV_4: u32 = 1;
pub const APIC_TDR_DIV_8: u32 = 2;
pub const APIC_TDR_DIV_16: u32 = 3;
pub const APIC_TDR_DIV_32: u32 = 8;
pub const APIC_TDR_DIV_64: u32 = 9;
pub const APIC_TDR_DIV_128: u32 = 10;
pub const APIC_EFEAT: u32 = 1024;
pub const APIC_ECTRL: u32 = 1040;
pub const APIC_EILVT_NR_AMD_K8: u32 = 1;
pub const APIC_EILVT_NR_AMD_10H: u32 = 4;
pub const APIC_EILVT_NR_MAX: u32 = 4;
pub const APIC_EILVT_MSG_FIX: u32 = 0;
pub const APIC_EILVT_MSG_SMI: u32 = 2;
pub const APIC_EILVT_MSG_NMI: u32 = 4;
pub const APIC_EILVT_MSG_EXT: u32 = 7;
pub const APIC_EILVT_MASKED: u32 = 65536;
pub const APIC_BASE_MSR: u32 = 2048;
pub const XAPIC_ENABLE: u32 = 2048;
pub const X2APIC_ENABLE: u32 = 1024;
pub const MAX_IO_APICS: u32 = 128;
pub const MAX_LOCAL_APIC: u32 = 32768;
pub const XAPIC_DEST_CPUS_SHIFT: u32 = 4;
pub const XAPIC_DEST_CPUS_MASK: u32 = 15;
pub const XAPIC_DEST_CLUSTER_MASK: u32 = 240;
pub const BAD_APICID: u32 = 65535;
pub const MAX_MP_BUSSES: u32 = 256;
pub const MAX_IRQ_SOURCES: u32 = 1024;
pub const LOCAL_DISTANCE: u32 = 10;
pub const REMOTE_DISTANCE: u32 = 20;
pub const DISTANCE_BITS: u32 = 8;
pub const RECLAIM_DISTANCE: u32 = 30;
pub const PENALTY_FOR_NODE_WITH_CPUS: u32 = 1;
pub const GFP_MOVABLE_SHIFT: u32 = 3;
pub const GFP_ZONES_SHIFT: u32 = 2;
pub const CSIGNAL: u32 = 255;
pub const CLONE_VM: u32 = 256;
pub const CLONE_FS: u32 = 512;
pub const CLONE_FILES: u32 = 1024;
pub const CLONE_SIGHAND: u32 = 2048;
pub const CLONE_PIDFD: u32 = 4096;
pub const CLONE_PTRACE: u32 = 8192;
pub const CLONE_VFORK: u32 = 16384;
pub const CLONE_PARENT: u32 = 32768;
pub const CLONE_THREAD: u32 = 65536;
pub const CLONE_NEWNS: u32 = 131072;
pub const CLONE_SYSVSEM: u32 = 262144;
pub const CLONE_SETTLS: u32 = 524288;
pub const CLONE_PARENT_SETTID: u32 = 1048576;
pub const CLONE_CHILD_CLEARTID: u32 = 2097152;
pub const CLONE_DETACHED: u32 = 4194304;
pub const CLONE_UNTRACED: u32 = 8388608;
pub const CLONE_CHILD_SETTID: u32 = 16777216;
pub const CLONE_NEWCGROUP: u32 = 33554432;
pub const CLONE_NEWUTS: u32 = 67108864;
pub const CLONE_NEWIPC: u32 = 134217728;
pub const CLONE_NEWUSER: u32 = 268435456;
pub const CLONE_NEWPID: u32 = 536870912;
pub const CLONE_NEWNET: u32 = 1073741824;
pub const CLONE_IO: u32 = 2147483648;
pub const CLONE_CLEAR_SIGHAND: u64 = 4294967296;
pub const CLONE_INTO_CGROUP: u64 = 8589934592;
pub const CLONE_NEWTIME: u32 = 128;
pub const CLONE_ARGS_SIZE_VER0: u32 = 64;
pub const CLONE_ARGS_SIZE_VER1: u32 = 80;
pub const CLONE_ARGS_SIZE_VER2: u32 = 88;
pub const SCHED_NORMAL: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_RESET_ON_FORK: u32 = 1073741824;
pub const SCHED_FLAG_RESET_ON_FORK: u32 = 1;
pub const SCHED_FLAG_RECLAIM: u32 = 2;
pub const SCHED_FLAG_DL_OVERRUN: u32 = 4;
pub const SCHED_FLAG_KEEP_POLICY: u32 = 8;
pub const SCHED_FLAG_KEEP_PARAMS: u32 = 16;
pub const SCHED_FLAG_UTIL_CLAMP_MIN: u32 = 32;
pub const SCHED_FLAG_UTIL_CLAMP_MAX: u32 = 64;
pub const SCHED_FLAG_KEEP_ALL: u32 = 24;
pub const SCHED_FLAG_UTIL_CLAMP: u32 = 96;
pub const SCHED_FLAG_ALL: u32 = 127;
pub const IPC_CREAT: u32 = 512;
pub const IPC_EXCL: u32 = 1024;
pub const IPC_NOWAIT: u32 = 2048;
pub const IPC_DIPC: u32 = 4096;
pub const IPC_OWN: u32 = 8192;
pub const IPC_RMID: u32 = 0;
pub const IPC_SET: u32 = 1;
pub const IPC_STAT: u32 = 2;
pub const IPC_INFO: u32 = 3;
pub const IPC_OLD: u32 = 0;
pub const IPC_64: u32 = 256;
pub const SEMOP: u32 = 1;
pub const SEMGET: u32 = 2;
pub const SEMCTL: u32 = 3;
pub const SEMTIMEDOP: u32 = 4;
pub const MSGSND: u32 = 11;
pub const MSGRCV: u32 = 12;
pub const MSGGET: u32 = 13;
pub const MSGCTL: u32 = 14;
pub const SHMAT: u32 = 21;
pub const SHMDT: u32 = 22;
pub const SHMGET: u32 = 23;
pub const SHMCTL: u32 = 24;
pub const DIPC: u32 = 25;
pub const SEM_UNDO: u32 = 4096;
pub const GETPID: u32 = 11;
pub const GETVAL: u32 = 12;
pub const GETALL: u32 = 13;
pub const GETNCNT: u32 = 14;
pub const GETZCNT: u32 = 15;
pub const SETVAL: u32 = 16;
pub const SETALL: u32 = 17;
pub const SEM_STAT: u32 = 18;
pub const SEM_INFO: u32 = 19;
pub const SEM_STAT_ANY: u32 = 20;
pub const SEMMNI: u32 = 32000;
pub const SEMMSL: u32 = 32000;
pub const SEMMNS: u32 = 1024000000;
pub const SEMOPM: u32 = 500;
pub const SEMVMX: u32 = 32767;
pub const SEMAEM: u32 = 32767;
pub const SEMUME: u32 = 500;
pub const SEMMNU: u32 = 1024000000;
pub const SEMMAP: u32 = 1024000000;
pub const SEMUSZ: u32 = 20;
pub const HUGETLB_FLAG_ENCODE_SHIFT: u32 = 26;
pub const HUGETLB_FLAG_ENCODE_MASK: u32 = 63;
pub const HUGETLB_FLAG_ENCODE_16KB: u32 = 939524096;
pub const HUGETLB_FLAG_ENCODE_64KB: u32 = 1073741824;
pub const HUGETLB_FLAG_ENCODE_512KB: u32 = 1275068416;
pub const HUGETLB_FLAG_ENCODE_1MB: u32 = 1342177280;
pub const HUGETLB_FLAG_ENCODE_2MB: u32 = 1409286144;
pub const HUGETLB_FLAG_ENCODE_8MB: u32 = 1543503872;
pub const HUGETLB_FLAG_ENCODE_16MB: u32 = 1610612736;
pub const HUGETLB_FLAG_ENCODE_32MB: u32 = 1677721600;
pub const HUGETLB_FLAG_ENCODE_256MB: u32 = 1879048192;
pub const HUGETLB_FLAG_ENCODE_512MB: u32 = 1946157056;
pub const HUGETLB_FLAG_ENCODE_1GB: u32 = 2013265920;
pub const HUGETLB_FLAG_ENCODE_2GB: u32 = 2080374784;
pub const HUGETLB_FLAG_ENCODE_16GB: u32 = 2281701376;
pub const SHMMIN: u32 = 1;
pub const SHMMNI: u32 = 4096;
pub const SHMMAX: i32 = -16777217;
pub const SHMALL: i32 = -16777217;
pub const SHMSEG: u32 = 4096;
pub const SHM_R: u32 = 256;
pub const SHM_W: u32 = 128;
pub const SHM_HUGETLB: u32 = 2048;
pub const SHM_NORESERVE: u32 = 4096;
pub const SHM_HUGE_SHIFT: u32 = 26;
pub const SHM_HUGE_MASK: u32 = 63;
pub const SHM_HUGE_64KB: u32 = 1073741824;
pub const SHM_HUGE_512KB: u32 = 1275068416;
pub const SHM_HUGE_1MB: u32 = 1342177280;
pub const SHM_HUGE_2MB: u32 = 1409286144;
pub const SHM_HUGE_8MB: u32 = 1543503872;
pub const SHM_HUGE_16MB: u32 = 1610612736;
pub const SHM_HUGE_32MB: u32 = 1677721600;
pub const SHM_HUGE_256MB: u32 = 1879048192;
pub const SHM_HUGE_512MB: u32 = 1946157056;
pub const SHM_HUGE_1GB: u32 = 2013265920;
pub const SHM_HUGE_2GB: u32 = 2080374784;
pub const SHM_HUGE_16GB: u32 = 2281701376;
pub const SHM_RDONLY: u32 = 4096;
pub const SHM_RND: u32 = 8192;
pub const SHM_REMAP: u32 = 16384;
pub const SHM_EXEC: u32 = 32768;
pub const SHM_LOCK: u32 = 11;
pub const SHM_UNLOCK: u32 = 12;
pub const SHM_STAT: u32 = 13;
pub const SHM_INFO: u32 = 14;
pub const SHM_STAT_ANY: u32 = 15;
pub const KMSAN_RETVAL_SIZE: u32 = 800;
pub const KMSAN_PARAM_SIZE: u32 = 800;
pub const HIGH_RES_NSEC: u32 = 1;
pub const KTIME_HIGH_RES: u32 = 1;
pub const MONOTONIC_RES_NSEC: u32 = 1;
pub const KTIME_MONOTONIC_RES: u32 = 1;
pub const HRTIMER_STATE_INACTIVE: u32 = 0;
pub const HRTIMER_STATE_ENQUEUED: u32 = 1;
pub const SECCOMP_MODE_DISABLED: u32 = 0;
pub const SECCOMP_MODE_STRICT: u32 = 1;
pub const SECCOMP_MODE_FILTER: u32 = 2;
pub const SECCOMP_SET_MODE_STRICT: u32 = 0;
pub const SECCOMP_SET_MODE_FILTER: u32 = 1;
pub const SECCOMP_GET_ACTION_AVAIL: u32 = 2;
pub const SECCOMP_GET_NOTIF_SIZES: u32 = 3;
pub const SECCOMP_FILTER_FLAG_TSYNC: u32 = 1;
pub const SECCOMP_FILTER_FLAG_LOG: u32 = 2;
pub const SECCOMP_FILTER_FLAG_SPEC_ALLOW: u32 = 4;
pub const SECCOMP_FILTER_FLAG_NEW_LISTENER: u32 = 8;
pub const SECCOMP_FILTER_FLAG_TSYNC_ESRCH: u32 = 16;
pub const SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV: u32 = 32;
pub const SECCOMP_RET_KILL_PROCESS: u32 = 2147483648;
pub const SECCOMP_RET_KILL_THREAD: u32 = 0;
pub const SECCOMP_RET_KILL: u32 = 0;
pub const SECCOMP_RET_TRAP: u32 = 196608;
pub const SECCOMP_RET_ERRNO: u32 = 327680;
pub const SECCOMP_RET_USER_NOTIF: u32 = 2143289344;
pub const SECCOMP_RET_TRACE: u32 = 2146435072;
pub const SECCOMP_RET_LOG: u32 = 2147221504;
pub const SECCOMP_RET_ALLOW: u32 = 2147418112;
pub const SECCOMP_RET_ACTION_FULL: u32 = 4294901760;
pub const SECCOMP_RET_ACTION: u32 = 2147418112;
pub const SECCOMP_RET_DATA: u32 = 65535;
pub const SECCOMP_USER_NOTIF_FLAG_CONTINUE: u32 = 1;
pub const SECCOMP_ADDFD_FLAG_SETFD: u32 = 1;
pub const SECCOMP_ADDFD_FLAG_SEND: u32 = 2;
pub const SECCOMP_IOC_MAGIC: u8 = 33u8;
pub const SECCOMP_FILTER_FLAG_MASK: u32 = 63;
pub const SECCOMP_NOTIFY_ADDFD_SIZE_VER0: u32 = 24;
pub const SECCOMP_NOTIFY_ADDFD_SIZE_LATEST: u32 = 24;
pub const _ASM_X86_UNISTD_H: u32 = 1;
pub const __X32_SYSCALL_BIT: u32 = 1073741824;
pub const __NR_read: u32 = 0;
pub const __NR_write: u32 = 1;
pub const __NR_open: u32 = 2;
pub const __NR_close: u32 = 3;
pub const __NR_stat: u32 = 4;
pub const __NR_fstat: u32 = 5;
pub const __NR_lstat: u32 = 6;
pub const __NR_poll: u32 = 7;
pub const __NR_lseek: u32 = 8;
pub const __NR_mmap: u32 = 9;
pub const __NR_mprotect: u32 = 10;
pub const __NR_munmap: u32 = 11;
pub const __NR_brk: u32 = 12;
pub const __NR_rt_sigaction: u32 = 13;
pub const __NR_rt_sigprocmask: u32 = 14;
pub const __NR_rt_sigreturn: u32 = 15;
pub const __NR_ioctl: u32 = 16;
pub const __NR_pread64: u32 = 17;
pub const __NR_pwrite64: u32 = 18;
pub const __NR_readv: u32 = 19;
pub const __NR_writev: u32 = 20;
pub const __NR_access: u32 = 21;
pub const __NR_pipe: u32 = 22;
pub const __NR_select: u32 = 23;
pub const __NR_sched_yield: u32 = 24;
pub const __NR_mremap: u32 = 25;
pub const __NR_msync: u32 = 26;
pub const __NR_mincore: u32 = 27;
pub const __NR_madvise: u32 = 28;
pub const __NR_shmget: u32 = 29;
pub const __NR_shmat: u32 = 30;
pub const __NR_shmctl: u32 = 31;
pub const __NR_dup: u32 = 32;
pub const __NR_dup2: u32 = 33;
pub const __NR_pause: u32 = 34;
pub const __NR_nanosleep: u32 = 35;
pub const __NR_getitimer: u32 = 36;
pub const __NR_alarm: u32 = 37;
pub const __NR_setitimer: u32 = 38;
pub const __NR_getpid: u32 = 39;
pub const __NR_sendfile: u32 = 40;
pub const __NR_socket: u32 = 41;
pub const __NR_connect: u32 = 42;
pub const __NR_accept: u32 = 43;
pub const __NR_sendto: u32 = 44;
pub const __NR_recvfrom: u32 = 45;
pub const __NR_sendmsg: u32 = 46;
pub const __NR_recvmsg: u32 = 47;
pub const __NR_shutdown: u32 = 48;
pub const __NR_bind: u32 = 49;
pub const __NR_listen: u32 = 50;
pub const __NR_getsockname: u32 = 51;
pub const __NR_getpeername: u32 = 52;
pub const __NR_socketpair: u32 = 53;
pub const __NR_setsockopt: u32 = 54;
pub const __NR_getsockopt: u32 = 55;
pub const __NR_clone: u32 = 56;
pub const __NR_fork: u32 = 57;
pub const __NR_vfork: u32 = 58;
pub const __NR_execve: u32 = 59;
pub const __NR_exit: u32 = 60;
pub const __NR_wait4: u32 = 61;
pub const __NR_kill: u32 = 62;
pub const __NR_uname: u32 = 63;
pub const __NR_semget: u32 = 64;
pub const __NR_semop: u32 = 65;
pub const __NR_semctl: u32 = 66;
pub const __NR_shmdt: u32 = 67;
pub const __NR_msgget: u32 = 68;
pub const __NR_msgsnd: u32 = 69;
pub const __NR_msgrcv: u32 = 70;
pub const __NR_msgctl: u32 = 71;
pub const __NR_fcntl: u32 = 72;
pub const __NR_flock: u32 = 73;
pub const __NR_fsync: u32 = 74;
pub const __NR_fdatasync: u32 = 75;
pub const __NR_truncate: u32 = 76;
pub const __NR_ftruncate: u32 = 77;
pub const __NR_getdents: u32 = 78;
pub const __NR_getcwd: u32 = 79;
pub const __NR_chdir: u32 = 80;
pub const __NR_fchdir: u32 = 81;
pub const __NR_rename: u32 = 82;
pub const __NR_mkdir: u32 = 83;
pub const __NR_rmdir: u32 = 84;
pub const __NR_creat: u32 = 85;
pub const __NR_link: u32 = 86;
pub const __NR_unlink: u32 = 87;
pub const __NR_symlink: u32 = 88;
pub const __NR_readlink: u32 = 89;
pub const __NR_chmod: u32 = 90;
pub const __NR_fchmod: u32 = 91;
pub const __NR_chown: u32 = 92;
pub const __NR_fchown: u32 = 93;
pub const __NR_lchown: u32 = 94;
pub const __NR_umask: u32 = 95;
pub const __NR_gettimeofday: u32 = 96;
pub const __NR_getrlimit: u32 = 97;
pub const __NR_getrusage: u32 = 98;
pub const __NR_sysinfo: u32 = 99;
pub const __NR_times: u32 = 100;
pub const __NR_ptrace: u32 = 101;
pub const __NR_getuid: u32 = 102;
pub const __NR_syslog: u32 = 103;
pub const __NR_getgid: u32 = 104;
pub const __NR_setuid: u32 = 105;
pub const __NR_setgid: u32 = 106;
pub const __NR_geteuid: u32 = 107;
pub const __NR_getegid: u32 = 108;
pub const __NR_setpgid: u32 = 109;
pub const __NR_getppid: u32 = 110;
pub const __NR_getpgrp: u32 = 111;
pub const __NR_setsid: u32 = 112;
pub const __NR_setreuid: u32 = 113;
pub const __NR_setregid: u32 = 114;
pub const __NR_getgroups: u32 = 115;
pub const __NR_setgroups: u32 = 116;
pub const __NR_setresuid: u32 = 117;
pub const __NR_getresuid: u32 = 118;
pub const __NR_setresgid: u32 = 119;
pub const __NR_getresgid: u32 = 120;
pub const __NR_getpgid: u32 = 121;
pub const __NR_setfsuid: u32 = 122;
pub const __NR_setfsgid: u32 = 123;
pub const __NR_getsid: u32 = 124;
pub const __NR_capget: u32 = 125;
pub const __NR_capset: u32 = 126;
pub const __NR_rt_sigpending: u32 = 127;
pub const __NR_rt_sigtimedwait: u32 = 128;
pub const __NR_rt_sigqueueinfo: u32 = 129;
pub const __NR_rt_sigsuspend: u32 = 130;
pub const __NR_sigaltstack: u32 = 131;
pub const __NR_utime: u32 = 132;
pub const __NR_mknod: u32 = 133;
pub const __NR_uselib: u32 = 134;
pub const __NR_personality: u32 = 135;
pub const __NR_ustat: u32 = 136;
pub const __NR_statfs: u32 = 137;
pub const __NR_fstatfs: u32 = 138;
pub const __NR_sysfs: u32 = 139;
pub const __NR_getpriority: u32 = 140;
pub const __NR_setpriority: u32 = 141;
pub const __NR_sched_setparam: u32 = 142;
pub const __NR_sched_getparam: u32 = 143;
pub const __NR_sched_setscheduler: u32 = 144;
pub const __NR_sched_getscheduler: u32 = 145;
pub const __NR_sched_get_priority_max: u32 = 146;
pub const __NR_sched_get_priority_min: u32 = 147;
pub const __NR_sched_rr_get_interval: u32 = 148;
pub const __NR_mlock: u32 = 149;
pub const __NR_munlock: u32 = 150;
pub const __NR_mlockall: u32 = 151;
pub const __NR_munlockall: u32 = 152;
pub const __NR_vhangup: u32 = 153;
pub const __NR_modify_ldt: u32 = 154;
pub const __NR_pivot_root: u32 = 155;
pub const __NR__sysctl: u32 = 156;
pub const __NR_prctl: u32 = 157;
pub const __NR_arch_prctl: u32 = 158;
pub const __NR_adjtimex: u32 = 159;
pub const __NR_setrlimit: u32 = 160;
pub const __NR_chroot: u32 = 161;
pub const __NR_sync: u32 = 162;
pub const __NR_acct: u32 = 163;
pub const __NR_settimeofday: u32 = 164;
pub const __NR_mount: u32 = 165;
pub const __NR_umount2: u32 = 166;
pub const __NR_swapon: u32 = 167;
pub const __NR_swapoff: u32 = 168;
pub const __NR_reboot: u32 = 169;
pub const __NR_sethostname: u32 = 170;
pub const __NR_setdomainname: u32 = 171;
pub const __NR_iopl: u32 = 172;
pub const __NR_ioperm: u32 = 173;
pub const __NR_create_module: u32 = 174;
pub const __NR_init_module: u32 = 175;
pub const __NR_delete_module: u32 = 176;
pub const __NR_get_kernel_syms: u32 = 177;
pub const __NR_query_module: u32 = 178;
pub const __NR_quotactl: u32 = 179;
pub const __NR_nfsservctl: u32 = 180;
pub const __NR_getpmsg: u32 = 181;
pub const __NR_putpmsg: u32 = 182;
pub const __NR_afs_syscall: u32 = 183;
pub const __NR_tuxcall: u32 = 184;
pub const __NR_security: u32 = 185;
pub const __NR_gettid: u32 = 186;
pub const __NR_readahead: u32 = 187;
pub const __NR_setxattr: u32 = 188;
pub const __NR_lsetxattr: u32 = 189;
pub const __NR_fsetxattr: u32 = 190;
pub const __NR_getxattr: u32 = 191;
pub const __NR_lgetxattr: u32 = 192;
pub const __NR_fgetxattr: u32 = 193;
pub const __NR_listxattr: u32 = 194;
pub const __NR_llistxattr: u32 = 195;
pub const __NR_flistxattr: u32 = 196;
pub const __NR_removexattr: u32 = 197;
pub const __NR_lremovexattr: u32 = 198;
pub const __NR_fremovexattr: u32 = 199;
pub const __NR_tkill: u32 = 200;
pub const __NR_time: u32 = 201;
pub const __NR_futex: u32 = 202;
pub const __NR_sched_setaffinity: u32 = 203;
pub const __NR_sched_getaffinity: u32 = 204;
pub const __NR_set_thread_area: u32 = 205;
pub const __NR_io_setup: u32 = 206;
pub const __NR_io_destroy: u32 = 207;
pub const __NR_io_getevents: u32 = 208;
pub const __NR_io_submit: u32 = 209;
pub const __NR_io_cancel: u32 = 210;
pub const __NR_get_thread_area: u32 = 211;
pub const __NR_lookup_dcookie: u32 = 212;
pub const __NR_epoll_create: u32 = 213;
pub const __NR_epoll_ctl_old: u32 = 214;
pub const __NR_epoll_wait_old: u32 = 215;
pub const __NR_remap_file_pages: u32 = 216;
pub const __NR_getdents64: u32 = 217;
pub const __NR_set_tid_address: u32 = 218;
pub const __NR_restart_syscall: u32 = 219;
pub const __NR_semtimedop: u32 = 220;
pub const __NR_fadvise64: u32 = 221;
pub const __NR_timer_create: u32 = 222;
pub const __NR_timer_settime: u32 = 223;
pub const __NR_timer_gettime: u32 = 224;
pub const __NR_timer_getoverrun: u32 = 225;
pub const __NR_timer_delete: u32 = 226;
pub const __NR_clock_settime: u32 = 227;
pub const __NR_clock_gettime: u32 = 228;
pub const __NR_clock_getres: u32 = 229;
pub const __NR_clock_nanosleep: u32 = 230;
pub const __NR_exit_group: u32 = 231;
pub const __NR_epoll_wait: u32 = 232;
pub const __NR_epoll_ctl: u32 = 233;
pub const __NR_tgkill: u32 = 234;
pub const __NR_utimes: u32 = 235;
pub const __NR_vserver: u32 = 236;
pub const __NR_mbind: u32 = 237;
pub const __NR_set_mempolicy: u32 = 238;
pub const __NR_get_mempolicy: u32 = 239;
pub const __NR_mq_open: u32 = 240;
pub const __NR_mq_unlink: u32 = 241;
pub const __NR_mq_timedsend: u32 = 242;
pub const __NR_mq_timedreceive: u32 = 243;
pub const __NR_mq_notify: u32 = 244;
pub const __NR_mq_getsetattr: u32 = 245;
pub const __NR_kexec_load: u32 = 246;
pub const __NR_waitid: u32 = 247;
pub const __NR_add_key: u32 = 248;
pub const __NR_request_key: u32 = 249;
pub const __NR_keyctl: u32 = 250;
pub const __NR_ioprio_set: u32 = 251;
pub const __NR_ioprio_get: u32 = 252;
pub const __NR_inotify_init: u32 = 253;
pub const __NR_inotify_add_watch: u32 = 254;
pub const __NR_inotify_rm_watch: u32 = 255;
pub const __NR_migrate_pages: u32 = 256;
pub const __NR_openat: u32 = 257;
pub const __NR_mkdirat: u32 = 258;
pub const __NR_mknodat: u32 = 259;
pub const __NR_fchownat: u32 = 260;
pub const __NR_futimesat: u32 = 261;
pub const __NR_newfstatat: u32 = 262;
pub const __NR_unlinkat: u32 = 263;
pub const __NR_renameat: u32 = 264;
pub const __NR_linkat: u32 = 265;
pub const __NR_symlinkat: u32 = 266;
pub const __NR_readlinkat: u32 = 267;
pub const __NR_fchmodat: u32 = 268;
pub const __NR_faccessat: u32 = 269;
pub const __NR_pselect6: u32 = 270;
pub const __NR_ppoll: u32 = 271;
pub const __NR_unshare: u32 = 272;
pub const __NR_set_robust_list: u32 = 273;
pub const __NR_get_robust_list: u32 = 274;
pub const __NR_splice: u32 = 275;
pub const __NR_tee: u32 = 276;
pub const __NR_sync_file_range: u32 = 277;
pub const __NR_vmsplice: u32 = 278;
pub const __NR_move_pages: u32 = 279;
pub const __NR_utimensat: u32 = 280;
pub const __NR_epoll_pwait: u32 = 281;
pub const __NR_signalfd: u32 = 282;
pub const __NR_timerfd_create: u32 = 283;
pub const __NR_eventfd: u32 = 284;
pub const __NR_fallocate: u32 = 285;
pub const __NR_timerfd_settime: u32 = 286;
pub const __NR_timerfd_gettime: u32 = 287;
pub const __NR_accept4: u32 = 288;
pub const __NR_signalfd4: u32 = 289;
pub const __NR_eventfd2: u32 = 290;
pub const __NR_epoll_create1: u32 = 291;
pub const __NR_dup3: u32 = 292;
pub const __NR_pipe2: u32 = 293;
pub const __NR_inotify_init1: u32 = 294;
pub const __NR_preadv: u32 = 295;
pub const __NR_pwritev: u32 = 296;
pub const __NR_rt_tgsigqueueinfo: u32 = 297;
pub const __NR_perf_event_open: u32 = 298;
pub const __NR_recvmmsg: u32 = 299;
pub const __NR_fanotify_init: u32 = 300;
pub const __NR_fanotify_mark: u32 = 301;
pub const __NR_prlimit64: u32 = 302;
pub const __NR_name_to_handle_at: u32 = 303;
pub const __NR_open_by_handle_at: u32 = 304;
pub const __NR_clock_adjtime: u32 = 305;
pub const __NR_syncfs: u32 = 306;
pub const __NR_sendmmsg: u32 = 307;
pub const __NR_setns: u32 = 308;
pub const __NR_getcpu: u32 = 309;
pub const __NR_process_vm_readv: u32 = 310;
pub const __NR_process_vm_writev: u32 = 311;
pub const __NR_kcmp: u32 = 312;
pub const __NR_finit_module: u32 = 313;
pub const __NR_sched_setattr: u32 = 314;
pub const __NR_sched_getattr: u32 = 315;
pub const __NR_renameat2: u32 = 316;
pub const __NR_seccomp: u32 = 317;
pub const __NR_getrandom: u32 = 318;
pub const __NR_memfd_create: u32 = 319;
pub const __NR_kexec_file_load: u32 = 320;
pub const __NR_bpf: u32 = 321;
pub const __NR_execveat: u32 = 322;
pub const __NR_userfaultfd: u32 = 323;
pub const __NR_membarrier: u32 = 324;
pub const __NR_mlock2: u32 = 325;
pub const __NR_copy_file_range: u32 = 326;
pub const __NR_preadv2: u32 = 327;
pub const __NR_pwritev2: u32 = 328;
pub const __NR_pkey_mprotect: u32 = 329;
pub const __NR_pkey_alloc: u32 = 330;
pub const __NR_pkey_free: u32 = 331;
pub const __NR_statx: u32 = 332;
pub const __NR_io_pgetevents: u32 = 333;
pub const __NR_rseq: u32 = 334;
pub const __NR_pidfd_send_signal: u32 = 424;
pub const __NR_io_uring_setup: u32 = 425;
pub const __NR_io_uring_enter: u32 = 426;
pub const __NR_io_uring_register: u32 = 427;
pub const __NR_open_tree: u32 = 428;
pub const __NR_move_mount: u32 = 429;
pub const __NR_fsopen: u32 = 430;
pub const __NR_fsconfig: u32 = 431;
pub const __NR_fsmount: u32 = 432;
pub const __NR_fspick: u32 = 433;
pub const __NR_pidfd_open: u32 = 434;
pub const __NR_clone3: u32 = 435;
pub const __NR_close_range: u32 = 436;
pub const __NR_openat2: u32 = 437;
pub const __NR_pidfd_getfd: u32 = 438;
pub const __NR_faccessat2: u32 = 439;
pub const __NR_process_madvise: u32 = 440;
pub const __NR_epoll_pwait2: u32 = 441;
pub const __NR_mount_setattr: u32 = 442;
pub const __NR_quotactl_fd: u32 = 443;
pub const __NR_landlock_create_ruleset: u32 = 444;
pub const __NR_landlock_add_rule: u32 = 445;
pub const __NR_landlock_restrict_self: u32 = 446;
pub const __NR_memfd_secret: u32 = 447;
pub const __NR_process_mrelease: u32 = 448;
pub const __NR_futex_waitv: u32 = 449;
pub const __NR_set_mempolicy_home_node: u32 = 450;
pub const __NR_syscalls: u32 = 451;
pub const __NR_x32_rt_sigaction: u32 = 512;
pub const __NR_x32_rt_sigreturn: u32 = 513;
pub const __NR_x32_ioctl: u32 = 514;
pub const __NR_x32_readv: u32 = 515;
pub const __NR_x32_writev: u32 = 516;
pub const __NR_x32_recvfrom: u32 = 517;
pub const __NR_x32_sendmsg: u32 = 518;
pub const __NR_x32_recvmsg: u32 = 519;
pub const __NR_x32_execve: u32 = 520;
pub const __NR_x32_ptrace: u32 = 521;
pub const __NR_x32_rt_sigpending: u32 = 522;
pub const __NR_x32_rt_sigtimedwait: u32 = 523;
pub const __NR_x32_rt_sigqueueinfo: u32 = 524;
pub const __NR_x32_sigaltstack: u32 = 525;
pub const __NR_x32_timer_create: u32 = 526;
pub const __NR_x32_mq_notify: u32 = 527;
pub const __NR_x32_kexec_load: u32 = 528;
pub const __NR_x32_waitid: u32 = 529;
pub const __NR_x32_set_robust_list: u32 = 530;
pub const __NR_x32_get_robust_list: u32 = 531;
pub const __NR_x32_vmsplice: u32 = 532;
pub const __NR_x32_move_pages: u32 = 533;
pub const __NR_x32_preadv: u32 = 534;
pub const __NR_x32_pwritev: u32 = 535;
pub const __NR_x32_rt_tgsigqueueinfo: u32 = 536;
pub const __NR_x32_recvmmsg: u32 = 537;
pub const __NR_x32_sendmmsg: u32 = 538;
pub const __NR_x32_process_vm_readv: u32 = 539;
pub const __NR_x32_process_vm_writev: u32 = 540;
pub const __NR_x32_setsockopt: u32 = 541;
pub const __NR_x32_getsockopt: u32 = 542;
pub const __NR_x32_io_setup: u32 = 543;
pub const __NR_x32_io_submit: u32 = 544;
pub const __NR_x32_execveat: u32 = 545;
pub const __NR_x32_preadv2: u32 = 546;
pub const __NR_x32_pwritev2: u32 = 547;
pub const __NR_x32_syscalls: u32 = 548;
pub const __NR_ia32_restart_syscall: u32 = 0;
pub const __NR_ia32_exit: u32 = 1;
pub const __NR_ia32_fork: u32 = 2;
pub const __NR_ia32_read: u32 = 3;
pub const __NR_ia32_write: u32 = 4;
pub const __NR_ia32_open: u32 = 5;
pub const __NR_ia32_close: u32 = 6;
pub const __NR_ia32_waitpid: u32 = 7;
pub const __NR_ia32_creat: u32 = 8;
pub const __NR_ia32_link: u32 = 9;
pub const __NR_ia32_unlink: u32 = 10;
pub const __NR_ia32_execve: u32 = 11;
pub const __NR_ia32_chdir: u32 = 12;
pub const __NR_ia32_time: u32 = 13;
pub const __NR_ia32_mknod: u32 = 14;
pub const __NR_ia32_chmod: u32 = 15;
pub const __NR_ia32_lchown: u32 = 16;
pub const __NR_ia32_break: u32 = 17;
pub const __NR_ia32_oldstat: u32 = 18;
pub const __NR_ia32_lseek: u32 = 19;
pub const __NR_ia32_getpid: u32 = 20;
pub const __NR_ia32_mount: u32 = 21;
pub const __NR_ia32_umount: u32 = 22;
pub const __NR_ia32_setuid: u32 = 23;
pub const __NR_ia32_getuid: u32 = 24;
pub const __NR_ia32_stime: u32 = 25;
pub const __NR_ia32_ptrace: u32 = 26;
pub const __NR_ia32_alarm: u32 = 27;
pub const __NR_ia32_oldfstat: u32 = 28;
pub const __NR_ia32_pause: u32 = 29;
pub const __NR_ia32_utime: u32 = 30;
pub const __NR_ia32_stty: u32 = 31;
pub const __NR_ia32_gtty: u32 = 32;
pub const __NR_ia32_access: u32 = 33;
pub const __NR_ia32_nice: u32 = 34;
pub const __NR_ia32_ftime: u32 = 35;
pub const __NR_ia32_sync: u32 = 36;
pub const __NR_ia32_kill: u32 = 37;
pub const __NR_ia32_rename: u32 = 38;
pub const __NR_ia32_mkdir: u32 = 39;
pub const __NR_ia32_rmdir: u32 = 40;
pub const __NR_ia32_dup: u32 = 41;
pub const __NR_ia32_pipe: u32 = 42;
pub const __NR_ia32_times: u32 = 43;
pub const __NR_ia32_prof: u32 = 44;
pub const __NR_ia32_brk: u32 = 45;
pub const __NR_ia32_setgid: u32 = 46;
pub const __NR_ia32_getgid: u32 = 47;
pub const __NR_ia32_signal: u32 = 48;
pub const __NR_ia32_geteuid: u32 = 49;
pub const __NR_ia32_getegid: u32 = 50;
pub const __NR_ia32_acct: u32 = 51;
pub const __NR_ia32_umount2: u32 = 52;
pub const __NR_ia32_lock: u32 = 53;
pub const __NR_ia32_ioctl: u32 = 54;
pub const __NR_ia32_fcntl: u32 = 55;
pub const __NR_ia32_mpx: u32 = 56;
pub const __NR_ia32_setpgid: u32 = 57;
pub const __NR_ia32_ulimit: u32 = 58;
pub const __NR_ia32_oldolduname: u32 = 59;
pub const __NR_ia32_umask: u32 = 60;
pub const __NR_ia32_chroot: u32 = 61;
pub const __NR_ia32_ustat: u32 = 62;
pub const __NR_ia32_dup2: u32 = 63;
pub const __NR_ia32_getppid: u32 = 64;
pub const __NR_ia32_getpgrp: u32 = 65;
pub const __NR_ia32_setsid: u32 = 66;
pub const __NR_ia32_sigaction: u32 = 67;
pub const __NR_ia32_sgetmask: u32 = 68;
pub const __NR_ia32_ssetmask: u32 = 69;
pub const __NR_ia32_setreuid: u32 = 70;
pub const __NR_ia32_setregid: u32 = 71;
pub const __NR_ia32_sigsuspend: u32 = 72;
pub const __NR_ia32_sigpending: u32 = 73;
pub const __NR_ia32_sethostname: u32 = 74;
pub const __NR_ia32_setrlimit: u32 = 75;
pub const __NR_ia32_getrlimit: u32 = 76;
pub const __NR_ia32_getrusage: u32 = 77;
pub const __NR_ia32_gettimeofday: u32 = 78;
pub const __NR_ia32_settimeofday: u32 = 79;
pub const __NR_ia32_getgroups: u32 = 80;
pub const __NR_ia32_setgroups: u32 = 81;
pub const __NR_ia32_select: u32 = 82;
pub const __NR_ia32_symlink: u32 = 83;
pub const __NR_ia32_oldlstat: u32 = 84;
pub const __NR_ia32_readlink: u32 = 85;
pub const __NR_ia32_uselib: u32 = 86;
pub const __NR_ia32_swapon: u32 = 87;
pub const __NR_ia32_reboot: u32 = 88;
pub const __NR_ia32_readdir: u32 = 89;
pub const __NR_ia32_mmap: u32 = 90;
pub const __NR_ia32_munmap: u32 = 91;
pub const __NR_ia32_truncate: u32 = 92;
pub const __NR_ia32_ftruncate: u32 = 93;
pub const __NR_ia32_fchmod: u32 = 94;
pub const __NR_ia32_fchown: u32 = 95;
pub const __NR_ia32_getpriority: u32 = 96;
pub const __NR_ia32_setpriority: u32 = 97;
pub const __NR_ia32_profil: u32 = 98;
pub const __NR_ia32_statfs: u32 = 99;
pub const __NR_ia32_fstatfs: u32 = 100;
pub const __NR_ia32_ioperm: u32 = 101;
pub const __NR_ia32_socketcall: u32 = 102;
pub const __NR_ia32_syslog: u32 = 103;
pub const __NR_ia32_setitimer: u32 = 104;
pub const __NR_ia32_getitimer: u32 = 105;
pub const __NR_ia32_stat: u32 = 106;
pub const __NR_ia32_lstat: u32 = 107;
pub const __NR_ia32_fstat: u32 = 108;
pub const __NR_ia32_olduname: u32 = 109;
pub const __NR_ia32_iopl: u32 = 110;
pub const __NR_ia32_vhangup: u32 = 111;
pub const __NR_ia32_idle: u32 = 112;
pub const __NR_ia32_vm86old: u32 = 113;
pub const __NR_ia32_wait4: u32 = 114;
pub const __NR_ia32_swapoff: u32 = 115;
pub const __NR_ia32_sysinfo: u32 = 116;
pub const __NR_ia32_ipc: u32 = 117;
pub const __NR_ia32_fsync: u32 = 118;
pub const __NR_ia32_sigreturn: u32 = 119;
pub const __NR_ia32_clone: u32 = 120;
pub const __NR_ia32_setdomainname: u32 = 121;
pub const __NR_ia32_uname: u32 = 122;
pub const __NR_ia32_modify_ldt: u32 = 123;
pub const __NR_ia32_adjtimex: u32 = 124;
pub const __NR_ia32_mprotect: u32 = 125;
pub const __NR_ia32_sigprocmask: u32 = 126;
pub const __NR_ia32_create_module: u32 = 127;
pub const __NR_ia32_init_module: u32 = 128;
pub const __NR_ia32_delete_module: u32 = 129;
pub const __NR_ia32_get_kernel_syms: u32 = 130;
pub const __NR_ia32_quotactl: u32 = 131;
pub const __NR_ia32_getpgid: u32 = 132;
pub const __NR_ia32_fchdir: u32 = 133;
pub const __NR_ia32_bdflush: u32 = 134;
pub const __NR_ia32_sysfs: u32 = 135;
pub const __NR_ia32_personality: u32 = 136;
pub const __NR_ia32_afs_syscall: u32 = 137;
pub const __NR_ia32_setfsuid: u32 = 138;
pub const __NR_ia32_setfsgid: u32 = 139;
pub const __NR_ia32__llseek: u32 = 140;
pub const __NR_ia32_getdents: u32 = 141;
pub const __NR_ia32__newselect: u32 = 142;
pub const __NR_ia32_flock: u32 = 143;
pub const __NR_ia32_msync: u32 = 144;
pub const __NR_ia32_readv: u32 = 145;
pub const __NR_ia32_writev: u32 = 146;
pub const __NR_ia32_getsid: u32 = 147;
pub const __NR_ia32_fdatasync: u32 = 148;
pub const __NR_ia32__sysctl: u32 = 149;
pub const __NR_ia32_mlock: u32 = 150;
pub const __NR_ia32_munlock: u32 = 151;
pub const __NR_ia32_mlockall: u32 = 152;
pub const __NR_ia32_munlockall: u32 = 153;
pub const __NR_ia32_sched_setparam: u32 = 154;
pub const __NR_ia32_sched_getparam: u32 = 155;
pub const __NR_ia32_sched_setscheduler: u32 = 156;
pub const __NR_ia32_sched_getscheduler: u32 = 157;
pub const __NR_ia32_sched_yield: u32 = 158;
pub const __NR_ia32_sched_get_priority_max: u32 = 159;
pub const __NR_ia32_sched_get_priority_min: u32 = 160;
pub const __NR_ia32_sched_rr_get_interval: u32 = 161;
pub const __NR_ia32_nanosleep: u32 = 162;
pub const __NR_ia32_mremap: u32 = 163;
pub const __NR_ia32_setresuid: u32 = 164;
pub const __NR_ia32_getresuid: u32 = 165;
pub const __NR_ia32_vm86: u32 = 166;
pub const __NR_ia32_query_module: u32 = 167;
pub const __NR_ia32_poll: u32 = 168;
pub const __NR_ia32_nfsservctl: u32 = 169;
pub const __NR_ia32_setresgid: u32 = 170;
pub const __NR_ia32_getresgid: u32 = 171;
pub const __NR_ia32_prctl: u32 = 172;
pub const __NR_ia32_rt_sigreturn: u32 = 173;
pub const __NR_ia32_rt_sigaction: u32 = 174;
pub const __NR_ia32_rt_sigprocmask: u32 = 175;
pub const __NR_ia32_rt_sigpending: u32 = 176;
pub const __NR_ia32_rt_sigtimedwait: u32 = 177;
pub const __NR_ia32_rt_sigqueueinfo: u32 = 178;
pub const __NR_ia32_rt_sigsuspend: u32 = 179;
pub const __NR_ia32_pread64: u32 = 180;
pub const __NR_ia32_pwrite64: u32 = 181;
pub const __NR_ia32_chown: u32 = 182;
pub const __NR_ia32_getcwd: u32 = 183;
pub const __NR_ia32_capget: u32 = 184;
pub const __NR_ia32_capset: u32 = 185;
pub const __NR_ia32_sigaltstack: u32 = 186;
pub const __NR_ia32_sendfile: u32 = 187;
pub const __NR_ia32_getpmsg: u32 = 188;
pub const __NR_ia32_putpmsg: u32 = 189;
pub const __NR_ia32_vfork: u32 = 190;
pub const __NR_ia32_ugetrlimit: u32 = 191;
pub const __NR_ia32_mmap2: u32 = 192;
pub const __NR_ia32_truncate64: u32 = 193;
pub const __NR_ia32_ftruncate64: u32 = 194;
pub const __NR_ia32_stat64: u32 = 195;
pub const __NR_ia32_lstat64: u32 = 196;
pub const __NR_ia32_fstat64: u32 = 197;
pub const __NR_ia32_lchown32: u32 = 198;
pub const __NR_ia32_getuid32: u32 = 199;
pub const __NR_ia32_getgid32: u32 = 200;
pub const __NR_ia32_geteuid32: u32 = 201;
pub const __NR_ia32_getegid32: u32 = 202;
pub const __NR_ia32_setreuid32: u32 = 203;
pub const __NR_ia32_setregid32: u32 = 204;
pub const __NR_ia32_getgroups32: u32 = 205;
pub const __NR_ia32_setgroups32: u32 = 206;
pub const __NR_ia32_fchown32: u32 = 207;
pub const __NR_ia32_setresuid32: u32 = 208;
pub const __NR_ia32_getresuid32: u32 = 209;
pub const __NR_ia32_setresgid32: u32 = 210;
pub const __NR_ia32_getresgid32: u32 = 211;
pub const __NR_ia32_chown32: u32 = 212;
pub const __NR_ia32_setuid32: u32 = 213;
pub const __NR_ia32_setgid32: u32 = 214;
pub const __NR_ia32_setfsuid32: u32 = 215;
pub const __NR_ia32_setfsgid32: u32 = 216;
pub const __NR_ia32_pivot_root: u32 = 217;
pub const __NR_ia32_mincore: u32 = 218;
pub const __NR_ia32_madvise: u32 = 219;
pub const __NR_ia32_getdents64: u32 = 220;
pub const __NR_ia32_fcntl64: u32 = 221;
pub const __NR_ia32_gettid: u32 = 224;
pub const __NR_ia32_readahead: u32 = 225;
pub const __NR_ia32_setxattr: u32 = 226;
pub const __NR_ia32_lsetxattr: u32 = 227;
pub const __NR_ia32_fsetxattr: u32 = 228;
pub const __NR_ia32_getxattr: u32 = 229;
pub const __NR_ia32_lgetxattr: u32 = 230;
pub const __NR_ia32_fgetxattr: u32 = 231;
pub const __NR_ia32_listxattr: u32 = 232;
pub const __NR_ia32_llistxattr: u32 = 233;
pub const __NR_ia32_flistxattr: u32 = 234;
pub const __NR_ia32_removexattr: u32 = 235;
pub const __NR_ia32_lremovexattr: u32 = 236;
pub const __NR_ia32_fremovexattr: u32 = 237;
pub const __NR_ia32_tkill: u32 = 238;
pub const __NR_ia32_sendfile64: u32 = 239;
pub const __NR_ia32_futex: u32 = 240;
pub const __NR_ia32_sched_setaffinity: u32 = 241;
pub const __NR_ia32_sched_getaffinity: u32 = 242;
pub const __NR_ia32_set_thread_area: u32 = 243;
pub const __NR_ia32_get_thread_area: u32 = 244;
pub const __NR_ia32_io_setup: u32 = 245;
pub const __NR_ia32_io_destroy: u32 = 246;
pub const __NR_ia32_io_getevents: u32 = 247;
pub const __NR_ia32_io_submit: u32 = 248;
pub const __NR_ia32_io_cancel: u32 = 249;
pub const __NR_ia32_fadvise64: u32 = 250;
pub const __NR_ia32_exit_group: u32 = 252;
pub const __NR_ia32_lookup_dcookie: u32 = 253;
pub const __NR_ia32_epoll_create: u32 = 254;
pub const __NR_ia32_epoll_ctl: u32 = 255;
pub const __NR_ia32_epoll_wait: u32 = 256;
pub const __NR_ia32_remap_file_pages: u32 = 257;
pub const __NR_ia32_set_tid_address: u32 = 258;
pub const __NR_ia32_timer_create: u32 = 259;
pub const __NR_ia32_timer_settime: u32 = 260;
pub const __NR_ia32_timer_gettime: u32 = 261;
pub const __NR_ia32_timer_getoverrun: u32 = 262;
pub const __NR_ia32_timer_delete: u32 = 263;
pub const __NR_ia32_clock_settime: u32 = 264;
pub const __NR_ia32_clock_gettime: u32 = 265;
pub const __NR_ia32_clock_getres: u32 = 266;
pub const __NR_ia32_clock_nanosleep: u32 = 267;
pub const __NR_ia32_statfs64: u32 = 268;
pub const __NR_ia32_fstatfs64: u32 = 269;
pub const __NR_ia32_tgkill: u32 = 270;
pub const __NR_ia32_utimes: u32 = 271;
pub const __NR_ia32_fadvise64_64: u32 = 272;
pub const __NR_ia32_vserver: u32 = 273;
pub const __NR_ia32_mbind: u32 = 274;
pub const __NR_ia32_get_mempolicy: u32 = 275;
pub const __NR_ia32_set_mempolicy: u32 = 276;
pub const __NR_ia32_mq_open: u32 = 277;
pub const __NR_ia32_mq_unlink: u32 = 278;
pub const __NR_ia32_mq_timedsend: u32 = 279;
pub const __NR_ia32_mq_timedreceive: u32 = 280;
pub const __NR_ia32_mq_notify: u32 = 281;
pub const __NR_ia32_mq_getsetattr: u32 = 282;
pub const __NR_ia32_kexec_load: u32 = 283;
pub const __NR_ia32_waitid: u32 = 284;
pub const __NR_ia32_add_key: u32 = 286;
pub const __NR_ia32_request_key: u32 = 287;
pub const __NR_ia32_keyctl: u32 = 288;
pub const __NR_ia32_ioprio_set: u32 = 289;
pub const __NR_ia32_ioprio_get: u32 = 290;
pub const __NR_ia32_inotify_init: u32 = 291;
pub const __NR_ia32_inotify_add_watch: u32 = 292;
pub const __NR_ia32_inotify_rm_watch: u32 = 293;
pub const __NR_ia32_migrate_pages: u32 = 294;
pub const __NR_ia32_openat: u32 = 295;
pub const __NR_ia32_mkdirat: u32 = 296;
pub const __NR_ia32_mknodat: u32 = 297;
pub const __NR_ia32_fchownat: u32 = 298;
pub const __NR_ia32_futimesat: u32 = 299;
pub const __NR_ia32_fstatat64: u32 = 300;
pub const __NR_ia32_unlinkat: u32 = 301;
pub const __NR_ia32_renameat: u32 = 302;
pub const __NR_ia32_linkat: u32 = 303;
pub const __NR_ia32_symlinkat: u32 = 304;
pub const __NR_ia32_readlinkat: u32 = 305;
pub const __NR_ia32_fchmodat: u32 = 306;
pub const __NR_ia32_faccessat: u32 = 307;
pub const __NR_ia32_pselect6: u32 = 308;
pub const __NR_ia32_ppoll: u32 = 309;
pub const __NR_ia32_unshare: u32 = 310;
pub const __NR_ia32_set_robust_list: u32 = 311;
pub const __NR_ia32_get_robust_list: u32 = 312;
pub const __NR_ia32_splice: u32 = 313;
pub const __NR_ia32_sync_file_range: u32 = 314;
pub const __NR_ia32_tee: u32 = 315;
pub const __NR_ia32_vmsplice: u32 = 316;
pub const __NR_ia32_move_pages: u32 = 317;
pub const __NR_ia32_getcpu: u32 = 318;
pub const __NR_ia32_epoll_pwait: u32 = 319;
pub const __NR_ia32_utimensat: u32 = 320;
pub const __NR_ia32_signalfd: u32 = 321;
pub const __NR_ia32_timerfd_create: u32 = 322;
pub const __NR_ia32_eventfd: u32 = 323;
pub const __NR_ia32_fallocate: u32 = 324;
pub const __NR_ia32_timerfd_settime: u32 = 325;
pub const __NR_ia32_timerfd_gettime: u32 = 326;
pub const __NR_ia32_signalfd4: u32 = 327;
pub const __NR_ia32_eventfd2: u32 = 328;
pub const __NR_ia32_epoll_create1: u32 = 329;
pub const __NR_ia32_dup3: u32 = 330;
pub const __NR_ia32_pipe2: u32 = 331;
pub const __NR_ia32_inotify_init1: u32 = 332;
pub const __NR_ia32_preadv: u32 = 333;
pub const __NR_ia32_pwritev: u32 = 334;
pub const __NR_ia32_rt_tgsigqueueinfo: u32 = 335;
pub const __NR_ia32_perf_event_open: u32 = 336;
pub const __NR_ia32_recvmmsg: u32 = 337;
pub const __NR_ia32_fanotify_init: u32 = 338;
pub const __NR_ia32_fanotify_mark: u32 = 339;
pub const __NR_ia32_prlimit64: u32 = 340;
pub const __NR_ia32_name_to_handle_at: u32 = 341;
pub const __NR_ia32_open_by_handle_at: u32 = 342;
pub const __NR_ia32_clock_adjtime: u32 = 343;
pub const __NR_ia32_syncfs: u32 = 344;
pub const __NR_ia32_sendmmsg: u32 = 345;
pub const __NR_ia32_setns: u32 = 346;
pub const __NR_ia32_process_vm_readv: u32 = 347;
pub const __NR_ia32_process_vm_writev: u32 = 348;
pub const __NR_ia32_kcmp: u32 = 349;
pub const __NR_ia32_finit_module: u32 = 350;
pub const __NR_ia32_sched_setattr: u32 = 351;
pub const __NR_ia32_sched_getattr: u32 = 352;
pub const __NR_ia32_renameat2: u32 = 353;
pub const __NR_ia32_seccomp: u32 = 354;
pub const __NR_ia32_getrandom: u32 = 355;
pub const __NR_ia32_memfd_create: u32 = 356;
pub const __NR_ia32_bpf: u32 = 357;
pub const __NR_ia32_execveat: u32 = 358;
pub const __NR_ia32_socket: u32 = 359;
pub const __NR_ia32_socketpair: u32 = 360;
pub const __NR_ia32_bind: u32 = 361;
pub const __NR_ia32_connect: u32 = 362;
pub const __NR_ia32_listen: u32 = 363;
pub const __NR_ia32_accept4: u32 = 364;
pub const __NR_ia32_getsockopt: u32 = 365;
pub const __NR_ia32_setsockopt: u32 = 366;
pub const __NR_ia32_getsockname: u32 = 367;
pub const __NR_ia32_getpeername: u32 = 368;
pub const __NR_ia32_sendto: u32 = 369;
pub const __NR_ia32_sendmsg: u32 = 370;
pub const __NR_ia32_recvfrom: u32 = 371;
pub const __NR_ia32_recvmsg: u32 = 372;
pub const __NR_ia32_shutdown: u32 = 373;
pub const __NR_ia32_userfaultfd: u32 = 374;
pub const __NR_ia32_membarrier: u32 = 375;
pub const __NR_ia32_mlock2: u32 = 376;
pub const __NR_ia32_copy_file_range: u32 = 377;
pub const __NR_ia32_preadv2: u32 = 378;
pub const __NR_ia32_pwritev2: u32 = 379;
pub const __NR_ia32_pkey_mprotect: u32 = 380;
pub const __NR_ia32_pkey_alloc: u32 = 381;
pub const __NR_ia32_pkey_free: u32 = 382;
pub const __NR_ia32_statx: u32 = 383;
pub const __NR_ia32_arch_prctl: u32 = 384;
pub const __NR_ia32_io_pgetevents: u32 = 385;
pub const __NR_ia32_rseq: u32 = 386;
pub const __NR_ia32_semget: u32 = 393;
pub const __NR_ia32_semctl: u32 = 394;
pub const __NR_ia32_shmget: u32 = 395;
pub const __NR_ia32_shmctl: u32 = 396;
pub const __NR_ia32_shmat: u32 = 397;
pub const __NR_ia32_shmdt: u32 = 398;
pub const __NR_ia32_msgget: u32 = 399;
pub const __NR_ia32_msgsnd: u32 = 400;
pub const __NR_ia32_msgrcv: u32 = 401;
pub const __NR_ia32_msgctl: u32 = 402;
pub const __NR_ia32_clock_gettime64: u32 = 403;
pub const __NR_ia32_clock_settime64: u32 = 404;
pub const __NR_ia32_clock_adjtime64: u32 = 405;
pub const __NR_ia32_clock_getres_time64: u32 = 406;
pub const __NR_ia32_clock_nanosleep_time64: u32 = 407;
pub const __NR_ia32_timer_gettime64: u32 = 408;
pub const __NR_ia32_timer_settime64: u32 = 409;
pub const __NR_ia32_timerfd_gettime64: u32 = 410;
pub const __NR_ia32_timerfd_settime64: u32 = 411;
pub const __NR_ia32_utimensat_time64: u32 = 412;
pub const __NR_ia32_pselect6_time64: u32 = 413;
pub const __NR_ia32_ppoll_time64: u32 = 414;
pub const __NR_ia32_io_pgetevents_time64: u32 = 416;
pub const __NR_ia32_recvmmsg_time64: u32 = 417;
pub const __NR_ia32_mq_timedsend_time64: u32 = 418;
pub const __NR_ia32_mq_timedreceive_time64: u32 = 419;
pub const __NR_ia32_semtimedop_time64: u32 = 420;
pub const __NR_ia32_rt_sigtimedwait_time64: u32 = 421;
pub const __NR_ia32_futex_time64: u32 = 422;
pub const __NR_ia32_sched_rr_get_interval_time64: u32 = 423;
pub const __NR_ia32_pidfd_send_signal: u32 = 424;
pub const __NR_ia32_io_uring_setup: u32 = 425;
pub const __NR_ia32_io_uring_enter: u32 = 426;
pub const __NR_ia32_io_uring_register: u32 = 427;
pub const __NR_ia32_open_tree: u32 = 428;
pub const __NR_ia32_move_mount: u32 = 429;
pub const __NR_ia32_fsopen: u32 = 430;
pub const __NR_ia32_fsconfig: u32 = 431;
pub const __NR_ia32_fsmount: u32 = 432;
pub const __NR_ia32_fspick: u32 = 433;
pub const __NR_ia32_pidfd_open: u32 = 434;
pub const __NR_ia32_clone3: u32 = 435;
pub const __NR_ia32_close_range: u32 = 436;
pub const __NR_ia32_openat2: u32 = 437;
pub const __NR_ia32_pidfd_getfd: u32 = 438;
pub const __NR_ia32_faccessat2: u32 = 439;
pub const __NR_ia32_process_madvise: u32 = 440;
pub const __NR_ia32_epoll_pwait2: u32 = 441;
pub const __NR_ia32_mount_setattr: u32 = 442;
pub const __NR_ia32_quotactl_fd: u32 = 443;
pub const __NR_ia32_landlock_create_ruleset: u32 = 444;
pub const __NR_ia32_landlock_add_rule: u32 = 445;
pub const __NR_ia32_landlock_restrict_self: u32 = 446;
pub const __NR_ia32_memfd_secret: u32 = 447;
pub const __NR_ia32_process_mrelease: u32 = 448;
pub const __NR_ia32_futex_waitv: u32 = 449;
pub const __NR_ia32_set_mempolicy_home_node: u32 = 450;
pub const __NR_ia32_syscalls: u32 = 451;
pub const X32_NR_syscalls: u32 = 548;
pub const IA32_NR_syscalls: u32 = 451;
pub const NR_syscalls: u32 = 451;
pub const __NR_seccomp_read_32: u32 = 3;
pub const __NR_seccomp_write_32: u32 = 4;
pub const __NR_seccomp_exit_32: u32 = 1;
pub const __NR_seccomp_sigreturn_32: u32 = 119;
pub const SECCOMP_ARCH_NATIVE_NR: u32 = 451;
pub const SECCOMP_ARCH_NATIVE_NAME: &'static [u8; 7usize] = b"x86_64\0";
pub const SECCOMP_ARCH_COMPAT_NR: u32 = 451;
pub const SECCOMP_ARCH_COMPAT_NAME: &'static [u8; 5usize] = b"ia32\0";
pub const __NR_seccomp_read: u32 = 0;
pub const __NR_seccomp_write: u32 = 1;
pub const __NR_seccomp_exit: u32 = 60;
pub const __NR_seccomp_sigreturn: u32 = 15;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_BOTH: i32 = -2;
pub const RUSAGE_THREAD: u32 = 1;
pub const RLIM64_INFINITY: i32 = -1;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const _STK_LIM: u32 = 8388608;
pub const MLOCK_LIMIT: u32 = 8388608;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_NPROC: u32 = 6;
pub const RLIMIT_NOFILE: u32 = 7;
pub const RLIMIT_MEMLOCK: u32 = 8;
pub const RLIMIT_AS: u32 = 9;
pub const RLIMIT_LOCKS: u32 = 10;
pub const RLIMIT_SIGPENDING: u32 = 11;
pub const RLIMIT_MSGQUEUE: u32 = 12;
pub const RLIMIT_NICE: u32 = 13;
pub const RLIMIT_RTPRIO: u32 = 14;
pub const RLIMIT_RTTIME: u32 = 15;
pub const RLIM_NLIMITS: u32 = 16;
pub const RLIM_INFINITY: i32 = -1;
pub const MAX_NICE: u32 = 19;
pub const MIN_NICE: i32 = -20;
pub const NICE_WIDTH: u32 = 40;
pub const MAX_RT_PRIO: u32 = 100;
pub const MAX_PRIO: u32 = 140;
pub const DEFAULT_PRIO: u32 = 120;
pub const _NSIG: u32 = 64;
pub const _NSIG_BPW: u32 = 64;
pub const _NSIG_WORDS: u32 = 1;
pub const SA_IA32_ABI: u32 = 33554432;
pub const SA_X32_ABI: u32 = 16777216;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGBUS: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGUSR1: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGUSR2: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGSTKFLT: u32 = 16;
pub const SIGCHLD: u32 = 17;
pub const SIGCONT: u32 = 18;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGURG: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGPOLL: u32 = 29;
pub const SIGPWR: u32 = 30;
pub const SIGSYS: u32 = 31;
pub const SIGUNUSED: u32 = 31;
pub const SIGRTMIN: u32 = 32;
pub const SIGRTMAX: u32 = 64;
pub const SA_RESTORER: u32 = 67108864;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_UNSUPPORTED: u32 = 1024;
pub const SA_EXPOSE_TAGBITS: u32 = 2048;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const SI_MAX_SIZE: u32 = 128;
pub const SI_USER: u32 = 0;
pub const SI_KERNEL: u32 = 128;
pub const SI_QUEUE: i32 = -1;
pub const SI_TIMER: i32 = -2;
pub const SI_MESGQ: i32 = -3;
pub const SI_ASYNCIO: i32 = -4;
pub const SI_SIGIO: i32 = -5;
pub const SI_TKILL: i32 = -6;
pub const SI_DETHREAD: i32 = -7;
pub const SI_ASYNCNL: i32 = -60;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLOPN: u32 = 2;
pub const ILL_ILLADR: u32 = 3;
pub const ILL_ILLTRP: u32 = 4;
pub const ILL_PRVOPC: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const ILL_BADIADDR: u32 = 9;
pub const __ILL_BREAK: u32 = 10;
pub const __ILL_BNDMOD: u32 = 11;
pub const NSIGILL: u32 = 11;
pub const FPE_INTDIV: u32 = 1;
pub const FPE_INTOVF: u32 = 2;
pub const FPE_FLTDIV: u32 = 3;
pub const FPE_FLTOVF: u32 = 4;
pub const FPE_FLTUND: u32 = 5;
pub const FPE_FLTRES: u32 = 6;
pub const FPE_FLTINV: u32 = 7;
pub const FPE_FLTSUB: u32 = 8;
pub const __FPE_DECOVF: u32 = 9;
pub const __FPE_DECDIV: u32 = 10;
pub const __FPE_DECERR: u32 = 11;
pub const __FPE_INVASC: u32 = 12;
pub const __FPE_INVDEC: u32 = 13;
pub const FPE_FLTUNK: u32 = 14;
pub const FPE_CONDTRAP: u32 = 15;
pub const NSIGFPE: u32 = 15;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const SEGV_BNDERR: u32 = 3;
pub const SEGV_PKUERR: u32 = 4;
pub const SEGV_ACCADI: u32 = 5;
pub const SEGV_ADIDERR: u32 = 6;
pub const SEGV_ADIPERR: u32 = 7;
pub const SEGV_MTEAERR: u32 = 8;
pub const SEGV_MTESERR: u32 = 9;
pub const NSIGSEGV: u32 = 9;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const BUS_MCEERR_AR: u32 = 4;
pub const BUS_MCEERR_AO: u32 = 5;
pub const NSIGBUS: u32 = 5;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const TRAP_BRANCH: u32 = 3;
pub const TRAP_HWBKPT: u32 = 4;
pub const TRAP_UNK: u32 = 5;
pub const TRAP_PERF: u32 = 6;
pub const NSIGTRAP: u32 = 6;
pub const TRAP_PERF_FLAG_ASYNC: u32 = 1;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const NSIGCHLD: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const NSIGPOLL: u32 = 6;
pub const SYS_SECCOMP: u32 = 1;
pub const SYS_USER_DISPATCH: u32 = 2;
pub const NSIGSYS: u32 = 2;
pub const EMT_TAGOVF: u32 = 1;
pub const NSIGEMT: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 0;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_THREAD: u32 = 2;
pub const SIGEV_THREAD_ID: u32 = 4;
pub const SIGEV_MAX_SIZE: u32 = 64;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SS_AUTODISARM: u32 = 2147483648;
pub const SS_FLAG_BITS: u32 = 2147483648;
pub const SIGQUEUE_PREALLOC: u32 = 1;
pub const SA_IMMUTABLE: u32 = 8388608;
pub const __ARCH_UAPI_SA_FLAGS: u32 = 67108864;
pub const UAPI_SA_FLAGS: u32 = 3690989575;
pub const ALARMTIMER_STATE_INACTIVE: u32 = 0;
pub const ALARMTIMER_STATE_ENQUEUED: u32 = 1;
pub const CPUCLOCK_PERTHREAD_MASK: u32 = 4;
pub const CPUCLOCK_CLOCK_MASK: u32 = 3;
pub const CPUCLOCK_PROF: u32 = 0;
pub const CPUCLOCK_VIRT: u32 = 1;
pub const CPUCLOCK_SCHED: u32 = 2;
pub const CPUCLOCK_MAX: u32 = 3;
pub const CLOCKFD: u32 = 3;
pub const CLOCKFD_MASK: u32 = 7;
pub const REQUEUE_PENDING: u32 = 1;
pub const MAX_DA_NAME_LEN: u32 = 24;
pub const KM_MAX_IDX: u32 = 16;
pub const TASK_RUNNING: u32 = 0;
pub const TASK_INTERRUPTIBLE: u32 = 1;
pub const TASK_UNINTERRUPTIBLE: u32 = 2;
pub const __TASK_STOPPED: u32 = 4;
pub const __TASK_TRACED: u32 = 8;
pub const EXIT_DEAD: u32 = 16;
pub const EXIT_ZOMBIE: u32 = 32;
pub const EXIT_TRACE: u32 = 48;
pub const TASK_PARKED: u32 = 64;
pub const TASK_DEAD: u32 = 128;
pub const TASK_WAKEKILL: u32 = 256;
pub const TASK_WAKING: u32 = 512;
pub const TASK_NOLOAD: u32 = 1024;
pub const TASK_NEW: u32 = 2048;
pub const TASK_RTLOCK_WAIT: u32 = 4096;
pub const TASK_FREEZABLE: u32 = 8192;
pub const TASK_FROZEN: u32 = 32768;
pub const TASK_STATE_MAX: u32 = 65536;
pub const TASK_ANY: u32 = 65535;
pub const TASK_KILLABLE: u32 = 258;
pub const TASK_STOPPED: u32 = 260;
pub const TASK_TRACED: u32 = 8;
pub const TASK_IDLE: u32 = 1026;
pub const TASK_NORMAL: u32 = 3;
pub const TASK_REPORT: u32 = 127;
pub const SCHED_FIXEDPOINT_SHIFT: u32 = 10;
pub const SCHED_FIXEDPOINT_SCALE: u32 = 1024;
pub const SCHED_CAPACITY_SHIFT: u32 = 10;
pub const SCHED_CAPACITY_SCALE: u32 = 1024;
pub const UTIL_EST_WEIGHT_SHIFT: u32 = 2;
pub const UTIL_AVG_UNCHANGED: u32 = 2147483648;
pub const TASK_REPORT_IDLE: u32 = 128;
pub const TASK_REPORT_MAX: u32 = 256;
pub const PF_VCPU: u32 = 1;
pub const PF_IDLE: u32 = 2;
pub const PF_EXITING: u32 = 4;
pub const PF_POSTCOREDUMP: u32 = 8;
pub const PF_IO_WORKER: u32 = 16;
pub const PF_WQ_WORKER: u32 = 32;
pub const PF_FORKNOEXEC: u32 = 64;
pub const PF_MCE_PROCESS: u32 = 128;
pub const PF_SUPERPRIV: u32 = 256;
pub const PF_DUMPCORE: u32 = 512;
pub const PF_SIGNALED: u32 = 1024;
pub const PF_MEMALLOC: u32 = 2048;
pub const PF_NPROC_EXCEEDED: u32 = 4096;
pub const PF_USED_MATH: u32 = 8192;
pub const PF__HOLE__00004000: u32 = 16384;
pub const PF_NOFREEZE: u32 = 32768;
pub const PF__HOLE__00010000: u32 = 65536;
pub const PF_KSWAPD: u32 = 131072;
pub const PF_MEMALLOC_NOFS: u32 = 262144;
pub const PF_MEMALLOC_NOIO: u32 = 524288;
pub const PF_LOCAL_THROTTLE: u32 = 1048576;
pub const PF_KTHREAD: u32 = 2097152;
pub const PF_RANDOMIZE: u32 = 4194304;
pub const PF__HOLE__00800000: u32 = 8388608;
pub const PF__HOLE__01000000: u32 = 16777216;
pub const PF__HOLE__02000000: u32 = 33554432;
pub const PF_NO_SETAFFINITY: u32 = 67108864;
pub const PF_MCE_EARLY: u32 = 134217728;
pub const PF_MEMALLOC_PIN: u32 = 268435456;
pub const PF__HOLE__20000000: u32 = 536870912;
pub const PF__HOLE__40000000: u32 = 1073741824;
pub const PF_SUSPEND_TASK: u32 = 2147483648;
pub const PFA_NO_NEW_PRIVS: u32 = 0;
pub const PFA_SPREAD_PAGE: u32 = 1;
pub const PFA_SPREAD_SLAB: u32 = 2;
pub const PFA_SPEC_SSB_DISABLE: u32 = 3;
pub const PFA_SPEC_SSB_FORCE_DISABLE: u32 = 4;
pub const PFA_SPEC_IB_DISABLE: u32 = 5;
pub const PFA_SPEC_IB_FORCE_DISABLE: u32 = 6;
pub const PFA_SPEC_SSB_NOEXEC: u32 = 7;
pub const MIGHT_RESCHED_RCU_SHIFT: u32 = 8;
pub const MIGHT_RESCHED_PREEMPT_MASK: u32 = 255;
pub const PREEMPT_LOCK_RESCHED_OFFSETS: u32 = 1;
pub const BITS_PER_XA_VALUE: u32 = 63;
pub const XA_MAX_MARKS: u32 = 3;
pub const RADIX_TREE_ENTRY_MASK: u32 = 3;
pub const RADIX_TREE_INTERNAL_NODE: u32 = 2;
pub const RADIX_TREE_MAX_TAGS: u32 = 3;
pub const _LINUX_CAPABILITY_VERSION_1: u32 = 429392688;
pub const _LINUX_CAPABILITY_U32S_1: u32 = 1;
pub const _LINUX_CAPABILITY_VERSION_2: u32 = 537333798;
pub const _LINUX_CAPABILITY_U32S_2: u32 = 2;
pub const _LINUX_CAPABILITY_VERSION_3: u32 = 537396514;
pub const _LINUX_CAPABILITY_U32S_3: u32 = 2;
pub const VFS_CAP_REVISION_MASK: u32 = 4278190080;
pub const VFS_CAP_REVISION_SHIFT: u32 = 24;
pub const VFS_CAP_FLAGS_MASK: i64 = -4278190081;
pub const VFS_CAP_FLAGS_EFFECTIVE: u32 = 1;
pub const VFS_CAP_REVISION_1: u32 = 16777216;
pub const VFS_CAP_U32_1: u32 = 1;
pub const VFS_CAP_REVISION_2: u32 = 33554432;
pub const VFS_CAP_U32_2: u32 = 2;
pub const VFS_CAP_REVISION_3: u32 = 50331648;
pub const VFS_CAP_U32_3: u32 = 2;
pub const VFS_CAP_U32: u32 = 2;
pub const VFS_CAP_REVISION: u32 = 50331648;
pub const CAP_CHOWN: u32 = 0;
pub const CAP_DAC_OVERRIDE: u32 = 1;
pub const CAP_DAC_READ_SEARCH: u32 = 2;
pub const CAP_FOWNER: u32 = 3;
pub const CAP_FSETID: u32 = 4;
pub const CAP_KILL: u32 = 5;
pub const CAP_SETGID: u32 = 6;
pub const CAP_SETUID: u32 = 7;
pub const CAP_SETPCAP: u32 = 8;
pub const CAP_LINUX_IMMUTABLE: u32 = 9;
pub const CAP_NET_BIND_SERVICE: u32 = 10;
pub const CAP_NET_BROADCAST: u32 = 11;
pub const CAP_NET_ADMIN: u32 = 12;
pub const CAP_NET_RAW: u32 = 13;
pub const CAP_IPC_LOCK: u32 = 14;
pub const CAP_IPC_OWNER: u32 = 15;
pub const CAP_SYS_MODULE: u32 = 16;
pub const CAP_SYS_RAWIO: u32 = 17;
pub const CAP_SYS_CHROOT: u32 = 18;
pub const CAP_SYS_PTRACE: u32 = 19;
pub const CAP_SYS_PACCT: u32 = 20;
pub const CAP_SYS_ADMIN: u32 = 21;
pub const CAP_SYS_BOOT: u32 = 22;
pub const CAP_SYS_NICE: u32 = 23;
pub const CAP_SYS_RESOURCE: u32 = 24;
pub const CAP_SYS_TIME: u32 = 25;
pub const CAP_SYS_TTY_CONFIG: u32 = 26;
pub const CAP_MKNOD: u32 = 27;
pub const CAP_LEASE: u32 = 28;
pub const CAP_AUDIT_WRITE: u32 = 29;
pub const CAP_AUDIT_CONTROL: u32 = 30;
pub const CAP_SETFCAP: u32 = 31;
pub const CAP_MAC_OVERRIDE: u32 = 32;
pub const CAP_MAC_ADMIN: u32 = 33;
pub const CAP_SYSLOG: u32 = 34;
pub const CAP_WAKE_ALARM: u32 = 35;
pub const CAP_BLOCK_SUSPEND: u32 = 36;
pub const CAP_AUDIT_READ: u32 = 37;
pub const CAP_PERFMON: u32 = 38;
pub const CAP_BPF: u32 = 39;
pub const CAP_CHECKPOINT_RESTORE: u32 = 40;
pub const CAP_LAST_CAP: u32 = 40;
pub const _KERNEL_CAPABILITY_VERSION: u32 = 537396514;
pub const _KERNEL_CAPABILITY_U32S: u32 = 2;
pub const CAP_LAST_U32: u32 = 1;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_DSYNC: u32 = 4096;
pub const FASYNC: u32 = 8192;
pub const O_DIRECT: u32 = 16384;
pub const O_LARGEFILE: u32 = 32768;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_NOATIME: u32 = 262144;
pub const O_CLOEXEC: u32 = 524288;
pub const __O_SYNC: u32 = 1048576;
pub const O_SYNC: u32 = 1052672;
pub const O_PATH: u32 = 2097152;
pub const __O_TMPFILE: u32 = 4194304;
pub const O_TMPFILE: u32 = 4259840;
pub const O_TMPFILE_MASK: u32 = 4259904;
pub const O_NDELAY: u32 = 2048;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const F_SETSIG: u32 = 10;
pub const F_GETSIG: u32 = 11;
pub const F_GETLK64: u32 = 12;
pub const F_SETLK64: u32 = 13;
pub const F_SETLKW64: u32 = 14;
pub const F_SETOWN_EX: u32 = 15;
pub const F_GETOWN_EX: u32 = 16;
pub const F_GETOWNER_UIDS: u32 = 17;
pub const F_OFD_GETLK: u32 = 36;
pub const F_OFD_SETLK: u32 = 37;
pub const F_OFD_SETLKW: u32 = 38;
pub const F_OWNER_TID: u32 = 0;
pub const F_OWNER_PID: u32 = 1;
pub const F_OWNER_PGRP: u32 = 2;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const LOCK_MAND: u32 = 32;
pub const LOCK_READ: u32 = 64;
pub const LOCK_WRITE: u32 = 128;
pub const LOCK_RW: u32 = 192;
pub const F_LINUX_SPECIFIC_BASE: u32 = 1024;
pub const RESOLVE_NO_XDEV: u32 = 1;
pub const RESOLVE_NO_MAGICLINKS: u32 = 2;
pub const RESOLVE_NO_SYMLINKS: u32 = 4;
pub const RESOLVE_BENEATH: u32 = 8;
pub const RESOLVE_IN_ROOT: u32 = 16;
pub const RESOLVE_CACHED: u32 = 32;
pub const F_SETLEASE: u32 = 1024;
pub const F_GETLEASE: u32 = 1025;
pub const F_CANCELLK: u32 = 1029;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const F_NOTIFY: u32 = 1026;
pub const F_SETPIPE_SZ: u32 = 1031;
pub const F_GETPIPE_SZ: u32 = 1032;
pub const F_ADD_SEALS: u32 = 1033;
pub const F_GET_SEALS: u32 = 1034;
pub const F_SEAL_SEAL: u32 = 1;
pub const F_SEAL_SHRINK: u32 = 2;
pub const F_SEAL_GROW: u32 = 4;
pub const F_SEAL_WRITE: u32 = 8;
pub const F_SEAL_FUTURE_WRITE: u32 = 16;
pub const F_GET_RW_HINT: u32 = 1035;
pub const F_SET_RW_HINT: u32 = 1036;
pub const F_GET_FILE_RW_HINT: u32 = 1037;
pub const F_SET_FILE_RW_HINT: u32 = 1038;
pub const RWH_WRITE_LIFE_NOT_SET: u32 = 0;
pub const RWH_WRITE_LIFE_NONE: u32 = 1;
pub const RWH_WRITE_LIFE_SHORT: u32 = 2;
pub const RWH_WRITE_LIFE_MEDIUM: u32 = 3;
pub const RWH_WRITE_LIFE_LONG: u32 = 4;
pub const RWH_WRITE_LIFE_EXTREME: u32 = 5;
pub const RWF_WRITE_LIFE_NOT_SET: u32 = 0;
pub const DN_ACCESS: u32 = 1;
pub const DN_MODIFY: u32 = 2;
pub const DN_CREATE: u32 = 4;
pub const DN_DELETE: u32 = 8;
pub const DN_RENAME: u32 = 16;
pub const DN_ATTRIB: u32 = 32;
pub const DN_MULTISHOT: u32 = 2147483648;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_EACCESS: u32 = 512;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_NO_AUTOMOUNT: u32 = 2048;
pub const AT_EMPTY_PATH: u32 = 4096;
pub const AT_STATX_SYNC_TYPE: u32 = 24576;
pub const AT_STATX_SYNC_AS_STAT: u32 = 0;
pub const AT_STATX_FORCE_SYNC: u32 = 8192;
pub const AT_STATX_DONT_SYNC: u32 = 16384;
pub const AT_RECURSIVE: u32 = 32768;
pub const VALID_OPEN_FLAGS: u32 = 8388547;
pub const VALID_RESOLVE_FLAGS: u32 = 63;
pub const OPEN_HOW_SIZE_VER0: u32 = 24;
pub const OPEN_HOW_SIZE_LATEST: u32 = 24;
pub const SIGEMT_MASK: u32 = 0;
pub const JOBCTL_STOP_SIGMASK: u32 = 65535;
pub const JOBCTL_STOP_DEQUEUED_BIT: u32 = 16;
pub const JOBCTL_STOP_PENDING_BIT: u32 = 17;
pub const JOBCTL_STOP_CONSUME_BIT: u32 = 18;
pub const JOBCTL_TRAP_STOP_BIT: u32 = 19;
pub const JOBCTL_TRAP_NOTIFY_BIT: u32 = 20;
pub const JOBCTL_TRAPPING_BIT: u32 = 21;
pub const JOBCTL_LISTENING_BIT: u32 = 22;
pub const JOBCTL_TRAP_FREEZE_BIT: u32 = 23;
pub const JOBCTL_PTRACE_FROZEN_BIT: u32 = 24;
pub const JOBCTL_STOPPED_BIT: u32 = 26;
pub const JOBCTL_TRACED_BIT: u32 = 27;
pub const JOBCTL_STOP_DEQUEUED: u32 = 65536;
pub const JOBCTL_STOP_PENDING: u32 = 131072;
pub const JOBCTL_STOP_CONSUME: u32 = 262144;
pub const JOBCTL_TRAP_STOP: u32 = 524288;
pub const JOBCTL_TRAP_NOTIFY: u32 = 1048576;
pub const JOBCTL_TRAPPING: u32 = 2097152;
pub const JOBCTL_LISTENING: u32 = 4194304;
pub const JOBCTL_TRAP_FREEZE: u32 = 8388608;
pub const JOBCTL_PTRACE_FROZEN: u32 = 16777216;
pub const JOBCTL_STOPPED: u32 = 67108864;
pub const JOBCTL_TRACED: u32 = 134217728;
pub const JOBCTL_TRAP_MASK: u32 = 1572864;
pub const JOBCTL_PENDING_MASK: u32 = 1703936;
pub const __ASM_CLAC: &'static [u8; 21usize] = b".byte 0x0f,0x01,0xca\0";
pub const __ASM_STAC: &'static [u8; 21usize] = b".byte 0x0f,0x01,0xcb\0";
pub const ARCH_HAS_NOCACHE_UACCESS: u32 = 1;
pub const CLONE_LEGACY_FLAGS: u32 = 4294967295;
pub const CTL_MAXNAME: u32 = 10;
pub const ASSOC_ARRAY_KEY_CHUNK_SIZE: u32 = 64;
pub const KEY_POS_VIEW: u32 = 16777216;
pub const KEY_POS_READ: u32 = 33554432;
pub const KEY_POS_WRITE: u32 = 67108864;
pub const KEY_POS_SEARCH: u32 = 134217728;
pub const KEY_POS_LINK: u32 = 268435456;
pub const KEY_POS_SETATTR: u32 = 536870912;
pub const KEY_POS_ALL: u32 = 1056964608;
pub const KEY_USR_VIEW: u32 = 65536;
pub const KEY_USR_READ: u32 = 131072;
pub const KEY_USR_WRITE: u32 = 262144;
pub const KEY_USR_SEARCH: u32 = 524288;
pub const KEY_USR_LINK: u32 = 1048576;
pub const KEY_USR_SETATTR: u32 = 2097152;
pub const KEY_USR_ALL: u32 = 4128768;
pub const KEY_GRP_VIEW: u32 = 256;
pub const KEY_GRP_READ: u32 = 512;
pub const KEY_GRP_WRITE: u32 = 1024;
pub const KEY_GRP_SEARCH: u32 = 2048;
pub const KEY_GRP_LINK: u32 = 4096;
pub const KEY_GRP_SETATTR: u32 = 8192;
pub const KEY_GRP_ALL: u32 = 16128;
pub const KEY_OTH_VIEW: u32 = 1;
pub const KEY_OTH_READ: u32 = 2;
pub const KEY_OTH_WRITE: u32 = 4;
pub const KEY_OTH_SEARCH: u32 = 8;
pub const KEY_OTH_LINK: u32 = 16;
pub const KEY_OTH_SETATTR: u32 = 32;
pub const KEY_OTH_ALL: u32 = 63;
pub const KEY_PERM_UNDEF: u32 = 4294967295;
pub const KEY_FLAG_DEAD: u32 = 0;
pub const KEY_FLAG_REVOKED: u32 = 1;
pub const KEY_FLAG_IN_QUOTA: u32 = 2;
pub const KEY_FLAG_USER_CONSTRUCT: u32 = 3;
pub const KEY_FLAG_ROOT_CAN_CLEAR: u32 = 4;
pub const KEY_FLAG_INVALIDATED: u32 = 5;
pub const KEY_FLAG_BUILTIN: u32 = 6;
pub const KEY_FLAG_ROOT_CAN_INVAL: u32 = 7;
pub const KEY_FLAG_KEEP: u32 = 8;
pub const KEY_FLAG_UID_KEYRING: u32 = 9;
pub const KEY_ALLOC_IN_QUOTA: u32 = 0;
pub const KEY_ALLOC_QUOTA_OVERRUN: u32 = 1;
pub const KEY_ALLOC_NOT_IN_QUOTA: u32 = 2;
pub const KEY_ALLOC_BUILT_IN: u32 = 4;
pub const KEY_ALLOC_BYPASS_RESTRICTION: u32 = 8;
pub const KEY_ALLOC_UID_KEYRING: u32 = 16;
pub const KEY_ALLOC_SET_KEEP: u32 = 32;
pub const SIGNAL_STOP_STOPPED: u32 = 1;
pub const SIGNAL_STOP_CONTINUED: u32 = 2;
pub const SIGNAL_GROUP_EXIT: u32 = 4;
pub const SIGNAL_CLD_STOPPED: u32 = 16;
pub const SIGNAL_CLD_CONTINUED: u32 = 32;
pub const SIGNAL_CLD_MASK: u32 = 48;
pub const SIGNAL_UNKILLABLE: u32 = 64;
pub const SIGNAL_STOP_MASK: u32 = 51;
pub const UUID_SIZE: u32 = 16;
pub const UUID_STRING_LEN: u32 = 36;
pub const RR_TIMESLICE: u32 = 100;
pub const IOPRIO_CLASS_SHIFT: u32 = 13;
pub const IOPRIO_CLASS_MASK: u32 = 7;
pub const IOPRIO_PRIO_MASK: u32 = 8191;
pub const IOPRIO_NR_LEVELS: u32 = 8;
pub const IOPRIO_BE_NR: u32 = 8;
pub const IOPRIO_NORM: u32 = 4;
pub const IOPRIO_BE_NORM: u32 = 4;
pub const S_DT_SHIFT: u32 = 12;
pub const S_DT_MASK: u32 = 15;
pub const DT_UNKNOWN: u32 = 0;
pub const DT_FIFO: u32 = 1;
pub const DT_CHR: u32 = 2;
pub const DT_DIR: u32 = 4;
pub const DT_BLK: u32 = 6;
pub const DT_REG: u32 = 8;
pub const DT_LNK: u32 = 10;
pub const DT_SOCK: u32 = 12;
pub const DT_WHT: u32 = 14;
pub const DT_MAX: u32 = 16;
pub const FT_UNKNOWN: u32 = 0;
pub const FT_REG_FILE: u32 = 1;
pub const FT_DIR: u32 = 2;
pub const FT_CHRDEV: u32 = 3;
pub const FT_BLKDEV: u32 = 4;
pub const FT_FIFO: u32 = 5;
pub const FT_SOCK: u32 = 6;
pub const FT_SYMLINK: u32 = 7;
pub const FT_MAX: u32 = 8;
pub const MNT_NOSUID: u32 = 1;
pub const MNT_NODEV: u32 = 2;
pub const MNT_NOEXEC: u32 = 4;
pub const MNT_NOATIME: u32 = 8;
pub const MNT_NODIRATIME: u32 = 16;
pub const MNT_RELATIME: u32 = 32;
pub const MNT_READONLY: u32 = 64;
pub const MNT_NOSYMFOLLOW: u32 = 128;
pub const MNT_SHRINKABLE: u32 = 256;
pub const MNT_WRITE_HOLD: u32 = 512;
pub const MNT_SHARED: u32 = 4096;
pub const MNT_UNBINDABLE: u32 = 8192;
pub const MNT_SHARED_MASK: u32 = 8192;
pub const MNT_USER_SETTABLE_MASK: u32 = 255;
pub const MNT_ATIME_MASK: u32 = 56;
pub const MNT_INTERNAL: u32 = 16384;
pub const MNT_LOCK_ATIME: u32 = 262144;
pub const MNT_LOCK_NOEXEC: u32 = 524288;
pub const MNT_LOCK_NOSUID: u32 = 1048576;
pub const MNT_LOCK_NODEV: u32 = 2097152;
pub const MNT_LOCK_READONLY: u32 = 4194304;
pub const MNT_LOCKED: u32 = 8388608;
pub const MNT_DOOMED: u32 = 16777216;
pub const MNT_SYNC_UMOUNT: u32 = 33554432;
pub const MNT_MARKED: u32 = 67108864;
pub const MNT_UMOUNT: u32 = 134217728;
pub const MNT_CURSOR: u32 = 268435456;
pub const SLAB_DEBUG_OBJECTS: u32 = 0;
pub const SLAB_FAILSLAB: u32 = 0;
pub const SLAB_ACCOUNT: u32 = 0;
pub const SLAB_SKIP_KFENCE: u32 = 0;
pub const KASAN_SHADOW_SCALE_SHIFT: u32 = 3;
pub const PKRU_AD_BIT: u32 = 1;
pub const PKRU_WD_BIT: u32 = 2;
pub const PKRU_BITS_PER_PKEY: u32 = 2;
pub const FIXMAP_PMD_NUM: u32 = 2;
pub const FIXMAP_PMD_TOP: u32 = 507;
pub const VSYSCALL_ADDR: i32 = -10485760;
pub const NR_FIX_BTMAPS: u32 = 64;
pub const FIX_BTMAPS_SLOTS: u32 = 8;
pub const TOTAL_FIX_BTMAPS: u32 = 512;
pub const SWP_TYPE_BITS: u32 = 5;
pub const SWP_OFFSET_FIRST_BIT: u32 = 9;
pub const SWP_OFFSET_SHIFT: u32 = 14;
pub const HAVE_PAGE_AGP: u32 = 1;
pub const _ASM_PGTABLE_INVERT_H: u32 = 1;
pub const PTI_PGTABLE_SWITCH_BIT: u32 = 12;
pub const __HAVE_ARCH_PFN_MODIFY_ALLOWED: u32 = 1;
pub const USER_PGTABLES_CEILING: u32 = 0;
pub const FIRST_USER_ADDRESS: u32 = 0;
pub const __PGTBL_PGD_MODIFIED: u32 = 0;
pub const __PGTBL_P4D_MODIFIED: u32 = 1;
pub const __PGTBL_PUD_MODIFIED: u32 = 2;
pub const __PGTBL_PMD_MODIFIED: u32 = 3;
pub const __PGTBL_PTE_MODIFIED: u32 = 4;
pub const MAX_PTRS_PER_PTE: u32 = 512;
pub const MAX_PTRS_PER_PMD: u32 = 512;
pub const MAX_PTRS_PER_PUD: u32 = 512;
pub const KASAN_SHADOW_INIT: u32 = 0;
pub const PTE_HWTABLE_PTRS: u32 = 0;
pub const KMALLOC_SHIFT_HIGH: u32 = 13;
pub const KMALLOC_SHIFT_MAX: u32 = 22;
pub const KMALLOC_SHIFT_LOW: u32 = 3;
pub const KMALLOC_MAX_SIZE: u32 = 4194304;
pub const KMALLOC_MAX_CACHE_SIZE: u32 = 8192;
pub const KMALLOC_MAX_ORDER: u32 = 10;
pub const KMALLOC_MIN_SIZE: u32 = 8;
pub const INR_OPEN_CUR: u32 = 1024;
pub const INR_OPEN_MAX: u32 = 4096;
pub const BLOCK_SIZE_BITS: u32 = 10;
pub const BLOCK_SIZE: u32 = 1024;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const SEEK_MAX: u32 = 4;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const FILE_DEDUPE_RANGE_SAME: u32 = 0;
pub const FILE_DEDUPE_RANGE_DIFFERS: u32 = 1;
pub const NR_FILE: u32 = 8192;
pub const FS_XFLAG_REALTIME: u32 = 1;
pub const FS_XFLAG_PREALLOC: u32 = 2;
pub const FS_XFLAG_IMMUTABLE: u32 = 8;
pub const FS_XFLAG_APPEND: u32 = 16;
pub const FS_XFLAG_SYNC: u32 = 32;
pub const FS_XFLAG_NOATIME: u32 = 64;
pub const FS_XFLAG_NODUMP: u32 = 128;
pub const FS_XFLAG_RTINHERIT: u32 = 256;
pub const FS_XFLAG_PROJINHERIT: u32 = 512;
pub const FS_XFLAG_NOSYMLINKS: u32 = 1024;
pub const FS_XFLAG_EXTSIZE: u32 = 2048;
pub const FS_XFLAG_EXTSZINHERIT: u32 = 4096;
pub const FS_XFLAG_NODEFRAG: u32 = 8192;
pub const FS_XFLAG_FILESTREAM: u32 = 16384;
pub const FS_XFLAG_DAX: u32 = 32768;
pub const FS_XFLAG_COWEXTSIZE: u32 = 65536;
pub const FS_XFLAG_HASATTR: u32 = 2147483648;
pub const BMAP_IOCTL: u32 = 1;
pub const FSLABEL_MAX: u32 = 256;
pub const FS_SECRM_FL: u32 = 1;
pub const FS_UNRM_FL: u32 = 2;
pub const FS_COMPR_FL: u32 = 4;
pub const FS_SYNC_FL: u32 = 8;
pub const FS_IMMUTABLE_FL: u32 = 16;
pub const FS_APPEND_FL: u32 = 32;
pub const FS_NODUMP_FL: u32 = 64;
pub const FS_NOATIME_FL: u32 = 128;
pub const FS_DIRTY_FL: u32 = 256;
pub const FS_COMPRBLK_FL: u32 = 512;
pub const FS_NOCOMP_FL: u32 = 1024;
pub const FS_ENCRYPT_FL: u32 = 2048;
pub const FS_BTREE_FL: u32 = 4096;
pub const FS_INDEX_FL: u32 = 4096;
pub const FS_IMAGIC_FL: u32 = 8192;
pub const FS_JOURNAL_DATA_FL: u32 = 16384;
pub const FS_NOTAIL_FL: u32 = 32768;
pub const FS_DIRSYNC_FL: u32 = 65536;
pub const FS_TOPDIR_FL: u32 = 131072;
pub const FS_HUGE_FILE_FL: u32 = 262144;
pub const FS_EXTENT_FL: u32 = 524288;
pub const FS_VERITY_FL: u32 = 1048576;
pub const FS_EA_INODE_FL: u32 = 2097152;
pub const FS_EOFBLOCKS_FL: u32 = 4194304;
pub const FS_NOCOW_FL: u32 = 8388608;
pub const FS_DAX_FL: u32 = 33554432;
pub const FS_INLINE_DATA_FL: u32 = 268435456;
pub const FS_PROJINHERIT_FL: u32 = 536870912;
pub const FS_CASEFOLD_FL: u32 = 1073741824;
pub const FS_RESERVED_FL: u32 = 2147483648;
pub const FS_FL_USER_VISIBLE: u32 = 253951;
pub const FS_FL_USER_MODIFIABLE: u32 = 229631;
pub const SYNC_FILE_RANGE_WAIT_BEFORE: u32 = 1;
pub const SYNC_FILE_RANGE_WRITE: u32 = 2;
pub const SYNC_FILE_RANGE_WAIT_AFTER: u32 = 4;
pub const SYNC_FILE_RANGE_WRITE_AND_WAIT: u32 = 7;
pub const MAY_EXEC: u32 = 1;
pub const MAY_WRITE: u32 = 2;
pub const MAY_READ: u32 = 4;
pub const MAY_APPEND: u32 = 8;
pub const MAY_ACCESS: u32 = 16;
pub const MAY_OPEN: u32 = 32;
pub const MAY_CHDIR: u32 = 64;
pub const MAY_NOT_BLOCK: u32 = 128;
pub const ATTR_MODE: u32 = 1;
pub const ATTR_UID: u32 = 2;
pub const ATTR_GID: u32 = 4;
pub const ATTR_SIZE: u32 = 8;
pub const ATTR_ATIME: u32 = 16;
pub const ATTR_MTIME: u32 = 32;
pub const ATTR_CTIME: u32 = 64;
pub const ATTR_ATIME_SET: u32 = 128;
pub const ATTR_MTIME_SET: u32 = 256;
pub const ATTR_FORCE: u32 = 512;
pub const ATTR_KILL_SUID: u32 = 2048;
pub const ATTR_KILL_SGID: u32 = 4096;
pub const ATTR_FILE: u32 = 8192;
pub const ATTR_KILL_PRIV: u32 = 16384;
pub const ATTR_OPEN: u32 = 32768;
pub const ATTR_TIMES_SET: u32 = 65536;
pub const ATTR_TOUCH: u32 = 131072;
pub const WHITEOUT_MODE: u32 = 0;
pub const WHITEOUT_DEV: u32 = 0;
pub const XQM_USRQUOTA: u32 = 0;
pub const XQM_GRPQUOTA: u32 = 1;
pub const XQM_PRJQUOTA: u32 = 2;
pub const XQM_MAXQUOTAS: u32 = 3;
pub const FS_DQUOT_VERSION: u32 = 1;
pub const FS_DQ_ISOFT: u32 = 1;
pub const FS_DQ_IHARD: u32 = 2;
pub const FS_DQ_BSOFT: u32 = 4;
pub const FS_DQ_BHARD: u32 = 8;
pub const FS_DQ_RTBSOFT: u32 = 16;
pub const FS_DQ_RTBHARD: u32 = 32;
pub const FS_DQ_LIMIT_MASK: u32 = 63;
pub const FS_DQ_BTIMER: u32 = 64;
pub const FS_DQ_ITIMER: u32 = 128;
pub const FS_DQ_RTBTIMER: u32 = 256;
pub const FS_DQ_TIMER_MASK: u32 = 448;
pub const FS_DQ_BWARNS: u32 = 512;
pub const FS_DQ_IWARNS: u32 = 1024;
pub const FS_DQ_RTBWARNS: u32 = 2048;
pub const FS_DQ_WARNS_MASK: u32 = 3584;
pub const FS_DQ_BCOUNT: u32 = 4096;
pub const FS_DQ_ICOUNT: u32 = 8192;
pub const FS_DQ_RTBCOUNT: u32 = 16384;
pub const FS_DQ_ACCT_MASK: u32 = 28672;
pub const FS_DQ_BIGTIME: u32 = 32768;
pub const FS_QUOTA_UDQ_ACCT: u32 = 1;
pub const FS_QUOTA_UDQ_ENFD: u32 = 2;
pub const FS_QUOTA_GDQ_ACCT: u32 = 4;
pub const FS_QUOTA_GDQ_ENFD: u32 = 8;
pub const FS_QUOTA_PDQ_ACCT: u32 = 16;
pub const FS_QUOTA_PDQ_ENFD: u32 = 32;
pub const FS_USER_QUOTA: u32 = 1;
pub const FS_PROJ_QUOTA: u32 = 2;
pub const FS_GROUP_QUOTA: u32 = 4;
pub const FS_QSTAT_VERSION: u32 = 1;
pub const FS_QSTATV_VERSION1: u32 = 1;
pub const V1_INIT_ALLOC: u32 = 1;
pub const V1_INIT_REWRITE: u32 = 1;
pub const V1_DEL_ALLOC: u32 = 0;
pub const V1_DEL_REWRITE: u32 = 2;
pub const QTREE_INIT_ALLOC: u32 = 4;
pub const QTREE_INIT_REWRITE: u32 = 2;
pub const QTREE_DEL_ALLOC: u32 = 0;
pub const QTREE_DEL_REWRITE: u32 = 6;
pub const V2_INIT_ALLOC: u32 = 4;
pub const V2_INIT_REWRITE: u32 = 2;
pub const V2_DEL_ALLOC: u32 = 0;
pub const V2_DEL_REWRITE: u32 = 6;
pub const OVERFLOW_PROJID: u32 = 65534;
pub const __DQUOT_VERSION__: &'static [u8; 12usize] = b"dquot_6.6.0\0";
pub const MAXQUOTAS: u32 = 3;
pub const USRQUOTA: u32 = 0;
pub const GRPQUOTA: u32 = 1;
pub const PRJQUOTA: u32 = 2;
pub const SUBCMDMASK: u32 = 255;
pub const SUBCMDSHIFT: u32 = 8;
pub const Q_SYNC: u32 = 8388609;
pub const Q_QUOTAON: u32 = 8388610;
pub const Q_QUOTAOFF: u32 = 8388611;
pub const Q_GETFMT: u32 = 8388612;
pub const Q_GETINFO: u32 = 8388613;
pub const Q_SETINFO: u32 = 8388614;
pub const Q_GETQUOTA: u32 = 8388615;
pub const Q_SETQUOTA: u32 = 8388616;
pub const Q_GETNEXTQUOTA: u32 = 8388617;
pub const QFMT_VFS_OLD: u32 = 1;
pub const QFMT_VFS_V0: u32 = 2;
pub const QFMT_OCFS2: u32 = 3;
pub const QFMT_VFS_V1: u32 = 4;
pub const QIF_DQBLKSIZE_BITS: u32 = 10;
pub const QIF_DQBLKSIZE: u32 = 1024;
pub const IIF_BGRACE: u32 = 1;
pub const IIF_IGRACE: u32 = 2;
pub const IIF_FLAGS: u32 = 4;
pub const IIF_ALL: u32 = 7;
pub const QUOTA_NL_NOWARN: u32 = 0;
pub const QUOTA_NL_IHARDWARN: u32 = 1;
pub const QUOTA_NL_ISOFTLONGWARN: u32 = 2;
pub const QUOTA_NL_ISOFTWARN: u32 = 3;
pub const QUOTA_NL_BHARDWARN: u32 = 4;
pub const QUOTA_NL_BSOFTLONGWARN: u32 = 5;
pub const QUOTA_NL_BSOFTWARN: u32 = 6;
pub const QUOTA_NL_IHARDBELOW: u32 = 7;
pub const QUOTA_NL_ISOFTBELOW: u32 = 8;
pub const QUOTA_NL_BHARDBELOW: u32 = 9;
pub const QUOTA_NL_BSOFTBELOW: u32 = 10;
pub const QTYPE_MASK_USR: u32 = 1;
pub const QTYPE_MASK_GRP: u32 = 2;
pub const QTYPE_MASK_PRJ: u32 = 4;
pub const DQ_MOD_B: u32 = 0;
pub const DQ_BLKS_B: u32 = 1;
pub const DQ_INODES_B: u32 = 2;
pub const DQ_FAKE_B: u32 = 3;
pub const DQ_READ_B: u32 = 4;
pub const DQ_ACTIVE_B: u32 = 5;
pub const DQ_LASTSET_B: u32 = 6;
pub const QC_INO_SOFT: u32 = 1;
pub const QC_INO_HARD: u32 = 2;
pub const QC_SPC_SOFT: u32 = 4;
pub const QC_SPC_HARD: u32 = 8;
pub const QC_RT_SPC_SOFT: u32 = 16;
pub const QC_RT_SPC_HARD: u32 = 32;
pub const QC_LIMIT_MASK: u32 = 63;
pub const QC_SPC_TIMER: u32 = 64;
pub const QC_INO_TIMER: u32 = 128;
pub const QC_RT_SPC_TIMER: u32 = 256;
pub const QC_TIMER_MASK: u32 = 448;
pub const QC_SPC_WARNS: u32 = 512;
pub const QC_INO_WARNS: u32 = 1024;
pub const QC_RT_SPC_WARNS: u32 = 2048;
pub const QC_WARNS_MASK: u32 = 3584;
pub const QC_SPACE: u32 = 4096;
pub const QC_INO_COUNT: u32 = 8192;
pub const QC_RT_SPACE: u32 = 16384;
pub const QC_ACCT_MASK: u32 = 28672;
pub const QC_FLAGS: u32 = 32768;
pub const QCI_SYSFILE: u32 = 1;
pub const QCI_ROOT_SQUASH: u32 = 2;
pub const QCI_ACCT_ENABLED: u32 = 4;
pub const QCI_LIMITS_ENFORCED: u32 = 8;
pub const FILESYSTEM_MAX_STACK_DEPTH: u32 = 2;
pub const IOCB_EVENTFD: u32 = 65536;
pub const IOCB_DIRECT: u32 = 131072;
pub const IOCB_WRITE: u32 = 262144;
pub const IOCB_WAITQ: u32 = 524288;
pub const IOCB_NOIO: u32 = 1048576;
pub const IOCB_ALLOC_CACHE: u32 = 2097152;
pub const IOP_FASTPERM: u32 = 1;
pub const IOP_LOOKUP: u32 = 2;
pub const IOP_NOFOLLOW: u32 = 4;
pub const IOP_XATTR: u32 = 8;
pub const IOP_DEFAULT_READLINK: u32 = 16;
pub const MAX_NON_LFS: u32 = 2147483647;
pub const FL_POSIX: u32 = 1;
pub const FL_FLOCK: u32 = 2;
pub const FL_DELEG: u32 = 4;
pub const FL_ACCESS: u32 = 8;
pub const FL_EXISTS: u32 = 16;
pub const FL_LEASE: u32 = 32;
pub const FL_CLOSE: u32 = 64;
pub const FL_SLEEP: u32 = 128;
pub const FL_DOWNGRADE_PENDING: u32 = 256;
pub const FL_UNLOCK_PENDING: u32 = 512;
pub const FL_OFDLCK: u32 = 1024;
pub const FL_LAYOUT: u32 = 2048;
pub const FL_RECLAIM: u32 = 4096;
pub const FL_CLOSE_POSIX: u32 = 65;
pub const FILE_LOCK_DEFERRED: u32 = 1;
pub const FASYNC_MAGIC: u32 = 17921;
pub const SB_RDONLY: u32 = 1;
pub const SB_NOSUID: u32 = 2;
pub const SB_NODEV: u32 = 4;
pub const SB_NOEXEC: u32 = 8;
pub const SB_SYNCHRONOUS: u32 = 16;
pub const SB_MANDLOCK: u32 = 64;
pub const SB_DIRSYNC: u32 = 128;
pub const SB_NOATIME: u32 = 1024;
pub const SB_NODIRATIME: u32 = 2048;
pub const SB_SILENT: u32 = 32768;
pub const SB_POSIXACL: u32 = 65536;
pub const SB_INLINECRYPT: u32 = 131072;
pub const SB_KERNMOUNT: u32 = 4194304;
pub const SB_I_VERSION: u32 = 8388608;
pub const SB_LAZYTIME: u32 = 33554432;
pub const SB_SUBMOUNT: u32 = 67108864;
pub const SB_FORCE: u32 = 134217728;
pub const SB_NOSEC: u32 = 268435456;
pub const SB_BORN: u32 = 536870912;
pub const SB_ACTIVE: u32 = 1073741824;
pub const SB_NOUSER: u32 = 2147483648;
pub const SB_ENC_STRICT_MODE_FL: u32 = 1;
pub const MNT_FORCE: u32 = 1;
pub const MNT_DETACH: u32 = 2;
pub const MNT_EXPIRE: u32 = 4;
pub const UMOUNT_NOFOLLOW: u32 = 8;
pub const UMOUNT_UNUSED: u32 = 2147483648;
pub const SB_I_CGROUPWB: u32 = 1;
pub const SB_I_NOEXEC: u32 = 2;
pub const SB_I_NODEV: u32 = 4;
pub const SB_I_STABLE_WRITES: u32 = 8;
pub const SB_I_USERNS_VISIBLE: u32 = 16;
pub const SB_I_IMA_UNVERIFIABLE_SIGNATURE: u32 = 32;
pub const SB_I_UNTRUSTED_MOUNTER: u32 = 64;
pub const SB_I_SKIP_SYNC: u32 = 256;
pub const SB_I_PERSB_BDI: u32 = 512;
pub const SB_I_TS_EXPIRY_WARNED: u32 = 1024;
pub const SB_I_RETIRED: u32 = 2048;
pub const NOMMU_MAP_COPY: u32 = 1;
pub const NOMMU_MAP_DIRECT: u32 = 8;
pub const REMAP_FILE_DEDUP: u32 = 1;
pub const REMAP_FILE_CAN_SHORTEN: u32 = 2;
pub const REMAP_FILE_ADVISORY: u32 = 2;
pub const COPY_FILE_SPLICE: u32 = 1;
pub const S_SYNC: u32 = 1;
pub const S_NOATIME: u32 = 2;
pub const S_APPEND: u32 = 4;
pub const S_IMMUTABLE: u32 = 8;
pub const S_DEAD: u32 = 16;
pub const S_NOQUOTA: u32 = 32;
pub const S_DIRSYNC: u32 = 64;
pub const S_NOCMTIME: u32 = 128;
pub const S_SWAPFILE: u32 = 256;
pub const S_PRIVATE: u32 = 512;
pub const S_IMA: u32 = 1024;
pub const S_AUTOMOUNT: u32 = 2048;
pub const S_NOSEC: u32 = 4096;
pub const S_DAX: u32 = 0;
pub const S_ENCRYPTED: u32 = 16384;
pub const S_CASEFOLD: u32 = 32768;
pub const S_VERITY: u32 = 65536;
pub const S_KERNEL_FILE: u32 = 131072;
pub const I_DIRTY_SYNC: u32 = 1;
pub const I_DIRTY_DATASYNC: u32 = 2;
pub const I_DIRTY_PAGES: u32 = 4;
pub const __I_NEW: u32 = 3;
pub const I_NEW: u32 = 8;
pub const I_WILL_FREE: u32 = 16;
pub const I_FREEING: u32 = 32;
pub const I_CLEAR: u32 = 64;
pub const __I_SYNC: u32 = 7;
pub const I_SYNC: u32 = 128;
pub const I_REFERENCED: u32 = 256;
pub const __I_DIO_WAKEUP: u32 = 9;
pub const I_DIO_WAKEUP: u32 = 512;
pub const I_LINKABLE: u32 = 1024;
pub const I_DIRTY_TIME: u32 = 2048;
pub const I_WB_SWITCH: u32 = 8192;
pub const I_OVL_INUSE: u32 = 16384;
pub const I_CREATING: u32 = 32768;
pub const I_DONTCACHE: u32 = 65536;
pub const I_SYNC_QUEUED: u32 = 131072;
pub const I_PINNING_FSCACHE_WB: u32 = 262144;
pub const I_DIRTY_INODE: u32 = 3;
pub const I_DIRTY: u32 = 7;
pub const I_DIRTY_ALL: u32 = 2055;
pub const FS_REQUIRES_DEV: u32 = 1;
pub const FS_BINARY_MOUNTDATA: u32 = 2;
pub const FS_HAS_SUBTYPE: u32 = 4;
pub const FS_USERNS_MOUNT: u32 = 8;
pub const FS_DISALLOW_NOTIFY_PERM: u32 = 16;
pub const FS_ALLOW_IDMAP: u32 = 32;
pub const FS_RENAME_DOES_D_MOVE: u32 = 32768;
pub const CHRDEV_MAJOR_MAX: u32 = 512;
pub const CHRDEV_MAJOR_DYN_END: u32 = 234;
pub const CHRDEV_MAJOR_DYN_EXT_START: u32 = 511;
pub const CHRDEV_MAJOR_DYN_EXT_END: u32 = 384;
pub const VM_IOREMAP: u32 = 1;
pub const VM_ALLOC: u32 = 2;
pub const VM_MAP: u32 = 4;
pub const VM_USERMAP: u32 = 8;
pub const VM_DMA_COHERENT: u32 = 16;
pub const VM_UNINITIALIZED: u32 = 32;
pub const VM_NO_GUARD: u32 = 64;
pub const VM_KASAN: u32 = 128;
pub const VM_FLUSH_RESET_PERMS: u32 = 256;
pub const VM_MAP_PUT_PAGES: u32 = 512;
pub const VM_ALLOW_HUGE_VMAP: u32 = 1024;
pub const VM_DEFER_KMEMLEAK: u32 = 2048;
pub const ARCH_PAGE_TABLE_SYNC_MASK: u32 = 0;
pub const LZ4_DEFAULT_UNCOMPRESSED_CHUNK_SIZE: u32 = 8388608;
pub const ARCHIVE_MAGICNUMBER: u32 = 407642370;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_branch_data {
    pub func: *const ::std::os::raw::c_char,
    pub file: *const ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: ftrace_branch_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ftrace_branch_data__bindgen_ty_1 {
    pub __bindgen_anon_1: ftrace_branch_data__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: ftrace_branch_data__bindgen_ty_1__bindgen_ty_2,
    pub miss_hit: [::std::os::raw::c_ulong; 2usize],
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrace_branch_data__bindgen_ty_1__bindgen_ty_1 {
    pub correct: ::std::os::raw::c_ulong,
    pub incorrect: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ftrace_branch_data__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_1>())).correct
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(correct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_1>())).incorrect
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(incorrect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrace_branch_data__bindgen_ty_1__bindgen_ty_2 {
    pub miss: ::std::os::raw::c_ulong,
    pub hit: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ftrace_branch_data__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_2>())).miss
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(miss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ftrace_branch_data__bindgen_ty_1__bindgen_ty_2>())).hit
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hit)
        )
    );
}
#[test]
fn bindgen_test_layout_ftrace_branch_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ftrace_branch_data__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ftrace_branch_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ftrace_branch_data__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ftrace_branch_data__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ftrace_branch_data__bindgen_ty_1>())).miss_hit as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data__bindgen_ty_1),
            "::",
            stringify!(miss_hit)
        )
    );
}
#[test]
fn bindgen_test_layout_ftrace_branch_data() {
    assert_eq!(
        ::std::mem::size_of::<ftrace_branch_data>(),
        40usize,
        concat!("Size of: ", stringify!(ftrace_branch_data))
    );
    assert_eq!(
        ::std::mem::align_of::<ftrace_branch_data>(),
        8usize,
        concat!("Alignment of ", stringify!(ftrace_branch_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrace_branch_data>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrace_branch_data>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrace_branch_data>())).line as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_branch_data),
            "::",
            stringify!(line)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_likely_data {
    pub data: ftrace_branch_data,
    pub constant: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ftrace_likely_data() {
    assert_eq!(
        ::std::mem::size_of::<ftrace_likely_data>(),
        48usize,
        concat!("Size of: ", stringify!(ftrace_likely_data))
    );
    assert_eq!(
        ::std::mem::align_of::<ftrace_likely_data>(),
        8usize,
        concat!("Alignment of ", stringify!(ftrace_likely_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrace_likely_data>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_likely_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ftrace_likely_data>())).constant as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ftrace_likely_data),
            "::",
            stringify!(constant)
        )
    );
}
extern "C" {
    pub fn unlz4(
        inbuf: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_long,
        fill: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_ulong,
            ) -> ::std::os::raw::c_long,
        >,
        flush: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_ulong,
            ) -> ::std::os::raw::c_long,
        >,
        output: *mut ::std::os::raw::c_uchar,
        pos: *mut ::std::os::raw::c_long,
        error: ::std::option::Option<unsafe extern "C" fn(x: *mut ::std::os::raw::c_char)>,
    ) -> ::std::os::raw::c_int;
}
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type s8 = __s8;
pub type u8_ = __u8;
pub type s16 = __s16;
pub type u16_ = __u16;
pub type s32 = __s32;
pub type u32_ = __u32;
pub type s64 = __s64;
pub type u64_ = __u64;
pub const false_: ::std::os::raw::c_uint = 0;
pub const true_: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
pub type __kernel_dev_t = u32_;
pub type fd_set = __kernel_fd_set;
pub type dev_t = __kernel_dev_t;
pub type ino_t = __kernel_ulong_t;
pub type mode_t = __kernel_mode_t;
pub type umode_t = ::std::os::raw::c_ushort;
pub type nlink_t = u32_;
pub type off_t = __kernel_off_t;
pub type pid_t = __kernel_pid_t;
pub type daddr_t = __kernel_daddr_t;
pub type key_t = __kernel_key_t;
pub type suseconds_t = __kernel_suseconds_t;
pub type timer_t = __kernel_timer_t;
pub type clockid_t = __kernel_clockid_t;
pub type mqd_t = __kernel_mqd_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type uid16_t = __kernel_uid16_t;
pub type gid16_t = __kernel_gid16_t;
pub type old_uid_t = __kernel_old_uid_t;
pub type old_gid_t = __kernel_old_gid_t;
pub type loff_t = __kernel_loff_t;
pub type size_t = __kernel_size_t;
pub type ssize_t = __kernel_ssize_t;
pub type clock_t = __kernel_clock_t;
pub type caddr_t = __kernel_caddr_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type unchar = ::std::os::raw::c_uchar;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type ulong = ::std::os::raw::c_ulong;
pub type u_int8_t = u8_;
pub type u_int16_t = u16_;
pub type u_int32_t = u32_;
pub type u_int64_t = u64_;
#[doc = " The type used for indexing onto a disc or disc partition."]
#[doc = ""]
#[doc = " Linux always considers sectors to be 512 bytes long independently"]
#[doc = " of the devices real block size."]
#[doc = ""]
#[doc = " blkcnt_t is the type of the inode's block count."]
pub type sector_t = u64_;
pub type blkcnt_t = u64_;
pub type dma_addr_t = u64_;
pub type gfp_t = ::std::os::raw::c_uint;
pub type slab_flags_t = ::std::os::raw::c_uint;
pub type fmode_t = ::std::os::raw::c_uint;
pub type phys_addr_t = u64_;
pub type resource_size_t = phys_addr_t;
pub type irq_hw_number_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic_t {
    pub counter: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_atomic_t() {
    assert_eq!(
        ::std::mem::size_of::<atomic_t>(),
        4usize,
        concat!("Size of: ", stringify!(atomic_t))
    );
    assert_eq!(
        ::std::mem::align_of::<atomic_t>(),
        4usize,
        concat!("Alignment of ", stringify!(atomic_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atomic_t>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_t),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic64_t {
    pub counter: s64,
}
#[test]
fn bindgen_test_layout_atomic64_t() {
    assert_eq!(
        ::std::mem::size_of::<atomic64_t>(),
        8usize,
        concat!("Size of: ", stringify!(atomic64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<atomic64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(atomic64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atomic64_t>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic64_t),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
#[test]
fn bindgen_test_layout_list_head() {
    assert_eq!(
        ::std::mem::size_of::<list_head>(),
        16usize,
        concat!("Size of: ", stringify!(list_head))
    );
    assert_eq!(
        ::std::mem::align_of::<list_head>(),
        8usize,
        concat!("Alignment of ", stringify!(list_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_head>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_head),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_head() {
    assert_eq!(
        ::std::mem::size_of::<hlist_head>(),
        8usize,
        concat!("Size of: ", stringify!(hlist_head))
    );
    assert_eq!(
        ::std::mem::align_of::<hlist_head>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hlist_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_head),
            "::",
            stringify!(first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
#[test]
fn bindgen_test_layout_hlist_node() {
    assert_eq!(
        ::std::mem::size_of::<hlist_node>(),
        16usize,
        concat!("Size of: ", stringify!(hlist_node))
    );
    assert_eq!(
        ::std::mem::align_of::<hlist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hlist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hlist_node>())).pprev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_node),
            "::",
            stringify!(pprev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ustat {
    pub f_tfree: __kernel_daddr_t,
    pub f_tinode: ::std::os::raw::c_ulong,
    pub f_fname: [::std::os::raw::c_char; 6usize],
    pub f_fpack: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout_ustat() {
    assert_eq!(
        ::std::mem::size_of::<ustat>(),
        32usize,
        concat!("Size of: ", stringify!(ustat))
    );
    assert_eq!(
        ::std::mem::align_of::<ustat>(),
        8usize,
        concat!("Alignment of ", stringify!(ustat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ustat>())).f_tfree as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ustat),
            "::",
            stringify!(f_tfree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ustat>())).f_tinode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ustat),
            "::",
            stringify!(f_tinode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ustat>())).f_fname as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ustat),
            "::",
            stringify!(f_fname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ustat>())).f_fpack as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ustat),
            "::",
            stringify!(f_fpack)
        )
    );
}
#[doc = " struct callback_head - callback structure for use with RCU and task_work"]
#[doc = " @next: next update requests in a list"]
#[doc = " @func: actual update function to call after the grace period."]
#[doc = ""]
#[doc = " The struct is aligned to size of pointer. On most architectures it happens"]
#[doc = " naturally due ABI requirements, but some architectures (like CRIS) have"]
#[doc = " weird ABI and we need to ask it explicitly."]
#[doc = ""]
#[doc = " The alignment is required to guarantee that bit 0 of @next will be"]
#[doc = " clear under normal conditions -- as long as we use call_rcu() or"]
#[doc = " call_srcu() to queue the callback."]
#[doc = ""]
#[doc = " This guarantee is important for few reasons:"]
#[doc = "  - future call_rcu_lazy() will make use of lower bits in the pointer;"]
#[doc = "  - the structure shares storage space in struct page with @compound_head,"]
#[doc = "    which encode PageTail() in bit 0. The guarantee is needed to avoid"]
#[doc = "    false-positive PageTail()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::std::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
}
#[test]
fn bindgen_test_layout_callback_head() {
    assert_eq!(
        ::std::mem::size_of::<callback_head>(),
        16usize,
        concat!("Size of: ", stringify!(callback_head))
    );
    assert_eq!(
        ::std::mem::align_of::<callback_head>(),
        8usize,
        concat!("Alignment of ", stringify!(callback_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callback_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callback_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<callback_head>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(callback_head),
            "::",
            stringify!(func)
        )
    );
}
pub type rcu_callback_t = ::std::option::Option<unsafe extern "C" fn(head: *mut callback_head)>;
pub type call_rcu_func_t =
    ::std::option::Option<unsafe extern "C" fn(head: *mut callback_head, func: rcu_callback_t)>;
pub type swap_r_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
        priv_: *const ::std::os::raw::c_void,
    ),
>;
pub type swap_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
    ),
>;
pub type cmp_r_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
        priv_: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type cmp_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __kasan_check_read(
        p: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __kasan_check_write(
        p: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    ) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kcsan_scoped_access {}
#[test]
fn bindgen_test_layout_kcsan_scoped_access() {
    assert_eq!(
        ::std::mem::size_of::<kcsan_scoped_access>(),
        0usize,
        concat!("Size of: ", stringify!(kcsan_scoped_access))
    );
    assert_eq!(
        ::std::mem::align_of::<kcsan_scoped_access>(),
        1usize,
        concat!("Alignment of ", stringify!(kcsan_scoped_access))
    );
}
pub type va_list = __builtin_va_list;
extern "C" {
    pub fn strndup_user(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memdup_user(
        arg1: *const ::std::os::raw::c_void,
        arg2: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmemdup_user(
        arg1: *const ::std::os::raw::c_void,
        arg2: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memdup_user_nul(
        arg1: *const ::std::os::raw::c_void,
        arg2: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub static mut static_key_initialized: bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key {
    pub enabled: atomic_t,
    pub __bindgen_anon_1: static_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_key__bindgen_ty_1 {
    pub type_: ::std::os::raw::c_ulong,
    pub entries: *mut jump_entry,
    pub next: *mut static_key_mod,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_static_key__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<static_key__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(static_key__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<static_key__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(static_key__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_key__bindgen_ty_1>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<static_key__bindgen_ty_1>())).entries as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key__bindgen_ty_1),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_key__bindgen_ty_1>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
}
#[test]
fn bindgen_test_layout_static_key() {
    assert_eq!(
        ::std::mem::size_of::<static_key>(),
        16usize,
        concat!("Size of: ", stringify!(static_key))
    );
    assert_eq!(
        ::std::mem::align_of::<static_key>(),
        8usize,
        concat!("Alignment of ", stringify!(static_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_key>())).enabled as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key),
            "::",
            stringify!(enabled)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}rsp"]
    pub static mut current_stack_pointer: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut x86_nops: [*const ::std::os::raw::c_uchar; 0usize];
}
extern "C" {
    pub fn arch_jump_entry_size(entry: *mut jump_entry) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jump_entry {
    pub code: s32,
    pub target: s32,
    pub key: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_jump_entry() {
    assert_eq!(
        ::std::mem::size_of::<jump_entry>(),
        16usize,
        concat!("Size of: ", stringify!(jump_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<jump_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(jump_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jump_entry>())).code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jump_entry),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jump_entry>())).target as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(jump_entry),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jump_entry>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(jump_entry),
            "::",
            stringify!(key)
        )
    );
}
pub const jump_label_type_JUMP_LABEL_NOP: jump_label_type = 0;
pub const jump_label_type_JUMP_LABEL_JMP: jump_label_type = 1;
pub type jump_label_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut __start___jump_table: [jump_entry; 0usize];
}
extern "C" {
    pub static mut __stop___jump_table: [jump_entry; 0usize];
}
extern "C" {
    pub fn jump_label_init();
}
extern "C" {
    pub fn jump_label_lock();
}
extern "C" {
    pub fn jump_label_unlock();
}
extern "C" {
    pub fn arch_jump_label_transform(entry: *mut jump_entry, type_: jump_label_type);
}
extern "C" {
    pub fn arch_jump_label_transform_queue(entry: *mut jump_entry, type_: jump_label_type)
        -> bool_;
}
extern "C" {
    pub fn arch_jump_label_transform_apply();
}
extern "C" {
    pub fn jump_label_text_reserved(
        start: *mut ::std::os::raw::c_void,
        end: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn static_key_slow_inc(key: *mut static_key);
}
extern "C" {
    pub fn static_key_slow_dec(key: *mut static_key);
}
extern "C" {
    pub fn static_key_slow_inc_cpuslocked(key: *mut static_key);
}
extern "C" {
    pub fn static_key_slow_dec_cpuslocked(key: *mut static_key);
}
extern "C" {
    pub fn static_key_count(key: *mut static_key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn static_key_enable(key: *mut static_key);
}
extern "C" {
    pub fn static_key_disable(key: *mut static_key);
}
extern "C" {
    pub fn static_key_enable_cpuslocked(key: *mut static_key);
}
extern "C" {
    pub fn static_key_disable_cpuslocked(key: *mut static_key);
}
extern "C" {
    pub fn jump_label_init_type(entry: *mut jump_entry) -> jump_label_type;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_true {
    pub key: static_key,
}
#[test]
fn bindgen_test_layout_static_key_true() {
    assert_eq!(
        ::std::mem::size_of::<static_key_true>(),
        16usize,
        concat!("Size of: ", stringify!(static_key_true))
    );
    assert_eq!(
        ::std::mem::align_of::<static_key_true>(),
        8usize,
        concat!("Alignment of ", stringify!(static_key_true))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_key_true>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key_true),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_false {
    pub key: static_key,
}
#[test]
fn bindgen_test_layout_static_key_false() {
    assert_eq!(
        ::std::mem::size_of::<static_key_false>(),
        16usize,
        concat!("Size of: ", stringify!(static_key_false))
    );
    assert_eq!(
        ::std::mem::align_of::<static_key_false>(),
        8usize,
        concat!("Alignment of ", stringify!(static_key_false))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_key_false>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_key_false),
            "::",
            stringify!(key)
        )
    );
}
extern "C" {
    pub fn ____wrong_branch_error() -> bool_;
}
extern "C" {
    pub fn memcpy(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __memcpy(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        s: *mut ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __memset(
        s: *mut ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        dest: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __memmove(
        dest: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        count: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        cs: *const ::std::os::raw::c_void,
        ct: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcpy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        cs: *const ::std::os::raw::c_char,
        ct: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcpy_flushcache(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        cnt: size_t,
    );
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strscpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn strscpy_pad(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        count: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __kernel_size_t,
    ) -> size_t;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnchrnul(
        arg1: *const ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn skip_spaces(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strim(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: __kernel_size_t) -> __kernel_size_t;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __memcat_p(
        a: *mut *mut ::std::os::raw::c_void,
        b: *mut *mut ::std::os::raw::c_void,
    ) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memscan(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: __kernel_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memchr_inv(
        s: *const ::std::os::raw::c_void,
        c: ::std::os::raw::c_int,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strreplace(
        s: *mut ::std::os::raw::c_char,
        old: ::std::os::raw::c_char,
        new: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kfree_const(x: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn kstrdup(s: *const ::std::os::raw::c_char, gfp: gfp_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kstrdup_const(
        s: *const ::std::os::raw::c_char,
        gfp: gfp_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn kstrndup(
        s: *const ::std::os::raw::c_char,
        len: size_t,
        gfp: gfp_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kmemdup(
        src: *const ::std::os::raw::c_void,
        len: size_t,
        gfp: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmemdup_nul(
        s: *const ::std::os::raw::c_char,
        len: size_t,
        gfp: gfp_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn argv_split(
        gfp: gfp_t,
        str_: *const ::std::os::raw::c_char,
        argcp: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn argv_free(argv: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn sysfs_streq(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> bool_;
}
extern "C" {
    pub fn match_string(
        array: *const *const ::std::os::raw::c_char,
        n: size_t,
        string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sysfs_match_string(
        array: *const *const ::std::os::raw::c_char,
        n: size_t,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vbin_printf(
        bin_buf: *mut u32_,
        size: size_t,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bstr_printf(
        buf: *mut ::std::os::raw::c_char,
        size: size_t,
        fmt: *const ::std::os::raw::c_char,
        bin_buf: *const u32_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bprintf(
        bin_buf: *mut u32_,
        size: size_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memory_read_from_buffer(
        to: *mut ::std::os::raw::c_void,
        count: size_t,
        ppos: *mut loff_t,
        from: *const ::std::os::raw::c_void,
        available: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn ptr_to_hashval(
        ptr: *const ::std::os::raw::c_void,
        hashval_out: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memweight(ptr: *const ::std::os::raw::c_void, bytes: size_t) -> size_t;
}
extern "C" {
    pub fn memcpy_and_pad(
        dest: *mut ::std::os::raw::c_void,
        dest_len: size_t,
        src: *const ::std::os::raw::c_void,
        count: size_t,
        pad: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LZ4_stream_t_internal {
    pub hashTable: [u32; 4096usize],
    pub currentOffset: u32,
    pub initCheck: u32,
    pub dictionary: *const u8,
    pub bufferStart: *mut u8,
    pub dictSize: u32,
}
#[test]
fn bindgen_test_layout_LZ4_stream_t_internal() {
    assert_eq!(
        ::std::mem::size_of::<LZ4_stream_t_internal>(),
        16416usize,
        concat!("Size of: ", stringify!(LZ4_stream_t_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_stream_t_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_stream_t_internal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_t_internal>())).hashTable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(hashTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_stream_t_internal>())).currentOffset as *const _ as usize
        },
        16384usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(currentOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_t_internal>())).initCheck as *const _ as usize },
        16388usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(initCheck)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_stream_t_internal>())).dictionary as *const _ as usize
        },
        16392usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictionary)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_stream_t_internal>())).bufferStart as *const _ as usize
        },
        16400usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(bufferStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_t_internal>())).dictSize as *const _ as usize },
        16408usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_stream_t {
    pub table: [::std::os::raw::c_ulonglong; 2052usize],
    pub internal_donotuse: LZ4_stream_t_internal,
    _bindgen_union_align: [u64; 2052usize],
}
#[test]
fn bindgen_test_layout_LZ4_stream_t() {
    assert_eq!(
        ::std::mem::size_of::<LZ4_stream_t>(),
        16416usize,
        concat!("Size of: ", stringify!(LZ4_stream_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_stream_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_stream_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_t>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_stream_t>())).internal_donotuse as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct LZ4HC_CCtx_internal {
    pub hashTable: [::std::os::raw::c_uint; 32768usize],
    pub chainTable: [::std::os::raw::c_ushort; 65536usize],
    pub end: *const ::std::os::raw::c_uchar,
    pub base: *const ::std::os::raw::c_uchar,
    pub dictBase: *const ::std::os::raw::c_uchar,
    pub dictLimit: ::std::os::raw::c_uint,
    pub lowLimit: ::std::os::raw::c_uint,
    pub nextToUpdate: ::std::os::raw::c_uint,
    pub compressionLevel: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_LZ4HC_CCtx_internal() {
    assert_eq!(
        ::std::mem::size_of::<LZ4HC_CCtx_internal>(),
        262184usize,
        concat!("Size of: ", stringify!(LZ4HC_CCtx_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4HC_CCtx_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4HC_CCtx_internal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).hashTable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(hashTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).chainTable as *const _ as usize },
        131072usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(chainTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).end as *const _ as usize },
        262144usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).base as *const _ as usize },
        262152usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).dictBase as *const _ as usize },
        262160usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(dictBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).dictLimit as *const _ as usize },
        262168usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(dictLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).lowLimit as *const _ as usize },
        262172usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(lowLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).nextToUpdate as *const _ as usize
        },
        262176usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(nextToUpdate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4HC_CCtx_internal>())).compressionLevel as *const _ as usize
        },
        262180usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(compressionLevel)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_streamHC_t {
    pub table: [size_t; 32774usize],
    pub internal_donotuse: LZ4HC_CCtx_internal,
    _bindgen_union_align: [u64; 32774usize],
}
#[test]
fn bindgen_test_layout_LZ4_streamHC_t() {
    assert_eq!(
        ::std::mem::size_of::<LZ4_streamHC_t>(),
        262192usize,
        concat!("Size of: ", stringify!(LZ4_streamHC_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_streamHC_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamHC_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_streamHC_t>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamHC_t),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamHC_t>())).internal_donotuse as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamHC_t),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4_streamDecode_t_internal {
    pub externalDict: *const u8,
    pub extDictSize: size_t,
    pub prefixEnd: *const u8,
    pub prefixSize: size_t,
}
#[test]
fn bindgen_test_layout_LZ4_streamDecode_t_internal() {
    assert_eq!(
        ::std::mem::size_of::<LZ4_streamDecode_t_internal>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4_streamDecode_t_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_streamDecode_t_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamDecode_t_internal))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamDecode_t_internal>())).externalDict as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(externalDict)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamDecode_t_internal>())).extDictSize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(extDictSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamDecode_t_internal>())).prefixEnd as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(prefixEnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamDecode_t_internal>())).prefixSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(prefixSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_streamDecode_t {
    pub table: [::std::os::raw::c_ulonglong; 4usize],
    pub internal_donotuse: LZ4_streamDecode_t_internal,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_LZ4_streamDecode_t() {
    assert_eq!(
        ::std::mem::size_of::<LZ4_streamDecode_t>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4_streamDecode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_streamDecode_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamDecode_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LZ4_streamDecode_t>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<LZ4_streamDecode_t>())).internal_donotuse as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
extern "C" {
    #[doc = " LZ4_compress_default() - Compress data from source to dest"]
    #[doc = " @source: source address of the original data"]
    #[doc = " @dest: output buffer address of the compressed data"]
    #[doc = " @inputSize: size of the input data. Max supported value is LZ4_MAX_INPUT_SIZE"]
    #[doc = " @maxOutputSize: full or partial size of buffer 'dest'"]
    #[doc = "\twhich must be already allocated"]
    #[doc = " @wrkmem: address of the working memory."]
    #[doc = "\tThis requires 'workmem' of LZ4_MEM_COMPRESS."]
    #[doc = ""]
    #[doc = " Compresses 'sourceSize' bytes from buffer 'source'"]
    #[doc = " into already allocated 'dest' buffer of size 'maxOutputSize'."]
    #[doc = " Compression is guaranteed to succeed if"]
    #[doc = " 'maxOutputSize' >= LZ4_compressBound(inputSize)."]
    #[doc = " It also runs faster, so it's a recommended setting."]
    #[doc = " If the function cannot compress 'source' into a more limited 'dest' budget,"]
    #[doc = " compression stops *immediately*, and the function result is zero."]
    #[doc = " As a consequence, 'dest' content is not valid."]
    #[doc = ""]
    #[doc = " Return: Number of bytes written into buffer 'dest'"]
    #[doc = "\t(necessarily <= maxOutputSize) or 0 if compression fails"]
    pub fn LZ4_compress_default(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
        wrkmem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast() - As LZ4_compress_default providing an acceleration param"]
    #[doc = " @source: source address of the original data"]
    #[doc = " @dest: output buffer address of the compressed data"]
    #[doc = " @inputSize: size of the input data. Max supported value is LZ4_MAX_INPUT_SIZE"]
    #[doc = " @maxOutputSize: full or partial size of buffer 'dest'"]
    #[doc = "\twhich must be already allocated"]
    #[doc = " @acceleration: acceleration factor"]
    #[doc = " @wrkmem: address of the working memory."]
    #[doc = "\tThis requires 'workmem' of LZ4_MEM_COMPRESS."]
    #[doc = ""]
    #[doc = " Same as LZ4_compress_default(), but allows to select an \"acceleration\""]
    #[doc = " factor. The larger the acceleration value, the faster the algorithm,"]
    #[doc = " but also the lesser the compression. It's a trade-off. It can be fine tuned,"]
    #[doc = " with each successive value providing roughly +~3% to speed."]
    #[doc = " An acceleration value of \"1\" is the same as regular LZ4_compress_default()"]
    #[doc = " Values <= 0 will be replaced by LZ4_ACCELERATION_DEFAULT, which is 1."]
    #[doc = ""]
    #[doc = " Return: Number of bytes written into buffer 'dest'"]
    #[doc = "\t(necessarily <= maxOutputSize) or 0 if compression fails"]
    pub fn LZ4_compress_fast(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
        acceleration: ::std::os::raw::c_int,
        wrkmem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_destSize() - Compress as much data as possible"]
    #[doc = "\tfrom source to dest"]
    #[doc = " @source: source address of the original data"]
    #[doc = " @dest: output buffer address of the compressed data"]
    #[doc = " @sourceSizePtr: will be modified to indicate how many bytes where read"]
    #[doc = "\tfrom 'source' to fill 'dest'. New value is necessarily <= old value."]
    #[doc = " @targetDestSize: Size of buffer 'dest' which must be already allocated"]
    #[doc = " @wrkmem: address of the working memory."]
    #[doc = "\tThis requires 'workmem' of LZ4_MEM_COMPRESS."]
    #[doc = ""]
    #[doc = " Reverse the logic, by compressing as much data as possible"]
    #[doc = " from 'source' buffer into already allocated buffer 'dest'"]
    #[doc = " of size 'targetDestSize'."]
    #[doc = " This function either compresses the entire 'source' content into 'dest'"]
    #[doc = " if it's large enough, or fill 'dest' buffer completely with as much data as"]
    #[doc = " possible from 'source'."]
    #[doc = ""]
    #[doc = " Return: Number of bytes written into 'dest' (necessarily <= targetDestSize)"]
    #[doc = "\tor 0 if compression fails"]
    pub fn LZ4_compress_destSize(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        sourceSizePtr: *mut ::std::os::raw::c_int,
        targetDestSize: ::std::os::raw::c_int,
        wrkmem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_fast() - Decompresses data from 'source' into 'dest'"]
    #[doc = " @source: source address of the compressed data"]
    #[doc = " @dest: output buffer address of the uncompressed data"]
    #[doc = "\twhich must be already allocated with 'originalSize' bytes"]
    #[doc = " @originalSize: is the original and therefore uncompressed size"]
    #[doc = ""]
    #[doc = " Decompresses data from 'source' into 'dest'."]
    #[doc = " This function fully respect memory boundaries for properly formed"]
    #[doc = " compressed data."]
    #[doc = " It is a bit faster than LZ4_decompress_safe()."]
    #[doc = " However, it does not provide any protection against intentionally"]
    #[doc = " modified data stream (malicious input)."]
    #[doc = " Use this function in trusted environment only"]
    #[doc = " (data to decode comes from a trusted source)."]
    #[doc = ""]
    #[doc = " Return: number of bytes read from the source buffer"]
    #[doc = "\tor a negative result if decompression fails."]
    pub fn LZ4_decompress_fast(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe() - Decompression protected against buffer overflow"]
    #[doc = " @source: source address of the compressed data"]
    #[doc = " @dest: output buffer address of the uncompressed data"]
    #[doc = "\twhich must be already allocated"]
    #[doc = " @compressedSize: is the precise full size of the compressed block"]
    #[doc = " @maxDecompressedSize: is the size of 'dest' buffer"]
    #[doc = ""]
    #[doc = " Decompresses data from 'source' into 'dest'."]
    #[doc = " If the source stream is detected malformed, the function will"]
    #[doc = " stop decoding and return a negative result."]
    #[doc = " This function is protected against buffer overflow exploits,"]
    #[doc = " including malicious data packets. It never writes outside output buffer,"]
    #[doc = " nor reads outside input buffer."]
    #[doc = ""]
    #[doc = " Return: number of bytes decompressed into destination buffer"]
    #[doc = "\t(necessarily <= maxDecompressedSize)"]
    #[doc = "\tor a negative result in case of error"]
    pub fn LZ4_decompress_safe(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        maxDecompressedSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe_partial() - Decompress a block of size 'compressedSize'"]
    #[doc = "\tat position 'source' into buffer 'dest'"]
    #[doc = " @source: source address of the compressed data"]
    #[doc = " @dest: output buffer address of the decompressed data which must be"]
    #[doc = "\talready allocated"]
    #[doc = " @compressedSize: is the precise full size of the compressed block."]
    #[doc = " @targetOutputSize: the decompression operation will try"]
    #[doc = "\tto stop as soon as 'targetOutputSize' has been reached"]
    #[doc = " @maxDecompressedSize: is the size of destination buffer"]
    #[doc = ""]
    #[doc = " This function decompresses a compressed block of size 'compressedSize'"]
    #[doc = " at position 'source' into destination buffer 'dest'"]
    #[doc = " of size 'maxDecompressedSize'."]
    #[doc = " The function tries to stop decompressing operation as soon as"]
    #[doc = " 'targetOutputSize' has been reached, reducing decompression time."]
    #[doc = " This function never writes outside of output buffer,"]
    #[doc = " and never reads outside of input buffer."]
    #[doc = " It is therefore protected against malicious data packets."]
    #[doc = ""]
    #[doc = " Return: the number of bytes decoded in the destination buffer"]
    #[doc = "\t(necessarily <= maxDecompressedSize)"]
    #[doc = "\tor a negative result in case of error"]
    #[doc = ""]
    pub fn LZ4_decompress_safe_partial(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        targetOutputSize: ::std::os::raw::c_int,
        maxDecompressedSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_HC() - Compress data from `src` into `dst`, using HC algorithm"]
    #[doc = " @src: source address of the original data"]
    #[doc = " @dst: output buffer address of the compressed data"]
    #[doc = " @srcSize: size of the input data. Max supported value is LZ4_MAX_INPUT_SIZE"]
    #[doc = " @dstCapacity: full or partial size of buffer 'dst',"]
    #[doc = "\twhich must be already allocated"]
    #[doc = " @compressionLevel: Recommended values are between 4 and 9, although any"]
    #[doc = "\tvalue between 1 and LZ4HC_MAX_CLEVEL will work."]
    #[doc = "\tValues >LZ4HC_MAX_CLEVEL behave the same as 16."]
    #[doc = " @wrkmem: address of the working memory."]
    #[doc = "\tThis requires 'wrkmem' of size LZ4HC_MEM_COMPRESS."]
    #[doc = ""]
    #[doc = " Compress data from 'src' into 'dst', using the more powerful"]
    #[doc = " but slower \"HC\" algorithm. Compression is guaranteed to succeed if"]
    #[doc = " `dstCapacity >= LZ4_compressBound(srcSize)"]
    #[doc = ""]
    #[doc = " Return : the number of bytes written into 'dst' or 0 if compression fails."]
    pub fn LZ4_compress_HC(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
        wrkmem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_resetStreamHC() - Init an allocated 'LZ4_streamHC_t' structure"]
    #[doc = " @streamHCPtr: pointer to the 'LZ4_streamHC_t' structure"]
    #[doc = " @compressionLevel: Recommended values are between 4 and 9, although any"]
    #[doc = "\tvalue between 1 and LZ4HC_MAX_CLEVEL will work."]
    #[doc = "\tValues >LZ4HC_MAX_CLEVEL behave the same as 16."]
    #[doc = ""]
    #[doc = " An LZ4_streamHC_t structure can be allocated once"]
    #[doc = " and re-used multiple times."]
    #[doc = " Use this function to init an allocated `LZ4_streamHC_t` structure"]
    #[doc = " and start a new compression."]
    pub fn LZ4_resetStreamHC(
        streamHCPtr: *mut LZ4_streamHC_t,
        compressionLevel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " LZ4_loadDictHC() - Load a static dictionary into LZ4_streamHC"]
    #[doc = " @streamHCPtr: pointer to the LZ4HC_stream_t"]
    #[doc = " @dictionary: dictionary to load"]
    #[doc = " @dictSize: size of dictionary"]
    #[doc = ""]
    #[doc = " Use this function to load a static dictionary into LZ4HC_stream."]
    #[doc = " Any previous data will be forgotten, only 'dictionary'"]
    #[doc = " will remain in memory."]
    #[doc = " Loading a size of 0 is allowed."]
    #[doc = ""]
    #[doc = " Return : dictionary size, in bytes (necessarily <= 64 KB)"]
    pub fn LZ4_loadDictHC(
        streamHCPtr: *mut LZ4_streamHC_t,
        dictionary: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_HC_continue() - Compress 'src' using data from previously"]
    #[doc = "\tcompressed blocks as a dictionary using the HC algorithm"]
    #[doc = " @streamHCPtr: Pointer to the previous 'LZ4_streamHC_t' structure"]
    #[doc = " @src: source address of the original data"]
    #[doc = " @dst: output buffer address of the compressed data,"]
    #[doc = "\twhich must be already allocated"]
    #[doc = " @srcSize: size of the input data. Max supported value is LZ4_MAX_INPUT_SIZE"]
    #[doc = " @maxDstSize: full or partial size of buffer 'dest'"]
    #[doc = "\twhich must be already allocated"]
    #[doc = ""]
    #[doc = " These functions compress data in successive blocks of any size, using"]
    #[doc = " previous blocks as dictionary. One key assumption is that previous"]
    #[doc = " blocks (up to 64 KB) remain read-accessible while"]
    #[doc = " compressing next blocks. There is an exception for ring buffers,"]
    #[doc = " which can be smaller than 64 KB."]
    #[doc = " Ring buffers scenario is automatically detected and handled by"]
    #[doc = " LZ4_compress_HC_continue()."]
    #[doc = " Before starting compression, state must be properly initialized,"]
    #[doc = " using LZ4_resetStreamHC()."]
    #[doc = " A first \"fictional block\" can then be designated as"]
    #[doc = " initial dictionary, using LZ4_loadDictHC() (Optional)."]
    #[doc = " Then, use LZ4_compress_HC_continue()"]
    #[doc = " to compress each successive block. Previous memory blocks"]
    #[doc = " (including initial dictionary when present) must remain accessible"]
    #[doc = " and unmodified during compression."]
    #[doc = " 'dst' buffer should be sized to handle worst case scenarios, using"]
    #[doc = "  LZ4_compressBound(), to ensure operation success."]
    #[doc = "  If, for any reason, previous data blocks can't be preserved unmodified"]
    #[doc = "  in memory during next compression block,"]
    #[doc = "  you must save it to a safer memory space, using LZ4_saveDictHC()."]
    #[doc = " Return value of LZ4_saveDictHC() is the size of dictionary"]
    #[doc = " effectively saved into 'safeBuffer'."]
    #[doc = ""]
    #[doc = " Return: Number of bytes written into buffer 'dst'  or 0 if compression fails"]
    pub fn LZ4_compress_HC_continue(
        streamHCPtr: *mut LZ4_streamHC_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        maxDstSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_saveDictHC() - Save static dictionary from LZ4HC_stream"]
    #[doc = " @streamHCPtr: pointer to the 'LZ4HC_stream_t' structure"]
    #[doc = " @safeBuffer: buffer to save dictionary to, must be already allocated"]
    #[doc = " @maxDictSize: size of 'safeBuffer'"]
    #[doc = ""]
    #[doc = " If previously compressed data block is not guaranteed"]
    #[doc = " to remain available at its memory location,"]
    #[doc = " save it into a safer place (char *safeBuffer)."]
    #[doc = " Note : you don't need to call LZ4_loadDictHC() afterwards,"]
    #[doc = " dictionary is immediately usable, you can therefore call"]
    #[doc = " LZ4_compress_HC_continue()."]
    #[doc = ""]
    #[doc = " Return : saved dictionary size in bytes (necessarily <= maxDictSize),"]
    #[doc = "\tor 0 if error."]
    pub fn LZ4_saveDictHC(
        streamHCPtr: *mut LZ4_streamHC_t,
        safeBuffer: *mut ::std::os::raw::c_char,
        maxDictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_resetStream() - Init an allocated 'LZ4_stream_t' structure"]
    #[doc = " @LZ4_stream: pointer to the 'LZ4_stream_t' structure"]
    #[doc = ""]
    #[doc = " An LZ4_stream_t structure can be allocated once"]
    #[doc = " and re-used multiple times."]
    #[doc = " Use this function to init an allocated `LZ4_stream_t` structure"]
    #[doc = " and start a new compression."]
    pub fn LZ4_resetStream(LZ4_stream: *mut LZ4_stream_t);
}
extern "C" {
    #[doc = " LZ4_loadDict() - Load a static dictionary into LZ4_stream"]
    #[doc = " @streamPtr: pointer to the LZ4_stream_t"]
    #[doc = " @dictionary: dictionary to load"]
    #[doc = " @dictSize: size of dictionary"]
    #[doc = ""]
    #[doc = " Use this function to load a static dictionary into LZ4_stream."]
    #[doc = " Any previous data will be forgotten, only 'dictionary'"]
    #[doc = " will remain in memory."]
    #[doc = " Loading a size of 0 is allowed."]
    #[doc = ""]
    #[doc = " Return : dictionary size, in bytes (necessarily <= 64 KB)"]
    pub fn LZ4_loadDict(
        streamPtr: *mut LZ4_stream_t,
        dictionary: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_saveDict() - Save static dictionary from LZ4_stream"]
    #[doc = " @streamPtr: pointer to the 'LZ4_stream_t' structure"]
    #[doc = " @safeBuffer: buffer to save dictionary to, must be already allocated"]
    #[doc = " @dictSize: size of 'safeBuffer'"]
    #[doc = ""]
    #[doc = " If previously compressed data block is not guaranteed"]
    #[doc = " to remain available at its memory location,"]
    #[doc = " save it into a safer place (char *safeBuffer)."]
    #[doc = " Note : you don't need to call LZ4_loadDict() afterwards,"]
    #[doc = " dictionary is immediately usable, you can therefore call"]
    #[doc = " LZ4_compress_fast_continue()."]
    #[doc = ""]
    #[doc = " Return : saved dictionary size in bytes (necessarily <= dictSize),"]
    #[doc = "\tor 0 if error."]
    pub fn LZ4_saveDict(
        streamPtr: *mut LZ4_stream_t,
        safeBuffer: *mut ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast_continue() - Compress 'src' using data from previously"]
    #[doc = "\tcompressed blocks as a dictionary"]
    #[doc = " @streamPtr: Pointer to the previous 'LZ4_stream_t' structure"]
    #[doc = " @src: source address of the original data"]
    #[doc = " @dst: output buffer address of the compressed data,"]
    #[doc = "\twhich must be already allocated"]
    #[doc = " @srcSize: size of the input data. Max supported value is LZ4_MAX_INPUT_SIZE"]
    #[doc = " @maxDstSize: full or partial size of buffer 'dest'"]
    #[doc = "\twhich must be already allocated"]
    #[doc = " @acceleration: acceleration factor"]
    #[doc = ""]
    #[doc = " Compress buffer content 'src', using data from previously compressed blocks"]
    #[doc = " as dictionary to improve compression ratio."]
    #[doc = " Important : Previous data blocks are assumed to still"]
    #[doc = " be present and unmodified !"]
    #[doc = " If maxDstSize >= LZ4_compressBound(srcSize),"]
    #[doc = " compression is guaranteed to succeed, and runs faster."]
    #[doc = ""]
    #[doc = " Return: Number of bytes written into buffer 'dst'  or 0 if compression fails"]
    pub fn LZ4_compress_fast_continue(
        streamPtr: *mut LZ4_stream_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        maxDstSize: ::std::os::raw::c_int,
        acceleration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_setStreamDecode() - Instruct where to find dictionary"]
    #[doc = " @LZ4_streamDecode: the 'LZ4_streamDecode_t' structure"]
    #[doc = " @dictionary: dictionary to use"]
    #[doc = " @dictSize: size of dictionary"]
    #[doc = ""]
    #[doc = " Use this function to instruct where to find the dictionary."]
    #[doc = "\tSetting a size of 0 is allowed (same effect as reset)."]
    #[doc = ""]
    #[doc = " Return: 1 if OK, 0 if error"]
    pub fn LZ4_setStreamDecode(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        dictionary: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe_continue() - Decompress blocks in streaming mode"]
    #[doc = " @LZ4_streamDecode: the 'LZ4_streamDecode_t' structure"]
    #[doc = " @source: source address of the compressed data"]
    #[doc = " @dest: output buffer address of the uncompressed data"]
    #[doc = "\twhich must be already allocated"]
    #[doc = " @compressedSize: is the precise full size of the compressed block"]
    #[doc = " @maxDecompressedSize: is the size of 'dest' buffer"]
    #[doc = ""]
    #[doc = " This decoding function allows decompression of multiple blocks"]
    #[doc = " in \"streaming\" mode."]
    #[doc = " Previously decoded blocks *must* remain available at the memory position"]
    #[doc = " where they were decoded (up to 64 KB)"]
    #[doc = " In the case of a ring buffers, decoding buffer must be either :"]
    #[doc = "    - Exactly same size as encoding buffer, with same update rule"]
    #[doc = "      (block boundaries at same positions) In which case,"]
    #[doc = "      the decoding & encoding ring buffer can have any size,"]
    #[doc = "      including very small ones ( < 64 KB)."]
    #[doc = "    - Larger than encoding buffer, by a minimum of maxBlockSize more bytes."]
    #[doc = "      maxBlockSize is implementation dependent."]
    #[doc = "      It's the maximum size you intend to compress into a single block."]
    #[doc = "      In which case, encoding and decoding buffers do not need"]
    #[doc = "      to be synchronized, and encoding ring buffer can have any size,"]
    #[doc = "      including small ones ( < 64 KB)."]
    #[doc = "    - _At least_ 64 KB + 8 bytes + maxBlockSize."]
    #[doc = "      In which case, encoding and decoding buffers do not need to be"]
    #[doc = "      synchronized, and encoding ring buffer can have any size,"]
    #[doc = "      including larger than decoding buffer. W"]
    #[doc = " Whenever these conditions are not possible, save the last 64KB of decoded"]
    #[doc = " data into a safe buffer, and indicate where it is saved"]
    #[doc = " using LZ4_setStreamDecode()"]
    #[doc = ""]
    #[doc = " Return: number of bytes decompressed into destination buffer"]
    #[doc = "\t(necessarily <= maxDecompressedSize)"]
    #[doc = "\tor a negative result in case of error"]
    pub fn LZ4_decompress_safe_continue(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        maxDecompressedSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_fast_continue() - Decompress blocks in streaming mode"]
    #[doc = " @LZ4_streamDecode: the 'LZ4_streamDecode_t' structure"]
    #[doc = " @source: source address of the compressed data"]
    #[doc = " @dest: output buffer address of the uncompressed data"]
    #[doc = "\twhich must be already allocated with 'originalSize' bytes"]
    #[doc = " @originalSize: is the original and therefore uncompressed size"]
    #[doc = ""]
    #[doc = " This decoding function allows decompression of multiple blocks"]
    #[doc = " in \"streaming\" mode."]
    #[doc = " Previously decoded blocks *must* remain available at the memory position"]
    #[doc = " where they were decoded (up to 64 KB)"]
    #[doc = " In the case of a ring buffers, decoding buffer must be either :"]
    #[doc = "    - Exactly same size as encoding buffer, with same update rule"]
    #[doc = "      (block boundaries at same positions) In which case,"]
    #[doc = "      the decoding & encoding ring buffer can have any size,"]
    #[doc = "      including very small ones ( < 64 KB)."]
    #[doc = "    - Larger than encoding buffer, by a minimum of maxBlockSize more bytes."]
    #[doc = "      maxBlockSize is implementation dependent."]
    #[doc = "      It's the maximum size you intend to compress into a single block."]
    #[doc = "      In which case, encoding and decoding buffers do not need"]
    #[doc = "      to be synchronized, and encoding ring buffer can have any size,"]
    #[doc = "      including small ones ( < 64 KB)."]
    #[doc = "    - _At least_ 64 KB + 8 bytes + maxBlockSize."]
    #[doc = "      In which case, encoding and decoding buffers do not need to be"]
    #[doc = "      synchronized, and encoding ring buffer can have any size,"]
    #[doc = "      including larger than decoding buffer. W"]
    #[doc = " Whenever these conditions are not possible, save the last 64KB of decoded"]
    #[doc = " data into a safe buffer, and indicate where it is saved"]
    #[doc = " using LZ4_setStreamDecode()"]
    #[doc = ""]
    #[doc = " Return: number of bytes decompressed into destination buffer"]
    #[doc = "\t(necessarily <= maxDecompressedSize)"]
    #[doc = "\tor a negative result in case of error"]
    pub fn LZ4_decompress_fast_continue(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe_usingDict() - Same as LZ4_setStreamDecode()"]
    #[doc = "\tfollowed by LZ4_decompress_safe_continue()"]
    #[doc = " @source: source address of the compressed data"]
    #[doc = " @dest: output buffer address of the uncompressed data"]
    #[doc = "\twhich must be already allocated"]
    #[doc = " @compressedSize: is the precise full size of the compressed block"]
    #[doc = " @maxDecompressedSize: is the size of 'dest' buffer"]
    #[doc = " @dictStart: pointer to the start of the dictionary in memory"]
    #[doc = " @dictSize: size of dictionary"]
    #[doc = ""]
    #[doc = " This decoding function works the same as"]
    #[doc = " a combination of LZ4_setStreamDecode() followed by"]
    #[doc = " LZ4_decompress_safe_continue()"]
    #[doc = " It is stand-alone, and doesn't need an LZ4_streamDecode_t structure."]
    #[doc = ""]
    #[doc = " Return: number of bytes decompressed into destination buffer"]
    #[doc = "\t(necessarily <= maxDecompressedSize)"]
    #[doc = "\tor a negative result in case of error"]
    pub fn LZ4_decompress_safe_usingDict(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        maxDecompressedSize: ::std::os::raw::c_int,
        dictStart: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_fast_usingDict() - Same as LZ4_setStreamDecode()"]
    #[doc = "\tfollowed by LZ4_decompress_fast_continue()"]
    #[doc = " @source: source address of the compressed data"]
    #[doc = " @dest: output buffer address of the uncompressed data"]
    #[doc = "\twhich must be already allocated with 'originalSize' bytes"]
    #[doc = " @originalSize: is the original and therefore uncompressed size"]
    #[doc = " @dictStart: pointer to the start of the dictionary in memory"]
    #[doc = " @dictSize: size of dictionary"]
    #[doc = ""]
    #[doc = " This decoding function works the same as"]
    #[doc = " a combination of LZ4_setStreamDecode() followed by"]
    #[doc = " LZ4_decompress_fast_continue()"]
    #[doc = " It is stand-alone, and doesn't need an LZ4_streamDecode_t structure."]
    #[doc = ""]
    #[doc = " Return: number of bytes decompressed into destination buffer"]
    #[doc = "\t(necessarily <= maxDecompressedSize)"]
    #[doc = "\tor a negative result in case of error"]
    pub fn LZ4_decompress_fast_usingDict(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
        dictStart: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_symbol {
    pub value_offset: ::std::os::raw::c_int,
    pub name_offset: ::std::os::raw::c_int,
    pub namespace_offset: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_kernel_symbol() {
    assert_eq!(
        ::std::mem::size_of::<kernel_symbol>(),
        12usize,
        concat!("Size of: ", stringify!(kernel_symbol))
    );
    assert_eq!(
        ::std::mem::align_of::<kernel_symbol>(),
        4usize,
        concat!("Alignment of ", stringify!(kernel_symbol))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_symbol>())).value_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_symbol),
            "::",
            stringify!(value_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_symbol>())).name_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_symbol),
            "::",
            stringify!(name_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_symbol>())).namespace_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_symbol),
            "::",
            stringify!(namespace_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct sysinfo {
    pub uptime: __kernel_long_t,
    pub loads: [__kernel_ulong_t; 3usize],
    pub totalram: __kernel_ulong_t,
    pub freeram: __kernel_ulong_t,
    pub sharedram: __kernel_ulong_t,
    pub bufferram: __kernel_ulong_t,
    pub totalswap: __kernel_ulong_t,
    pub freeswap: __kernel_ulong_t,
    pub procs: __u16,
    pub pad: __u16,
    pub totalhigh: __kernel_ulong_t,
    pub freehigh: __kernel_ulong_t,
    pub mem_unit: __u32,
    pub _f: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_sysinfo() {
    assert_eq!(
        ::std::mem::size_of::<sysinfo>(),
        112usize,
        concat!("Size of: ", stringify!(sysinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<sysinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(sysinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).uptime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(uptime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).loads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(loads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).totalram as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(totalram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).freeram as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(freeram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).sharedram as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(sharedram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).bufferram as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(bufferram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).totalswap as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(totalswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).freeswap as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(freeswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).procs as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(procs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).pad as *const _ as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).totalhigh as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(totalhigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).freehigh as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(freehigh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>())).mem_unit as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(mem_unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysinfo>()))._f as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinfo),
            "::",
            stringify!(_f)
        )
    );
}
extern "C" {
    pub fn __sw_hweight8(w: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __sw_hweight16(w: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __sw_hweight32(w: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __sw_hweight64(w: __u64) -> ::std::os::raw::c_ulong;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct alt_instr {
    pub instr_offset: s32,
    pub repl_offset: s32,
    pub cpuid: u16_,
    pub instrlen: u8_,
    pub replacementlen: u8_,
}
#[test]
fn bindgen_test_layout_alt_instr() {
    assert_eq!(
        ::std::mem::size_of::<alt_instr>(),
        12usize,
        concat!("Size of: ", stringify!(alt_instr))
    );
    assert_eq!(
        ::std::mem::align_of::<alt_instr>(),
        1usize,
        concat!("Alignment of ", stringify!(alt_instr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).instr_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(instr_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).repl_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(repl_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).cpuid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(cpuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).instrlen as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(instrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_instr>())).replacementlen as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_instr),
            "::",
            stringify!(replacementlen)
        )
    );
}
extern "C" {
    pub static mut alternatives_patched: ::std::os::raw::c_int;
}
extern "C" {
    pub fn alternative_instructions();
}
extern "C" {
    pub fn apply_alternatives(start: *mut alt_instr, end: *mut alt_instr);
}
extern "C" {
    pub fn apply_retpolines(start: *mut s32, end: *mut s32);
}
extern "C" {
    pub fn apply_returns(start: *mut s32, end: *mut s32);
}
extern "C" {
    pub fn apply_ibt_endbr(start: *mut s32, end: *mut s32);
}
extern "C" {
    pub fn alternatives_smp_module_add(
        mod_: *mut module,
        name: *mut ::std::os::raw::c_char,
        locks: *mut ::std::os::raw::c_void,
        locks_end: *mut ::std::os::raw::c_void,
        text: *mut ::std::os::raw::c_void,
        text_end: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn alternatives_smp_module_del(mod_: *mut module);
}
extern "C" {
    pub fn alternatives_enable_smp();
}
extern "C" {
    pub fn alternatives_text_reserved(
        start: *mut ::std::os::raw::c_void,
        end: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut skip_smp_alternatives: bool_;
}
extern "C" {
    pub fn _kstrtoul(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _kstrtol(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoull(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoll(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtouint(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoint(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou16(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut u16_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos16(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut s16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou8(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut u8_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos8(
        s: *const ::std::os::raw::c_char,
        base: ::std::os::raw::c_uint,
        res: *mut s8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtobool(s: *const ::std::os::raw::c_char, res: *mut bool_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoull_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoll_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoul_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtol_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtouint_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtoint_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou16_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut u16_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos16_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut s16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtou8_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut u8_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtos8_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        base: ::std::os::raw::c_uint,
        res: *mut s8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kstrtobool_from_user(
        s: *const ::std::os::raw::c_char,
        count: size_t,
        res: *mut bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_strtoul(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn simple_strtol(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn simple_strtoull(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn simple_strtoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_longlong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s16_fract {
    pub numerator: __s16,
    pub denominator: __s16,
}
#[test]
fn bindgen_test_layout_s16_fract() {
    assert_eq!(
        ::std::mem::size_of::<s16_fract>(),
        4usize,
        concat!("Size of: ", stringify!(s16_fract))
    );
    assert_eq!(
        ::std::mem::align_of::<s16_fract>(),
        2usize,
        concat!("Alignment of ", stringify!(s16_fract))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<s16_fract>())).numerator as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(s16_fract),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<s16_fract>())).denominator as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(s16_fract),
            "::",
            stringify!(denominator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct u16_fract {
    pub numerator: __u16,
    pub denominator: __u16,
}
#[test]
fn bindgen_test_layout_u16_fract() {
    assert_eq!(
        ::std::mem::size_of::<u16_fract>(),
        4usize,
        concat!("Size of: ", stringify!(u16_fract))
    );
    assert_eq!(
        ::std::mem::align_of::<u16_fract>(),
        2usize,
        concat!("Alignment of ", stringify!(u16_fract))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<u16_fract>())).numerator as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(u16_fract),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<u16_fract>())).denominator as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(u16_fract),
            "::",
            stringify!(denominator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s32_fract {
    pub numerator: __s32,
    pub denominator: __s32,
}
#[test]
fn bindgen_test_layout_s32_fract() {
    assert_eq!(
        ::std::mem::size_of::<s32_fract>(),
        8usize,
        concat!("Size of: ", stringify!(s32_fract))
    );
    assert_eq!(
        ::std::mem::align_of::<s32_fract>(),
        4usize,
        concat!("Alignment of ", stringify!(s32_fract))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<s32_fract>())).numerator as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(s32_fract),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<s32_fract>())).denominator as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(s32_fract),
            "::",
            stringify!(denominator)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct u32_fract {
    pub numerator: __u32,
    pub denominator: __u32,
}
#[test]
fn bindgen_test_layout_u32_fract() {
    assert_eq!(
        ::std::mem::size_of::<u32_fract>(),
        8usize,
        concat!("Size of: ", stringify!(u32_fract))
    );
    assert_eq!(
        ::std::mem::align_of::<u32_fract>(),
        4usize,
        concat!("Alignment of ", stringify!(u32_fract))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<u32_fract>())).numerator as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(u32_fract),
            "::",
            stringify!(numerator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<u32_fract>())).denominator as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(u32_fract),
            "::",
            stringify!(denominator)
        )
    );
}
extern "C" {
    pub fn int_pow(base: u64_, exp: ::std::os::raw::c_uint) -> u64_;
}
extern "C" {
    pub fn int_sqrt(arg1: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut panic_blink: ::std::option::Option<
        unsafe extern "C" fn(state: ::std::os::raw::c_int) -> ::std::os::raw::c_long,
    >;
}
extern "C" {
    pub fn panic(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn nmi_panic(regs: *mut pt_regs, msg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn oops_enter();
}
extern "C" {
    pub fn oops_exit();
}
extern "C" {
    pub fn oops_may_print() -> bool_;
}
extern "C" {
    pub static mut panic_timeout: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut panic_print: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut panic_on_oops: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut panic_on_unrecovered_nmi: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut panic_on_io_nmi: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut panic_on_warn: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut panic_on_taint: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut panic_on_taint_nousertaint: bool_;
}
extern "C" {
    pub static mut sysctl_panic_on_rcu_stall: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sysctl_max_rcu_stall_to_panic: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sysctl_panic_on_stackoverflow: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut crash_kexec_post_notifiers: bool_;
}
extern "C" {
    pub static mut panic_cpu: atomic_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct taint_flag {
    pub c_true: ::std::os::raw::c_char,
    pub c_false: ::std::os::raw::c_char,
    pub module: bool_,
}
#[test]
fn bindgen_test_layout_taint_flag() {
    assert_eq!(
        ::std::mem::size_of::<taint_flag>(),
        3usize,
        concat!("Size of: ", stringify!(taint_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<taint_flag>(),
        1usize,
        concat!("Alignment of ", stringify!(taint_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<taint_flag>())).c_true as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(taint_flag),
            "::",
            stringify!(c_true)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<taint_flag>())).c_false as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(taint_flag),
            "::",
            stringify!(c_false)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<taint_flag>())).module as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(taint_flag),
            "::",
            stringify!(module)
        )
    );
}
extern "C" {
    pub static taint_flags: [taint_flag; 19usize];
}
pub const lockdep_ok_LOCKDEP_STILL_OK: lockdep_ok = 0;
pub const lockdep_ok_LOCKDEP_NOW_UNRELIABLE: lockdep_ok = 1;
pub type lockdep_ok = ::std::os::raw::c_uint;
extern "C" {
    pub fn print_tainted() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn add_taint(flag: ::std::os::raw::c_uint, arg1: lockdep_ok);
}
extern "C" {
    pub fn test_taint(flag: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_taint() -> ::std::os::raw::c_ulong;
}
pub type initcall_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type exitcall_t = ::std::option::Option<unsafe extern "C" fn()>;
pub type initcall_entry_t = ::std::os::raw::c_int;
extern "C" {
    pub static mut __con_initcall_start: [initcall_entry_t; 0usize];
}
extern "C" {
    pub static mut __con_initcall_end: [initcall_entry_t; 0usize];
}
pub type ctor_fn_t = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn do_one_initcall(fn_: initcall_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut boot_command_line: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut saved_command_line: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut reset_devices: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn setup_arch(arg1: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn prepare_namespace();
}
extern "C" {
    pub fn init_rootfs();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_system_type {
    pub name: *const ::std::os::raw::c_char,
    pub fs_flags: ::std::os::raw::c_int,
    pub init_fs_context:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut fs_context) -> ::std::os::raw::c_int>,
    pub parameters: *const fs_parameter_spec,
    pub mount: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_system_type,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_char,
            arg4: *mut ::std::os::raw::c_void,
        ) -> *mut dentry,
    >,
    pub kill_sb: ::std::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub owner: *mut module,
    pub next: *mut file_system_type,
    pub fs_supers: hlist_head,
    pub s_lock_key: lock_class_key,
    pub s_umount_key: lock_class_key,
    pub s_vfs_rename_key: lock_class_key,
    pub s_writers_key: [lock_class_key; 3usize],
    pub i_lock_key: lock_class_key,
    pub i_mutex_key: lock_class_key,
    pub invalidate_lock_key: lock_class_key,
    pub i_mutex_dir_key: lock_class_key,
}
#[test]
fn bindgen_test_layout_file_system_type() {
    assert_eq!(
        ::std::mem::size_of::<file_system_type>(),
        72usize,
        concat!("Size of: ", stringify!(file_system_type))
    );
    assert_eq!(
        ::std::mem::align_of::<file_system_type>(),
        8usize,
        concat!("Alignment of ", stringify!(file_system_type))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_system_type>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_system_type>())).fs_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(fs_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_system_type>())).init_fs_context as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(init_fs_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_system_type>())).parameters as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(parameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_system_type>())).mount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(mount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_system_type>())).kill_sb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(kill_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_system_type>())).owner as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_system_type>())).next as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_system_type>())).fs_supers as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(fs_supers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_system_type>())).s_lock_key as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_lock_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_system_type>())).s_umount_key as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_umount_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_system_type>())).s_vfs_rename_key as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_vfs_rename_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_system_type>())).s_writers_key as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(s_writers_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_system_type>())).i_lock_key as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(i_lock_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_system_type>())).i_mutex_key as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(i_mutex_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_system_type>())).invalidate_lock_key as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(invalidate_lock_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_system_type>())).i_mutex_dir_key as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_system_type),
            "::",
            stringify!(i_mutex_dir_key)
        )
    );
}
extern "C" {
    pub static mut rootfs_fs_type: file_system_type;
}
extern "C" {
    pub static mut rodata_enabled: bool_;
}
extern "C" {
    pub fn mark_rodata_ro();
}
extern "C" {
    pub static mut late_time_init: ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub static mut initcall_debug: bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obs_kernel_param {
    pub str_: *const ::std::os::raw::c_char,
    pub setup_func: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int,
    >,
    pub early: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_obs_kernel_param() {
    assert_eq!(
        ::std::mem::size_of::<obs_kernel_param>(),
        24usize,
        concat!("Size of: ", stringify!(obs_kernel_param))
    );
    assert_eq!(
        ::std::mem::align_of::<obs_kernel_param>(),
        8usize,
        concat!("Alignment of ", stringify!(obs_kernel_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_kernel_param>())).str_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_kernel_param),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_kernel_param>())).setup_func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_kernel_param),
            "::",
            stringify!(setup_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obs_kernel_param>())).early as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obs_kernel_param),
            "::",
            stringify!(early)
        )
    );
}
extern "C" {
    pub fn parse_early_param();
}
extern "C" {
    pub fn parse_early_options(cmdline: *mut ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qspinlock {
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qspinlock__bindgen_ty_1 {
    pub val: atomic_t,
    pub __bindgen_anon_1: qspinlock__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: qspinlock__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_1 {
    pub locked: u8_,
    pub pending: u8_,
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).locked as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_1>())).pending as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pending)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qspinlock__bindgen_ty_1__bindgen_ty_2 {
    pub locked_pending: u16_,
    pub tail: u16_,
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qspinlock__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).locked_pending
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(locked_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qspinlock__bindgen_ty_1__bindgen_ty_2>())).tail as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(tail)
        )
    );
}
#[test]
fn bindgen_test_layout_qspinlock__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qspinlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qspinlock__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qspinlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(qspinlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qspinlock__bindgen_ty_1>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qspinlock__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
}
#[test]
fn bindgen_test_layout_qspinlock() {
    assert_eq!(
        ::std::mem::size_of::<qspinlock>(),
        4usize,
        concat!("Size of: ", stringify!(qspinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<qspinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(qspinlock))
    );
}
pub type arch_spinlock_t = qspinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qrwlock {
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1,
    pub wait_lock: arch_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qrwlock__bindgen_ty_1 {
    pub cnts: atomic_t,
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qrwlock__bindgen_ty_1__bindgen_ty_1 {
    pub wlocked: u8_,
    pub __lstate: [u8_; 3usize],
}
#[test]
fn bindgen_test_layout_qrwlock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qrwlock__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qrwlock__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qrwlock__bindgen_ty_1__bindgen_ty_1>())).wlocked as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(wlocked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qrwlock__bindgen_ty_1__bindgen_ty_1>())).__lstate as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__lstate)
        )
    );
}
#[test]
fn bindgen_test_layout_qrwlock__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qrwlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(qrwlock__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qrwlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(qrwlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qrwlock__bindgen_ty_1>())).cnts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock__bindgen_ty_1),
            "::",
            stringify!(cnts)
        )
    );
}
#[test]
fn bindgen_test_layout_qrwlock() {
    assert_eq!(
        ::std::mem::size_of::<qrwlock>(),
        8usize,
        concat!("Size of: ", stringify!(qrwlock))
    );
    assert_eq!(
        ::std::mem::align_of::<qrwlock>(),
        4usize,
        concat!("Alignment of ", stringify!(qrwlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qrwlock>())).wait_lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qrwlock),
            "::",
            stringify!(wait_lock)
        )
    );
}
pub type arch_rwlock_t = qrwlock;
pub const lockdep_wait_type_LD_WAIT_INV: lockdep_wait_type = 0;
pub const lockdep_wait_type_LD_WAIT_FREE: lockdep_wait_type = 1;
pub const lockdep_wait_type_LD_WAIT_SPIN: lockdep_wait_type = 2;
pub const lockdep_wait_type_LD_WAIT_CONFIG: lockdep_wait_type = 2;
pub const lockdep_wait_type_LD_WAIT_SLEEP: lockdep_wait_type = 3;
pub const lockdep_wait_type_LD_WAIT_MAX: lockdep_wait_type = 4;
pub type lockdep_wait_type = ::std::os::raw::c_uint;
pub const lockdep_lock_type_LD_LOCK_NORMAL: lockdep_lock_type = 0;
pub const lockdep_lock_type_LD_LOCK_PERCPU: lockdep_lock_type = 1;
pub const lockdep_lock_type_LD_LOCK_MAX: lockdep_lock_type = 2;
pub type lockdep_lock_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_class_key {}
#[test]
fn bindgen_test_layout_lock_class_key() {
    assert_eq!(
        ::std::mem::size_of::<lock_class_key>(),
        0usize,
        concat!("Size of: ", stringify!(lock_class_key))
    );
    assert_eq!(
        ::std::mem::align_of::<lock_class_key>(),
        1usize,
        concat!("Alignment of ", stringify!(lock_class_key))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lockdep_map {}
#[test]
fn bindgen_test_layout_lockdep_map() {
    assert_eq!(
        ::std::mem::size_of::<lockdep_map>(),
        0usize,
        concat!("Size of: ", stringify!(lockdep_map))
    );
    assert_eq!(
        ::std::mem::align_of::<lockdep_map>(),
        1usize,
        concat!("Alignment of ", stringify!(lockdep_map))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pin_cookie {}
#[test]
fn bindgen_test_layout_pin_cookie() {
    assert_eq!(
        ::std::mem::size_of::<pin_cookie>(),
        0usize,
        concat!("Size of: ", stringify!(pin_cookie))
    );
    assert_eq!(
        ::std::mem::align_of::<pin_cookie>(),
        1usize,
        concat!("Alignment of ", stringify!(pin_cookie))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
}
#[test]
fn bindgen_test_layout_raw_spinlock() {
    assert_eq!(
        ::std::mem::size_of::<raw_spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(raw_spinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<raw_spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(raw_spinlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raw_spinlock>())).raw_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raw_spinlock),
            "::",
            stringify!(raw_lock)
        )
    );
}
pub type raw_spinlock_t = raw_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ratelimit_state {
    pub lock: raw_spinlock_t,
    pub interval: ::std::os::raw::c_int,
    pub burst: ::std::os::raw::c_int,
    pub printed: ::std::os::raw::c_int,
    pub missed: ::std::os::raw::c_int,
    pub begin: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_ratelimit_state() {
    assert_eq!(
        ::std::mem::size_of::<ratelimit_state>(),
        40usize,
        concat!("Size of: ", stringify!(ratelimit_state))
    );
    assert_eq!(
        ::std::mem::align_of::<ratelimit_state>(),
        8usize,
        concat!("Alignment of ", stringify!(ratelimit_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratelimit_state>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratelimit_state>())).interval as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratelimit_state>())).burst as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(burst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratelimit_state>())).printed as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(printed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratelimit_state>())).missed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(missed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratelimit_state>())).begin as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ratelimit_state>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ratelimit_state),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn ___ratelimit(
        rs: *mut ratelimit_state,
        func: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut linux_banner: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut linux_proc_banner: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut oops_in_progress: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut console_printk: [::std::os::raw::c_int; 0usize];
}
extern "C" {
    pub fn console_verbose();
}
extern "C" {
    pub static mut devkmsg_log_str: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut suppress_printk: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct va_format {
    pub fmt: *const ::std::os::raw::c_char,
    pub va: *mut va_list,
}
#[test]
fn bindgen_test_layout_va_format() {
    assert_eq!(
        ::std::mem::size_of::<va_format>(),
        16usize,
        concat!("Size of: ", stringify!(va_format))
    );
    assert_eq!(
        ::std::mem::align_of::<va_format>(),
        8usize,
        concat!("Alignment of ", stringify!(va_format))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<va_format>())).fmt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(va_format),
            "::",
            stringify!(fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<va_format>())).va as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(va_format),
            "::",
            stringify!(va)
        )
    );
}
extern "C" {
    pub fn early_printk(fmt: *const ::std::os::raw::c_char, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_printk_info {
    _unused: [u8; 0],
}
extern "C" {
    pub fn vprintk_emit(
        facility: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
        dev_info: *const dev_printk_info,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintk(
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _printk(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _printk_deferred(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __printk_safe_enter();
}
extern "C" {
    pub fn __printk_safe_exit();
}
extern "C" {
    pub fn __printk_ratelimit(func: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printk_timed_ratelimit(
        caller_jiffies: *mut ::std::os::raw::c_ulong,
        interval_msec: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub static mut printk_delay_msec: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut dmesg_restrict: ::std::os::raw::c_int;
}
extern "C" {
    pub fn wake_up_klogd();
}
extern "C" {
    pub fn log_buf_addr_get() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn log_buf_len_get() -> u32_;
}
extern "C" {
    pub fn log_buf_vmcoreinfo_setup();
}
extern "C" {
    pub fn setup_log_buf(early: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dump_stack_set_arch_desc(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn dump_stack_print_info(log_lvl: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn show_regs_print_info(log_lvl: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn dump_stack_lvl(log_lvl: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn dump_stack();
}
extern "C" {
    pub fn printk_trigger_flush();
}
extern "C" {
    pub fn __printk_cpu_sync_try_get() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __printk_cpu_sync_wait();
}
extern "C" {
    pub fn __printk_cpu_sync_put();
}
extern "C" {
    pub static mut kptr_restrict: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ddebug {
    pub modname: *const ::std::os::raw::c_char,
    pub function: *const ::std::os::raw::c_char,
    pub filename: *const ::std::os::raw::c_char,
    pub format: *const ::std::os::raw::c_char,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub key: _ddebug__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ddebug__bindgen_ty_1 {
    pub dd_key_true: static_key_true,
    pub dd_key_false: static_key_false,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout__ddebug__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_ddebug__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_ddebug__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_ddebug__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_ddebug__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ddebug__bindgen_ty_1>())).dd_key_true as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug__bindgen_ty_1),
            "::",
            stringify!(dd_key_true)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ddebug__bindgen_ty_1>())).dd_key_false as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug__bindgen_ty_1),
            "::",
            stringify!(dd_key_false)
        )
    );
}
#[test]
fn bindgen_test_layout__ddebug() {
    assert_eq!(
        ::std::mem::size_of::<_ddebug>(),
        56usize,
        concat!("Size of: ", stringify!(_ddebug))
    );
    assert_eq!(
        ::std::mem::align_of::<_ddebug>(),
        8usize,
        concat!("Alignment of ", stringify!(_ddebug))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug>())).modname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug),
            "::",
            stringify!(modname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug>())).function as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug>())).filename as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug>())).format as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug>())).key as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug),
            "::",
            stringify!(key)
        )
    );
}
impl _ddebug {
    #[inline]
    pub fn lineno(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_lineno(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn class_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_class_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lineno: ::std::os::raw::c_uint,
        class_id: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 18u8, {
            let lineno: u32 = unsafe { ::std::mem::transmute(lineno) };
            lineno as u64
        });
        __bindgen_bitfield_unit.set(18usize, 6u8, {
            let class_id: u32 = unsafe { ::std::mem::transmute(class_id) };
            class_id as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const class_map_type_DD_CLASS_TYPE_DISJOINT_BITS: class_map_type = 0;
#[doc = " DD_CLASS_TYPE_DISJOINT_BITS: classes are independent, one per bit."]
#[doc = " expecting hex input. Built for drm.debug, basis for other types."]
pub const class_map_type_DD_CLASS_TYPE_LEVEL_NUM: class_map_type = 1;
#[doc = " DD_CLASS_TYPE_LEVEL_NUM: input is numeric level, 0-N."]
#[doc = " N turns on just bits N-1 .. 0, so N=0 turns all bits off."]
pub const class_map_type_DD_CLASS_TYPE_DISJOINT_NAMES: class_map_type = 2;
#[doc = " DD_CLASS_TYPE_DISJOINT_NAMES: input is a CSV of [+-]CLASS_NAMES,"]
#[doc = " classes are independent, like _DISJOINT_BITS."]
pub const class_map_type_DD_CLASS_TYPE_LEVEL_NAMES: class_map_type = 3;
pub type class_map_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ddebug_class_map {
    pub link: list_head,
    pub mod_: *mut module,
    pub mod_name: *const ::std::os::raw::c_char,
    pub class_names: *mut *const ::std::os::raw::c_char,
    pub length: ::std::os::raw::c_int,
    pub base: ::std::os::raw::c_int,
    pub map_type: class_map_type,
}
#[test]
fn bindgen_test_layout_ddebug_class_map() {
    assert_eq!(
        ::std::mem::size_of::<ddebug_class_map>(),
        56usize,
        concat!("Size of: ", stringify!(ddebug_class_map))
    );
    assert_eq!(
        ::std::mem::align_of::<ddebug_class_map>(),
        8usize,
        concat!("Alignment of ", stringify!(ddebug_class_map))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_map>())).link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_map),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_map>())).mod_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_map),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_map>())).mod_name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_map),
            "::",
            stringify!(mod_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_map>())).class_names as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_map),
            "::",
            stringify!(class_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_map>())).length as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_map),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_map>())).base as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_map),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_map>())).map_type as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_map),
            "::",
            stringify!(map_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ddebug_info {
    pub descs: *mut _ddebug,
    pub classes: *mut ddebug_class_map,
    pub num_descs: ::std::os::raw::c_uint,
    pub num_classes: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__ddebug_info() {
    assert_eq!(
        ::std::mem::size_of::<_ddebug_info>(),
        24usize,
        concat!("Size of: ", stringify!(_ddebug_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_ddebug_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_ddebug_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug_info>())).descs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug_info),
            "::",
            stringify!(descs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug_info>())).classes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug_info),
            "::",
            stringify!(classes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug_info>())).num_descs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug_info),
            "::",
            stringify!(num_descs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ddebug_info>())).num_classes as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ddebug_info),
            "::",
            stringify!(num_classes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ddebug_class_param {
    pub __bindgen_anon_1: ddebug_class_param__bindgen_ty_1,
    pub flags: [::std::os::raw::c_char; 8usize],
    pub map: *const ddebug_class_map,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ddebug_class_param__bindgen_ty_1 {
    pub bits: *mut ::std::os::raw::c_ulong,
    pub lvl: *mut ::std::os::raw::c_uint,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_ddebug_class_param__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ddebug_class_param__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ddebug_class_param__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ddebug_class_param__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ddebug_class_param__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddebug_class_param__bindgen_ty_1>())).bits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_param__bindgen_ty_1),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ddebug_class_param__bindgen_ty_1>())).lvl as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_param__bindgen_ty_1),
            "::",
            stringify!(lvl)
        )
    );
}
#[test]
fn bindgen_test_layout_ddebug_class_param() {
    assert_eq!(
        ::std::mem::size_of::<ddebug_class_param>(),
        24usize,
        concat!("Size of: ", stringify!(ddebug_class_param))
    );
    assert_eq!(
        ::std::mem::align_of::<ddebug_class_param>(),
        8usize,
        concat!("Alignment of ", stringify!(ddebug_class_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_param>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_param),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ddebug_class_param>())).map as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ddebug_class_param),
            "::",
            stringify!(map)
        )
    );
}
extern "C" {
    pub fn ddebug_add_module(
        dyndbg: *mut _ddebug_info,
        modname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ddebug_remove_module(mod_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __dynamic_pr_debug(descriptor: *mut _ddebug, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn ddebug_dyndbg_module_param_cb(
        param: *mut ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_char,
        modname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __dynamic_dev_dbg(
        descriptor: *mut _ddebug,
        dev: *const device,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __dynamic_netdev_dbg(
        descriptor: *mut _ddebug,
        dev: *const net_device,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __dynamic_ibdev_dbg(
        descriptor: *mut _ddebug,
        ibdev: *const ib_device,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_param {
    _unused: [u8; 0],
}
extern "C" {
    pub fn param_set_dyndbg_classes(
        instr: *const ::std::os::raw::c_char,
        kp: *const kernel_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn param_get_dyndbg_classes(
        buffer: *mut ::std::os::raw::c_char,
        kp: *const kernel_param,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_param_ops {
    _unused: [u8; 0],
}
extern "C" {
    pub static param_ops_dyndbg_classes: kernel_param_ops;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_operations {
    pub owner: *mut module,
    pub llseek: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: loff_t, arg3: ::std::os::raw::c_int) -> loff_t,
    >,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut ::std::os::raw::c_char,
            arg3: size_t,
            arg4: *mut loff_t,
        ) -> ssize_t,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *const ::std::os::raw::c_char,
            arg3: size_t,
            arg4: *mut loff_t,
        ) -> ssize_t,
    >,
    pub read_iter: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t,
    >,
    pub write_iter: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t,
    >,
    pub iopoll: ::std::option::Option<
        unsafe extern "C" fn(
            kiocb: *mut kiocb,
            arg1: *mut io_comp_batch,
            flags: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub iterate: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> ::std::os::raw::c_int,
    >,
    pub iterate_shared: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> ::std::os::raw::c_int,
    >,
    pub poll: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
    pub unlocked_ioctl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::std::os::raw::c_uint,
            arg3: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_long,
    >,
    pub compat_ioctl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::std::os::raw::c_uint,
            arg3: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_long,
    >,
    pub mmap: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut vm_area_struct) -> ::std::os::raw::c_int,
    >,
    pub mmap_supported_flags: ::std::os::raw::c_ulong,
    pub open: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::std::os::raw::c_int,
    >,
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut file, id: fl_owner_t) -> ::std::os::raw::c_int,
    >,
    pub release: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::std::os::raw::c_int,
    >,
    pub fsync: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            datasync: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub fasync: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut file,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub lock: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::std::os::raw::c_int,
            arg3: *mut file_lock,
        ) -> ::std::os::raw::c_int,
    >,
    pub sendpage: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut page,
            arg3: ::std::os::raw::c_int,
            arg4: size_t,
            arg5: *mut loff_t,
            arg6: ::std::os::raw::c_int,
        ) -> ssize_t,
    >,
    pub get_unmapped_area: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::std::os::raw::c_ulong,
            arg3: ::std::os::raw::c_ulong,
            arg4: ::std::os::raw::c_ulong,
            arg5: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong,
    >,
    pub check_flags: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    >,
    pub flock: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::std::os::raw::c_int,
            arg3: *mut file_lock,
        ) -> ::std::os::raw::c_int,
    >,
    pub splice_write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pipe_inode_info,
            arg2: *mut file,
            arg3: *mut loff_t,
            arg4: size_t,
            arg5: ::std::os::raw::c_uint,
        ) -> ssize_t,
    >,
    pub splice_read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut loff_t,
            arg3: *mut pipe_inode_info,
            arg4: size_t,
            arg5: ::std::os::raw::c_uint,
        ) -> ssize_t,
    >,
    pub setlease: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: ::std::os::raw::c_long,
            arg3: *mut *mut file_lock,
            arg4: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub fallocate: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            mode: ::std::os::raw::c_int,
            offset: loff_t,
            len: loff_t,
        ) -> ::std::os::raw::c_long,
    >,
    pub show_fdinfo: ::std::option::Option<unsafe extern "C" fn(m: *mut seq_file, f: *mut file)>,
    pub copy_file_range: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: size_t,
            arg6: ::std::os::raw::c_uint,
        ) -> ssize_t,
    >,
    pub remap_file_range: ::std::option::Option<
        unsafe extern "C" fn(
            file_in: *mut file,
            pos_in: loff_t,
            file_out: *mut file,
            pos_out: loff_t,
            len: loff_t,
            remap_flags: ::std::os::raw::c_uint,
        ) -> loff_t,
    >,
    pub fadvise: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub uring_cmd: ::std::option::Option<
        unsafe extern "C" fn(
            ioucmd: *mut io_uring_cmd,
            issue_flags: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub uring_cmd_iopoll: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut io_uring_cmd,
            arg2: *mut io_comp_batch,
            poll_flags: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_file_operations() {
    assert_eq!(
        ::std::mem::size_of::<file_operations>(),
        272usize,
        concat!("Size of: ", stringify!(file_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<file_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(file_operations))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).llseek as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(llseek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).read as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).write as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).read_iter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(read_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).write_iter as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(write_iter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).iopoll as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(iopoll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).iterate as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(iterate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).iterate_shared as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(iterate_shared)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).poll as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).unlocked_ioctl as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(unlocked_ioctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).compat_ioctl as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(compat_ioctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).mmap as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(mmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_operations>())).mmap_supported_flags as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(mmap_supported_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).open as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).flush as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).release as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).fsync as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(fsync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).fasync as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(fasync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).lock as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).sendpage as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(sendpage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_operations>())).get_unmapped_area as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(get_unmapped_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).check_flags as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(check_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).flock as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(flock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).splice_write as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(splice_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).splice_read as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(splice_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).setlease as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(setlease)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).fallocate as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(fallocate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).show_fdinfo as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(show_fdinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).copy_file_range as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(copy_file_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_operations>())).remap_file_range as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(remap_file_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).fadvise as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(fadvise)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_operations>())).uring_cmd as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(uring_cmd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_operations>())).uring_cmd_iopoll as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(file_operations),
            "::",
            stringify!(uring_cmd_iopoll)
        )
    );
}
extern "C" {
    pub static kmsg_fops: file_operations;
}
pub const DUMP_PREFIX_NONE: ::std::os::raw::c_uint = 0;
pub const DUMP_PREFIX_ADDRESS: ::std::os::raw::c_uint = 1;
pub const DUMP_PREFIX_OFFSET: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
extern "C" {
    pub fn hex_dump_to_buffer(
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        rowsize: ::std::os::raw::c_int,
        groupsize: ::std::os::raw::c_int,
        linebuf: *mut ::std::os::raw::c_char,
        linebuflen: size_t,
        ascii: bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn print_hex_dump(
        level: *const ::std::os::raw::c_char,
        prefix_str: *const ::std::os::raw::c_char,
        prefix_type: ::std::os::raw::c_int,
        rowsize: ::std::os::raw::c_int,
        groupsize: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        ascii: bool_,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct static_call_site {
    pub addr: s32,
    pub key: s32,
}
#[test]
fn bindgen_test_layout_static_call_site() {
    assert_eq!(
        ::std::mem::size_of::<static_call_site>(),
        8usize,
        concat!("Size of: ", stringify!(static_call_site))
    );
    assert_eq!(
        ::std::mem::align_of::<static_call_site>(),
        4usize,
        concat!("Alignment of ", stringify!(static_call_site))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_call_site>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_call_site),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_call_site>())).key as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(static_call_site),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_call_key {
    pub func: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: static_call_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_call_key__bindgen_ty_1 {
    pub type_: ::std::os::raw::c_ulong,
    pub mods: *mut static_call_mod,
    pub sites: *mut static_call_site,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_static_call_key__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<static_call_key__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(static_call_key__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<static_call_key__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(static_call_key__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<static_call_key__bindgen_ty_1>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_call_key__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<static_call_key__bindgen_ty_1>())).mods as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_call_key__bindgen_ty_1),
            "::",
            stringify!(mods)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<static_call_key__bindgen_ty_1>())).sites as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_call_key__bindgen_ty_1),
            "::",
            stringify!(sites)
        )
    );
}
#[test]
fn bindgen_test_layout_static_call_key() {
    assert_eq!(
        ::std::mem::size_of::<static_call_key>(),
        16usize,
        concat!("Size of: ", stringify!(static_call_key))
    );
    assert_eq!(
        ::std::mem::align_of::<static_call_key>(),
        8usize,
        concat!("Alignment of ", stringify!(static_call_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<static_call_key>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_call_key),
            "::",
            stringify!(func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __cond_resched() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __SCK__might_resched: static_call_key;
}
extern "C" {
    pub fn __SCT__might_resched() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_exit(error_code: ::std::os::raw::c_long);
}
extern "C" {
    pub fn num_to_str(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        num: ::std::os::raw::c_ulonglong,
        width: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        buf: *mut ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        buf: *mut ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scnprintf(
        buf: *mut ::std::os::raw::c_char,
        size: size_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscnprintf(
        buf: *mut ::std::os::raw::c_char,
        size: size_t,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kasprintf(
        gfp: gfp_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kvasprintf(
        gfp: gfp_t,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn kvasprintf_const(
        gfp: gfp_t,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn no_hash_pointers_enable(str_: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_option(
        str_: *mut *mut ::std::os::raw::c_char,
        pint: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_options(
        str_: *const ::std::os::raw::c_char,
        nints: ::std::os::raw::c_int,
        ints: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memparse(
        ptr: *const ::std::os::raw::c_char,
        retptr: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn parse_option_str(
        str_: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
    ) -> bool_;
}
extern "C" {
    pub fn next_arg(
        args: *mut ::std::os::raw::c_char,
        param: *mut *mut ::std::os::raw::c_char,
        val: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn core_kernel_text(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __kernel_text_address(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kernel_text_address(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn func_ptr_is_kernel_text(ptr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bust_spinlocks(yes: ::std::os::raw::c_int);
}
extern "C" {
    pub static mut root_mountflags: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut early_boot_irqs_disabled: bool_;
}
pub const system_states_SYSTEM_BOOTING: system_states = 0;
pub const system_states_SYSTEM_SCHEDULING: system_states = 1;
pub const system_states_SYSTEM_FREEING_INITMEM: system_states = 2;
pub const system_states_SYSTEM_RUNNING: system_states = 3;
pub const system_states_SYSTEM_HALT: system_states = 4;
pub const system_states_SYSTEM_POWER_OFF: system_states = 5;
pub const system_states_SYSTEM_RESTART: system_states = 6;
pub const system_states_SYSTEM_SUSPEND: system_states = 7;
pub type system_states = ::std::os::raw::c_uint;
extern "C" {
    pub static mut system_state: system_states;
}
extern "C" {
    pub static mut hex_asc: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut hex_asc_upper: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn hex_to_bin(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hex2bin(
        dst: *mut u8_,
        src: *const ::std::os::raw::c_char,
        count: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bin2hex(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_void,
        count: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mac_pton(s: *const ::std::os::raw::c_char, mac: *mut u8_) -> bool_;
}
pub const ftrace_dump_mode_DUMP_NONE: ftrace_dump_mode = 0;
pub const ftrace_dump_mode_DUMP_ALL: ftrace_dump_mode = 1;
pub const ftrace_dump_mode_DUMP_ORIG: ftrace_dump_mode = 2;
pub type ftrace_dump_mode = ::std::os::raw::c_uint;
extern "C" {
    pub fn tracing_on();
}
extern "C" {
    pub fn tracing_off();
}
extern "C" {
    pub fn tracing_is_on() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tracing_snapshot();
}
extern "C" {
    pub fn tracing_snapshot_alloc();
}
extern "C" {
    pub fn tracing_start();
}
extern "C" {
    pub fn tracing_stop();
}
extern "C" {
    pub fn __trace_bprintk(
        ip: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __trace_printk(
        ip: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __trace_bputs(
        ip: ::std::os::raw::c_ulong,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __trace_puts(
        ip: ::std::os::raw::c_ulong,
        str_: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn trace_dump_stack(skip: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __ftrace_vbprintk(
        ip: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ftrace_vprintk(
        ip: ::std::os::raw::c_ulong,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftrace_dump(oops_dump_mode: ftrace_dump_mode);
}
extern "C" {
    pub fn __bad_size_call_parameter();
}
extern "C" {
    pub fn __this_cpu_preempt_check(op: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut __per_cpu_offset: [::std::os::raw::c_ulong; 64usize];
}
extern "C" {
    pub fn setup_per_cpu_areas();
}
extern "C" {
    pub static mut this_cpu_off: ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unwind_hint {
    pub ip: u32_,
    pub sp_offset: s16,
    pub sp_reg: u8_,
    pub type_: u8_,
    pub end: u8_,
}
#[test]
fn bindgen_test_layout_unwind_hint() {
    assert_eq!(
        ::std::mem::size_of::<unwind_hint>(),
        12usize,
        concat!("Size of: ", stringify!(unwind_hint))
    );
    assert_eq!(
        ::std::mem::align_of::<unwind_hint>(),
        4usize,
        concat!("Alignment of ", stringify!(unwind_hint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unwind_hint>())).ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_hint),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unwind_hint>())).sp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_hint),
            "::",
            stringify!(sp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unwind_hint>())).sp_reg as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_hint),
            "::",
            stringify!(sp_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unwind_hint>())).type_ as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_hint),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<unwind_hint>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_hint),
            "::",
            stringify!(end)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct warn_args {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __warn(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        caller: *mut ::std::os::raw::c_void,
        taint: ::std::os::raw::c_uint,
        regs: *mut pt_regs,
        args: *mut warn_args,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bug_entry {
    pub bug_addr_disp: ::std::os::raw::c_int,
    pub file_disp: ::std::os::raw::c_int,
    pub line: ::std::os::raw::c_ushort,
    pub flags: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_bug_entry() {
    assert_eq!(
        ::std::mem::size_of::<bug_entry>(),
        12usize,
        concat!("Size of: ", stringify!(bug_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<bug_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(bug_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bug_entry>())).bug_addr_disp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(bug_addr_disp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bug_entry>())).file_disp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(file_disp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bug_entry>())).line as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bug_entry>())).flags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bug_entry),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn __warn_printk(fmt: *const ::std::os::raw::c_char, ...);
}
pub const bug_trap_type_BUG_TRAP_TYPE_NONE: bug_trap_type = 0;
pub const bug_trap_type_BUG_TRAP_TYPE_WARN: bug_trap_type = 1;
pub const bug_trap_type_BUG_TRAP_TYPE_BUG: bug_trap_type = 2;
pub type bug_trap_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn bug_get_file_line(
        bug: *mut bug_entry,
        file: *mut *const ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn find_bug(bugaddr: ::std::os::raw::c_ulong) -> *mut bug_entry;
}
extern "C" {
    pub fn report_bug(bug_addr: ::std::os::raw::c_ulong, regs: *mut pt_regs) -> bug_trap_type;
}
extern "C" {
    pub fn is_valid_bugaddr(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_bug_clear_once();
}
extern "C" {
    pub fn iter_div_u64_rem(dividend: u64_, divisor: u32_, remainder: *mut u64_) -> u32_;
}
pub type time64_t = __s64;
pub type timeu64_t = __u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_timespec {
    pub tv_sec: __kernel_time64_t,
    pub tv_nsec: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___kernel_timespec() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_timespec>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_itimerspec {
    pub it_interval: __kernel_timespec,
    pub it_value: __kernel_timespec,
}
#[test]
fn bindgen_test_layout___kernel_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(__kernel_itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_old_timeval {
    pub tv_sec: __kernel_long_t,
    pub tv_usec: __kernel_long_t,
}
#[test]
fn bindgen_test_layout___kernel_old_timeval() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_old_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_old_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_old_timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_old_timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_old_timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_old_timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_old_timespec {
    pub tv_sec: __kernel_old_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout___kernel_old_timespec() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_old_timespec>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_old_timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_old_timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_old_timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_old_timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_old_timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_old_itimerval {
    pub it_interval: __kernel_old_timeval,
    pub it_value: __kernel_old_timeval,
}
#[test]
fn bindgen_test_layout___kernel_old_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_old_itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(__kernel_old_itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_old_itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_old_itimerval))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__kernel_old_itimerval>())).it_interval as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_old_itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_old_itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_sock_timeval {
    pub tv_sec: __s64,
    pub tv_usec: __s64,
}
#[test]
fn bindgen_test_layout___kernel_sock_timeval() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_sock_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_sock_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_sock_timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_sock_timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sock_timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sock_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_sock_timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_sock_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec64 {
    pub tv_sec: time64_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec64() {
    assert_eq!(
        ::std::mem::size_of::<timespec64>(),
        16usize,
        concat!("Size of: ", stringify!(timespec64))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec64>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec64>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec64),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec64>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec64),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec64 {
    pub it_interval: timespec64,
    pub it_value: timespec64,
}
#[test]
fn bindgen_test_layout_itimerspec64() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec64>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec64))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec64>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec64>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec64),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec64>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec64),
            "::",
            stringify!(it_value)
        )
    );
}
extern "C" {
    pub fn set_normalized_timespec64(ts: *mut timespec64, sec: time64_t, nsec: s64);
}
extern "C" {
    #[doc = " ns_to_timespec64 - Convert nanoseconds to timespec64"]
    #[doc = " @nsec:\tthe nanoseconds value to be converted"]
    #[doc = ""]
    #[doc = " Returns the timespec64 representation of the nsec parameter."]
    pub fn ns_to_timespec64(nsec: s64) -> timespec64;
}
extern "C" {
    pub fn timespec64_add_safe(lhs: timespec64, rhs: timespec64) -> timespec64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    _unused: [u8; 0],
}
pub const timespec_type_TT_NONE: timespec_type = 0;
pub const timespec_type_TT_NATIVE: timespec_type = 1;
pub const timespec_type_TT_COMPAT: timespec_type = 2;
pub type timespec_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block {
    pub arch_data: ::std::os::raw::c_ulong,
    pub fn_: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut restart_block) -> ::std::os::raw::c_long,
    >,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1 {
    pub futex: restart_block__bindgen_ty_1__bindgen_ty_1,
    pub nanosleep: restart_block__bindgen_ty_1__bindgen_ty_2,
    pub poll: restart_block__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_1 {
    pub uaddr: *mut u32_,
    pub val: u32_,
    pub flags: u32_,
    pub bitset: u32_,
    pub time: u64_,
    pub uaddr2: *mut u32_,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).uaddr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uaddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).val as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).flags as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).bitset as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(bitset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).time as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_1>())).uaddr2 as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uaddr2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_2 {
    pub clockid: clockid_t,
    pub type_: timespec_type,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub expires: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub rmtp: *mut __kernel_timespec,
    pub compat_rmtp: *mut old_timespec32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>())).rmtp
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(rmtp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                .compat_rmtp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(compat_rmtp)
        )
    );
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).clockid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(clockid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).type_ as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_2>())).expires
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(expires)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_3 {
    pub ufds: *mut pollfd,
    pub nfds: ::std::os::raw::c_int,
    pub has_timeout: ::std::os::raw::c_int,
    pub tv_sec: ::std::os::raw::c_ulong,
    pub tv_nsec: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<restart_block__bindgen_ty_1__bindgen_ty_3>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).ufds as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(ufds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).nfds as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(nfds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).has_timeout
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(has_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).tv_sec as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1__bindgen_ty_3>())).tv_nsec
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[test]
fn bindgen_test_layout_restart_block__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<restart_block__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(restart_block__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(restart_block__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1>())).futex as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1>())).nanosleep as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(nanosleep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<restart_block__bindgen_ty_1>())).poll as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block__bindgen_ty_1),
            "::",
            stringify!(poll)
        )
    );
}
#[test]
fn bindgen_test_layout_restart_block() {
    assert_eq!(
        ::std::mem::size_of::<restart_block>(),
        56usize,
        concat!("Size of: ", stringify!(restart_block))
    );
    assert_eq!(
        ::std::mem::align_of::<restart_block>(),
        8usize,
        concat!("Alignment of ", stringify!(restart_block))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<restart_block>())).arch_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block),
            "::",
            stringify!(arch_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<restart_block>())).fn_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(restart_block),
            "::",
            stringify!(fn_)
        )
    );
}
extern "C" {
    pub fn do_no_restart_syscall(parm: *mut restart_block) -> ::std::os::raw::c_long;
}
extern "C" {
    pub static mut current_task: *mut task_struct;
}
pub const BAD_STACK: ::std::os::raw::c_int = -1;
pub const NOT_STACK: ::std::os::raw::c_int = 0;
pub const GOOD_FRAME: ::std::os::raw::c_int = 1;
pub const GOOD_STACK: ::std::os::raw::c_int = 2;
pub type _bindgen_ty_3 = ::std::os::raw::c_int;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SECCOMP: syscall_work_bit = 0;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_TRACEPOINT: syscall_work_bit = 1;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_TRACE: syscall_work_bit = 2;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_EMU: syscall_work_bit = 3;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_AUDIT: syscall_work_bit = 4;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_USER_DISPATCH: syscall_work_bit = 5;
pub const syscall_work_bit_SYSCALL_WORK_BIT_SYSCALL_EXIT_TRAP: syscall_work_bit = 6;
pub type syscall_work_bit = ::std::os::raw::c_uint;
#[doc = " @CC_ATTR_MEM_ENCRYPT: Memory encryption is active"]
#[doc = ""]
#[doc = " The platform/OS is running with active memory encryption. This"]
#[doc = " includes running either as a bare-metal system or a hypervisor"]
#[doc = " and actively using memory encryption or as a guest/virtual machine"]
#[doc = " and actively using memory encryption."]
#[doc = ""]
#[doc = " Examples include SME, SEV and SEV-ES."]
pub const cc_attr_CC_ATTR_MEM_ENCRYPT: cc_attr = 0;
#[doc = " @CC_ATTR_HOST_MEM_ENCRYPT: Host memory encryption is active"]
#[doc = ""]
#[doc = " The platform/OS is running as a bare-metal system or a hypervisor"]
#[doc = " and actively using memory encryption."]
#[doc = ""]
#[doc = " Examples include SME."]
pub const cc_attr_CC_ATTR_HOST_MEM_ENCRYPT: cc_attr = 1;
#[doc = " @CC_ATTR_GUEST_MEM_ENCRYPT: Guest memory encryption is active"]
#[doc = ""]
#[doc = " The platform/OS is running as a guest/virtual machine and actively"]
#[doc = " using memory encryption."]
#[doc = ""]
#[doc = " Examples include SEV and SEV-ES."]
pub const cc_attr_CC_ATTR_GUEST_MEM_ENCRYPT: cc_attr = 2;
#[doc = " @CC_ATTR_GUEST_STATE_ENCRYPT: Guest state encryption is active"]
#[doc = ""]
#[doc = " The platform/OS is running as a guest/virtual machine and actively"]
#[doc = " using memory encryption and register state encryption."]
#[doc = ""]
#[doc = " Examples include SEV-ES."]
pub const cc_attr_CC_ATTR_GUEST_STATE_ENCRYPT: cc_attr = 3;
#[doc = " @CC_ATTR_GUEST_UNROLL_STRING_IO: String I/O is implemented with"]
#[doc = "                                  IN/OUT instructions"]
#[doc = ""]
#[doc = " The platform/OS is running as a guest/virtual machine and uses"]
#[doc = " IN/OUT instructions in place of string I/O."]
#[doc = ""]
#[doc = " Examples include TDX guest & SEV."]
pub const cc_attr_CC_ATTR_GUEST_UNROLL_STRING_IO: cc_attr = 4;
#[doc = " @CC_ATTR_SEV_SNP: Guest SNP is active."]
#[doc = ""]
#[doc = " The platform/OS is running as a guest/virtual machine and actively"]
#[doc = " using AMD SEV-SNP features."]
pub const cc_attr_CC_ATTR_GUEST_SEV_SNP: cc_attr = 5;
#[doc = " @CC_ATTR_HOTPLUG_DISABLED: Hotplug is not supported or disabled."]
#[doc = ""]
#[doc = " The platform/OS is running as a guest/virtual machine does not"]
#[doc = " support CPU hotplug feature."]
#[doc = ""]
#[doc = " Examples include TDX Guest."]
pub const cc_attr_CC_ATTR_HOTPLUG_DISABLED: cc_attr = 6;
#[doc = " enum cc_attr - Confidential computing attributes"]
#[doc = ""]
#[doc = " These attributes represent confidential computing features that are"]
#[doc = " currently active."]
pub type cc_attr = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct screen_info {
    pub orig_x: __u8,
    pub orig_y: __u8,
    pub ext_mem_k: __u16,
    pub orig_video_page: __u16,
    pub orig_video_mode: __u8,
    pub orig_video_cols: __u8,
    pub flags: __u8,
    pub unused2: __u8,
    pub orig_video_ega_bx: __u16,
    pub unused3: __u16,
    pub orig_video_lines: __u8,
    pub orig_video_isVGA: __u8,
    pub orig_video_points: __u16,
    pub lfb_width: __u16,
    pub lfb_height: __u16,
    pub lfb_depth: __u16,
    pub lfb_base: __u32,
    pub lfb_size: __u32,
    pub cl_magic: __u16,
    pub cl_offset: __u16,
    pub lfb_linelength: __u16,
    pub red_size: __u8,
    pub red_pos: __u8,
    pub green_size: __u8,
    pub green_pos: __u8,
    pub blue_size: __u8,
    pub blue_pos: __u8,
    pub rsvd_size: __u8,
    pub rsvd_pos: __u8,
    pub vesapm_seg: __u16,
    pub vesapm_off: __u16,
    pub pages: __u16,
    pub vesa_attributes: __u16,
    pub capabilities: __u32,
    pub ext_lfb_base: __u32,
    pub _reserved: [__u8; 2usize],
}
#[test]
fn bindgen_test_layout_screen_info() {
    assert_eq!(
        ::std::mem::size_of::<screen_info>(),
        64usize,
        concat!("Size of: ", stringify!(screen_info))
    );
    assert_eq!(
        ::std::mem::align_of::<screen_info>(),
        1usize,
        concat!("Alignment of ", stringify!(screen_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_y as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).ext_mem_k as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(ext_mem_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_page as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_page)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_mode as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_cols as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).unused2 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(unused2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_ega_bx as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_ega_bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).unused3 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(unused3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_lines as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_lines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_isVGA as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_isVGA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).orig_video_points as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(orig_video_points)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_width as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_height as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_depth as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).cl_magic as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(cl_magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).cl_offset as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(cl_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).lfb_linelength as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(lfb_linelength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).red_size as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(red_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).red_pos as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(red_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).green_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(green_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).green_pos as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(green_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).blue_size as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(blue_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).blue_pos as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(blue_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).rsvd_size as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(rsvd_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).rsvd_pos as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(rsvd_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).vesapm_seg as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(vesapm_seg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).vesapm_off as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(vesapm_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).pages as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).vesa_attributes as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(vesa_attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).capabilities as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>())).ext_lfb_base as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(ext_lfb_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<screen_info>()))._reserved as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(screen_info),
            "::",
            stringify!(_reserved)
        )
    );
}
extern "C" {
    pub static mut screen_info: screen_info;
}
pub type apm_event_t = ::std::os::raw::c_ushort;
pub type apm_eventinfo_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apm_bios_info {
    pub version: __u16,
    pub cseg: __u16,
    pub offset: __u32,
    pub cseg_16: __u16,
    pub dseg: __u16,
    pub flags: __u16,
    pub cseg_len: __u16,
    pub cseg_16_len: __u16,
    pub dseg_len: __u16,
}
#[test]
fn bindgen_test_layout_apm_bios_info() {
    assert_eq!(
        ::std::mem::size_of::<apm_bios_info>(),
        20usize,
        concat!("Size of: ", stringify!(apm_bios_info))
    );
    assert_eq!(
        ::std::mem::align_of::<apm_bios_info>(),
        4usize,
        concat!("Alignment of ", stringify!(apm_bios_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).cseg as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(cseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).cseg_16 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(cseg_16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).dseg as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(dseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).cseg_len as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(cseg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).cseg_16_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(cseg_16_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_bios_info>())).dseg_len as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_bios_info),
            "::",
            stringify!(dseg_len)
        )
    );
}
extern "C" {
    pub static mut __invalid_size_argument_for_IOC: ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apm_info {
    pub bios: apm_bios_info,
    pub connection_version: ::std::os::raw::c_ushort,
    pub get_power_status_broken: ::std::os::raw::c_int,
    pub get_power_status_swabinminutes: ::std::os::raw::c_int,
    pub allow_ints: ::std::os::raw::c_int,
    pub forbid_idle: ::std::os::raw::c_int,
    pub realmode_power_off: ::std::os::raw::c_int,
    pub disabled: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_apm_info() {
    assert_eq!(
        ::std::mem::size_of::<apm_info>(),
        48usize,
        concat!("Size of: ", stringify!(apm_info))
    );
    assert_eq!(
        ::std::mem::align_of::<apm_info>(),
        4usize,
        concat!("Alignment of ", stringify!(apm_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).bios as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(bios)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).connection_version as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(connection_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apm_info>())).get_power_status_broken as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(get_power_status_broken)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<apm_info>())).get_power_status_swabinminutes as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(get_power_status_swabinminutes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).allow_ints as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(allow_ints)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).forbid_idle as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(forbid_idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).realmode_power_off as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(realmode_power_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<apm_info>())).disabled as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(apm_info),
            "::",
            stringify!(disabled)
        )
    );
}
extern "C" {
    pub static mut apm_info: apm_info;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_device_params {
    pub length: __u16,
    pub info_flags: __u16,
    pub num_default_cylinders: __u32,
    pub num_default_heads: __u32,
    pub sectors_per_track: __u32,
    pub number_of_sectors: __u64,
    pub bytes_per_sector: __u16,
    pub dpte_ptr: __u32,
    pub key: __u16,
    pub device_path_info_length: __u8,
    pub reserved2: __u8,
    pub reserved3: __u16,
    pub host_bus_type: [__u8; 4usize],
    pub interface_type: [__u8; 8usize],
    pub interface_path: edd_device_params__bindgen_ty_1,
    pub device_path: edd_device_params__bindgen_ty_2,
    pub reserved4: __u8,
    pub checksum: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union edd_device_params__bindgen_ty_1 {
    pub isa: edd_device_params__bindgen_ty_1__bindgen_ty_1,
    pub pci: edd_device_params__bindgen_ty_1__bindgen_ty_2,
    pub ibnd: edd_device_params__bindgen_ty_1__bindgen_ty_3,
    pub xprs: edd_device_params__bindgen_ty_1__bindgen_ty_4,
    pub htpt: edd_device_params__bindgen_ty_1__bindgen_ty_5,
    pub unknown: edd_device_params__bindgen_ty_1__bindgen_ty_6,
    _bindgen_union_align: [u8; 8usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_1 {
    pub base_address: __u16,
    pub reserved1: __u16,
    pub reserved2: __u32,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_1>())).base_address
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(base_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_1>())).reserved1
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_1>())).reserved2
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_2 {
    pub bus: __u8,
    pub slot: __u8,
    pub function: __u8,
    pub channel: __u8,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_2>())).bus
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_2>())).slot
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_2>())).function
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_2>())).channel
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_2>())).reserved
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_3 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_3>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_4 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_4>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_4>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_5>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_5>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_1__bindgen_ty_6 {
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1__bindgen_ty_6>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1__bindgen_ty_6>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(edd_device_params__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(edd_device_params__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).isa as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(isa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).pci as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(pci)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).ibnd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(ibnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).xprs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(xprs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).htpt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(htpt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_1>())).unknown as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_1),
            "::",
            stringify!(unknown)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union edd_device_params__bindgen_ty_2 {
    pub ata: edd_device_params__bindgen_ty_2__bindgen_ty_1,
    pub atapi: edd_device_params__bindgen_ty_2__bindgen_ty_2,
    pub scsi: edd_device_params__bindgen_ty_2__bindgen_ty_3,
    pub usb: edd_device_params__bindgen_ty_2__bindgen_ty_4,
    pub i1394: edd_device_params__bindgen_ty_2__bindgen_ty_5,
    pub fibre: edd_device_params__bindgen_ty_2__bindgen_ty_6,
    pub i2o: edd_device_params__bindgen_ty_2__bindgen_ty_7,
    pub raid: edd_device_params__bindgen_ty_2__bindgen_ty_8,
    pub sata: edd_device_params__bindgen_ty_2__bindgen_ty_9,
    pub unknown: edd_device_params__bindgen_ty_2__bindgen_ty_10,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_1 {
    pub device: __u8,
    pub reserved1: __u8,
    pub reserved2: __u16,
    pub reserved3: __u32,
    pub reserved4: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_1>())).device
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_1>())).reserved1
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_1>())).reserved2
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_1>())).reserved3
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_1>())).reserved4
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(reserved4)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_2 {
    pub device: __u8,
    pub lun: __u8,
    pub reserved1: __u8,
    pub reserved2: __u8,
    pub reserved3: __u32,
    pub reserved4: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).device
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).lun
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(lun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).reserved1
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).reserved2
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).reserved3
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_2>())).reserved4
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(reserved4)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_3 {
    pub id: __u16,
    pub lun: __u64,
    pub reserved1: __u16,
    pub reserved2: __u32,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_3>())).id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_3>())).lun
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(lun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_3>())).reserved1
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_3>())).reserved2
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_4 {
    pub serial_number: __u64,
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_4>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_4>())).serial_number
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_4),
            "::",
            stringify!(serial_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_4>())).reserved
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_4),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_5 {
    pub eui: __u64,
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_5>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_5>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_5>())).eui
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_5),
            "::",
            stringify!(eui)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_5>())).reserved
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_5),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_6 {
    pub wwid: __u64,
    pub lun: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_6>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_6>())).wwid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_6),
            "::",
            stringify!(wwid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_6>())).lun
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_6),
            "::",
            stringify!(lun)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_7 {
    pub identity_tag: __u64,
    pub reserved: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_7>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_7>())).identity_tag
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_7),
            "::",
            stringify!(identity_tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_7>())).reserved
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_7),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_8 {
    pub array_number: __u32,
    pub reserved1: __u32,
    pub reserved2: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_8>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_8>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_8>())).array_number
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_8),
            "::",
            stringify!(array_number)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_8>())).reserved1
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_8),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_8>())).reserved2
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_8),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_9 {
    pub device: __u8,
    pub reserved1: __u8,
    pub reserved2: __u16,
    pub reserved3: __u32,
    pub reserved4: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_9>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_9>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_9>())).device
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_9>())).reserved1
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_9>())).reserved2
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_9>())).reserved3
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_9>())).reserved4
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(reserved4)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct edd_device_params__bindgen_ty_2__bindgen_ty_10 {
    pub reserved1: __u64,
    pub reserved2: __u64,
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2__bindgen_ty_10>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_10)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2__bindgen_ty_10>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_10>())).reserved1
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_10),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2__bindgen_ty_10>())).reserved2
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2__bindgen_ty_10),
            "::",
            stringify!(reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout_edd_device_params__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(edd_device_params__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(edd_device_params__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).ata as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(ata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).atapi as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(atapi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).scsi as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(scsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).usb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(usb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).i1394 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(i1394)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).fibre as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(fibre)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).i2o as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(i2o)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).raid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(raid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).sata as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(sata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params__bindgen_ty_2>())).unknown as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params__bindgen_ty_2),
            "::",
            stringify!(unknown)
        )
    );
}
#[test]
fn bindgen_test_layout_edd_device_params() {
    assert_eq!(
        ::std::mem::size_of::<edd_device_params>(),
        74usize,
        concat!("Size of: ", stringify!(edd_device_params))
    );
    assert_eq!(
        ::std::mem::align_of::<edd_device_params>(),
        1usize,
        concat!("Alignment of ", stringify!(edd_device_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).info_flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(info_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).num_default_cylinders as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(num_default_cylinders)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).num_default_heads as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(num_default_heads)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).sectors_per_track as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(sectors_per_track)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).number_of_sectors as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(number_of_sectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).bytes_per_sector as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(bytes_per_sector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).dpte_ptr as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(dpte_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).key as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).device_path_info_length as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(device_path_info_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).reserved2 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).reserved3 as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).host_bus_type as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(host_bus_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).interface_type as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(interface_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_device_params>())).interface_path as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(interface_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).device_path as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(device_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).reserved4 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_device_params>())).checksum as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_device_params),
            "::",
            stringify!(checksum)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct edd_info {
    pub device: __u8,
    pub version: __u8,
    pub interface_support: __u16,
    pub legacy_max_cylinder: __u16,
    pub legacy_max_head: __u8,
    pub legacy_sectors_per_track: __u8,
    pub params: edd_device_params,
}
#[test]
fn bindgen_test_layout_edd_info() {
    assert_eq!(
        ::std::mem::size_of::<edd_info>(),
        82usize,
        concat!("Size of: ", stringify!(edd_info))
    );
    assert_eq!(
        ::std::mem::align_of::<edd_info>(),
        1usize,
        concat!("Alignment of ", stringify!(edd_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).version as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).interface_support as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(interface_support)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).legacy_max_cylinder as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(legacy_max_cylinder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).legacy_max_head as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(legacy_max_head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<edd_info>())).legacy_sectors_per_track as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(legacy_sectors_per_track)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd_info>())).params as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(edd_info),
            "::",
            stringify!(params)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct edd {
    pub mbr_signature: [::std::os::raw::c_uint; 16usize],
    pub edd_info: [edd_info; 6usize],
    pub mbr_signature_nr: ::std::os::raw::c_uchar,
    pub edd_info_nr: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_edd() {
    assert_eq!(
        ::std::mem::size_of::<edd>(),
        560usize,
        concat!("Size of: ", stringify!(edd))
    );
    assert_eq!(
        ::std::mem::align_of::<edd>(),
        4usize,
        concat!("Alignment of ", stringify!(edd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd>())).mbr_signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edd),
            "::",
            stringify!(mbr_signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd>())).edd_info as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(edd),
            "::",
            stringify!(edd_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd>())).mbr_signature_nr as *const _ as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(edd),
            "::",
            stringify!(mbr_signature_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edd>())).edd_info_nr as *const _ as usize },
        557usize,
        concat!(
            "Offset of field: ",
            stringify!(edd),
            "::",
            stringify!(edd_info_nr)
        )
    );
}
extern "C" {
    pub static mut edd: edd;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ist_info {
    pub signature: __u32,
    pub command: __u32,
    pub event: __u32,
    pub perf_level: __u32,
}
#[test]
fn bindgen_test_layout_ist_info() {
    assert_eq!(
        ::std::mem::size_of::<ist_info>(),
        16usize,
        concat!("Size of: ", stringify!(ist_info))
    );
    assert_eq!(
        ::std::mem::align_of::<ist_info>(),
        4usize,
        concat!("Alignment of ", stringify!(ist_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ist_info>())).signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ist_info),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ist_info>())).command as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ist_info),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ist_info>())).event as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ist_info),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ist_info>())).perf_level as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ist_info),
            "::",
            stringify!(perf_level)
        )
    );
}
extern "C" {
    pub static mut ist_info: ist_info;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct edid_info {
    pub dummy: [::std::os::raw::c_uchar; 128usize],
}
#[test]
fn bindgen_test_layout_edid_info() {
    assert_eq!(
        ::std::mem::size_of::<edid_info>(),
        128usize,
        concat!("Size of: ", stringify!(edid_info))
    );
    assert_eq!(
        ::std::mem::align_of::<edid_info>(),
        1usize,
        concat!("Alignment of ", stringify!(edid_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<edid_info>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(edid_info),
            "::",
            stringify!(dummy)
        )
    );
}
extern "C" {
    pub static mut edid_info: edid_info;
}
#[repr(C)]
#[derive(Debug)]
pub struct setup_data {
    pub next: __u64,
    pub type_: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_setup_data() {
    assert_eq!(
        ::std::mem::size_of::<setup_data>(),
        16usize,
        concat!("Size of: ", stringify!(setup_data))
    );
    assert_eq!(
        ::std::mem::align_of::<setup_data>(),
        8usize,
        concat!("Alignment of ", stringify!(setup_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_data>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_data),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_data>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_data),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_data>())).len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_data),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_data>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_data),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct setup_indirect {
    pub type_: __u32,
    pub reserved: __u32,
    pub len: __u64,
    pub addr: __u64,
}
#[test]
fn bindgen_test_layout_setup_indirect() {
    assert_eq!(
        ::std::mem::size_of::<setup_indirect>(),
        24usize,
        concat!("Size of: ", stringify!(setup_indirect))
    );
    assert_eq!(
        ::std::mem::align_of::<setup_indirect>(),
        8usize,
        concat!("Alignment of ", stringify!(setup_indirect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_indirect>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_indirect),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_indirect>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_indirect),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_indirect>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_indirect),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_indirect>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_indirect),
            "::",
            stringify!(addr)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct setup_header {
    pub setup_sects: __u8,
    pub root_flags: __u16,
    pub syssize: __u32,
    pub ram_size: __u16,
    pub vid_mode: __u16,
    pub root_dev: __u16,
    pub boot_flag: __u16,
    pub jump: __u16,
    pub header: __u32,
    pub version: __u16,
    pub realmode_swtch: __u32,
    pub start_sys_seg: __u16,
    pub kernel_version: __u16,
    pub type_of_loader: __u8,
    pub loadflags: __u8,
    pub setup_move_size: __u16,
    pub code32_start: __u32,
    pub ramdisk_image: __u32,
    pub ramdisk_size: __u32,
    pub bootsect_kludge: __u32,
    pub heap_end_ptr: __u16,
    pub ext_loader_ver: __u8,
    pub ext_loader_type: __u8,
    pub cmd_line_ptr: __u32,
    pub initrd_addr_max: __u32,
    pub kernel_alignment: __u32,
    pub relocatable_kernel: __u8,
    pub min_alignment: __u8,
    pub xloadflags: __u16,
    pub cmdline_size: __u32,
    pub hardware_subarch: __u32,
    pub hardware_subarch_data: __u64,
    pub payload_offset: __u32,
    pub payload_length: __u32,
    pub setup_data: __u64,
    pub pref_address: __u64,
    pub init_size: __u32,
    pub handover_offset: __u32,
    pub kernel_info_offset: __u32,
}
#[test]
fn bindgen_test_layout_setup_header() {
    assert_eq!(
        ::std::mem::size_of::<setup_header>(),
        123usize,
        concat!("Size of: ", stringify!(setup_header))
    );
    assert_eq!(
        ::std::mem::align_of::<setup_header>(),
        1usize,
        concat!("Alignment of ", stringify!(setup_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).setup_sects as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(setup_sects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).root_flags as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(root_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).syssize as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(syssize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).ram_size as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(ram_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).vid_mode as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(vid_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).root_dev as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(root_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).boot_flag as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(boot_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).jump as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(jump)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).header as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).version as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).realmode_swtch as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(realmode_swtch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).start_sys_seg as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(start_sys_seg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).kernel_version as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(kernel_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).type_of_loader as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(type_of_loader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).loadflags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(loadflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).setup_move_size as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(setup_move_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).code32_start as *const _ as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(code32_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).ramdisk_image as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(ramdisk_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).ramdisk_size as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(ramdisk_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).bootsect_kludge as *const _ as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(bootsect_kludge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).heap_end_ptr as *const _ as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(heap_end_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).ext_loader_ver as *const _ as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(ext_loader_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).ext_loader_type as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(ext_loader_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).cmd_line_ptr as *const _ as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(cmd_line_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).initrd_addr_max as *const _ as usize },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(initrd_addr_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).kernel_alignment as *const _ as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(kernel_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).relocatable_kernel as *const _ as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(relocatable_kernel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).min_alignment as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(min_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).xloadflags as *const _ as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(xloadflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).cmdline_size as *const _ as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(cmdline_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).hardware_subarch as *const _ as usize },
        75usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(hardware_subarch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<setup_header>())).hardware_subarch_data as *const _ as usize
        },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(hardware_subarch_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).payload_offset as *const _ as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(payload_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).payload_length as *const _ as usize },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(payload_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).setup_data as *const _ as usize },
        95usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(setup_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).pref_address as *const _ as usize },
        103usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(pref_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).init_size as *const _ as usize },
        111usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(init_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).handover_offset as *const _ as usize },
        115usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(handover_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_header>())).kernel_info_offset as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_header),
            "::",
            stringify!(kernel_info_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sys_desc_table {
    pub length: __u16,
    pub table: [__u8; 14usize],
}
#[test]
fn bindgen_test_layout_sys_desc_table() {
    assert_eq!(
        ::std::mem::size_of::<sys_desc_table>(),
        16usize,
        concat!("Size of: ", stringify!(sys_desc_table))
    );
    assert_eq!(
        ::std::mem::align_of::<sys_desc_table>(),
        2usize,
        concat!("Alignment of ", stringify!(sys_desc_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sys_desc_table>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_desc_table),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sys_desc_table>())).table as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sys_desc_table),
            "::",
            stringify!(table)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct olpc_ofw_header {
    pub ofw_magic: __u32,
    pub ofw_version: __u32,
    pub cif_handler: __u32,
    pub irq_desc_table: __u32,
}
#[test]
fn bindgen_test_layout_olpc_ofw_header() {
    assert_eq!(
        ::std::mem::size_of::<olpc_ofw_header>(),
        16usize,
        concat!("Size of: ", stringify!(olpc_ofw_header))
    );
    assert_eq!(
        ::std::mem::align_of::<olpc_ofw_header>(),
        1usize,
        concat!("Alignment of ", stringify!(olpc_ofw_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<olpc_ofw_header>())).ofw_magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(olpc_ofw_header),
            "::",
            stringify!(ofw_magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<olpc_ofw_header>())).ofw_version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(olpc_ofw_header),
            "::",
            stringify!(ofw_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<olpc_ofw_header>())).cif_handler as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(olpc_ofw_header),
            "::",
            stringify!(cif_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<olpc_ofw_header>())).irq_desc_table as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(olpc_ofw_header),
            "::",
            stringify!(irq_desc_table)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct efi_info {
    pub efi_loader_signature: __u32,
    pub efi_systab: __u32,
    pub efi_memdesc_size: __u32,
    pub efi_memdesc_version: __u32,
    pub efi_memmap: __u32,
    pub efi_memmap_size: __u32,
    pub efi_systab_hi: __u32,
    pub efi_memmap_hi: __u32,
}
#[test]
fn bindgen_test_layout_efi_info() {
    assert_eq!(
        ::std::mem::size_of::<efi_info>(),
        32usize,
        concat!("Size of: ", stringify!(efi_info))
    );
    assert_eq!(
        ::std::mem::align_of::<efi_info>(),
        4usize,
        concat!("Alignment of ", stringify!(efi_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_loader_signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_loader_signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_systab as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_systab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_memdesc_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_memdesc_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_memdesc_version as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_memdesc_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_memmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_memmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_memmap_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_memmap_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_systab_hi as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_systab_hi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<efi_info>())).efi_memmap_hi as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(efi_info),
            "::",
            stringify!(efi_memmap_hi)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct boot_e820_entry {
    pub addr: __u64,
    pub size: __u64,
    pub type_: __u32,
}
#[test]
fn bindgen_test_layout_boot_e820_entry() {
    assert_eq!(
        ::std::mem::size_of::<boot_e820_entry>(),
        20usize,
        concat!("Size of: ", stringify!(boot_e820_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<boot_e820_entry>(),
        1usize,
        concat!("Alignment of ", stringify!(boot_e820_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_e820_entry>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_e820_entry),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_e820_entry>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_e820_entry),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_e820_entry>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_e820_entry),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct jailhouse_setup_data {
    pub hdr: jailhouse_setup_data__bindgen_ty_1,
    pub v1: jailhouse_setup_data__bindgen_ty_2,
    pub v2: jailhouse_setup_data__bindgen_ty_3,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct jailhouse_setup_data__bindgen_ty_1 {
    pub version: __u16,
    pub compatible_version: __u16,
}
#[test]
fn bindgen_test_layout_jailhouse_setup_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<jailhouse_setup_data__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(jailhouse_setup_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<jailhouse_setup_data__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(jailhouse_setup_data__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_1>())).version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_1>())).compatible_version
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_1),
            "::",
            stringify!(compatible_version)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct jailhouse_setup_data__bindgen_ty_2 {
    pub pm_timer_address: __u16,
    pub num_cpus: __u16,
    pub pci_mmconfig_base: __u64,
    pub tsc_khz: __u32,
    pub apic_khz: __u32,
    pub standard_ioapic: __u8,
    pub cpu_ids: [__u8; 255usize],
}
#[test]
fn bindgen_test_layout_jailhouse_setup_data__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<jailhouse_setup_data__bindgen_ty_2>(),
        276usize,
        concat!("Size of: ", stringify!(jailhouse_setup_data__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<jailhouse_setup_data__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(jailhouse_setup_data__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_2>())).pm_timer_address
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_2),
            "::",
            stringify!(pm_timer_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_2>())).num_cpus as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_2),
            "::",
            stringify!(num_cpus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_2>())).pci_mmconfig_base
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_2),
            "::",
            stringify!(pci_mmconfig_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_2>())).tsc_khz as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_2),
            "::",
            stringify!(tsc_khz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_2>())).apic_khz as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_2),
            "::",
            stringify!(apic_khz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_2>())).standard_ioapic
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_2),
            "::",
            stringify!(standard_ioapic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_2>())).cpu_ids as *const _
                as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_2),
            "::",
            stringify!(cpu_ids)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct jailhouse_setup_data__bindgen_ty_3 {
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_jailhouse_setup_data__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<jailhouse_setup_data__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(jailhouse_setup_data__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<jailhouse_setup_data__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(jailhouse_setup_data__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<jailhouse_setup_data__bindgen_ty_3>())).flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data__bindgen_ty_3),
            "::",
            stringify!(flags)
        )
    );
}
#[test]
fn bindgen_test_layout_jailhouse_setup_data() {
    assert_eq!(
        ::std::mem::size_of::<jailhouse_setup_data>(),
        284usize,
        concat!("Size of: ", stringify!(jailhouse_setup_data))
    );
    assert_eq!(
        ::std::mem::align_of::<jailhouse_setup_data>(),
        1usize,
        concat!("Alignment of ", stringify!(jailhouse_setup_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jailhouse_setup_data>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jailhouse_setup_data>())).v1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data),
            "::",
            stringify!(v1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jailhouse_setup_data>())).v2 as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(jailhouse_setup_data),
            "::",
            stringify!(v2)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ima_setup_data {
    pub addr: __u64,
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_ima_setup_data() {
    assert_eq!(
        ::std::mem::size_of::<ima_setup_data>(),
        16usize,
        concat!("Size of: ", stringify!(ima_setup_data))
    );
    assert_eq!(
        ::std::mem::align_of::<ima_setup_data>(),
        1usize,
        concat!("Alignment of ", stringify!(ima_setup_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ima_setup_data>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ima_setup_data),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ima_setup_data>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ima_setup_data),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct boot_params {
    pub screen_info: screen_info,
    pub apm_bios_info: apm_bios_info,
    pub _pad2: [__u8; 4usize],
    pub tboot_addr: __u64,
    pub ist_info: ist_info,
    pub acpi_rsdp_addr: __u64,
    pub _pad3: [__u8; 8usize],
    pub hd0_info: [__u8; 16usize],
    pub hd1_info: [__u8; 16usize],
    pub sys_desc_table: sys_desc_table,
    pub olpc_ofw_header: olpc_ofw_header,
    pub ext_ramdisk_image: __u32,
    pub ext_ramdisk_size: __u32,
    pub ext_cmd_line_ptr: __u32,
    pub _pad4: [__u8; 112usize],
    pub cc_blob_address: __u32,
    pub edid_info: edid_info,
    pub efi_info: efi_info,
    pub alt_mem_k: __u32,
    pub scratch: __u32,
    pub e820_entries: __u8,
    pub eddbuf_entries: __u8,
    pub edd_mbr_sig_buf_entries: __u8,
    pub kbd_status: __u8,
    pub secure_boot: __u8,
    pub _pad5: [__u8; 2usize],
    pub sentinel: __u8,
    pub _pad6: [__u8; 1usize],
    pub hdr: setup_header,
    pub _pad7: [__u8; 36usize],
    pub edd_mbr_sig_buffer: [__u32; 16usize],
    pub e820_table: [boot_e820_entry; 128usize],
    pub _pad8: [__u8; 48usize],
    pub eddbuf: [edd_info; 6usize],
    pub _pad9: [__u8; 276usize],
}
#[test]
fn bindgen_test_layout_boot_params() {
    assert_eq!(
        ::std::mem::size_of::<boot_params>(),
        4096usize,
        concat!("Size of: ", stringify!(boot_params))
    );
    assert_eq!(
        ::std::mem::align_of::<boot_params>(),
        1usize,
        concat!("Alignment of ", stringify!(boot_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).screen_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(screen_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).apm_bios_info as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(apm_bios_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad2 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).tboot_addr as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(tboot_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).ist_info as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(ist_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).acpi_rsdp_addr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(acpi_rsdp_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad3 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).hd0_info as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(hd0_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).hd1_info as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(hd1_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).sys_desc_table as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(sys_desc_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).olpc_ofw_header as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(olpc_ofw_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).ext_ramdisk_image as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(ext_ramdisk_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).ext_ramdisk_size as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(ext_ramdisk_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).ext_cmd_line_ptr as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(ext_cmd_line_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad4 as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).cc_blob_address as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(cc_blob_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).edid_info as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(edid_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).efi_info as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(efi_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).alt_mem_k as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(alt_mem_k)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).scratch as *const _ as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(scratch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).e820_entries as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(e820_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).eddbuf_entries as *const _ as usize },
        489usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(eddbuf_entries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<boot_params>())).edd_mbr_sig_buf_entries as *const _ as usize
        },
        490usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(edd_mbr_sig_buf_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).kbd_status as *const _ as usize },
        491usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(kbd_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).secure_boot as *const _ as usize },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(secure_boot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad5 as *const _ as usize },
        493usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).sentinel as *const _ as usize },
        495usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(sentinel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad6 as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).hdr as *const _ as usize },
        497usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad7 as *const _ as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).edd_mbr_sig_buffer as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(edd_mbr_sig_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).e820_table as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(e820_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad8 as *const _ as usize },
        3280usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>())).eddbuf as *const _ as usize },
        3328usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(eddbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<boot_params>()))._pad9 as *const _ as usize },
        3820usize,
        concat!(
            "Offset of field: ",
            stringify!(boot_params),
            "::",
            stringify!(_pad9)
        )
    );
}
pub const x86_hardware_subarch_X86_SUBARCH_PC: x86_hardware_subarch = 0;
pub const x86_hardware_subarch_X86_SUBARCH_LGUEST: x86_hardware_subarch = 1;
pub const x86_hardware_subarch_X86_SUBARCH_XEN: x86_hardware_subarch = 2;
pub const x86_hardware_subarch_X86_SUBARCH_INTEL_MID: x86_hardware_subarch = 3;
pub const x86_hardware_subarch_X86_SUBARCH_CE4100: x86_hardware_subarch = 4;
pub const x86_hardware_subarch_X86_NR_SUBARCHS: x86_hardware_subarch = 5;
#[doc = " enum x86_hardware_subarch - x86 hardware subarchitecture"]
#[doc = ""]
#[doc = " The x86 hardware_subarch and hardware_subarch_data were added as of the x86"]
#[doc = " boot protocol 2.07 to help distinguish and support custom x86 boot"]
#[doc = " sequences. This enum represents accepted values for the x86"]
#[doc = " hardware_subarch.  Custom x86 boot sequences (not X86_SUBARCH_PC) do not"]
#[doc = " have or simply *cannot* make use of natural stubs like BIOS or EFI, the"]
#[doc = " hardware_subarch can be used on the Linux entry path to revector to a"]
#[doc = " subarchitecture stub when needed. This subarchitecture stub can be used to"]
#[doc = " set up Linux boot parameters or for special care to account for nonstandard"]
#[doc = " handling of page tables."]
#[doc = ""]
#[doc = " These enums should only ever be used by x86 code, and the code that uses"]
#[doc = " it should be well contained and compartmentalized."]
#[doc = ""]
#[doc = " KVM and Xen HVM do not have a subarch as these are expected to follow"]
#[doc = " standard x86 boot entries. If there is a genuine need for \"hypervisor\" type"]
#[doc = " that should be considered separately in the future. Future guest types"]
#[doc = " should seriously consider working with standard x86 boot stubs such as"]
#[doc = " the BIOS or EFI boot stubs."]
#[doc = ""]
#[doc = " WARNING: this enum is only used for legacy hacks, for platform features that"]
#[doc = "\t    are not easily enumerated or discoverable. You should not ever use"]
#[doc = "\t    this for new features."]
#[doc = ""]
#[doc = " @X86_SUBARCH_PC: Should be used if the hardware is enumerable using standard"]
#[doc = "\tPC mechanisms (PCI, ACPI) and doesn't need a special boot flow."]
#[doc = " @X86_SUBARCH_LGUEST: Used for x86 hypervisor demo, lguest, deprecated"]
#[doc = " @X86_SUBARCH_XEN: Used for Xen guest types which follow the PV boot path,"]
#[doc = " \twhich start at asm startup_xen() entry point and later jump to the C"]
#[doc = " \txen_start_kernel() entry point. Both domU and dom0 type of guests are"]
#[doc = " \tcurrently supported through this PV boot path."]
#[doc = " @X86_SUBARCH_INTEL_MID: Used for Intel MID (Mobile Internet Device) platform"]
#[doc = "\tsystems which do not have the PCI legacy interfaces."]
#[doc = " @X86_SUBARCH_CE4100: Used for Intel CE media processor (CE4100) SoC"]
#[doc = " \tfor settop boxes and media devices, the use of a subarch for CE4100"]
#[doc = " \tis more of a hack..."]
pub type x86_hardware_subarch = ::std::os::raw::c_uint;
extern "C" {
    pub fn mem_encrypt_init();
}
extern "C" {
    pub fn add_encrypt_protection_map();
}
extern "C" {
    pub static mut __start_bss_decrypted: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut __end_bss_decrypted: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut __start_bss_decrypted_unused: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn kaslr_get_random_long(purpose: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn devmem_is_allowed(pagenr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut max_low_pfn_mapped: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut max_pfn_mapped: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn pfn_range_is_mapped(
        start_pfn: ::std::os::raw::c_ulong,
        end_pfn: ::std::os::raw::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn initmem_init();
}
extern "C" {
    pub static mut max_pfn: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut phys_base: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut page_offset_base: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut vmalloc_base: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut vmemmap_base: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn clear_page_orig(page: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn clear_page_rep(page: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn clear_page_erms(page: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn copy_page(to: *mut ::std::os::raw::c_void, from: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct range {
    pub start: u64_,
    pub end: u64_,
}
#[test]
fn bindgen_test_layout_range() {
    assert_eq!(
        ::std::mem::size_of::<range>(),
        16usize,
        concat!("Size of: ", stringify!(range))
    );
    assert_eq!(
        ::std::mem::align_of::<range>(),
        8usize,
        concat!("Alignment of ", stringify!(range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<range>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(range),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<range>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(range),
            "::",
            stringify!(end)
        )
    );
}
extern "C" {
    pub fn add_range(
        range: *mut range,
        az: ::std::os::raw::c_int,
        nr_range: ::std::os::raw::c_int,
        start: u64_,
        end: u64_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_range_with_merge(
        range: *mut range,
        az: ::std::os::raw::c_int,
        nr_range: ::std::os::raw::c_int,
        start: u64_,
        end: u64_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn subtract_range(range: *mut range, az: ::std::os::raw::c_int, start: u64_, end: u64_);
}
extern "C" {
    pub fn clean_sort_range(range: *mut range, az: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sort_range(range: *mut range, nr_range: ::std::os::raw::c_int);
}
extern "C" {
    pub static mut pfn_mapped: [range; 0usize];
}
extern "C" {
    pub static mut nr_pfn_mapped: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __virt_addr_valid(kaddr: ::std::os::raw::c_ulong) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pfn_t {
    pub val: u64_,
}
#[test]
fn bindgen_test_layout_pfn_t() {
    assert_eq!(
        ::std::mem::size_of::<pfn_t>(),
        8usize,
        concat!("Size of: ", stringify!(pfn_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pfn_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pfn_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pfn_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pfn_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_bitmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm86 {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut early_idt_handler_array: [[::std::os::raw::c_char; 9usize]; 32usize];
}
extern "C" {
    pub fn early_ignore_irq();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_regs {
    pub r15: ::std::os::raw::c_ulong,
    pub r14: ::std::os::raw::c_ulong,
    pub r13: ::std::os::raw::c_ulong,
    pub r12: ::std::os::raw::c_ulong,
    pub bp: ::std::os::raw::c_ulong,
    pub bx: ::std::os::raw::c_ulong,
    pub r11: ::std::os::raw::c_ulong,
    pub r10: ::std::os::raw::c_ulong,
    pub r9: ::std::os::raw::c_ulong,
    pub r8: ::std::os::raw::c_ulong,
    pub ax: ::std::os::raw::c_ulong,
    pub cx: ::std::os::raw::c_ulong,
    pub dx: ::std::os::raw::c_ulong,
    pub si: ::std::os::raw::c_ulong,
    pub di: ::std::os::raw::c_ulong,
    pub orig_ax: ::std::os::raw::c_ulong,
    pub ip: ::std::os::raw::c_ulong,
    pub cs: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub sp: ::std::os::raw::c_ulong,
    pub ss: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_pt_regs() {
    assert_eq!(
        ::std::mem::size_of::<pt_regs>(),
        168usize,
        concat!("Size of: ", stringify!(pt_regs))
    );
    assert_eq!(
        ::std::mem::align_of::<pt_regs>(),
        8usize,
        concat!("Alignment of ", stringify!(pt_regs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r15 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r14 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r13 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r12 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).bp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).bx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r11 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r10 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r9 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).r8 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).ax as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).cx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).dx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).si as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(si)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).di as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(di)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).orig_ax as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(orig_ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).ip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).cs as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).flags as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).sp as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pt_regs>())).ss as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(ss)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct desc_struct {
    pub limit0: u16_,
    pub base0: u16_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
#[test]
fn bindgen_test_layout_desc_struct() {
    assert_eq!(
        ::std::mem::size_of::<desc_struct>(),
        8usize,
        concat!("Size of: ", stringify!(desc_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<desc_struct>(),
        1usize,
        concat!("Alignment of ", stringify!(desc_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<desc_struct>())).limit0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(desc_struct),
            "::",
            stringify!(limit0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<desc_struct>())).base0 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(desc_struct),
            "::",
            stringify!(base0)
        )
    );
}
impl desc_struct {
    #[inline]
    pub fn base1(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn s(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_s(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit1(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_limit1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn avl(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_avl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_l(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn d(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_d(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn g(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_g(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn base2(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base2(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        base1: u16_,
        type_: u16_,
        s: u16_,
        dpl: u16_,
        p: u16_,
        limit1: u16_,
        avl: u16_,
        l: u16_,
        d: u16_,
        g: u16_,
        base2: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let base1: u16 = unsafe { ::std::mem::transmute(base1) };
            base1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let type_: u16 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let s: u16 = unsafe { ::std::mem::transmute(s) };
            s as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u16 = unsafe { ::std::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u16 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let limit1: u16 = unsafe { ::std::mem::transmute(limit1) };
            limit1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let avl: u16 = unsafe { ::std::mem::transmute(avl) };
            avl as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let l: u16 = unsafe { ::std::mem::transmute(l) };
            l as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let d: u16 = unsafe { ::std::mem::transmute(d) };
            d as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let g: u16 = unsafe { ::std::mem::transmute(g) };
            g as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let base2: u16 = unsafe { ::std::mem::transmute(base2) };
            base2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const GATE_INTERRUPT: ::std::os::raw::c_uint = 14;
pub const GATE_TRAP: ::std::os::raw::c_uint = 15;
pub const GATE_CALL: ::std::os::raw::c_uint = 12;
pub const GATE_TASK: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const DESC_TSS: ::std::os::raw::c_uint = 9;
pub const DESC_LDT: ::std::os::raw::c_uint = 2;
pub const DESCTYPE_S: ::std::os::raw::c_uint = 16;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ldttss_desc {
    pub limit0: u16_,
    pub base0: u16_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub base3: u32_,
    pub zero1: u32_,
}
#[test]
fn bindgen_test_layout_ldttss_desc() {
    assert_eq!(
        ::std::mem::size_of::<ldttss_desc>(),
        16usize,
        concat!("Size of: ", stringify!(ldttss_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<ldttss_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(ldttss_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldttss_desc>())).limit0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldttss_desc),
            "::",
            stringify!(limit0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldttss_desc>())).base0 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ldttss_desc),
            "::",
            stringify!(base0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldttss_desc>())).base3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldttss_desc),
            "::",
            stringify!(base3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldttss_desc>())).zero1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ldttss_desc),
            "::",
            stringify!(zero1)
        )
    );
}
impl ldttss_desc {
    #[inline]
    pub fn base1(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit1(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_limit1(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn zero0(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_zero0(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn g(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_g(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn base2(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_base2(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        base1: u16_,
        type_: u16_,
        dpl: u16_,
        p: u16_,
        limit1: u16_,
        zero0: u16_,
        g: u16_,
        base2: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let base1: u16 = unsafe { ::std::mem::transmute(base1) };
            base1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let type_: u16 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u16 = unsafe { ::std::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u16 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let limit1: u16 = unsafe { ::std::mem::transmute(limit1) };
            limit1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let zero0: u16 = unsafe { ::std::mem::transmute(zero0) };
            zero0 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let g: u16 = unsafe { ::std::mem::transmute(g) };
            g as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let base2: u16 = unsafe { ::std::mem::transmute(base2) };
            base2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ldt_desc = ldttss_desc;
pub type tss_desc = ldttss_desc;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct idt_bits {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_idt_bits() {
    assert_eq!(
        ::std::mem::size_of::<idt_bits>(),
        2usize,
        concat!("Size of: ", stringify!(idt_bits))
    );
    assert_eq!(
        ::std::mem::align_of::<idt_bits>(),
        1usize,
        concat!("Alignment of ", stringify!(idt_bits))
    );
}
impl idt_bits {
    #[inline]
    pub fn ist(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_ist(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn zero(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_zero(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dpl(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_dpl(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn p(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ist: u16_,
        zero: u16_,
        type_: u16_,
        dpl: u16_,
        p: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let ist: u16 = unsafe { ::std::mem::transmute(ist) };
            ist as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let zero: u16 = unsafe { ::std::mem::transmute(zero) };
            zero as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let type_: u16 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dpl: u16 = unsafe { ::std::mem::transmute(dpl) };
            dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let p: u16 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idt_data {
    pub vector: ::std::os::raw::c_uint,
    pub segment: ::std::os::raw::c_uint,
    pub bits: idt_bits,
    pub addr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_idt_data() {
    assert_eq!(
        ::std::mem::size_of::<idt_data>(),
        24usize,
        concat!("Size of: ", stringify!(idt_data))
    );
    assert_eq!(
        ::std::mem::align_of::<idt_data>(),
        8usize,
        concat!("Alignment of ", stringify!(idt_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idt_data>())).vector as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(idt_data),
            "::",
            stringify!(vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idt_data>())).segment as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(idt_data),
            "::",
            stringify!(segment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idt_data>())).bits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(idt_data),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<idt_data>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(idt_data),
            "::",
            stringify!(addr)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct gate_struct {
    pub offset_low: u16_,
    pub segment: u16_,
    pub bits: idt_bits,
    pub offset_middle: u16_,
    pub offset_high: u32_,
    pub reserved: u32_,
}
#[test]
fn bindgen_test_layout_gate_struct() {
    assert_eq!(
        ::std::mem::size_of::<gate_struct>(),
        16usize,
        concat!("Size of: ", stringify!(gate_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<gate_struct>(),
        1usize,
        concat!("Alignment of ", stringify!(gate_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).offset_low as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(offset_low)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).segment as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(segment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).bits as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).offset_middle as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(offset_middle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).offset_high as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(offset_high)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gate_struct>())).reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gate_struct),
            "::",
            stringify!(reserved)
        )
    );
}
pub type gate_desc = gate_struct;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct desc_ptr {
    pub size: ::std::os::raw::c_ushort,
    pub address: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_desc_ptr() {
    assert_eq!(
        ::std::mem::size_of::<desc_ptr>(),
        10usize,
        concat!("Size of: ", stringify!(desc_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<desc_ptr>(),
        1usize,
        concat!("Alignment of ", stringify!(desc_ptr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<desc_ptr>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(desc_ptr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<desc_ptr>())).address as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(desc_ptr),
            "::",
            stringify!(address)
        )
    );
}
pub const page_cache_mode__PAGE_CACHE_MODE_WB: page_cache_mode = 0;
pub const page_cache_mode__PAGE_CACHE_MODE_WC: page_cache_mode = 1;
pub const page_cache_mode__PAGE_CACHE_MODE_UC_MINUS: page_cache_mode = 2;
pub const page_cache_mode__PAGE_CACHE_MODE_UC: page_cache_mode = 3;
pub const page_cache_mode__PAGE_CACHE_MODE_WT: page_cache_mode = 4;
pub const page_cache_mode__PAGE_CACHE_MODE_WP: page_cache_mode = 5;
pub const page_cache_mode__PAGE_CACHE_MODE_NUM: page_cache_mode = 8;
pub type page_cache_mode = ::std::os::raw::c_uint;
pub type pteval_t = ::std::os::raw::c_ulong;
pub type pmdval_t = ::std::os::raw::c_ulong;
pub type pudval_t = ::std::os::raw::c_ulong;
pub type p4dval_t = ::std::os::raw::c_ulong;
pub type pgdval_t = ::std::os::raw::c_ulong;
pub type pgprotval_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pte_t {
    pub pte: pteval_t,
}
#[test]
fn bindgen_test_layout_pte_t() {
    assert_eq!(
        ::std::mem::size_of::<pte_t>(),
        8usize,
        concat!("Size of: ", stringify!(pte_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pte_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pte_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pte_t>())).pte as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pte_t),
            "::",
            stringify!(pte)
        )
    );
}
extern "C" {
    pub static mut __pgtable_l5_enabled: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut pgdir_shift: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut ptrs_per_p4d: ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pgprot {
    pub pgprot: pgprotval_t,
}
#[test]
fn bindgen_test_layout_pgprot() {
    assert_eq!(
        ::std::mem::size_of::<pgprot>(),
        8usize,
        concat!("Size of: ", stringify!(pgprot))
    );
    assert_eq!(
        ::std::mem::align_of::<pgprot>(),
        8usize,
        concat!("Alignment of ", stringify!(pgprot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pgprot>())).pgprot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pgprot),
            "::",
            stringify!(pgprot)
        )
    );
}
pub type pgprot_t = pgprot;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pgd_t {
    pub pgd: pgdval_t,
}
#[test]
fn bindgen_test_layout_pgd_t() {
    assert_eq!(
        ::std::mem::size_of::<pgd_t>(),
        8usize,
        concat!("Size of: ", stringify!(pgd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pgd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pgd_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pgd_t>())).pgd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pgd_t),
            "::",
            stringify!(pgd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct p4d_t {
    pub p4d: p4dval_t,
}
#[test]
fn bindgen_test_layout_p4d_t() {
    assert_eq!(
        ::std::mem::size_of::<p4d_t>(),
        8usize,
        concat!("Size of: ", stringify!(p4d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<p4d_t>(),
        8usize,
        concat!("Alignment of ", stringify!(p4d_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<p4d_t>())).p4d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(p4d_t),
            "::",
            stringify!(p4d)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pud_t {
    pub pud: pudval_t,
}
#[test]
fn bindgen_test_layout_pud_t() {
    assert_eq!(
        ::std::mem::size_of::<pud_t>(),
        8usize,
        concat!("Size of: ", stringify!(pud_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pud_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pud_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pud_t>())).pud as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pud_t),
            "::",
            stringify!(pud)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmd_t {
    pub pmd: pmdval_t,
}
#[test]
fn bindgen_test_layout_pmd_t() {
    assert_eq!(
        ::std::mem::size_of::<pmd_t>(),
        8usize,
        concat!("Size of: ", stringify!(pmd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pmd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pmd_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pmd_t>())).pmd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmd_t),
            "::",
            stringify!(pmd)
        )
    );
}
extern "C" {
    pub fn cachemode2protval(pcm: page_cache_mode) -> ::std::os::raw::c_ulong;
}
pub type pgtable_t = *mut page;
extern "C" {
    pub static mut __supported_pte_mask: pteval_t;
}
extern "C" {
    pub static mut __default_kernel_pte_mask: pteval_t;
}
extern "C" {
    pub fn set_nx();
}
extern "C" {
    pub static mut nx_enabled: ::std::os::raw::c_int;
}
extern "C" {
    pub fn pgprot_writecombine(prot: pgprot_t) -> pgprot_t;
}
extern "C" {
    pub fn pgprot_writethrough(prot: pgprot_t) -> pgprot_t;
}
extern "C" {
    pub fn phys_mem_access_prot(
        file: *mut file,
        pfn: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        vma_prot: pgprot_t,
    ) -> pgprot_t;
}
extern "C" {
    pub fn set_pte_vaddr(vaddr: ::std::os::raw::c_ulong, pte: pte_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seq_file {
    _unused: [u8; 0],
}
extern "C" {
    pub fn arch_report_meminfo(m: *mut seq_file);
}
pub const pg_level_PG_LEVEL_NONE: pg_level = 0;
pub const pg_level_PG_LEVEL_4K: pg_level = 1;
pub const pg_level_PG_LEVEL_2M: pg_level = 2;
pub const pg_level_PG_LEVEL_1G: pg_level = 3;
pub const pg_level_PG_LEVEL_512G: pg_level = 4;
pub const pg_level_PG_LEVEL_NUM: pg_level = 5;
pub type pg_level = ::std::os::raw::c_uint;
extern "C" {
    pub fn update_page_count(level: ::std::os::raw::c_int, pages: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn lookup_address(
        address: ::std::os::raw::c_ulong,
        level: *mut ::std::os::raw::c_uint,
    ) -> *mut pte_t;
}
extern "C" {
    pub fn lookup_address_in_pgd(
        pgd: *mut pgd_t,
        address: ::std::os::raw::c_ulong,
        level: *mut ::std::os::raw::c_uint,
    ) -> *mut pte_t;
}
extern "C" {
    pub fn lookup_pmd_address(address: ::std::os::raw::c_ulong) -> *mut pmd_t;
}
extern "C" {
    pub fn slow_virt_to_phys(__address: *mut ::std::os::raw::c_void) -> phys_addr_t;
}
extern "C" {
    pub fn kernel_map_pages_in_pgd(
        pgd: *mut pgd_t,
        pfn: u64_,
        address: ::std::os::raw::c_ulong,
        numpages: ::std::os::raw::c_uint,
        page_flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kernel_unmap_pages_in_pgd(
        pgd: *mut pgd_t,
        address: ::std::os::raw::c_ulong,
        numpages: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct orc_entry {
    pub sp_offset: s16,
    pub bp_offset: s16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_orc_entry() {
    assert_eq!(
        ::std::mem::size_of::<orc_entry>(),
        6usize,
        concat!("Size of: ", stringify!(orc_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<orc_entry>(),
        1usize,
        concat!("Alignment of ", stringify!(orc_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<orc_entry>())).sp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(orc_entry),
            "::",
            stringify!(sp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<orc_entry>())).bp_offset as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(orc_entry),
            "::",
            stringify!(bp_offset)
        )
    );
}
impl orc_entry {
    #[inline]
    pub fn sp_reg(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sp_reg(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bp_reg(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_bp_reg(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn end(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_end(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sp_reg: ::std::os::raw::c_uint,
        bp_reg: ::std::os::raw::c_uint,
        type_: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sp_reg: u32 = unsafe { ::std::mem::transmute(sp_reg) };
            sp_reg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let bp_reg: u32 = unsafe { ::std::mem::transmute(bp_reg) };
            bp_reg as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let end: u32 = unsafe { ::std::mem::transmute(end) };
            end as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type retpoline_thunk_t = [u8_; 32usize];
extern "C" {
    pub static mut __x86_indirect_thunk_array: [retpoline_thunk_t; 0usize];
}
extern "C" {
    pub fn __x86_return_thunk();
}
extern "C" {
    pub fn zen_untrain_ret();
}
extern "C" {
    pub fn entry_ibpb();
}
extern "C" {
    pub static mut __x86_indirect_thunk_rax: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rcx: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rdx: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rbx: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rsp: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rbp: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rsi: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_rdi: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r8: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r9: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r10: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r11: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r12: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r13: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r14: retpoline_thunk_t;
}
extern "C" {
    pub static mut __x86_indirect_thunk_r15: retpoline_thunk_t;
}
pub const spectre_v2_mitigation_SPECTRE_V2_NONE: spectre_v2_mitigation = 0;
pub const spectre_v2_mitigation_SPECTRE_V2_RETPOLINE: spectre_v2_mitigation = 1;
pub const spectre_v2_mitigation_SPECTRE_V2_LFENCE: spectre_v2_mitigation = 2;
pub const spectre_v2_mitigation_SPECTRE_V2_EIBRS: spectre_v2_mitigation = 3;
pub const spectre_v2_mitigation_SPECTRE_V2_EIBRS_RETPOLINE: spectre_v2_mitigation = 4;
pub const spectre_v2_mitigation_SPECTRE_V2_EIBRS_LFENCE: spectre_v2_mitigation = 5;
pub const spectre_v2_mitigation_SPECTRE_V2_IBRS: spectre_v2_mitigation = 6;
pub type spectre_v2_mitigation = ::std::os::raw::c_uint;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_NONE: spectre_v2_user_mitigation = 0;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_STRICT: spectre_v2_user_mitigation = 1;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_STRICT_PREFERRED: spectre_v2_user_mitigation =
    2;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_PRCTL: spectre_v2_user_mitigation = 3;
pub const spectre_v2_user_mitigation_SPECTRE_V2_USER_SECCOMP: spectre_v2_user_mitigation = 4;
pub type spectre_v2_user_mitigation = ::std::os::raw::c_uint;
pub const ssb_mitigation_SPEC_STORE_BYPASS_NONE: ssb_mitigation = 0;
pub const ssb_mitigation_SPEC_STORE_BYPASS_DISABLE: ssb_mitigation = 1;
pub const ssb_mitigation_SPEC_STORE_BYPASS_PRCTL: ssb_mitigation = 2;
pub const ssb_mitigation_SPEC_STORE_BYPASS_SECCOMP: ssb_mitigation = 3;
pub type ssb_mitigation = ::std::os::raw::c_uint;
extern "C" {
    pub static mut __indirect_thunk_start: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut __indirect_thunk_end: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut x86_spec_ctrl_base: u64_;
}
extern "C" {
    pub static mut x86_spec_ctrl_current: ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn update_spec_ctrl_cond(val: u64_);
}
extern "C" {
    pub fn spec_ctrl_current() -> u64_;
}
extern "C" {
    pub static mut switch_to_cond_stibp: static_key_false;
}
extern "C" {
    pub static mut switch_mm_cond_ibpb: static_key_false;
}
extern "C" {
    pub static mut switch_mm_always_ibpb: static_key_false;
}
extern "C" {
    pub static mut mds_user_clear: static_key_false;
}
extern "C" {
    pub static mut mds_idle_clear: static_key_false;
}
extern "C" {
    pub static mut switch_mm_cond_l1d_flush: static_key_false;
}
extern "C" {
    pub static mut mmio_stale_data_clear: static_key_false;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flush_tlb_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmu_gather {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct paravirt_callee_save {
    pub func: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_paravirt_callee_save() {
    assert_eq!(
        ::std::mem::size_of::<paravirt_callee_save>(),
        8usize,
        concat!("Size of: ", stringify!(paravirt_callee_save))
    );
    assert_eq!(
        ::std::mem::align_of::<paravirt_callee_save>(),
        8usize,
        concat!("Alignment of ", stringify!(paravirt_callee_save))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_callee_save>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_callee_save),
            "::",
            stringify!(func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pv_info {
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_pv_info() {
    assert_eq!(
        ::std::mem::size_of::<pv_info>(),
        8usize,
        concat!("Size of: ", stringify!(pv_info))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_info>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_info),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pv_cpu_ops {
    pub io_delay: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_pv_cpu_ops() {
    assert_eq!(
        ::std::mem::size_of::<pv_cpu_ops>(),
        8usize,
        concat!("Size of: ", stringify!(pv_cpu_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_cpu_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_cpu_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_cpu_ops>())).io_delay as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_cpu_ops),
            "::",
            stringify!(io_delay)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pv_irq_ops {}
#[test]
fn bindgen_test_layout_pv_irq_ops() {
    assert_eq!(
        ::std::mem::size_of::<pv_irq_ops>(),
        0usize,
        concat!("Size of: ", stringify!(pv_irq_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_irq_ops>(),
        1usize,
        concat!("Alignment of ", stringify!(pv_irq_ops))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pv_mmu_ops {
    pub flush_tlb_user: ::std::option::Option<unsafe extern "C" fn()>,
    pub flush_tlb_kernel: ::std::option::Option<unsafe extern "C" fn()>,
    pub flush_tlb_one_user:
        ::std::option::Option<unsafe extern "C" fn(addr: ::std::os::raw::c_ulong)>,
    pub flush_tlb_multi: ::std::option::Option<
        unsafe extern "C" fn(cpus: *const cpumask, info: *const flush_tlb_info),
    >,
    pub tlb_remove_table: ::std::option::Option<
        unsafe extern "C" fn(tlb: *mut mmu_gather, table: *mut ::std::os::raw::c_void),
    >,
    pub exit_mmap: ::std::option::Option<unsafe extern "C" fn(mm: *mut mm_struct)>,
    pub notify_page_enc_status_changed: ::std::option::Option<
        unsafe extern "C" fn(
            pfn: ::std::os::raw::c_ulong,
            npages: ::std::os::raw::c_int,
            enc: bool_,
        ),
    >,
}
#[test]
fn bindgen_test_layout_pv_mmu_ops() {
    assert_eq!(
        ::std::mem::size_of::<pv_mmu_ops>(),
        56usize,
        concat!("Size of: ", stringify!(pv_mmu_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_mmu_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_mmu_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).flush_tlb_user as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(flush_tlb_user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).flush_tlb_kernel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(flush_tlb_kernel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).flush_tlb_one_user as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(flush_tlb_one_user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).flush_tlb_multi as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(flush_tlb_multi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).tlb_remove_table as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(tlb_remove_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_mmu_ops>())).exit_mmap as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(exit_mmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pv_mmu_ops>())).notify_page_enc_status_changed as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_mmu_ops),
            "::",
            stringify!(notify_page_enc_status_changed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_spinlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pv_lock_ops {
    pub queued_spin_lock_slowpath:
        ::std::option::Option<unsafe extern "C" fn(lock: *mut qspinlock, val: u32_)>,
    pub queued_spin_unlock: paravirt_callee_save,
    pub wait: ::std::option::Option<unsafe extern "C" fn(ptr: *mut u8_, val: u8_)>,
    pub kick: ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_int)>,
    pub vcpu_is_preempted: paravirt_callee_save,
}
#[test]
fn bindgen_test_layout_pv_lock_ops() {
    assert_eq!(
        ::std::mem::size_of::<pv_lock_ops>(),
        40usize,
        concat!("Size of: ", stringify!(pv_lock_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<pv_lock_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(pv_lock_ops))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pv_lock_ops>())).queued_spin_lock_slowpath as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lock_ops),
            "::",
            stringify!(queued_spin_lock_slowpath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_lock_ops>())).queued_spin_unlock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lock_ops),
            "::",
            stringify!(queued_spin_unlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_lock_ops>())).wait as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lock_ops),
            "::",
            stringify!(wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_lock_ops>())).kick as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lock_ops),
            "::",
            stringify!(kick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pv_lock_ops>())).vcpu_is_preempted as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pv_lock_ops),
            "::",
            stringify!(vcpu_is_preempted)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct paravirt_patch_template {
    pub cpu: pv_cpu_ops,
    pub irq: pv_irq_ops,
    pub mmu: pv_mmu_ops,
    pub lock: pv_lock_ops,
}
#[test]
fn bindgen_test_layout_paravirt_patch_template() {
    assert_eq!(
        ::std::mem::size_of::<paravirt_patch_template>(),
        104usize,
        concat!("Size of: ", stringify!(paravirt_patch_template))
    );
    assert_eq!(
        ::std::mem::align_of::<paravirt_patch_template>(),
        8usize,
        concat!("Alignment of ", stringify!(paravirt_patch_template))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_template>())).cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_template),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_template>())).irq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_template),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_template>())).mmu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_template),
            "::",
            stringify!(mmu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_template>())).lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_template),
            "::",
            stringify!(lock)
        )
    );
}
extern "C" {
    pub static mut pv_info: pv_info;
}
extern "C" {
    pub static mut pv_ops: paravirt_patch_template;
}
extern "C" {
    pub fn paravirt_patch(
        type_: u8_,
        insn_buff: *mut ::std::os::raw::c_void,
        addr: ::std::os::raw::c_ulong,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn paravirt_disable_iospace() -> ::std::os::raw::c_int;
}
pub const paravirt_lazy_mode_PARAVIRT_LAZY_NONE: paravirt_lazy_mode = 0;
pub const paravirt_lazy_mode_PARAVIRT_LAZY_MMU: paravirt_lazy_mode = 1;
pub const paravirt_lazy_mode_PARAVIRT_LAZY_CPU: paravirt_lazy_mode = 2;
pub type paravirt_lazy_mode = ::std::os::raw::c_uint;
extern "C" {
    pub fn paravirt_get_lazy_mode() -> paravirt_lazy_mode;
}
extern "C" {
    pub fn paravirt_start_context_switch(prev: *mut task_struct);
}
extern "C" {
    pub fn paravirt_end_context_switch(next: *mut task_struct);
}
extern "C" {
    pub fn paravirt_enter_lazy_mmu();
}
extern "C" {
    pub fn paravirt_leave_lazy_mmu();
}
extern "C" {
    pub fn paravirt_flush_lazy_mmu();
}
extern "C" {
    pub fn _paravirt_nop();
}
extern "C" {
    pub fn paravirt_BUG();
}
extern "C" {
    pub fn _paravirt_ident_64(arg1: u64_) -> u64_;
}
extern "C" {
    pub fn paravirt_ret0() -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct paravirt_patch_site {
    pub instr: *mut u8_,
    pub type_: u8_,
    pub len: u8_,
}
#[test]
fn bindgen_test_layout_paravirt_patch_site() {
    assert_eq!(
        ::std::mem::size_of::<paravirt_patch_site>(),
        16usize,
        concat!("Size of: ", stringify!(paravirt_patch_site))
    );
    assert_eq!(
        ::std::mem::align_of::<paravirt_patch_site>(),
        8usize,
        concat!("Alignment of ", stringify!(paravirt_patch_site))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_site>())).instr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_site),
            "::",
            stringify!(instr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_site>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_site),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<paravirt_patch_site>())).len as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(paravirt_patch_site),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub static mut __parainstructions: [paravirt_patch_site; 0usize];
}
extern "C" {
    pub static mut __parainstructions_end: [paravirt_patch_site; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user_desc {
    pub entry_number: ::std::os::raw::c_uint,
    pub base_addr: ::std::os::raw::c_uint,
    pub limit: ::std::os::raw::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_user_desc() {
    assert_eq!(
        ::std::mem::size_of::<user_desc>(),
        16usize,
        concat!("Size of: ", stringify!(user_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<user_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(user_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_desc>())).entry_number as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(user_desc),
            "::",
            stringify!(entry_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_desc>())).base_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(user_desc),
            "::",
            stringify!(base_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_desc>())).limit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(user_desc),
            "::",
            stringify!(limit)
        )
    );
}
impl user_desc {
    #[inline]
    pub fn seg_32bit(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_seg_32bit(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn contents(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_contents(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn read_exec_only(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read_exec_only(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn limit_in_pages(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_limit_in_pages(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn seg_not_present(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_seg_not_present(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn useable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_useable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lm(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lm(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        seg_32bit: ::std::os::raw::c_uint,
        contents: ::std::os::raw::c_uint,
        read_exec_only: ::std::os::raw::c_uint,
        limit_in_pages: ::std::os::raw::c_uint,
        seg_not_present: ::std::os::raw::c_uint,
        useable: ::std::os::raw::c_uint,
        lm: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let seg_32bit: u32 = unsafe { ::std::mem::transmute(seg_32bit) };
            seg_32bit as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let contents: u32 = unsafe { ::std::mem::transmute(contents) };
            contents as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let read_exec_only: u32 = unsafe { ::std::mem::transmute(read_exec_only) };
            read_exec_only as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let limit_in_pages: u32 = unsafe { ::std::mem::transmute(limit_in_pages) };
            limit_in_pages as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let seg_not_present: u32 = unsafe { ::std::mem::transmute(seg_not_present) };
            seg_not_present as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let useable: u32 = unsafe { ::std::mem::transmute(useable) };
            useable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let lm: u32 = unsafe { ::std::mem::transmute(lm) };
            lm as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn syscall_init();
}
extern "C" {
    pub fn entry_SYSCALL_64();
}
extern "C" {
    pub fn entry_SYSCALL_64_safe_stack();
}
extern "C" {
    pub fn entry_SYSRETQ_unsafe_stack();
}
extern "C" {
    pub fn entry_SYSRETQ_end();
}
extern "C" {
    pub fn do_arch_prctl_64(
        task: *mut task_struct,
        option: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn entry_SYSENTER_compat();
}
extern "C" {
    pub fn __end_entry_SYSENTER_compat();
}
extern "C" {
    pub fn entry_SYSCALL_compat();
}
extern "C" {
    pub fn entry_SYSCALL_compat_safe_stack();
}
extern "C" {
    pub fn entry_SYSRETL_compat_unsafe_stack();
}
extern "C" {
    pub fn entry_SYSRETL_compat_end();
}
extern "C" {
    pub fn entry_INT80_compat();
}
extern "C" {
    pub fn x86_configure_nx();
}
extern "C" {
    pub static mut reboot_force: ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_arch_prctl_common(
        option: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn profile_pc(regs: *mut pt_regs) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn convert_ip_to_linear(
        child: *mut task_struct,
        regs: *mut pt_regs,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn send_sigtrap(
        regs: *mut pt_regs,
        error_code: ::std::os::raw::c_int,
        si_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn regs_query_register_offset(name: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regs_query_register_name(
        offset: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn copy_from_kernel_nofault(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn do_get_thread_area(
        p: *mut task_struct,
        idx: ::std::os::raw::c_int,
        info: *mut user_desc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_set_thread_area(
        p: *mut task_struct,
        idx: ::std::os::raw::c_int,
        info: *mut user_desc,
        can_allocate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct math_emu_info {
    pub ___orig_eip: ::std::os::raw::c_long,
    pub regs: *mut pt_regs,
}
#[test]
fn bindgen_test_layout_math_emu_info() {
    assert_eq!(
        ::std::mem::size_of::<math_emu_info>(),
        16usize,
        concat!("Size of: ", stringify!(math_emu_info))
    );
    assert_eq!(
        ::std::mem::align_of::<math_emu_info>(),
        8usize,
        concat!("Alignment of ", stringify!(math_emu_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<math_emu_info>())).___orig_eip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(math_emu_info),
            "::",
            stringify!(___orig_eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<math_emu_info>())).regs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(math_emu_info),
            "::",
            stringify!(regs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __u32,
    pub extended_size: __u32,
    pub xfeatures: __u64,
    pub xstate_size: __u32,
    pub padding: [__u32; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(
        ::std::mem::size_of::<_fpx_sw_bytes>(),
        48usize,
        concat!("Size of: ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpx_sw_bytes>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).magic1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(magic1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).extended_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(extended_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xfeatures as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).padding as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [__u16; 4usize],
    pub exponent: __u16,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpreg>(),
        10usize,
        concat!("Size of: ", stringify!(_fpreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [__u16; 4usize],
    pub exponent: __u16,
    pub padding: [__u16; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).padding as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__u32; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _fpstate_32 {
    pub cw: __u32,
    pub sw: __u32,
    pub tag: __u32,
    pub ipoff: __u32,
    pub cssel: __u32,
    pub dataoff: __u32,
    pub datasel: __u32,
    pub _st: [_fpreg; 8usize],
    pub status: __u16,
    pub magic: __u16,
    pub _fxsr_env: [__u32; 6usize],
    pub mxcsr: __u32,
    pub reserved: __u32,
    pub _fxsr_st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 8usize],
    pub __bindgen_anon_1: _fpstate_32__bindgen_ty_1,
    pub __bindgen_anon_2: _fpstate_32__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fpstate_32__bindgen_ty_1 {
    pub padding1: [__u32; 44usize],
    pub padding: [__u32; 44usize],
    _bindgen_union_align: [u32; 44usize],
}
#[test]
fn bindgen_test_layout__fpstate_32__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_32__bindgen_ty_1>(),
        176usize,
        concat!("Size of: ", stringify!(_fpstate_32__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_32__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_fpstate_32__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_1>())).padding1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_1),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_1>())).padding as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fpstate_32__bindgen_ty_2 {
    pub padding2: [__u32; 12usize],
    pub sw_reserved: _fpx_sw_bytes,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout__fpstate_32__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_32__bindgen_ty_2>(),
        48usize,
        concat!("Size of: ", stringify!(_fpstate_32__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_32__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate_32__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_2>())).padding2 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_2),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_32__bindgen_ty_2>())).sw_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32__bindgen_ty_2),
            "::",
            stringify!(sw_reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__fpstate_32() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_32>(),
        624usize,
        concat!("Size of: ", stringify!(_fpstate_32))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_32>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate_32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).cw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(cw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).sw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(sw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).tag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).ipoff as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(ipoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).cssel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(cssel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).dataoff as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(dataoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).datasel as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(datasel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._st as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).status as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).magic as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._fxsr_env as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_fxsr_env)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).mxcsr as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>())).reserved as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._fxsr_st as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_fxsr_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_32>()))._xmm as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_32),
            "::",
            stringify!(_xmm)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _fpstate_64 {
    pub cwd: __u16,
    pub swd: __u16,
    pub twd: __u16,
    pub fop: __u16,
    pub rip: __u64,
    pub rdp: __u64,
    pub mxcsr: __u32,
    pub mxcsr_mask: __u32,
    pub st_space: [__u32; 32usize],
    pub xmm_space: [__u32; 64usize],
    pub reserved2: [__u32; 12usize],
    pub __bindgen_anon_1: _fpstate_64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _fpstate_64__bindgen_ty_1 {
    pub reserved3: [__u32; 12usize],
    pub sw_reserved: _fpx_sw_bytes,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout__fpstate_64__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_64__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(_fpstate_64__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_64__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate_64__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_64__bindgen_ty_1>())).reserved3 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64__bindgen_ty_1),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_fpstate_64__bindgen_ty_1>())).sw_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64__bindgen_ty_1),
            "::",
            stringify!(sw_reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__fpstate_64() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate_64>(),
        512usize,
        concat!("Size of: ", stringify!(_fpstate_64))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate_64>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate_64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).twd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).mxcsr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(mxcsr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).st_space as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).xmm_space as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(xmm_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate_64>())).reserved2 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate_64),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _header {
    pub xfeatures: __u64,
    pub reserved1: [__u64; 2usize],
    pub reserved2: [__u64; 5usize],
}
#[test]
fn bindgen_test_layout__header() {
    assert_eq!(
        ::std::mem::size_of::<_header>(),
        64usize,
        concat!("Size of: ", stringify!(_header))
    );
    assert_eq!(
        ::std::mem::align_of::<_header>(),
        8usize,
        concat!("Alignment of ", stringify!(_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header>())).xfeatures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_header),
            "::",
            stringify!(xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header>())).reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_header),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header>())).reserved2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_header),
            "::",
            stringify!(reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__u32; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(
        ::std::mem::size_of::<_ymmh_state>(),
        256usize,
        concat!("Size of: ", stringify!(_ymmh_state))
    );
    assert_eq!(
        ::std::mem::align_of::<_ymmh_state>(),
        4usize,
        concat!("Alignment of ", stringify!(_ymmh_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ymmh_state>())).ymmh_space as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ymmh_state),
            "::",
            stringify!(ymmh_space)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate_64,
    pub xstate_hdr: _header,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(
        ::std::mem::size_of::<_xstate>(),
        832usize,
        concat!("Size of: ", stringify!(_xstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_xstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_xstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).fpstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).xstate_hdr as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(xstate_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).ymmh as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(ymmh)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext_32 {
    pub gs: __u16,
    pub __gsh: __u16,
    pub fs: __u16,
    pub __fsh: __u16,
    pub es: __u16,
    pub __esh: __u16,
    pub ds: __u16,
    pub __dsh: __u16,
    pub di: __u32,
    pub si: __u32,
    pub bp: __u32,
    pub sp: __u32,
    pub bx: __u32,
    pub dx: __u32,
    pub cx: __u32,
    pub ax: __u32,
    pub trapno: __u32,
    pub err: __u32,
    pub ip: __u32,
    pub cs: __u16,
    pub __csh: __u16,
    pub flags: __u32,
    pub sp_at_signal: __u32,
    pub ss: __u16,
    pub __ssh: __u16,
    pub fpstate: __u32,
    pub oldmask: __u32,
    pub cr2: __u32,
}
#[test]
fn bindgen_test_layout_sigcontext_32() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext_32>(),
        88usize,
        concat!("Size of: ", stringify!(sigcontext_32))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext_32>(),
        4usize,
        concat!("Alignment of ", stringify!(sigcontext_32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).gs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__gsh as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__gsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).fs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__fsh as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__fsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).es as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__esh as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__esh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ds as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__dsh as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__dsh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).di as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(di)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).si as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(si)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).bp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).sp as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).bx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).dx as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).cx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ax as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).trapno as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).err as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ip as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).cs as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__csh as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__csh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).sp_at_signal as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(sp_at_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).ss as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).__ssh as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(__ssh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).fpstate as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).oldmask as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_32>())).cr2 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_32),
            "::",
            stringify!(cr2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigcontext_64 {
    pub r8: __u64,
    pub r9: __u64,
    pub r10: __u64,
    pub r11: __u64,
    pub r12: __u64,
    pub r13: __u64,
    pub r14: __u64,
    pub r15: __u64,
    pub di: __u64,
    pub si: __u64,
    pub bp: __u64,
    pub bx: __u64,
    pub dx: __u64,
    pub ax: __u64,
    pub cx: __u64,
    pub sp: __u64,
    pub ip: __u64,
    pub flags: __u64,
    pub cs: __u16,
    pub gs: __u16,
    pub fs: __u16,
    pub ss: __u16,
    pub err: __u64,
    pub trapno: __u64,
    pub oldmask: __u64,
    pub cr2: __u64,
    pub fpstate: __u64,
    pub reserved1: [__u64; 8usize],
}
#[test]
fn bindgen_test_layout_sigcontext_64() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext_64>(),
        256usize,
        concat!("Size of: ", stringify!(sigcontext_64))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext_64>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext_64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r9 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r10 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r11 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r12 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r13 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r14 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).r15 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).di as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(di)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).si as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(si)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).bp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(bp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).bx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(bx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).dx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).ax as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(ax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).cx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).sp as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).ip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).cs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).gs as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).fs as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).ss as *const _ as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).err as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).trapno as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).oldmask as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).cr2 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).fpstate as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext_64>())).reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext_64),
            "::",
            stringify!(reserved1)
        )
    );
}
extern "C" {
    pub fn _find_next_bit(
        addr1: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _find_next_and_bit(
        addr1: *const ::std::os::raw::c_ulong,
        addr2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _find_next_andnot_bit(
        addr1: *const ::std::os::raw::c_ulong,
        addr2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _find_next_zero_bit(
        addr: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _find_first_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __find_nth_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __find_nth_and_bit(
        addr1: *const ::std::os::raw::c_ulong,
        addr2: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __find_nth_andnot_bit(
        addr1: *const ::std::os::raw::c_ulong,
        addr2: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _find_first_and_bit(
        addr1: *const ::std::os::raw::c_ulong,
        addr2: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _find_first_zero_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _find_last_bit(
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " find_next_clump8 - find next 8-bit clump with set bits in a memory region"]
    #[doc = " @clump: location to store copy of found clump"]
    #[doc = " @addr: address to base the search on"]
    #[doc = " @size: bitmap size in number of bits"]
    #[doc = " @offset: bit offset at which to start searching"]
    #[doc = ""]
    #[doc = " Returns the bit offset for the next set clump; the found clump value is"]
    #[doc = " copied to the location pointed by @clump. If no bits are set, returns @size."]
    pub fn find_next_clump8(
        clump: *mut ::std::os::raw::c_ulong,
        addr: *const ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        offset: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " DOC: declare bitmap"]
    #[doc = " The DECLARE_BITMAP(name,bits) macro, in linux/types.h, can be used"]
    #[doc = " to declare an array named 'name' of just enough unsigned longs to"]
    #[doc = " contain all bit positions from 0 to 'bits' - 1."]
    pub fn bitmap_alloc(
        nbits: ::std::os::raw::c_uint,
        flags: gfp_t,
    ) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bitmap_zalloc(
        nbits: ::std::os::raw::c_uint,
        flags: gfp_t,
    ) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bitmap_alloc_node(
        nbits: ::std::os::raw::c_uint,
        flags: gfp_t,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bitmap_zalloc_node(
        nbits: ::std::os::raw::c_uint,
        flags: gfp_t,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bitmap_free(bitmap: *const ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn devm_bitmap_alloc(
        dev: *mut device,
        nbits: ::std::os::raw::c_uint,
        flags: gfp_t,
    ) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn devm_bitmap_zalloc(
        dev: *mut device,
        nbits: ::std::os::raw::c_uint,
        flags: gfp_t,
    ) -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __bitmap_equal(
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_or_equal(
        src1: *const ::std::os::raw::c_ulong,
        src2: *const ::std::os::raw::c_ulong,
        src3: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_complement(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_shift_right(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        shift: ::std::os::raw::c_uint,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_shift_left(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        shift: ::std::os::raw::c_uint,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn bitmap_cut(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        first: ::std::os::raw::c_uint,
        cut: ::std::os::raw::c_uint,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_and(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_or(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_xor(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_andnot(
        dst: *mut ::std::os::raw::c_ulong,
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_replace(
        dst: *mut ::std::os::raw::c_ulong,
        old: *const ::std::os::raw::c_ulong,
        new: *const ::std::os::raw::c_ulong,
        mask: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_intersects(
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_subset(
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_weight(
        bitmap: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __bitmap_weight_and(
        bitmap1: *const ::std::os::raw::c_ulong,
        bitmap2: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __bitmap_set(
        map: *mut ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn __bitmap_clear(
        map: *mut ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_uint,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn bitmap_find_next_zero_area_off(
        map: *mut ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
        nr: ::std::os::raw::c_uint,
        align_mask: ::std::os::raw::c_ulong,
        align_offset: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn bitmap_parse(
        buf: *const ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_uint,
        dst: *mut ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_parse_user(
        ubuf: *const ::std::os::raw::c_char,
        ulen: ::std::os::raw::c_uint,
        dst: *mut ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_parselist(
        buf: *const ::std::os::raw::c_char,
        maskp: *mut ::std::os::raw::c_ulong,
        nmaskbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_parselist_user(
        ubuf: *const ::std::os::raw::c_char,
        ulen: ::std::os::raw::c_uint,
        dst: *mut ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_remap(
        dst: *mut ::std::os::raw::c_ulong,
        src: *const ::std::os::raw::c_ulong,
        old: *const ::std::os::raw::c_ulong,
        new: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn bitmap_bitremap(
        oldbit: ::std::os::raw::c_int,
        old: *const ::std::os::raw::c_ulong,
        new: *const ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_onto(
        dst: *mut ::std::os::raw::c_ulong,
        orig: *const ::std::os::raw::c_ulong,
        relmap: *const ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn bitmap_fold(
        dst: *mut ::std::os::raw::c_ulong,
        orig: *const ::std::os::raw::c_ulong,
        sz: ::std::os::raw::c_uint,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn bitmap_find_free_region(
        bitmap: *mut ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_uint,
        order: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_release_region(
        bitmap: *mut ::std::os::raw::c_ulong,
        pos: ::std::os::raw::c_uint,
        order: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn bitmap_allocate_region(
        bitmap: *mut ::std::os::raw::c_ulong,
        pos: ::std::os::raw::c_uint,
        order: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_print_to_pagebuf(
        list: bool_,
        buf: *mut ::std::os::raw::c_char,
        maskp: *const ::std::os::raw::c_ulong,
        nmaskbits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_print_bitmask_to_buf(
        buf: *mut ::std::os::raw::c_char,
        maskp: *const ::std::os::raw::c_ulong,
        nmaskbits: ::std::os::raw::c_int,
        off: loff_t,
        count: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_print_list_to_buf(
        buf: *mut ::std::os::raw::c_char,
        maskp: *const ::std::os::raw::c_ulong,
        nmaskbits: ::std::os::raw::c_int,
        off: loff_t,
        count: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitmap_from_arr32(
        bitmap: *mut ::std::os::raw::c_ulong,
        buf: *const u32_,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn bitmap_to_arr32(
        buf: *mut u32_,
        bitmap: *const ::std::os::raw::c_ulong,
        nbits: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn __xchg_wrong_size();
}
extern "C" {
    pub fn __cmpxchg_wrong_size();
}
extern "C" {
    pub fn __xadd_wrong_size();
}
extern "C" {
    pub fn __add_wrong_size();
}
pub type atomic_long_t = atomic64_t;
extern "C" {
    pub fn numa_map_to_online_node(node: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpumask {
    pub bits: [::std::os::raw::c_ulong; 1usize],
}
#[test]
fn bindgen_test_layout_cpumask() {
    assert_eq!(
        ::std::mem::size_of::<cpumask>(),
        8usize,
        concat!("Size of: ", stringify!(cpumask))
    );
    assert_eq!(
        ::std::mem::align_of::<cpumask>(),
        8usize,
        concat!("Alignment of ", stringify!(cpumask))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpumask>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpumask),
            "::",
            stringify!(bits)
        )
    );
}
pub type cpumask_t = cpumask;
extern "C" {
    pub static mut nr_cpu_ids: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut __cpu_possible_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_online_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_present_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_active_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_dying_mask: cpumask;
}
extern "C" {
    pub static mut __num_online_cpus: atomic_t;
}
extern "C" {
    pub static mut cpus_booted_once_mask: cpumask_t;
}
extern "C" {
    pub fn cpumask_local_spread(
        i: ::std::os::raw::c_uint,
        node: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn cpumask_any_and_distribute(
        src1p: *const cpumask,
        src2p: *const cpumask,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn cpumask_any_distribute(srcp: *const cpumask) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn cpumask_next_wrap(
        n: ::std::os::raw::c_int,
        mask: *const cpumask,
        start: ::std::os::raw::c_int,
        wrap: bool_,
    ) -> ::std::os::raw::c_uint;
}
pub type cpumask_var_t = [cpumask; 1usize];
extern "C" {
    pub static cpu_all_bits: [::std::os::raw::c_ulong; 1usize];
}
extern "C" {
    pub fn init_cpu_present(src: *const cpumask);
}
extern "C" {
    pub fn init_cpu_possible(src: *const cpumask);
}
extern "C" {
    pub fn init_cpu_online(src: *const cpumask);
}
extern "C" {
    pub fn set_cpu_online(cpu: ::std::os::raw::c_uint, online: bool_);
}
extern "C" {
    pub static mut cpu_bit_bitmap: [[::std::os::raw::c_ulong; 1usize]; 65usize];
}
extern "C" {
    pub static mut cpu_callin_mask: cpumask_var_t;
}
extern "C" {
    pub static mut cpu_callout_mask: cpumask_var_t;
}
extern "C" {
    pub static mut cpu_initialized_mask: cpumask_var_t;
}
extern "C" {
    pub static mut cpu_sibling_setup_mask: cpumask_var_t;
}
extern "C" {
    pub fn setup_cpu_local_masks();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msr {
    pub __bindgen_anon_1: msr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msr__bindgen_ty_1 {
    pub __bindgen_anon_1: msr__bindgen_ty_1__bindgen_ty_1,
    pub q: u64_,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msr__bindgen_ty_1__bindgen_ty_1 {
    pub l: u32_,
    pub h: u32_,
}
#[test]
fn bindgen_test_layout_msr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<msr__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(msr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<msr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(msr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<msr__bindgen_ty_1__bindgen_ty_1>())).l as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<msr__bindgen_ty_1__bindgen_ty_1>())).h as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(msr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(h)
        )
    );
}
#[test]
fn bindgen_test_layout_msr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<msr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(msr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<msr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(msr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr__bindgen_ty_1>())).q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msr__bindgen_ty_1),
            "::",
            stringify!(q)
        )
    );
}
#[test]
fn bindgen_test_layout_msr() {
    assert_eq!(
        ::std::mem::size_of::<msr>(),
        8usize,
        concat!("Size of: ", stringify!(msr))
    );
    assert_eq!(
        ::std::mem::align_of::<msr>(),
        8usize,
        concat!("Alignment of ", stringify!(msr))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msr_info {
    pub msr_no: u32_,
    pub reg: msr,
    pub msrs: *mut msr,
    pub err: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msr_info() {
    assert_eq!(
        ::std::mem::size_of::<msr_info>(),
        32usize,
        concat!("Size of: ", stringify!(msr_info))
    );
    assert_eq!(
        ::std::mem::align_of::<msr_info>(),
        8usize,
        concat!("Alignment of ", stringify!(msr_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_info>())).msr_no as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_info),
            "::",
            stringify!(msr_no)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_info>())).reg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_info),
            "::",
            stringify!(reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_info>())).msrs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_info),
            "::",
            stringify!(msrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_info>())).err as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_info),
            "::",
            stringify!(err)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msr_regs_info {
    pub regs: *mut u32_,
    pub err: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msr_regs_info() {
    assert_eq!(
        ::std::mem::size_of::<msr_regs_info>(),
        16usize,
        concat!("Size of: ", stringify!(msr_regs_info))
    );
    assert_eq!(
        ::std::mem::align_of::<msr_regs_info>(),
        8usize,
        concat!("Alignment of ", stringify!(msr_regs_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_regs_info>())).regs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_regs_info),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msr_regs_info>())).err as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msr_regs_info),
            "::",
            stringify!(err)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct saved_msr {
    pub valid: bool_,
    pub info: msr_info,
}
#[test]
fn bindgen_test_layout_saved_msr() {
    assert_eq!(
        ::std::mem::size_of::<saved_msr>(),
        40usize,
        concat!("Size of: ", stringify!(saved_msr))
    );
    assert_eq!(
        ::std::mem::align_of::<saved_msr>(),
        8usize,
        concat!("Alignment of ", stringify!(saved_msr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<saved_msr>())).valid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(saved_msr),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<saved_msr>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(saved_msr),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct saved_msrs {
    pub num: ::std::os::raw::c_uint,
    pub array: *mut saved_msr,
}
#[test]
fn bindgen_test_layout_saved_msrs() {
    assert_eq!(
        ::std::mem::size_of::<saved_msrs>(),
        16usize,
        concat!("Size of: ", stringify!(saved_msrs))
    );
    assert_eq!(
        ::std::mem::align_of::<saved_msrs>(),
        8usize,
        concat!("Alignment of ", stringify!(saved_msrs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<saved_msrs>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(saved_msrs),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<saved_msrs>())).array as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(saved_msrs),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_print_flags {
    pub mask: ::std::os::raw::c_ulong,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_trace_print_flags() {
    assert_eq!(
        ::std::mem::size_of::<trace_print_flags>(),
        16usize,
        concat!("Size of: ", stringify!(trace_print_flags))
    );
    assert_eq!(
        ::std::mem::align_of::<trace_print_flags>(),
        8usize,
        concat!("Alignment of ", stringify!(trace_print_flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trace_print_flags>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(trace_print_flags),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trace_print_flags>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(trace_print_flags),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trace_print_flags_u64 {
    pub mask: ::std::os::raw::c_ulonglong,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_trace_print_flags_u64() {
    assert_eq!(
        ::std::mem::size_of::<trace_print_flags_u64>(),
        16usize,
        concat!("Size of: ", stringify!(trace_print_flags_u64))
    );
    assert_eq!(
        ::std::mem::align_of::<trace_print_flags_u64>(),
        8usize,
        concat!("Alignment of ", stringify!(trace_print_flags_u64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trace_print_flags_u64>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(trace_print_flags_u64),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<trace_print_flags_u64>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(trace_print_flags_u64),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tracepoint_func {
    pub func: *mut ::std::os::raw::c_void,
    pub data: *mut ::std::os::raw::c_void,
    pub prio: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tracepoint_func() {
    assert_eq!(
        ::std::mem::size_of::<tracepoint_func>(),
        24usize,
        concat!("Size of: ", stringify!(tracepoint_func))
    );
    assert_eq!(
        ::std::mem::align_of::<tracepoint_func>(),
        8usize,
        concat!("Alignment of ", stringify!(tracepoint_func))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint_func>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint_func),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint_func>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint_func),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint_func>())).prio as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint_func),
            "::",
            stringify!(prio)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint {
    pub name: *const ::std::os::raw::c_char,
    pub key: static_key,
    pub static_call_key: *mut static_call_key,
    pub static_call_tramp: *mut ::std::os::raw::c_void,
    pub iterator: *mut ::std::os::raw::c_void,
    pub regfunc: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub unregfunc: ::std::option::Option<unsafe extern "C" fn()>,
    pub funcs: *mut tracepoint_func,
}
#[test]
fn bindgen_test_layout_tracepoint() {
    assert_eq!(
        ::std::mem::size_of::<tracepoint>(),
        72usize,
        concat!("Size of: ", stringify!(tracepoint))
    );
    assert_eq!(
        ::std::mem::align_of::<tracepoint>(),
        8usize,
        concat!("Alignment of ", stringify!(tracepoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).static_call_key as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(static_call_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).static_call_tramp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(static_call_tramp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).iterator as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(iterator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).regfunc as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(regfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).unregfunc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(unregfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tracepoint>())).funcs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tracepoint),
            "::",
            stringify!(funcs)
        )
    );
}
pub type tracepoint_ptr_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct bpf_raw_event_map {
    pub tp: *mut tracepoint,
    pub bpf_func: *mut ::std::os::raw::c_void,
    pub num_args: u32_,
    pub writable_size: u32_,
}
#[test]
fn bindgen_test_layout_bpf_raw_event_map() {
    assert_eq!(
        ::std::mem::size_of::<bpf_raw_event_map>(),
        32usize,
        concat!("Size of: ", stringify!(bpf_raw_event_map))
    );
    assert_eq!(
        ::std::mem::align_of::<bpf_raw_event_map>(),
        32usize,
        concat!("Alignment of ", stringify!(bpf_raw_event_map))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_raw_event_map>())).tp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_raw_event_map),
            "::",
            stringify!(tp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_raw_event_map>())).bpf_func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_raw_event_map),
            "::",
            stringify!(bpf_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_raw_event_map>())).num_args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_raw_event_map),
            "::",
            stringify!(num_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bpf_raw_event_map>())).writable_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bpf_raw_event_map),
            "::",
            stringify!(writable_size)
        )
    );
}
extern "C" {
    pub static mut __tracepoint_read_msr: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_write_msr: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_rdpmc: tracepoint;
}
extern "C" {
    pub fn do_trace_write_msr(
        msr: ::std::os::raw::c_uint,
        val: u64_,
        failed: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn do_trace_read_msr(msr: ::std::os::raw::c_uint, val: u64_, failed: ::std::os::raw::c_int);
}
extern "C" {
    pub fn do_trace_rdpmc(msr: ::std::os::raw::c_uint, val: u64_, failed: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rdmsr_safe_regs(regs: *mut u32_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe_regs(regs: *mut u32_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msrs_alloc() -> *mut msr;
}
extern "C" {
    pub fn msrs_free(msrs: *mut msr);
}
extern "C" {
    pub fn msr_set_bit(msr: u32_, bit: u8_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msr_clear_bit(msr: u32_, bit: u8_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsr_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        l: *mut u32_,
        h: *mut u32_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        l: u32_,
        h: u32_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsrl_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        q: *mut u64_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsrl_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        q: u64_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsr_on_cpus(mask: *const cpumask, msr_no: u32_, msrs: *mut msr);
}
extern "C" {
    pub fn wrmsr_on_cpus(mask: *const cpumask, msr_no: u32_, msrs: *mut msr);
}
extern "C" {
    pub fn rdmsr_safe_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        l: *mut u32_,
        h: *mut u32_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        l: u32_,
        h: u32_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsrl_safe_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        q: *mut u64_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsrl_safe_on_cpu(
        cpu: ::std::os::raw::c_uint,
        msr_no: u32_,
        q: u64_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdmsr_safe_regs_on_cpu(
        cpu: ::std::os::raw::c_uint,
        regs: *mut u32_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe_regs_on_cpu(
        cpu: ::std::os::raw::c_uint,
        regs: *mut u32_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_write_cr0(val: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn native_write_cr4(val: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn asm_load_gs_index(selector: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fregs_state {
    pub cwd: u32_,
    pub swd: u32_,
    pub twd: u32_,
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
    pub st_space: [u32_; 20usize],
    pub status: u32_,
}
#[test]
fn bindgen_test_layout_fregs_state() {
    assert_eq!(
        ::std::mem::size_of::<fregs_state>(),
        112usize,
        concat!("Size of: ", stringify!(fregs_state))
    );
    assert_eq!(
        ::std::mem::align_of::<fregs_state>(),
        4usize,
        concat!("Alignment of ", stringify!(fregs_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).swd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).twd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).fip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).fcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).foo as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).fos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(fos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).st_space as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fregs_state>())).status as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(fregs_state),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct fxregs_state {
    pub cwd: u16_,
    pub swd: u16_,
    pub twd: u16_,
    pub fop: u16_,
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1,
    pub mxcsr: u32_,
    pub mxcsr_mask: u32_,
    pub st_space: [u32_; 32usize],
    pub xmm_space: [u32_; 64usize],
    pub padding: [u32_; 12usize],
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_1 {
    pub __bindgen_anon_1: fxregs_state__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: fxregs_state__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_1 {
    pub rip: u64_,
    pub rdp: u64_,
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_1>())).rip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_1>())).rdp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rdp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fxregs_state__bindgen_ty_1__bindgen_ty_2 {
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<fxregs_state__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fip as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fcs as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).foo as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_1__bindgen_ty_2>())).fos as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fos)
        )
    );
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<fxregs_state__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(fxregs_state__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<fxregs_state__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(fxregs_state__bindgen_ty_1))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fxregs_state__bindgen_ty_2 {
    pub padding1: [u32_; 12usize],
    pub sw_reserved: [u32_; 12usize],
    _bindgen_union_align: [u32; 12usize],
}
#[test]
fn bindgen_test_layout_fxregs_state__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<fxregs_state__bindgen_ty_2>(),
        48usize,
        concat!("Size of: ", stringify!(fxregs_state__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<fxregs_state__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(fxregs_state__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_2>())).padding1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_2),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fxregs_state__bindgen_ty_2>())).sw_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state__bindgen_ty_2),
            "::",
            stringify!(sw_reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_fxregs_state() {
    assert_eq!(
        ::std::mem::size_of::<fxregs_state>(),
        512usize,
        concat!("Size of: ", stringify!(fxregs_state))
    );
    assert_eq!(
        ::std::mem::align_of::<fxregs_state>(),
        16usize,
        concat!("Alignment of ", stringify!(fxregs_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).twd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).mxcsr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(mxcsr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).st_space as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).xmm_space as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(xmm_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fxregs_state>())).padding as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(fxregs_state),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swregs_state {
    pub cwd: u32_,
    pub swd: u32_,
    pub twd: u32_,
    pub fip: u32_,
    pub fcs: u32_,
    pub foo: u32_,
    pub fos: u32_,
    pub st_space: [u32_; 20usize],
    pub ftop: u8_,
    pub changed: u8_,
    pub lookahead: u8_,
    pub no_update: u8_,
    pub rm: u8_,
    pub alimit: u8_,
    pub info: *mut math_emu_info,
    pub entry_eip: u32_,
}
#[test]
fn bindgen_test_layout_swregs_state() {
    assert_eq!(
        ::std::mem::size_of::<swregs_state>(),
        136usize,
        concat!("Size of: ", stringify!(swregs_state))
    );
    assert_eq!(
        ::std::mem::align_of::<swregs_state>(),
        8usize,
        concat!("Alignment of ", stringify!(swregs_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).swd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).twd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(twd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).fip as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).fcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).foo as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(foo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).fos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(fos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).st_space as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(st_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).ftop as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(ftop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).changed as *const _ as usize },
        109usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).lookahead as *const _ as usize },
        110usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(lookahead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).no_update as *const _ as usize },
        111usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(no_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).rm as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(rm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).alimit as *const _ as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(alimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).info as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swregs_state>())).entry_eip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(swregs_state),
            "::",
            stringify!(entry_eip)
        )
    );
}
pub const xfeature_XFEATURE_FP: xfeature = 0;
pub const xfeature_XFEATURE_SSE: xfeature = 1;
pub const xfeature_XFEATURE_YMM: xfeature = 2;
pub const xfeature_XFEATURE_BNDREGS: xfeature = 3;
pub const xfeature_XFEATURE_BNDCSR: xfeature = 4;
pub const xfeature_XFEATURE_OPMASK: xfeature = 5;
pub const xfeature_XFEATURE_ZMM_Hi256: xfeature = 6;
pub const xfeature_XFEATURE_Hi16_ZMM: xfeature = 7;
pub const xfeature_XFEATURE_PT_UNIMPLEMENTED_SO_FAR: xfeature = 8;
pub const xfeature_XFEATURE_PKRU: xfeature = 9;
pub const xfeature_XFEATURE_PASID: xfeature = 10;
pub const xfeature_XFEATURE_RSRVD_COMP_11: xfeature = 11;
pub const xfeature_XFEATURE_RSRVD_COMP_12: xfeature = 12;
pub const xfeature_XFEATURE_RSRVD_COMP_13: xfeature = 13;
pub const xfeature_XFEATURE_RSRVD_COMP_14: xfeature = 14;
pub const xfeature_XFEATURE_LBR: xfeature = 15;
pub const xfeature_XFEATURE_RSRVD_COMP_16: xfeature = 16;
pub const xfeature_XFEATURE_XTILE_CFG: xfeature = 17;
pub const xfeature_XFEATURE_XTILE_DATA: xfeature = 18;
pub const xfeature_XFEATURE_MAX: xfeature = 19;
pub type xfeature = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reg_128_bit {
    pub regbytes: [u8_; 16usize],
}
#[test]
fn bindgen_test_layout_reg_128_bit() {
    assert_eq!(
        ::std::mem::size_of::<reg_128_bit>(),
        16usize,
        concat!("Size of: ", stringify!(reg_128_bit))
    );
    assert_eq!(
        ::std::mem::align_of::<reg_128_bit>(),
        1usize,
        concat!("Alignment of ", stringify!(reg_128_bit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reg_128_bit>())).regbytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_128_bit),
            "::",
            stringify!(regbytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reg_256_bit {
    pub regbytes: [u8_; 32usize],
}
#[test]
fn bindgen_test_layout_reg_256_bit() {
    assert_eq!(
        ::std::mem::size_of::<reg_256_bit>(),
        32usize,
        concat!("Size of: ", stringify!(reg_256_bit))
    );
    assert_eq!(
        ::std::mem::align_of::<reg_256_bit>(),
        1usize,
        concat!("Alignment of ", stringify!(reg_256_bit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reg_256_bit>())).regbytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_256_bit),
            "::",
            stringify!(regbytes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct reg_512_bit {
    pub regbytes: [u8_; 64usize],
}
#[test]
fn bindgen_test_layout_reg_512_bit() {
    assert_eq!(
        ::std::mem::size_of::<reg_512_bit>(),
        64usize,
        concat!("Size of: ", stringify!(reg_512_bit))
    );
    assert_eq!(
        ::std::mem::align_of::<reg_512_bit>(),
        1usize,
        concat!("Alignment of ", stringify!(reg_512_bit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reg_512_bit>())).regbytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_512_bit),
            "::",
            stringify!(regbytes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct reg_1024_byte {
    pub regbytes: [u8_; 1024usize],
}
#[test]
fn bindgen_test_layout_reg_1024_byte() {
    assert_eq!(
        ::std::mem::size_of::<reg_1024_byte>(),
        1024usize,
        concat!("Size of: ", stringify!(reg_1024_byte))
    );
    assert_eq!(
        ::std::mem::align_of::<reg_1024_byte>(),
        1usize,
        concat!("Alignment of ", stringify!(reg_1024_byte))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<reg_1024_byte>())).regbytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(reg_1024_byte),
            "::",
            stringify!(regbytes)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ymmh_struct {
    pub hi_ymm: [reg_128_bit; 16usize],
}
#[test]
fn bindgen_test_layout_ymmh_struct() {
    assert_eq!(
        ::std::mem::size_of::<ymmh_struct>(),
        256usize,
        concat!("Size of: ", stringify!(ymmh_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<ymmh_struct>(),
        1usize,
        concat!("Alignment of ", stringify!(ymmh_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ymmh_struct>())).hi_ymm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ymmh_struct),
            "::",
            stringify!(hi_ymm)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct mpx_bndreg {
    pub lower_bound: u64_,
    pub upper_bound: u64_,
}
#[test]
fn bindgen_test_layout_mpx_bndreg() {
    assert_eq!(
        ::std::mem::size_of::<mpx_bndreg>(),
        16usize,
        concat!("Size of: ", stringify!(mpx_bndreg))
    );
    assert_eq!(
        ::std::mem::align_of::<mpx_bndreg>(),
        1usize,
        concat!("Alignment of ", stringify!(mpx_bndreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpx_bndreg>())).lower_bound as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndreg),
            "::",
            stringify!(lower_bound)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpx_bndreg>())).upper_bound as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndreg),
            "::",
            stringify!(upper_bound)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct mpx_bndreg_state {
    pub bndreg: [mpx_bndreg; 4usize],
}
#[test]
fn bindgen_test_layout_mpx_bndreg_state() {
    assert_eq!(
        ::std::mem::size_of::<mpx_bndreg_state>(),
        64usize,
        concat!("Size of: ", stringify!(mpx_bndreg_state))
    );
    assert_eq!(
        ::std::mem::align_of::<mpx_bndreg_state>(),
        1usize,
        concat!("Alignment of ", stringify!(mpx_bndreg_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpx_bndreg_state>())).bndreg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndreg_state),
            "::",
            stringify!(bndreg)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct mpx_bndcsr {
    pub bndcfgu: u64_,
    pub bndstatus: u64_,
}
#[test]
fn bindgen_test_layout_mpx_bndcsr() {
    assert_eq!(
        ::std::mem::size_of::<mpx_bndcsr>(),
        16usize,
        concat!("Size of: ", stringify!(mpx_bndcsr))
    );
    assert_eq!(
        ::std::mem::align_of::<mpx_bndcsr>(),
        1usize,
        concat!("Alignment of ", stringify!(mpx_bndcsr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpx_bndcsr>())).bndcfgu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndcsr),
            "::",
            stringify!(bndcfgu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpx_bndcsr>())).bndstatus as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndcsr),
            "::",
            stringify!(bndstatus)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct mpx_bndcsr_state {
    pub __bindgen_anon_1: mpx_bndcsr_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mpx_bndcsr_state__bindgen_ty_1 {
    pub bndcsr: mpx_bndcsr,
    pub pad_to_64_bytes: [u8_; 64usize],
    _bindgen_union_align: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_mpx_bndcsr_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mpx_bndcsr_state__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(mpx_bndcsr_state__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mpx_bndcsr_state__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(mpx_bndcsr_state__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpx_bndcsr_state__bindgen_ty_1>())).bndcsr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndcsr_state__bindgen_ty_1),
            "::",
            stringify!(bndcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mpx_bndcsr_state__bindgen_ty_1>())).pad_to_64_bytes as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpx_bndcsr_state__bindgen_ty_1),
            "::",
            stringify!(pad_to_64_bytes)
        )
    );
}
#[test]
fn bindgen_test_layout_mpx_bndcsr_state() {
    assert_eq!(
        ::std::mem::size_of::<mpx_bndcsr_state>(),
        64usize,
        concat!("Size of: ", stringify!(mpx_bndcsr_state))
    );
    assert_eq!(
        ::std::mem::align_of::<mpx_bndcsr_state>(),
        1usize,
        concat!("Alignment of ", stringify!(mpx_bndcsr_state))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct avx_512_opmask_state {
    pub opmask_reg: [u64_; 8usize],
}
#[test]
fn bindgen_test_layout_avx_512_opmask_state() {
    assert_eq!(
        ::std::mem::size_of::<avx_512_opmask_state>(),
        64usize,
        concat!("Size of: ", stringify!(avx_512_opmask_state))
    );
    assert_eq!(
        ::std::mem::align_of::<avx_512_opmask_state>(),
        1usize,
        concat!("Alignment of ", stringify!(avx_512_opmask_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avx_512_opmask_state>())).opmask_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avx_512_opmask_state),
            "::",
            stringify!(opmask_reg)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct avx_512_zmm_uppers_state {
    pub zmm_upper: [reg_256_bit; 16usize],
}
#[test]
fn bindgen_test_layout_avx_512_zmm_uppers_state() {
    assert_eq!(
        ::std::mem::size_of::<avx_512_zmm_uppers_state>(),
        512usize,
        concat!("Size of: ", stringify!(avx_512_zmm_uppers_state))
    );
    assert_eq!(
        ::std::mem::align_of::<avx_512_zmm_uppers_state>(),
        1usize,
        concat!("Alignment of ", stringify!(avx_512_zmm_uppers_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<avx_512_zmm_uppers_state>())).zmm_upper as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avx_512_zmm_uppers_state),
            "::",
            stringify!(zmm_upper)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct avx_512_hi16_state {
    pub hi16_zmm: [reg_512_bit; 16usize],
}
#[test]
fn bindgen_test_layout_avx_512_hi16_state() {
    assert_eq!(
        ::std::mem::size_of::<avx_512_hi16_state>(),
        1024usize,
        concat!("Size of: ", stringify!(avx_512_hi16_state))
    );
    assert_eq!(
        ::std::mem::align_of::<avx_512_hi16_state>(),
        1usize,
        concat!("Alignment of ", stringify!(avx_512_hi16_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avx_512_hi16_state>())).hi16_zmm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avx_512_hi16_state),
            "::",
            stringify!(hi16_zmm)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pkru_state {
    pub pkru: u32_,
    pub pad: u32_,
}
#[test]
fn bindgen_test_layout_pkru_state() {
    assert_eq!(
        ::std::mem::size_of::<pkru_state>(),
        8usize,
        concat!("Size of: ", stringify!(pkru_state))
    );
    assert_eq!(
        ::std::mem::align_of::<pkru_state>(),
        1usize,
        concat!("Alignment of ", stringify!(pkru_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkru_state>())).pkru as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pkru_state),
            "::",
            stringify!(pkru)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pkru_state>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pkru_state),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lbr_entry {
    pub from: u64_,
    pub to: u64_,
    pub info: u64_,
}
#[test]
fn bindgen_test_layout_lbr_entry() {
    assert_eq!(
        ::std::mem::size_of::<lbr_entry>(),
        24usize,
        concat!("Size of: ", stringify!(lbr_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<lbr_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(lbr_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lbr_entry>())).from as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lbr_entry),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lbr_entry>())).to as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lbr_entry),
            "::",
            stringify!(to)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lbr_entry>())).info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lbr_entry),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct arch_lbr_state {
    pub lbr_ctl: u64_,
    pub lbr_depth: u64_,
    pub ler_from: u64_,
    pub ler_to: u64_,
    pub ler_info: u64_,
    pub entries: __IncompleteArrayField<lbr_entry>,
}
#[test]
fn bindgen_test_layout_arch_lbr_state() {
    assert_eq!(
        ::std::mem::size_of::<arch_lbr_state>(),
        40usize,
        concat!("Size of: ", stringify!(arch_lbr_state))
    );
    assert_eq!(
        ::std::mem::align_of::<arch_lbr_state>(),
        8usize,
        concat!("Alignment of ", stringify!(arch_lbr_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_lbr_state>())).lbr_ctl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_lbr_state),
            "::",
            stringify!(lbr_ctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_lbr_state>())).lbr_depth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_lbr_state),
            "::",
            stringify!(lbr_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_lbr_state>())).ler_from as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_lbr_state),
            "::",
            stringify!(ler_from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_lbr_state>())).ler_to as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_lbr_state),
            "::",
            stringify!(ler_to)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_lbr_state>())).ler_info as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_lbr_state),
            "::",
            stringify!(ler_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_lbr_state>())).entries as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_lbr_state),
            "::",
            stringify!(entries)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct xtile_cfg {
    pub tcfg: [u64_; 8usize],
}
#[test]
fn bindgen_test_layout_xtile_cfg() {
    assert_eq!(
        ::std::mem::size_of::<xtile_cfg>(),
        64usize,
        concat!("Size of: ", stringify!(xtile_cfg))
    );
    assert_eq!(
        ::std::mem::align_of::<xtile_cfg>(),
        1usize,
        concat!("Alignment of ", stringify!(xtile_cfg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xtile_cfg>())).tcfg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtile_cfg),
            "::",
            stringify!(tcfg)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct xtile_data {
    pub tmm: reg_1024_byte,
}
#[test]
fn bindgen_test_layout_xtile_data() {
    assert_eq!(
        ::std::mem::size_of::<xtile_data>(),
        1024usize,
        concat!("Size of: ", stringify!(xtile_data))
    );
    assert_eq!(
        ::std::mem::align_of::<xtile_data>(),
        1usize,
        concat!("Alignment of ", stringify!(xtile_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xtile_data>())).tmm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtile_data),
            "::",
            stringify!(tmm)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ia32_pasid_state {
    pub pasid: u64_,
}
#[test]
fn bindgen_test_layout_ia32_pasid_state() {
    assert_eq!(
        ::std::mem::size_of::<ia32_pasid_state>(),
        8usize,
        concat!("Size of: ", stringify!(ia32_pasid_state))
    );
    assert_eq!(
        ::std::mem::align_of::<ia32_pasid_state>(),
        1usize,
        concat!("Alignment of ", stringify!(ia32_pasid_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ia32_pasid_state>())).pasid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ia32_pasid_state),
            "::",
            stringify!(pasid)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct xstate_header {
    pub xfeatures: u64_,
    pub xcomp_bv: u64_,
    pub reserved: [u64_; 6usize],
}
#[test]
fn bindgen_test_layout_xstate_header() {
    assert_eq!(
        ::std::mem::size_of::<xstate_header>(),
        64usize,
        concat!("Size of: ", stringify!(xstate_header))
    );
    assert_eq!(
        ::std::mem::align_of::<xstate_header>(),
        1usize,
        concat!("Alignment of ", stringify!(xstate_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xstate_header>())).xfeatures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xstate_header),
            "::",
            stringify!(xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xstate_header>())).xcomp_bv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xstate_header),
            "::",
            stringify!(xcomp_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xstate_header>())).reserved as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xstate_header),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C, packed(64))]
#[repr(align(64))]
pub struct xregs_state {
    pub i387: fxregs_state,
    pub header: xstate_header,
    pub extended_state_area: __IncompleteArrayField<u8_>,
}
#[test]
fn bindgen_test_layout_xregs_state() {
    assert_eq!(
        ::std::mem::size_of::<xregs_state>(),
        576usize,
        concat!("Size of: ", stringify!(xregs_state))
    );
    assert_eq!(
        ::std::mem::align_of::<xregs_state>(),
        64usize,
        concat!("Alignment of ", stringify!(xregs_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xregs_state>())).i387 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xregs_state),
            "::",
            stringify!(i387)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xregs_state>())).header as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(xregs_state),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xregs_state>())).extended_state_area as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(xregs_state),
            "::",
            stringify!(extended_state_area)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
pub struct fpregs_state {
    pub fsave: __BindgenUnionField<fregs_state>,
    pub fxsave: __BindgenUnionField<fxregs_state>,
    pub soft: __BindgenUnionField<swregs_state>,
    pub xsave: __BindgenUnionField<xregs_state>,
    pub __padding: __BindgenUnionField<[u8_; 4096usize]>,
    pub bindgen_union_field: [u8; 4096usize],
}
#[test]
fn bindgen_test_layout_fpregs_state() {
    assert_eq!(
        ::std::mem::size_of::<fpregs_state>(),
        4096usize,
        concat!("Size of: ", stringify!(fpregs_state))
    );
    assert_eq!(
        ::std::mem::align_of::<fpregs_state>(),
        64usize,
        concat!("Alignment of ", stringify!(fpregs_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs_state>())).fsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(fsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs_state>())).fxsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(fxsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs_state>())).soft as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(soft)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs_state>())).xsave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(xsave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpregs_state>())).__padding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpregs_state),
            "::",
            stringify!(__padding)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
pub struct fpstate {
    pub size: ::std::os::raw::c_uint,
    pub user_size: ::std::os::raw::c_uint,
    pub xfeatures: u64_,
    pub user_xfeatures: u64_,
    pub xfd: u64_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u64; 3usize],
    pub regs: fpregs_state,
}
#[test]
fn bindgen_test_layout_fpstate() {
    assert_eq!(
        ::std::mem::size_of::<fpstate>(),
        4160usize,
        concat!("Size of: ", stringify!(fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<fpstate>(),
        64usize,
        concat!("Alignment of ", stringify!(fpstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpstate>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpstate),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpstate>())).user_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fpstate),
            "::",
            stringify!(user_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpstate>())).xfeatures as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpstate),
            "::",
            stringify!(xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpstate>())).user_xfeatures as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpstate),
            "::",
            stringify!(user_xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpstate>())).xfd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fpstate),
            "::",
            stringify!(xfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpstate>())).regs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fpstate),
            "::",
            stringify!(regs)
        )
    );
}
impl fpstate {
    #[inline]
    pub fn is_valloc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_valloc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_guest(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_guest(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_confidential(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_confidential(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_use(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_use(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_valloc: ::std::os::raw::c_uint,
        is_guest: ::std::os::raw::c_uint,
        is_confidential: ::std::os::raw::c_uint,
        in_use: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_valloc: u32 = unsafe { ::std::mem::transmute(is_valloc) };
            is_valloc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_guest: u32 = unsafe { ::std::mem::transmute(is_guest) };
            is_guest as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_confidential: u32 = unsafe { ::std::mem::transmute(is_confidential) };
            is_confidential as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let in_use: u32 = unsafe { ::std::mem::transmute(in_use) };
            in_use as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpu_state_perm {
    pub __state_perm: u64_,
    pub __state_size: ::std::os::raw::c_uint,
    pub __user_state_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_fpu_state_perm() {
    assert_eq!(
        ::std::mem::size_of::<fpu_state_perm>(),
        16usize,
        concat!("Size of: ", stringify!(fpu_state_perm))
    );
    assert_eq!(
        ::std::mem::align_of::<fpu_state_perm>(),
        8usize,
        concat!("Alignment of ", stringify!(fpu_state_perm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_state_perm>())).__state_perm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_perm),
            "::",
            stringify!(__state_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_state_perm>())).__state_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_perm),
            "::",
            stringify!(__state_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fpu_state_perm>())).__user_state_size as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_perm),
            "::",
            stringify!(__user_state_size)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
pub struct fpu {
    pub last_cpu: ::std::os::raw::c_uint,
    pub avx512_timestamp: ::std::os::raw::c_ulong,
    pub fpstate: *mut fpstate,
    pub __task_fpstate: *mut fpstate,
    pub perm: fpu_state_perm,
    pub guest_perm: fpu_state_perm,
    pub __fpstate: fpstate,
}
#[test]
fn bindgen_test_layout_fpu() {
    assert_eq!(
        ::std::mem::size_of::<fpu>(),
        4224usize,
        concat!("Size of: ", stringify!(fpu))
    );
    assert_eq!(
        ::std::mem::align_of::<fpu>(),
        64usize,
        concat!("Alignment of ", stringify!(fpu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).last_cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(last_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).avx512_timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(avx512_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).fpstate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).__task_fpstate as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(__task_fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).perm as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(fpu), "::", stringify!(perm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).guest_perm as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(guest_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu>())).__fpstate as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu),
            "::",
            stringify!(__fpstate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpu_guest {
    pub xfeatures: u64_,
    pub perm: u64_,
    pub xfd_err: u64_,
    pub uabi_size: ::std::os::raw::c_uint,
    pub fpstate: *mut fpstate,
}
#[test]
fn bindgen_test_layout_fpu_guest() {
    assert_eq!(
        ::std::mem::size_of::<fpu_guest>(),
        40usize,
        concat!("Size of: ", stringify!(fpu_guest))
    );
    assert_eq!(
        ::std::mem::align_of::<fpu_guest>(),
        8usize,
        concat!("Alignment of ", stringify!(fpu_guest))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_guest>())).xfeatures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_guest),
            "::",
            stringify!(xfeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_guest>())).perm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_guest),
            "::",
            stringify!(perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_guest>())).xfd_err as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_guest),
            "::",
            stringify!(xfd_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_guest>())).uabi_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_guest),
            "::",
            stringify!(uabi_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_guest>())).fpstate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_guest),
            "::",
            stringify!(fpstate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpu_state_config {
    pub max_size: ::std::os::raw::c_uint,
    pub default_size: ::std::os::raw::c_uint,
    pub max_features: u64_,
    pub default_features: u64_,
    pub legacy_features: u64_,
}
#[test]
fn bindgen_test_layout_fpu_state_config() {
    assert_eq!(
        ::std::mem::size_of::<fpu_state_config>(),
        32usize,
        concat!("Size of: ", stringify!(fpu_state_config))
    );
    assert_eq!(
        ::std::mem::align_of::<fpu_state_config>(),
        8usize,
        concat!("Alignment of ", stringify!(fpu_state_config))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_state_config>())).max_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_config),
            "::",
            stringify!(max_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_state_config>())).default_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_config),
            "::",
            stringify!(default_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fpu_state_config>())).max_features as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_config),
            "::",
            stringify!(max_features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fpu_state_config>())).default_features as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_config),
            "::",
            stringify!(default_features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<fpu_state_config>())).legacy_features as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fpu_state_config),
            "::",
            stringify!(legacy_features)
        )
    );
}
extern "C" {
    pub static mut fpu_kernel_cfg: fpu_state_config;
}
extern "C" {
    pub static mut fpu_user_cfg: fpu_state_config;
}
pub const UNAME26: ::std::os::raw::c_uint = 131072;
pub const ADDR_NO_RANDOMIZE: ::std::os::raw::c_uint = 262144;
pub const FDPIC_FUNCPTRS: ::std::os::raw::c_uint = 524288;
pub const MMAP_PAGE_ZERO: ::std::os::raw::c_uint = 1048576;
pub const ADDR_COMPAT_LAYOUT: ::std::os::raw::c_uint = 2097152;
pub const READ_IMPLIES_EXEC: ::std::os::raw::c_uint = 4194304;
pub const ADDR_LIMIT_32BIT: ::std::os::raw::c_uint = 8388608;
pub const SHORT_INODE: ::std::os::raw::c_uint = 16777216;
pub const WHOLE_SECONDS: ::std::os::raw::c_uint = 33554432;
pub const STICKY_TIMEOUTS: ::std::os::raw::c_uint = 67108864;
pub const ADDR_LIMIT_3GB: ::std::os::raw::c_uint = 134217728;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const PER_LINUX: ::std::os::raw::c_uint = 0;
pub const PER_LINUX_32BIT: ::std::os::raw::c_uint = 8388608;
pub const PER_LINUX_FDPIC: ::std::os::raw::c_uint = 524288;
pub const PER_SVR4: ::std::os::raw::c_uint = 68157441;
pub const PER_SVR3: ::std::os::raw::c_uint = 83886082;
pub const PER_SCOSVR3: ::std::os::raw::c_uint = 117440515;
pub const PER_OSR5: ::std::os::raw::c_uint = 100663299;
pub const PER_WYSEV386: ::std::os::raw::c_uint = 83886084;
pub const PER_ISCR4: ::std::os::raw::c_uint = 67108869;
pub const PER_BSD: ::std::os::raw::c_uint = 6;
pub const PER_SUNOS: ::std::os::raw::c_uint = 67108870;
pub const PER_XENIX: ::std::os::raw::c_uint = 83886087;
pub const PER_LINUX32: ::std::os::raw::c_uint = 8;
pub const PER_LINUX32_3GB: ::std::os::raw::c_uint = 134217736;
pub const PER_IRIX32: ::std::os::raw::c_uint = 67108873;
pub const PER_IRIXN32: ::std::os::raw::c_uint = 67108874;
pub const PER_IRIX64: ::std::os::raw::c_uint = 67108875;
pub const PER_RISCOS: ::std::os::raw::c_uint = 12;
pub const PER_SOLARIS: ::std::os::raw::c_uint = 67108877;
pub const PER_UW7: ::std::os::raw::c_uint = 68157454;
pub const PER_OSF4: ::std::os::raw::c_uint = 15;
pub const PER_HPUX: ::std::os::raw::c_uint = 16;
pub const PER_MASK: ::std::os::raw::c_uint = 255;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(64))]
pub struct cacheline_padding {
    pub x: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_cacheline_padding() {
    assert_eq!(
        ::std::mem::size_of::<cacheline_padding>(),
        0usize,
        concat!("Size of: ", stringify!(cacheline_padding))
    );
    assert_eq!(
        ::std::mem::align_of::<cacheline_padding>(),
        64usize,
        concat!("Alignment of ", stringify!(cacheline_padding))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cacheline_padding>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cacheline_padding),
            "::",
            stringify!(x)
        )
    );
}
pub const tlb_infos_ENTRIES: tlb_infos = 0;
pub const tlb_infos_NR_INFO: tlb_infos = 1;
pub type tlb_infos = ::std::os::raw::c_uint;
extern "C" {
    pub static mut tlb_lli_4k: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lli_2m: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lli_4m: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lld_4k: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lld_2m: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lld_4m: [u16_; 1usize];
}
extern "C" {
    pub static mut tlb_lld_1g: [u16_; 1usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpuinfo_x86 {
    pub x86: __u8,
    pub x86_vendor: __u8,
    pub x86_model: __u8,
    pub x86_stepping: __u8,
    pub x86_tlbsize: ::std::os::raw::c_int,
    pub vmx_capability: [__u32; 5usize],
    pub x86_virt_bits: __u8,
    pub x86_phys_bits: __u8,
    pub x86_coreid_bits: __u8,
    pub cu_id: __u8,
    pub extended_cpuid_level: __u32,
    pub cpuid_level: ::std::os::raw::c_int,
    pub __bindgen_anon_1: cpuinfo_x86__bindgen_ty_1,
    pub x86_vendor_id: [::std::os::raw::c_char; 16usize],
    pub x86_model_id: [::std::os::raw::c_char; 64usize],
    pub x86_cache_size: ::std::os::raw::c_uint,
    pub x86_cache_alignment: ::std::os::raw::c_int,
    pub x86_cache_max_rmid: ::std::os::raw::c_int,
    pub x86_cache_occ_scale: ::std::os::raw::c_int,
    pub x86_cache_mbm_width_offset: ::std::os::raw::c_int,
    pub x86_power: ::std::os::raw::c_int,
    pub loops_per_jiffy: ::std::os::raw::c_ulong,
    pub ppin: u64_,
    pub x86_max_cores: u16_,
    pub apicid: u16_,
    pub initial_apicid: u16_,
    pub x86_clflush_size: u16_,
    pub booted_cores: u16_,
    pub phys_proc_id: u16_,
    pub logical_proc_id: u16_,
    pub cpu_core_id: u16_,
    pub cpu_die_id: u16_,
    pub logical_die_id: u16_,
    pub cpu_index: u16_,
    pub smt_active: bool_,
    pub microcode: u32_,
    pub x86_cache_bits: u8_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpuinfo_x86__bindgen_ty_1 {
    pub x86_capability: [__u32; 21usize],
    pub x86_capability_alignment: ::std::os::raw::c_ulong,
    _bindgen_union_align: [u64; 11usize],
}
#[test]
fn bindgen_test_layout_cpuinfo_x86__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cpuinfo_x86__bindgen_ty_1>(),
        88usize,
        concat!("Size of: ", stringify!(cpuinfo_x86__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cpuinfo_x86__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cpuinfo_x86__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpuinfo_x86__bindgen_ty_1>())).x86_capability as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86__bindgen_ty_1),
            "::",
            stringify!(x86_capability)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpuinfo_x86__bindgen_ty_1>())).x86_capability_alignment
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86__bindgen_ty_1),
            "::",
            stringify!(x86_capability_alignment)
        )
    );
}
#[test]
fn bindgen_test_layout_cpuinfo_x86() {
    assert_eq!(
        ::std::mem::size_of::<cpuinfo_x86>(),
        280usize,
        concat!("Size of: ", stringify!(cpuinfo_x86))
    );
    assert_eq!(
        ::std::mem::align_of::<cpuinfo_x86>(),
        8usize,
        concat!("Alignment of ", stringify!(cpuinfo_x86))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_vendor as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_vendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_model as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_stepping as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_stepping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_tlbsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_tlbsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).vmx_capability as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(vmx_capability)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_virt_bits as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_virt_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_phys_bits as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_phys_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_coreid_bits as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_coreid_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).cu_id as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(cu_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpuinfo_x86>())).extended_cpuid_level as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(extended_cpuid_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).cpuid_level as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(cpuid_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_vendor_id as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_model_id as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_model_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_size as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_alignment as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_max_rmid as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_max_rmid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_occ_scale as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_occ_scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_mbm_width_offset as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_mbm_width_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_power as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_power)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).loops_per_jiffy as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(loops_per_jiffy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).ppin as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(ppin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_max_cores as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_max_cores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).apicid as *const _ as usize },
        250usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(apicid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).initial_apicid as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(initial_apicid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_clflush_size as *const _ as usize },
        254usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_clflush_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).booted_cores as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(booted_cores)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).phys_proc_id as *const _ as usize },
        258usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(phys_proc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).logical_proc_id as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(logical_proc_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).cpu_core_id as *const _ as usize },
        262usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(cpu_core_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).cpu_die_id as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(cpu_die_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).logical_die_id as *const _ as usize },
        266usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(logical_die_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).cpu_index as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(cpu_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).smt_active as *const _ as usize },
        270usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(smt_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).microcode as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(microcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuinfo_x86>())).x86_cache_bits as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuinfo_x86),
            "::",
            stringify!(x86_cache_bits)
        )
    );
}
impl cpuinfo_x86 {
    #[inline]
    pub fn initialized(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_initialized(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        initialized: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let initialized: u32 = unsafe { ::std::mem::transmute(initialized) };
            initialized as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpuid_regs {
    pub eax: u32_,
    pub ebx: u32_,
    pub ecx: u32_,
    pub edx: u32_,
}
#[test]
fn bindgen_test_layout_cpuid_regs() {
    assert_eq!(
        ::std::mem::size_of::<cpuid_regs>(),
        16usize,
        concat!("Size of: ", stringify!(cpuid_regs))
    );
    assert_eq!(
        ::std::mem::align_of::<cpuid_regs>(),
        4usize,
        concat!("Alignment of ", stringify!(cpuid_regs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuid_regs>())).eax as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_regs),
            "::",
            stringify!(eax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuid_regs>())).ebx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_regs),
            "::",
            stringify!(ebx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuid_regs>())).ecx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_regs),
            "::",
            stringify!(ecx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpuid_regs>())).edx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuid_regs),
            "::",
            stringify!(edx)
        )
    );
}
pub const cpuid_regs_idx_CPUID_EAX: cpuid_regs_idx = 0;
pub const cpuid_regs_idx_CPUID_EBX: cpuid_regs_idx = 1;
pub const cpuid_regs_idx_CPUID_ECX: cpuid_regs_idx = 2;
pub const cpuid_regs_idx_CPUID_EDX: cpuid_regs_idx = 3;
pub type cpuid_regs_idx = ::std::os::raw::c_uint;
extern "C" {
    pub static mut boot_cpu_data: cpuinfo_x86;
}
extern "C" {
    pub static mut new_cpu_data: cpuinfo_x86;
}
extern "C" {
    pub static mut cpu_caps_cleared: [__u32; 21usize];
}
extern "C" {
    pub static mut cpu_caps_set: [__u32; 21usize];
}
extern "C" {
    pub static mut cpu_info: cpuinfo_x86;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seq_operations {
    _unused: [u8; 0],
}
extern "C" {
    pub static cpuinfo_op: seq_operations;
}
extern "C" {
    pub fn cpu_detect(c: *mut cpuinfo_x86);
}
extern "C" {
    pub fn early_cpu_init();
}
extern "C" {
    pub fn identify_boot_cpu();
}
extern "C" {
    pub fn identify_secondary_cpu(arg1: *mut cpuinfo_x86);
}
extern "C" {
    pub fn print_cpu_info(arg1: *mut cpuinfo_x86);
}
extern "C" {
    pub fn print_cpu_msr(arg1: *mut cpuinfo_x86);
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct x86_hw_tss {
    pub reserved1: u32_,
    pub sp0: u64_,
    pub sp1: u64_,
    pub sp2: u64_,
    pub reserved2: u64_,
    pub ist: [u64_; 7usize],
    pub reserved3: u32_,
    pub reserved4: u32_,
    pub reserved5: u16_,
    pub io_bitmap_base: u16_,
}
#[test]
fn bindgen_test_layout_x86_hw_tss() {
    assert_eq!(
        ::std::mem::size_of::<x86_hw_tss>(),
        104usize,
        concat!("Size of: ", stringify!(x86_hw_tss))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_hw_tss>(),
        1usize,
        concat!("Alignment of ", stringify!(x86_hw_tss))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).reserved1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).sp0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(sp0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).sp1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(sp1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).sp2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(sp2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).reserved2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).ist as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(ist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).reserved3 as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).reserved4 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).reserved5 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hw_tss>())).io_bitmap_base as *const _ as usize },
        102usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hw_tss),
            "::",
            stringify!(io_bitmap_base)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct entry_stack {
    pub stack: [::std::os::raw::c_char; 4096usize],
}
#[test]
fn bindgen_test_layout_entry_stack() {
    assert_eq!(
        ::std::mem::size_of::<entry_stack>(),
        4096usize,
        concat!("Size of: ", stringify!(entry_stack))
    );
    assert_eq!(
        ::std::mem::align_of::<entry_stack>(),
        1usize,
        concat!("Alignment of ", stringify!(entry_stack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<entry_stack>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(entry_stack),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[repr(align(4096))]
#[derive(Copy, Clone)]
pub struct entry_stack_page {
    pub stack: entry_stack,
}
#[test]
fn bindgen_test_layout_entry_stack_page() {
    assert_eq!(
        ::std::mem::size_of::<entry_stack_page>(),
        4096usize,
        concat!("Size of: ", stringify!(entry_stack_page))
    );
    assert_eq!(
        ::std::mem::align_of::<entry_stack_page>(),
        4096usize,
        concat!("Alignment of ", stringify!(entry_stack_page))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<entry_stack_page>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(entry_stack_page),
            "::",
            stringify!(stack)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x86_io_bitmap {
    pub prev_sequence: u64_,
    pub prev_max: ::std::os::raw::c_uint,
    pub bitmap: [::std::os::raw::c_ulong; 1025usize],
    pub mapall: [::std::os::raw::c_ulong; 1025usize],
}
#[test]
fn bindgen_test_layout_x86_io_bitmap() {
    assert_eq!(
        ::std::mem::size_of::<x86_io_bitmap>(),
        16416usize,
        concat!("Size of: ", stringify!(x86_io_bitmap))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_io_bitmap>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_io_bitmap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_io_bitmap>())).prev_sequence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_io_bitmap),
            "::",
            stringify!(prev_sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_io_bitmap>())).prev_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_io_bitmap),
            "::",
            stringify!(prev_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_io_bitmap>())).bitmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_io_bitmap),
            "::",
            stringify!(bitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_io_bitmap>())).mapall as *const _ as usize },
        8216usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_io_bitmap),
            "::",
            stringify!(mapall)
        )
    );
}
#[repr(C)]
#[repr(align(4096))]
#[derive(Copy, Clone)]
pub struct tss_struct {
    pub x86_tss: x86_hw_tss,
    pub io_bitmap: x86_io_bitmap,
}
#[test]
fn bindgen_test_layout_tss_struct() {
    assert_eq!(
        ::std::mem::size_of::<tss_struct>(),
        20480usize,
        concat!("Size of: ", stringify!(tss_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<tss_struct>(),
        4096usize,
        concat!("Alignment of ", stringify!(tss_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tss_struct>())).x86_tss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(x86_tss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tss_struct>())).io_bitmap as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(tss_struct),
            "::",
            stringify!(io_bitmap)
        )
    );
}
extern "C" {
    pub static mut cpu_tss_rw: tss_struct;
}
#[repr(C)]
#[repr(align(32768))]
#[derive(Copy, Clone)]
pub struct irq_stack {
    pub stack: [::std::os::raw::c_char; 32768usize],
}
#[test]
fn bindgen_test_layout_irq_stack() {
    assert_eq!(
        ::std::mem::size_of::<irq_stack>(),
        32768usize,
        concat!("Size of: ", stringify!(irq_stack))
    );
    assert_eq!(
        ::std::mem::align_of::<irq_stack>(),
        32768usize,
        concat!("Alignment of ", stringify!(irq_stack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<irq_stack>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(irq_stack),
            "::",
            stringify!(stack)
        )
    );
}
extern "C" {
    pub static mut cpu_current_top_of_stack: ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fixed_percpu_data {
    pub gs_base: [::std::os::raw::c_char; 40usize],
    pub stack_canary: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_fixed_percpu_data() {
    assert_eq!(
        ::std::mem::size_of::<fixed_percpu_data>(),
        48usize,
        concat!("Size of: ", stringify!(fixed_percpu_data))
    );
    assert_eq!(
        ::std::mem::align_of::<fixed_percpu_data>(),
        8usize,
        concat!("Alignment of ", stringify!(fixed_percpu_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fixed_percpu_data>())).gs_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fixed_percpu_data),
            "::",
            stringify!(gs_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fixed_percpu_data>())).stack_canary as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fixed_percpu_data),
            "::",
            stringify!(stack_canary)
        )
    );
}
extern "C" {
    pub static mut fixed_percpu_data: fixed_percpu_data;
}
extern "C" {
    pub static mut init_per_cpu__fixed_percpu_data: fixed_percpu_data;
}
extern "C" {
    pub static mut hardirq_stack_ptr: *mut ::std::os::raw::c_void;
}
extern "C" {
    pub static mut hardirq_stack_inuse: bool;
}
extern "C" {
    pub fn ignore_sysret();
}
extern "C" {
    pub fn current_save_fsgs();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_event {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
pub struct thread_struct {
    pub tls_array: [desc_struct; 3usize],
    pub sp: ::std::os::raw::c_ulong,
    pub es: ::std::os::raw::c_ushort,
    pub ds: ::std::os::raw::c_ushort,
    pub fsindex: ::std::os::raw::c_ushort,
    pub gsindex: ::std::os::raw::c_ushort,
    pub fsbase: ::std::os::raw::c_ulong,
    pub gsbase: ::std::os::raw::c_ulong,
    pub ptrace_bps: [*mut perf_event; 4usize],
    pub virtual_dr6: ::std::os::raw::c_ulong,
    pub ptrace_dr7: ::std::os::raw::c_ulong,
    pub cr2: ::std::os::raw::c_ulong,
    pub trap_nr: ::std::os::raw::c_ulong,
    pub error_code: ::std::os::raw::c_ulong,
    pub io_bitmap: *mut io_bitmap,
    pub iopl_emul: ::std::os::raw::c_ulong,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub pkru: u32_,
    pub __bindgen_padding_0: [u64; 5usize],
    pub fpu: fpu,
}
#[test]
fn bindgen_test_layout_thread_struct() {
    assert_eq!(
        ::std::mem::size_of::<thread_struct>(),
        4416usize,
        concat!("Size of: ", stringify!(thread_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<thread_struct>(),
        64usize,
        concat!("Alignment of ", stringify!(thread_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).tls_array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(tls_array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).sp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).es as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).ds as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).fsindex as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fsindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).gsindex as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(gsindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).fsbase as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fsbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).gsbase as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(gsbase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).ptrace_bps as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ptrace_bps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).virtual_dr6 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(virtual_dr6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).ptrace_dr7 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(ptrace_dr7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).cr2 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).trap_nr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(trap_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).error_code as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).io_bitmap as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(io_bitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).iopl_emul as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(iopl_emul)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).pkru as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(pkru)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_struct>())).fpu as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_struct),
            "::",
            stringify!(fpu)
        )
    );
}
impl thread_struct {
    #[inline]
    pub fn iopl_warn(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_iopl_warn(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_on_uaccess_err(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_on_uaccess_err(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        iopl_warn: ::std::os::raw::c_uint,
        sig_on_uaccess_err: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let iopl_warn: u32 = unsafe { ::std::mem::transmute(iopl_warn) };
            iopl_warn as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sig_on_uaccess_err: u32 = unsafe { ::std::mem::transmute(sig_on_uaccess_err) };
            sig_on_uaccess_err as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn fpu_thread_struct_whitelist(
        offset: *mut ::std::os::raw::c_ulong,
        size: *mut ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __get_wchan(p: *mut task_struct) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn select_idle_routine(c: *const cpuinfo_x86);
}
extern "C" {
    pub fn amd_e400_c1e_apic_setup();
}
extern "C" {
    pub static mut boot_option_idle_override: ::std::os::raw::c_ulong;
}
pub const idle_boot_override_IDLE_NO_OVERRIDE: idle_boot_override = 0;
pub const idle_boot_override_IDLE_HALT: idle_boot_override = 1;
pub const idle_boot_override_IDLE_NOMWAIT: idle_boot_override = 2;
pub const idle_boot_override_IDLE_POLL: idle_boot_override = 3;
pub type idle_boot_override = ::std::os::raw::c_uint;
extern "C" {
    pub fn enable_sep_cpu();
}
extern "C" {
    pub fn sysenter_setup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut early_gdt_descr: desc_ptr;
}
extern "C" {
    pub fn switch_to_new_gdt(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn load_direct_gdt(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn load_fixmap_gdt(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn load_percpu_segment(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cpu_init();
}
extern "C" {
    pub fn cpu_init_secondary();
}
extern "C" {
    pub fn cpu_init_exception_handling();
}
extern "C" {
    pub fn cr4_init();
}
extern "C" {
    pub fn set_task_blockstep(task: *mut task_struct, on: bool_);
}
extern "C" {
    pub static mut bootloader_type: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut bootloader_version: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut ignore_fpu_irq: ::std::os::raw::c_char;
}
extern "C" {
    pub fn KSTK_ESP(task: *mut task_struct) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn start_thread(
        regs: *mut pt_regs,
        new_ip: ::std::os::raw::c_ulong,
        new_sp: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn get_tsc_mode(adr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_tsc_mode(val: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut msr_misc_features_shadow: ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn get_llc_id(cpu: ::std::os::raw::c_uint) -> u16_;
}
extern "C" {
    pub fn amd_get_nodes_per_socket() -> u32_;
}
extern "C" {
    pub fn amd_get_highest_perf() -> u32_;
}
extern "C" {
    pub fn arch_align_stack(sp: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn free_init_pages(
        what: *const ::std::os::raw::c_char,
        begin: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn free_kernel_image_pages(
        what: *const ::std::os::raw::c_char,
        begin: *mut ::std::os::raw::c_void,
        end: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn default_idle();
}
extern "C" {
    pub fn stop_this_cpu(dummy: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn microcode_check();
}
pub const l1tf_mitigations_L1TF_MITIGATION_OFF: l1tf_mitigations = 0;
pub const l1tf_mitigations_L1TF_MITIGATION_FLUSH_NOWARN: l1tf_mitigations = 1;
pub const l1tf_mitigations_L1TF_MITIGATION_FLUSH: l1tf_mitigations = 2;
pub const l1tf_mitigations_L1TF_MITIGATION_FLUSH_NOSMT: l1tf_mitigations = 3;
pub const l1tf_mitigations_L1TF_MITIGATION_FULL: l1tf_mitigations = 4;
pub const l1tf_mitigations_L1TF_MITIGATION_FULL_FORCE: l1tf_mitigations = 5;
pub type l1tf_mitigations = ::std::os::raw::c_uint;
extern "C" {
    pub static mut l1tf_mitigation: l1tf_mitigations;
}
pub const mds_mitigations_MDS_MITIGATION_OFF: mds_mitigations = 0;
pub const mds_mitigations_MDS_MITIGATION_FULL: mds_mitigations = 1;
pub const mds_mitigations_MDS_MITIGATION_VMWERV: mds_mitigations = 2;
pub type mds_mitigations = ::std::os::raw::c_uint;
pub const cpuid_leafs_CPUID_1_EDX: cpuid_leafs = 0;
pub const cpuid_leafs_CPUID_8000_0001_EDX: cpuid_leafs = 1;
pub const cpuid_leafs_CPUID_8086_0001_EDX: cpuid_leafs = 2;
pub const cpuid_leafs_CPUID_LNX_1: cpuid_leafs = 3;
pub const cpuid_leafs_CPUID_1_ECX: cpuid_leafs = 4;
pub const cpuid_leafs_CPUID_C000_0001_EDX: cpuid_leafs = 5;
pub const cpuid_leafs_CPUID_8000_0001_ECX: cpuid_leafs = 6;
pub const cpuid_leafs_CPUID_LNX_2: cpuid_leafs = 7;
pub const cpuid_leafs_CPUID_LNX_3: cpuid_leafs = 8;
pub const cpuid_leafs_CPUID_7_0_EBX: cpuid_leafs = 9;
pub const cpuid_leafs_CPUID_D_1_EAX: cpuid_leafs = 10;
pub const cpuid_leafs_CPUID_LNX_4: cpuid_leafs = 11;
pub const cpuid_leafs_CPUID_7_1_EAX: cpuid_leafs = 12;
pub const cpuid_leafs_CPUID_8000_0008_EBX: cpuid_leafs = 13;
pub const cpuid_leafs_CPUID_6_EAX: cpuid_leafs = 14;
pub const cpuid_leafs_CPUID_8000_000A_EDX: cpuid_leafs = 15;
pub const cpuid_leafs_CPUID_7_ECX: cpuid_leafs = 16;
pub const cpuid_leafs_CPUID_8000_0007_EBX: cpuid_leafs = 17;
pub const cpuid_leafs_CPUID_7_EDX: cpuid_leafs = 18;
pub const cpuid_leafs_CPUID_8000_001F_EAX: cpuid_leafs = 19;
pub type cpuid_leafs = ::std::os::raw::c_uint;
extern "C" {
    pub static x86_cap_flags: [*const ::std::os::raw::c_char; 640usize];
}
extern "C" {
    pub static x86_power_flags: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub static x86_bug_flags: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub fn setup_clear_cpu_cap(bit: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn clear_cpu_cap(c: *mut cpuinfo_x86, bit: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_info {
    pub flags: ::std::os::raw::c_ulong,
    pub syscall_work: ::std::os::raw::c_ulong,
    pub status: u32_,
    pub cpu: u32_,
}
#[test]
fn bindgen_test_layout_thread_info() {
    assert_eq!(
        ::std::mem::size_of::<thread_info>(),
        24usize,
        concat!("Size of: ", stringify!(thread_info))
    );
    assert_eq!(
        ::std::mem::align_of::<thread_info>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_info>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_info>())).syscall_work as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(syscall_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_info>())).status as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_info>())).cpu as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_info),
            "::",
            stringify!(cpu)
        )
    );
}
extern "C" {
    pub fn arch_task_cache_init();
}
extern "C" {
    pub fn arch_dup_task_struct(
        dst: *mut task_struct,
        src: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_release_task_struct(tsk: *mut task_struct);
}
extern "C" {
    pub fn arch_setup_new_exec();
}
extern "C" {
    pub fn __bad_copy_from();
}
extern "C" {
    pub fn __bad_copy_to();
}
extern "C" {
    pub fn __copy_overflow(size: ::std::os::raw::c_int, count: ::std::os::raw::c_ulong);
}
extern "C" {
    pub static mut __preempt_count: ::std::os::raw::c_int;
}
extern "C" {
    pub fn preempt_schedule();
}
extern "C" {
    pub fn preempt_schedule_thunk();
}
extern "C" {
    pub fn preempt_schedule_notrace();
}
extern "C" {
    pub fn preempt_schedule_notrace_thunk();
}
extern "C" {
    pub static mut __SCK__preempt_schedule: static_call_key;
}
extern "C" {
    pub fn __SCT__preempt_schedule();
}
extern "C" {
    pub static mut __SCK__preempt_schedule_notrace: static_call_key;
}
extern "C" {
    pub fn __SCT__preempt_schedule_notrace();
}
extern "C" {
    pub fn preempt_count_add(val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn preempt_count_sub(val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn migrate_disable();
}
extern "C" {
    pub fn migrate_enable();
}
extern "C" {
    pub fn _local_bh_enable();
}
extern "C" {
    pub fn __local_bh_enable_ip(ip: ::std::os::raw::c_ulong, cnt: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llist_head {
    pub first: *mut llist_node,
}
#[test]
fn bindgen_test_layout_llist_head() {
    assert_eq!(
        ::std::mem::size_of::<llist_head>(),
        8usize,
        concat!("Size of: ", stringify!(llist_head))
    );
    assert_eq!(
        ::std::mem::align_of::<llist_head>(),
        8usize,
        concat!("Alignment of ", stringify!(llist_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llist_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llist_head),
            "::",
            stringify!(first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llist_node {
    pub next: *mut llist_node,
}
#[test]
fn bindgen_test_layout_llist_node() {
    assert_eq!(
        ::std::mem::size_of::<llist_node>(),
        8usize,
        concat!("Size of: ", stringify!(llist_node))
    );
    assert_eq!(
        ::std::mem::align_of::<llist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(llist_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llist_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llist_node),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn llist_add_batch(
        new_first: *mut llist_node,
        new_last: *mut llist_node,
        head: *mut llist_head,
    ) -> bool_;
}
extern "C" {
    pub fn llist_del_first(head: *mut llist_head) -> *mut llist_node;
}
extern "C" {
    pub fn llist_reverse_order(head: *mut llist_node) -> *mut llist_node;
}
pub const CSD_FLAG_LOCK: ::std::os::raw::c_uint = 1;
pub const IRQ_WORK_PENDING: ::std::os::raw::c_uint = 1;
pub const IRQ_WORK_BUSY: ::std::os::raw::c_uint = 2;
pub const IRQ_WORK_LAZY: ::std::os::raw::c_uint = 4;
pub const IRQ_WORK_HARD_IRQ: ::std::os::raw::c_uint = 8;
pub const IRQ_WORK_CLAIMED: ::std::os::raw::c_uint = 3;
pub const CSD_TYPE_ASYNC: ::std::os::raw::c_uint = 0;
pub const CSD_TYPE_SYNC: ::std::os::raw::c_uint = 16;
pub const CSD_TYPE_IRQ_WORK: ::std::os::raw::c_uint = 32;
pub const CSD_TYPE_TTWU: ::std::os::raw::c_uint = 48;
pub const CSD_FLAG_TYPE_MASK: ::std::os::raw::c_uint = 240;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_node {
    pub llist: llist_node,
    pub __bindgen_anon_1: __call_single_node__bindgen_ty_1,
    pub src: u16_,
    pub dst: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __call_single_node__bindgen_ty_1 {
    pub u_flags: ::std::os::raw::c_uint,
    pub a_flags: atomic_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___call_single_node__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__call_single_node__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__call_single_node__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__call_single_node__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__call_single_node__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__call_single_node__bindgen_ty_1>())).u_flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_node__bindgen_ty_1),
            "::",
            stringify!(u_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__call_single_node__bindgen_ty_1>())).a_flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_node__bindgen_ty_1),
            "::",
            stringify!(a_flags)
        )
    );
}
#[test]
fn bindgen_test_layout___call_single_node() {
    assert_eq!(
        ::std::mem::size_of::<__call_single_node>(),
        16usize,
        concat!("Size of: ", stringify!(__call_single_node))
    );
    assert_eq!(
        ::std::mem::align_of::<__call_single_node>(),
        8usize,
        concat!("Alignment of ", stringify!(__call_single_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_node>())).llist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_node),
            "::",
            stringify!(llist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_node>())).src as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_node),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_node>())).dst as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_node),
            "::",
            stringify!(dst)
        )
    );
}
pub type smp_call_func_t =
    ::std::option::Option<unsafe extern "C" fn(info: *mut ::std::os::raw::c_void)>;
pub type smp_cond_func_t = ::std::option::Option<
    unsafe extern "C" fn(cpu: ::std::os::raw::c_int, info: *mut ::std::os::raw::c_void) -> bool_,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_data {
    pub node: __call_single_node,
    pub func: smp_call_func_t,
    pub info: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___call_single_data() {
    assert_eq!(
        ::std::mem::size_of::<__call_single_data>(),
        32usize,
        concat!("Size of: ", stringify!(__call_single_data))
    );
    assert_eq!(
        ::std::mem::align_of::<__call_single_data>(),
        8usize,
        concat!("Alignment of ", stringify!(__call_single_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_data>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_data>())).func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__call_single_data>())).info as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__call_single_data),
            "::",
            stringify!(info)
        )
    );
}
pub type call_single_data_t = __call_single_data;
extern "C" {
    pub fn __smp_call_single_queue(cpu: ::std::os::raw::c_int, node: *mut llist_node);
}
extern "C" {
    pub static mut total_cpus: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn smp_call_function_single(
        cpuid: ::std::os::raw::c_int,
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_each_cpu_cond_mask(
        cond_func: smp_cond_func_t,
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: bool_,
        mask: *const cpumask,
    );
}
extern "C" {
    pub fn smp_call_function_single_async(
        cpu: ::std::os::raw::c_int,
        csd: *mut __call_single_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn panic_smp_self_stop();
}
extern "C" {
    pub fn nmi_panic_self_stop(regs: *mut pt_regs);
}
extern "C" {
    pub fn crash_smp_send_stop();
}
extern "C" {
    pub static mut smp_num_siblings: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut num_processors: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut cpu_sibling_map: [cpumask; 1usize];
}
extern "C" {
    pub static mut cpu_core_map: [cpumask; 1usize];
}
extern "C" {
    pub static mut cpu_die_map: [cpumask; 1usize];
}
extern "C" {
    pub static mut cpu_llc_shared_map: [cpumask; 1usize];
}
extern "C" {
    pub static mut cpu_l2c_shared_map: [cpumask; 1usize];
}
extern "C" {
    pub static mut cpu_llc_id: ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut cpu_l2c_id: ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut cpu_number: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut x86_cpu_to_apicid: ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut x86_cpu_to_apicid_early_ptr: *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut x86_cpu_to_apicid_early_map: [::std::os::raw::c_ushort; 0usize];
}
extern "C" {
    pub static mut x86_cpu_to_acpiid: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut x86_cpu_to_acpiid_early_ptr: *mut ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut x86_cpu_to_acpiid_early_map: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut x86_bios_cpu_apicid: ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut x86_bios_cpu_apicid_early_ptr: *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub static mut x86_bios_cpu_apicid_early_map: [::std::os::raw::c_ushort; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct smp_ops {
    pub smp_prepare_boot_cpu: ::std::option::Option<unsafe extern "C" fn()>,
    pub smp_prepare_cpus:
        ::std::option::Option<unsafe extern "C" fn(max_cpus: ::std::os::raw::c_uint)>,
    pub smp_cpus_done:
        ::std::option::Option<unsafe extern "C" fn(max_cpus: ::std::os::raw::c_uint)>,
    pub stop_other_cpus: ::std::option::Option<unsafe extern "C" fn(wait: ::std::os::raw::c_int)>,
    pub crash_stop_other_cpus: ::std::option::Option<unsafe extern "C" fn()>,
    pub smp_send_reschedule:
        ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_int)>,
    pub cpu_up: ::std::option::Option<
        unsafe extern "C" fn(
            cpu: ::std::os::raw::c_uint,
            tidle: *mut task_struct,
        ) -> ::std::os::raw::c_int,
    >,
    pub cpu_disable: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub cpu_die: ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_uint)>,
    pub play_dead: ::std::option::Option<unsafe extern "C" fn()>,
    pub send_call_func_ipi: ::std::option::Option<unsafe extern "C" fn(mask: *const cpumask)>,
    pub send_call_func_single_ipi:
        ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_int)>,
}
#[test]
fn bindgen_test_layout_smp_ops() {
    assert_eq!(
        ::std::mem::size_of::<smp_ops>(),
        96usize,
        concat!("Size of: ", stringify!(smp_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<smp_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(smp_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).smp_prepare_boot_cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(smp_prepare_boot_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).smp_prepare_cpus as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(smp_prepare_cpus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).smp_cpus_done as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(smp_cpus_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).stop_other_cpus as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(stop_other_cpus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).crash_stop_other_cpus as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(crash_stop_other_cpus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).smp_send_reschedule as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(smp_send_reschedule)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).cpu_up as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(cpu_up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).cpu_disable as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(cpu_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).cpu_die as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(cpu_die)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).play_dead as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(play_dead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<smp_ops>())).send_call_func_ipi as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(send_call_func_ipi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<smp_ops>())).send_call_func_single_ipi as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(smp_ops),
            "::",
            stringify!(send_call_func_single_ipi)
        )
    );
}
extern "C" {
    pub fn set_cpu_sibling_map(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub static mut smp_ops: smp_ops;
}
extern "C" {
    pub fn cpu_disable_common();
}
extern "C" {
    pub fn native_smp_prepare_boot_cpu();
}
extern "C" {
    pub fn smp_prepare_cpus_common();
}
extern "C" {
    pub fn native_smp_prepare_cpus(max_cpus: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn calculate_max_logical_packages();
}
extern "C" {
    pub fn native_smp_cpus_done(max_cpus: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn common_cpu_up(
        cpunum: ::std::os::raw::c_uint,
        tidle: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_cpu_up(
        cpunum: ::std::os::raw::c_uint,
        tidle: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_cpu_disable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn common_cpu_die(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn native_cpu_die(cpu: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hlt_play_dead();
}
extern "C" {
    pub fn native_play_dead();
}
extern "C" {
    pub fn play_dead_common();
}
extern "C" {
    pub fn wbinvd_on_cpu(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn wbinvd_on_all_cpus() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cond_wakeup_cpu0();
}
extern "C" {
    pub fn native_smp_send_reschedule(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn native_send_call_func_ipi(mask: *const cpumask);
}
extern "C" {
    pub fn native_send_call_func_single_ipi(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn x86_idle_thread_init(cpu: ::std::os::raw::c_uint, idle: *mut task_struct);
}
extern "C" {
    pub fn smp_store_boot_cpu_info();
}
extern "C" {
    pub fn smp_store_cpu_info(id: ::std::os::raw::c_int);
}
extern "C" {
    pub fn smp_reboot_interrupt();
}
extern "C" {
    pub fn smp_reschedule_interrupt(regs: *mut pt_regs);
}
extern "C" {
    pub fn smp_call_function_interrupt(regs: *mut pt_regs);
}
extern "C" {
    pub fn smp_call_function_single_interrupt(r: *mut pt_regs);
}
extern "C" {
    pub static mut disabled_cpus: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hard_smp_processor_id() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smp_call_function(
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn smp_call_function_many(
        mask: *const cpumask,
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: bool_,
    );
}
extern "C" {
    pub fn smp_call_function_any(
        mask: *const cpumask,
        func: smp_call_func_t,
        info: *mut ::std::os::raw::c_void,
        wait: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kick_all_cpus_sync();
}
extern "C" {
    pub fn wake_up_all_idle_cpus();
}
extern "C" {
    pub fn call_function_init();
}
extern "C" {
    pub fn generic_smp_call_function_single_interrupt();
}
extern "C" {
    pub static mut setup_max_cpus: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn setup_nr_cpu_ids();
}
extern "C" {
    pub fn smp_init();
}
extern "C" {
    pub static mut __boot_cpu_id: ::std::os::raw::c_int;
}
extern "C" {
    pub fn debug_smp_processor_id() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn arch_disable_smp_support();
}
extern "C" {
    pub fn arch_thaw_secondary_cpus_begin();
}
extern "C" {
    pub fn arch_thaw_secondary_cpus_end();
}
extern "C" {
    pub fn smp_setup_processor_id();
}
extern "C" {
    pub fn smp_call_on_cpu(
        cpu: ::std::os::raw::c_uint,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        par: *mut ::std::os::raw::c_void,
        phys: bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smpcfd_prepare_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smpcfd_dead_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn smpcfd_dying_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lock_is_held(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockdep_is_held(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
pub const xhlock_context_t_XHLOCK_HARD: xhlock_context_t = 0;
pub const xhlock_context_t_XHLOCK_SOFT: xhlock_context_t = 1;
pub const xhlock_context_t_XHLOCK_CTX_NR: xhlock_context_t = 2;
pub type xhlock_context_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spinlock {
    pub __bindgen_anon_1: spinlock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spinlock__bindgen_ty_1 {
    pub rlock: raw_spinlock,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_spinlock__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spinlock__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spinlock__bindgen_ty_1>())).rlock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spinlock__bindgen_ty_1),
            "::",
            stringify!(rlock)
        )
    );
}
#[test]
fn bindgen_test_layout_spinlock() {
    assert_eq!(
        ::std::mem::size_of::<spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(spinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(spinlock))
    );
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rwlock_t {
    pub raw_lock: arch_rwlock_t,
}
#[test]
fn bindgen_test_layout_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<rwlock_t>(),
        8usize,
        concat!("Size of: ", stringify!(rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rwlock_t>())).raw_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rwlock_t),
            "::",
            stringify!(raw_lock)
        )
    );
}
extern "C" {
    pub fn dummy_steal_clock(cpu: ::std::os::raw::c_int) -> u64_;
}
extern "C" {
    pub fn dummy_sched_clock() -> u64_;
}
extern "C" {
    pub static mut __SCK__pv_steal_clock: static_call_key;
}
extern "C" {
    pub fn __SCT__pv_steal_clock(arg1: ::std::os::raw::c_int) -> u64_;
}
extern "C" {
    pub static mut __SCK__pv_sched_clock: static_call_key;
}
extern "C" {
    pub fn __SCT__pv_sched_clock() -> u64_;
}
extern "C" {
    pub fn paravirt_set_sched_clock(func: ::std::option::Option<unsafe extern "C" fn() -> u64_>);
}
extern "C" {
    pub static mut paravirt_steal_enabled: static_key;
}
extern "C" {
    pub static mut paravirt_steal_rq_enabled: static_key;
}
extern "C" {
    pub fn __native_queued_spin_unlock(lock: *mut qspinlock);
}
extern "C" {
    pub fn pv_is_native_spin_unlock() -> bool_;
}
extern "C" {
    pub fn __native_vcpu_is_preempted(cpu: ::std::os::raw::c_long) -> bool_;
}
extern "C" {
    pub fn pv_is_native_vcpu_is_preempted() -> bool_;
}
extern "C" {
    pub fn native_flush_tlb_local();
}
extern "C" {
    pub fn native_flush_tlb_global();
}
extern "C" {
    pub fn native_flush_tlb_one_user(addr: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn native_flush_tlb_multi(cpumask: *const cpumask, info: *const flush_tlb_info);
}
extern "C" {
    pub fn default_banner();
}
extern "C" {
    pub static mut virt_spin_lock_key: static_key_true;
}
extern "C" {
    pub fn native_pv_lock_init();
}
extern "C" {
    pub fn queued_spin_lock_slowpath(lock: *mut qspinlock, val: u32_);
}
extern "C" {
    pub fn queued_read_lock_slowpath(lock: *mut qrwlock);
}
extern "C" {
    pub fn queued_write_lock_slowpath(lock: *mut qrwlock);
}
extern "C" {
    pub fn in_lock_functions(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_spin_lock(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_nested(lock: *mut raw_spinlock_t, subclass: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _raw_spin_lock_nest_lock(lock: *mut raw_spinlock_t, map: *mut lockdep_map);
}
extern "C" {
    pub fn _raw_spin_lock_bh(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_irq(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_irqsave(lock: *mut raw_spinlock_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_spin_lock_irqsave_nested(
        lock: *mut raw_spinlock_t,
        subclass: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_spin_trylock(lock: *mut raw_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_spin_trylock_bh(lock: *mut raw_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_spin_unlock(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_bh(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_irq(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_irqrestore(lock: *mut raw_spinlock_t, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn _raw_read_lock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_nested(lock: *mut rwlock_t, subclass: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _raw_read_lock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_lock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_lock_irqsave(lock: *mut rwlock_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_write_lock_irqsave(lock: *mut rwlock_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _raw_read_trylock(lock: *mut rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_write_trylock(lock: *mut rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _raw_read_unlock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_irqrestore(lock: *mut rwlock_t, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn _raw_write_unlock_irqrestore(lock: *mut rwlock_t, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    #[doc = " atomic_dec_and_lock - lock on reaching reference count zero"]
    #[doc = " @atomic: the atomic counter"]
    #[doc = " @lock: the spinlock in question"]
    #[doc = ""]
    #[doc = " Decrements @atomic by 1.  If the result is 0, returns true and locks"]
    #[doc = " @lock.  Returns false for all other cases."]
    pub fn _atomic_dec_and_lock(
        atomic: *mut atomic_t,
        lock: *mut spinlock_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atomic_dec_and_lock_irqsave(
        atomic: *mut atomic_t,
        lock: *mut spinlock_t,
        flags: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __alloc_bucket_spinlocks(
        locks: *mut *mut spinlock_t,
        lock_mask: *mut ::std::os::raw::c_uint,
        max_size: size_t,
        cpu_mult: ::std::os::raw::c_uint,
        gfp: gfp_t,
        name: *const ::std::os::raw::c_char,
        key: *mut lock_class_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn free_bucket_spinlocks(locks: *mut spinlock_t);
}
pub type wait_queue_entry_t = wait_queue_entry;
pub type wait_queue_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        wq_entry: *mut wait_queue_entry,
        mode: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn default_wake_function(
        wq_entry: *mut wait_queue_entry,
        mode: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait_queue_entry {
    pub flags: ::std::os::raw::c_uint,
    pub private: *mut ::std::os::raw::c_void,
    pub func: wait_queue_func_t,
    pub entry: list_head,
}
#[test]
fn bindgen_test_layout_wait_queue_entry() {
    assert_eq!(
        ::std::mem::size_of::<wait_queue_entry>(),
        40usize,
        concat!("Size of: ", stringify!(wait_queue_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<wait_queue_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(wait_queue_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_queue_entry>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_entry),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_queue_entry>())).private as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_entry),
            "::",
            stringify!(private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_queue_entry>())).func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_entry),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_queue_entry>())).entry as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_entry),
            "::",
            stringify!(entry)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_head {
    pub lock: spinlock_t,
    pub head: list_head,
}
#[test]
fn bindgen_test_layout_wait_queue_head() {
    assert_eq!(
        ::std::mem::size_of::<wait_queue_head>(),
        24usize,
        concat!("Size of: ", stringify!(wait_queue_head))
    );
    assert_eq!(
        ::std::mem::align_of::<wait_queue_head>(),
        8usize,
        concat!("Alignment of ", stringify!(wait_queue_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_queue_head>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_head),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_queue_head>())).head as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_queue_head),
            "::",
            stringify!(head)
        )
    );
}
pub type wait_queue_head_t = wait_queue_head;
extern "C" {
    pub fn __init_waitqueue_head(
        wq_head: *mut wait_queue_head,
        name: *const ::std::os::raw::c_char,
        arg1: *mut lock_class_key,
    );
}
extern "C" {
    pub fn add_wait_queue(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn add_wait_queue_exclusive(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn add_wait_queue_priority(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn remove_wait_queue(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn __wake_up(
        wq_head: *mut wait_queue_head,
        mode: ::std::os::raw::c_uint,
        nr: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __wake_up_locked_key(
        wq_head: *mut wait_queue_head,
        mode: ::std::os::raw::c_uint,
        key: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __wake_up_locked_key_bookmark(
        wq_head: *mut wait_queue_head,
        mode: ::std::os::raw::c_uint,
        key: *mut ::std::os::raw::c_void,
        bookmark: *mut wait_queue_entry_t,
    );
}
extern "C" {
    pub fn __wake_up_sync_key(
        wq_head: *mut wait_queue_head,
        mode: ::std::os::raw::c_uint,
        key: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __wake_up_locked_sync_key(
        wq_head: *mut wait_queue_head,
        mode: ::std::os::raw::c_uint,
        key: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __wake_up_locked(
        wq_head: *mut wait_queue_head,
        mode: ::std::os::raw::c_uint,
        nr: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn __wake_up_sync(wq_head: *mut wait_queue_head, mode: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn __wake_up_pollfree(wq_head: *mut wait_queue_head);
}
extern "C" {
    pub fn init_wait_entry(wq_entry: *mut wait_queue_entry, flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn do_wait_intr(
        arg1: *mut wait_queue_head_t,
        arg2: *mut wait_queue_entry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_wait_intr_irq(
        arg1: *mut wait_queue_head_t,
        arg2: *mut wait_queue_entry_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn prepare_to_wait(
        wq_head: *mut wait_queue_head,
        wq_entry: *mut wait_queue_entry,
        state: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn prepare_to_wait_exclusive(
        wq_head: *mut wait_queue_head,
        wq_entry: *mut wait_queue_entry,
        state: ::std::os::raw::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn prepare_to_wait_event(
        wq_head: *mut wait_queue_head,
        wq_entry: *mut wait_queue_entry,
        state: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn finish_wait(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn wait_woken(
        wq_entry: *mut wait_queue_entry,
        mode: ::std::os::raw::c_uint,
        timeout: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn woken_wake_function(
        wq_entry: *mut wait_queue_entry,
        mode: ::std::os::raw::c_uint,
        sync: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn autoremove_wake_function(
        wq_entry: *mut wait_queue_entry,
        mode: ::std::os::raw::c_uint,
        sync: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type task_call_f = ::std::option::Option<
    unsafe extern "C" fn(
        p: *mut task_struct,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn task_call_func(
        p: *mut task_struct,
        func: task_call_f,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait_bit_key {
    pub flags: *mut ::std::os::raw::c_void,
    pub bit_nr: ::std::os::raw::c_int,
    pub timeout: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_wait_bit_key() {
    assert_eq!(
        ::std::mem::size_of::<wait_bit_key>(),
        24usize,
        concat!("Size of: ", stringify!(wait_bit_key))
    );
    assert_eq!(
        ::std::mem::align_of::<wait_bit_key>(),
        8usize,
        concat!("Alignment of ", stringify!(wait_bit_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_bit_key>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_bit_key),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_bit_key>())).bit_nr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_bit_key),
            "::",
            stringify!(bit_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_bit_key>())).timeout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_bit_key),
            "::",
            stringify!(timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait_bit_queue_entry {
    pub key: wait_bit_key,
    pub wq_entry: wait_queue_entry,
}
#[test]
fn bindgen_test_layout_wait_bit_queue_entry() {
    assert_eq!(
        ::std::mem::size_of::<wait_bit_queue_entry>(),
        64usize,
        concat!("Size of: ", stringify!(wait_bit_queue_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<wait_bit_queue_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(wait_bit_queue_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_bit_queue_entry>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_bit_queue_entry),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait_bit_queue_entry>())).wq_entry as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wait_bit_queue_entry),
            "::",
            stringify!(wq_entry)
        )
    );
}
pub type wait_bit_action_f = ::std::option::Option<
    unsafe extern "C" fn(
        key: *mut wait_bit_key,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __wake_up_bit(
        wq_head: *mut wait_queue_head,
        word: *mut ::std::os::raw::c_void,
        bit: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn __wait_on_bit(
        wq_head: *mut wait_queue_head,
        wbq_entry: *mut wait_bit_queue_entry,
        action: wait_bit_action_f,
        mode: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wait_on_bit_lock(
        wq_head: *mut wait_queue_head,
        wbq_entry: *mut wait_bit_queue_entry,
        action: wait_bit_action_f,
        mode: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wake_up_bit(word: *mut ::std::os::raw::c_void, bit: ::std::os::raw::c_int);
}
extern "C" {
    pub fn out_of_line_wait_on_bit(
        word: *mut ::std::os::raw::c_void,
        arg1: ::std::os::raw::c_int,
        action: wait_bit_action_f,
        mode: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn out_of_line_wait_on_bit_timeout(
        word: *mut ::std::os::raw::c_void,
        arg1: ::std::os::raw::c_int,
        action: wait_bit_action_f,
        mode: ::std::os::raw::c_uint,
        timeout: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn out_of_line_wait_on_bit_lock(
        word: *mut ::std::os::raw::c_void,
        arg1: ::std::os::raw::c_int,
        action: wait_bit_action_f,
        mode: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bit_waitqueue(
        word: *mut ::std::os::raw::c_void,
        bit: ::std::os::raw::c_int,
    ) -> *mut wait_queue_head;
}
extern "C" {
    pub fn wait_bit_init();
}
extern "C" {
    pub fn wake_bit_function(
        wq_entry: *mut wait_queue_entry,
        mode: ::std::os::raw::c_uint,
        sync: ::std::os::raw::c_int,
        key: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bit_wait(key: *mut wait_bit_key, mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bit_wait_io(
        key: *mut wait_bit_key,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bit_wait_timeout(
        key: *mut wait_bit_key,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bit_wait_io_timeout(
        key: *mut wait_bit_key,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn init_wait_var_entry(
        wbq_entry: *mut wait_bit_queue_entry,
        var: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn wake_up_var(var: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __var_waitqueue(p: *mut ::std::os::raw::c_void) -> *mut wait_queue_head_t;
}
extern "C" {
    pub fn ct_irq_enter();
}
extern "C" {
    pub fn ct_irq_exit();
}
extern "C" {
    pub fn ct_irq_enter_irqson();
}
extern "C" {
    pub fn ct_irq_exit_irqson();
}
extern "C" {
    pub fn ct_nmi_enter();
}
extern "C" {
    pub fn ct_nmi_exit();
}
extern "C" {
    pub fn call_rcu(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn rcu_barrier_tasks();
}
extern "C" {
    pub fn rcu_barrier_tasks_rude();
}
extern "C" {
    pub fn synchronize_rcu();
}
extern "C" {
    pub fn get_completed_synchronize_rcu() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn get_completed_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn __rcu_read_lock();
}
extern "C" {
    pub fn __rcu_read_unlock();
}
extern "C" {
    pub fn rcu_init();
}
extern "C" {
    pub static mut rcu_scheduler_active: ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcu_sched_clock_irq(user: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rcu_report_dead(cpu: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rcutree_migrate_callbacks(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn rcu_init_tasks_generic();
}
extern "C" {
    pub fn rcu_sysrq_start();
}
extern "C" {
    pub fn rcu_sysrq_end();
}
extern "C" {
    pub fn call_rcu_tasks(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn synchronize_rcu_tasks();
}
extern "C" {
    pub fn exit_tasks_rcu_start();
}
extern "C" {
    pub fn exit_tasks_rcu_finish();
}
extern "C" {
    pub fn rcu_softirq_qs();
}
extern "C" {
    pub fn rcu_note_context_switch(preempt: bool_);
}
extern "C" {
    pub fn rcu_needs_cpu() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcu_cpu_stall_reset();
}
extern "C" {
    pub fn synchronize_rcu_expedited();
}
extern "C" {
    pub fn kvfree_call_rcu(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn rcu_barrier();
}
extern "C" {
    pub fn rcu_eqs_special_set(cpu: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn rcu_momentary_dyntick_idle();
}
extern "C" {
    pub fn kfree_rcu_scheduler_running();
}
extern "C" {
    pub fn rcu_gp_might_be_stalled() -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_gp_oldstate {
    pub rgos_norm: ::std::os::raw::c_ulong,
    pub rgos_exp: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_rcu_gp_oldstate() {
    assert_eq!(
        ::std::mem::size_of::<rcu_gp_oldstate>(),
        16usize,
        concat!("Size of: ", stringify!(rcu_gp_oldstate))
    );
    assert_eq!(
        ::std::mem::align_of::<rcu_gp_oldstate>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_gp_oldstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_gp_oldstate>())).rgos_norm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_gp_oldstate),
            "::",
            stringify!(rgos_norm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_gp_oldstate>())).rgos_exp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_gp_oldstate),
            "::",
            stringify!(rgos_exp)
        )
    );
}
extern "C" {
    pub fn start_poll_synchronize_rcu_expedited() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn start_poll_synchronize_rcu_expedited_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn cond_synchronize_rcu_expedited(oldstate: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn cond_synchronize_rcu_expedited_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn get_state_synchronize_rcu() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn get_state_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn start_poll_synchronize_rcu() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn start_poll_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn poll_state_synchronize_rcu(oldstate: ::std::os::raw::c_ulong) -> bool_;
}
extern "C" {
    pub fn poll_state_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate) -> bool_;
}
extern "C" {
    pub fn cond_synchronize_rcu(oldstate: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn cond_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn rcu_is_idle_cpu(cpu: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn rcu_preempt_deferred_qs(t: *mut task_struct);
}
extern "C" {
    pub fn exit_rcu();
}
extern "C" {
    pub fn rcu_scheduler_starting();
}
extern "C" {
    pub fn rcu_end_inkernel_boot();
}
extern "C" {
    pub fn rcu_inkernel_boot_has_ended() -> bool_;
}
extern "C" {
    pub fn rcu_is_watching() -> bool_;
}
extern "C" {
    pub fn rcutree_prepare_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcutree_online_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcutree_offline_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcutree_dead_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcutree_dying_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcu_cpu_starting(cpu: ::std::os::raw::c_uint);
}
extern "C" {
    pub static mut rcu_lock_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_bh_lock_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_sched_lock_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_callback_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_expedited: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut rcu_normal: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_bl_head {
    pub first: *mut hlist_bl_node,
}
#[test]
fn bindgen_test_layout_hlist_bl_head() {
    assert_eq!(
        ::std::mem::size_of::<hlist_bl_head>(),
        8usize,
        concat!("Size of: ", stringify!(hlist_bl_head))
    );
    assert_eq!(
        ::std::mem::align_of::<hlist_bl_head>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_bl_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hlist_bl_head>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_bl_head),
            "::",
            stringify!(first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hlist_bl_node {
    pub next: *mut hlist_bl_node,
    pub pprev: *mut *mut hlist_bl_node,
}
#[test]
fn bindgen_test_layout_hlist_bl_node() {
    assert_eq!(
        ::std::mem::size_of::<hlist_bl_node>(),
        16usize,
        concat!("Size of: ", stringify!(hlist_bl_node))
    );
    assert_eq!(
        ::std::mem::align_of::<hlist_bl_node>(),
        8usize,
        concat!("Alignment of ", stringify!(hlist_bl_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hlist_bl_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_bl_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hlist_bl_node>())).pprev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hlist_bl_node),
            "::",
            stringify!(pprev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct optimistic_spin_node {
    pub next: *mut optimistic_spin_node,
    pub prev: *mut optimistic_spin_node,
    pub locked: ::std::os::raw::c_int,
    pub cpu: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_optimistic_spin_node() {
    assert_eq!(
        ::std::mem::size_of::<optimistic_spin_node>(),
        24usize,
        concat!("Size of: ", stringify!(optimistic_spin_node))
    );
    assert_eq!(
        ::std::mem::align_of::<optimistic_spin_node>(),
        8usize,
        concat!("Alignment of ", stringify!(optimistic_spin_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<optimistic_spin_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(optimistic_spin_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<optimistic_spin_node>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(optimistic_spin_node),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<optimistic_spin_node>())).locked as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(optimistic_spin_node),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<optimistic_spin_node>())).cpu as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(optimistic_spin_node),
            "::",
            stringify!(cpu)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct optimistic_spin_queue {
    pub tail: atomic_t,
}
#[test]
fn bindgen_test_layout_optimistic_spin_queue() {
    assert_eq!(
        ::std::mem::size_of::<optimistic_spin_queue>(),
        4usize,
        concat!("Size of: ", stringify!(optimistic_spin_queue))
    );
    assert_eq!(
        ::std::mem::align_of::<optimistic_spin_queue>(),
        4usize,
        concat!("Alignment of ", stringify!(optimistic_spin_queue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<optimistic_spin_queue>())).tail as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(optimistic_spin_queue),
            "::",
            stringify!(tail)
        )
    );
}
extern "C" {
    pub fn osq_lock(lock: *mut optimistic_spin_queue) -> bool_;
}
extern "C" {
    pub fn osq_unlock(lock: *mut optimistic_spin_queue);
}
extern "C" {
    pub static mut debug_locks: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut debug_locks_silent: ::std::os::raw::c_int;
}
extern "C" {
    pub fn debug_locks_off() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mutex {
    pub owner: atomic_long_t,
    pub wait_lock: raw_spinlock_t,
    pub osq: optimistic_spin_queue,
    pub wait_list: list_head,
}
#[test]
fn bindgen_test_layout_mutex() {
    assert_eq!(
        ::std::mem::size_of::<mutex>(),
        32usize,
        concat!("Size of: ", stringify!(mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<mutex>(),
        8usize,
        concat!("Alignment of ", stringify!(mutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mutex>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mutex>())).wait_lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(wait_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mutex>())).osq as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(osq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mutex>())).wait_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mutex),
            "::",
            stringify!(wait_list)
        )
    );
}
extern "C" {
    pub fn __mutex_init(
        lock: *mut mutex,
        name: *const ::std::os::raw::c_char,
        key: *mut lock_class_key,
    );
}
extern "C" {
    #[doc = " mutex_is_locked - is the mutex locked"]
    #[doc = " @lock: the mutex to be queried"]
    #[doc = ""]
    #[doc = " Returns true if the mutex is locked, false if unlocked."]
    pub fn mutex_is_locked(lock: *mut mutex) -> bool_;
}
extern "C" {
    pub fn mutex_lock(lock: *mut mutex);
}
extern "C" {
    pub fn mutex_lock_interruptible(lock: *mut mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mutex_lock_killable(lock: *mut mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mutex_lock_io(lock: *mut mutex);
}
extern "C" {
    pub fn mutex_trylock(lock: *mut mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mutex_unlock(lock: *mut mutex);
}
extern "C" {
    pub fn atomic_dec_and_mutex_lock(cnt: *mut atomic_t, lock: *mut mutex)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seqcount {
    pub sequence: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_seqcount() {
    assert_eq!(
        ::std::mem::size_of::<seqcount>(),
        4usize,
        concat!("Size of: ", stringify!(seqcount))
    );
    assert_eq!(
        ::std::mem::align_of::<seqcount>(),
        4usize,
        concat!("Alignment of ", stringify!(seqcount))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seqcount>())).sequence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seqcount),
            "::",
            stringify!(sequence)
        )
    );
}
pub type seqcount_t = seqcount;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seqcount_raw_spinlock {
    pub seqcount: seqcount_t,
}
#[test]
fn bindgen_test_layout_seqcount_raw_spinlock() {
    assert_eq!(
        ::std::mem::size_of::<seqcount_raw_spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(seqcount_raw_spinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<seqcount_raw_spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(seqcount_raw_spinlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seqcount_raw_spinlock>())).seqcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seqcount_raw_spinlock),
            "::",
            stringify!(seqcount)
        )
    );
}
pub type seqcount_raw_spinlock_t = seqcount_raw_spinlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seqcount_spinlock {
    pub seqcount: seqcount_t,
}
#[test]
fn bindgen_test_layout_seqcount_spinlock() {
    assert_eq!(
        ::std::mem::size_of::<seqcount_spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(seqcount_spinlock))
    );
    assert_eq!(
        ::std::mem::align_of::<seqcount_spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(seqcount_spinlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seqcount_spinlock>())).seqcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seqcount_spinlock),
            "::",
            stringify!(seqcount)
        )
    );
}
pub type seqcount_spinlock_t = seqcount_spinlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seqcount_rwlock {
    pub seqcount: seqcount_t,
}
#[test]
fn bindgen_test_layout_seqcount_rwlock() {
    assert_eq!(
        ::std::mem::size_of::<seqcount_rwlock>(),
        4usize,
        concat!("Size of: ", stringify!(seqcount_rwlock))
    );
    assert_eq!(
        ::std::mem::align_of::<seqcount_rwlock>(),
        4usize,
        concat!("Alignment of ", stringify!(seqcount_rwlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seqcount_rwlock>())).seqcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seqcount_rwlock),
            "::",
            stringify!(seqcount)
        )
    );
}
pub type seqcount_rwlock_t = seqcount_rwlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seqcount_mutex {
    pub seqcount: seqcount_t,
}
#[test]
fn bindgen_test_layout_seqcount_mutex() {
    assert_eq!(
        ::std::mem::size_of::<seqcount_mutex>(),
        4usize,
        concat!("Size of: ", stringify!(seqcount_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<seqcount_mutex>(),
        4usize,
        concat!("Alignment of ", stringify!(seqcount_mutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seqcount_mutex>())).seqcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seqcount_mutex),
            "::",
            stringify!(seqcount)
        )
    );
}
pub type seqcount_mutex_t = seqcount_mutex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seqcount_latch_t {
    pub seqcount: seqcount_t,
}
#[test]
fn bindgen_test_layout_seqcount_latch_t() {
    assert_eq!(
        ::std::mem::size_of::<seqcount_latch_t>(),
        4usize,
        concat!("Size of: ", stringify!(seqcount_latch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<seqcount_latch_t>(),
        4usize,
        concat!("Alignment of ", stringify!(seqcount_latch_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seqcount_latch_t>())).seqcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seqcount_latch_t),
            "::",
            stringify!(seqcount)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seqlock_t {
    pub seqcount: seqcount_spinlock_t,
    pub lock: spinlock_t,
}
#[test]
fn bindgen_test_layout_seqlock_t() {
    assert_eq!(
        ::std::mem::size_of::<seqlock_t>(),
        8usize,
        concat!("Size of: ", stringify!(seqlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<seqlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(seqlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seqlock_t>())).seqcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seqlock_t),
            "::",
            stringify!(seqcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seqlock_t>())).lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(seqlock_t),
            "::",
            stringify!(lock)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref {
    pub __bindgen_anon_1: lockref__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lockref__bindgen_ty_1 {
    pub lock_count: __u64,
    pub __bindgen_anon_1: lockref__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref__bindgen_ty_1__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lockref__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lockref__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lockref__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lockref__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(lockref__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockref__bindgen_ty_1__bindgen_ty_1>())).lock as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockref__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockref__bindgen_ty_1__bindgen_ty_1>())).count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lockref__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(count)
        )
    );
}
#[test]
fn bindgen_test_layout_lockref__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lockref__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(lockref__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lockref__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lockref__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lockref__bindgen_ty_1>())).lock_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lockref__bindgen_ty_1),
            "::",
            stringify!(lock_count)
        )
    );
}
#[test]
fn bindgen_test_layout_lockref() {
    assert_eq!(
        ::std::mem::size_of::<lockref>(),
        8usize,
        concat!("Size of: ", stringify!(lockref))
    );
    assert_eq!(
        ::std::mem::align_of::<lockref>(),
        8usize,
        concat!("Alignment of ", stringify!(lockref))
    );
}
extern "C" {
    pub fn lockref_get(arg1: *mut lockref);
}
extern "C" {
    pub fn lockref_put_return(arg1: *mut lockref) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockref_get_not_zero(arg1: *mut lockref) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockref_put_not_zero(arg1: *mut lockref) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockref_put_or_lock(arg1: *mut lockref) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockref_mark_dead(arg1: *mut lockref);
}
extern "C" {
    pub fn lockref_get_not_dead(arg1: *mut lockref) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn full_name_hash(
        salt: *const ::std::os::raw::c_void,
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hashlen_string(
        salt: *const ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> u64_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qstr {
    pub __bindgen_anon_1: qstr__bindgen_ty_1,
    pub name: *const ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qstr__bindgen_ty_1 {
    pub __bindgen_anon_1: qstr__bindgen_ty_1__bindgen_ty_1,
    pub hash_len: u64_,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qstr__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u32_,
    pub len: u32_,
}
#[test]
fn bindgen_test_layout_qstr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qstr__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(qstr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qstr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(qstr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qstr__bindgen_ty_1__bindgen_ty_1>())).hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qstr__bindgen_ty_1__bindgen_ty_1>())).len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
}
#[test]
fn bindgen_test_layout_qstr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<qstr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(qstr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qstr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(qstr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qstr__bindgen_ty_1>())).hash_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr__bindgen_ty_1),
            "::",
            stringify!(hash_len)
        )
    );
}
#[test]
fn bindgen_test_layout_qstr() {
    assert_eq!(
        ::std::mem::size_of::<qstr>(),
        16usize,
        concat!("Size of: ", stringify!(qstr))
    );
    assert_eq!(
        ::std::mem::align_of::<qstr>(),
        8usize,
        concat!("Alignment of ", stringify!(qstr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qstr>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qstr),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    pub static empty_name: qstr;
}
extern "C" {
    pub static slash_name: qstr;
}
extern "C" {
    pub static dotdot_name: qstr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dentry {
    pub d_flags: ::std::os::raw::c_uint,
    pub d_seq: seqcount_spinlock_t,
    pub d_hash: hlist_bl_node,
    pub d_parent: *mut dentry,
    pub d_name: qstr,
    pub d_inode: *mut inode,
    pub d_iname: [::std::os::raw::c_uchar; 32usize],
    pub d_lockref: lockref,
    pub d_op: *const dentry_operations,
    pub d_sb: *mut super_block,
    pub d_time: ::std::os::raw::c_ulong,
    pub d_fsdata: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: dentry__bindgen_ty_1,
    pub d_child: list_head,
    pub d_subdirs: list_head,
    pub d_u: dentry__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_1 {
    pub d_lru: list_head,
    pub d_wait: *mut wait_queue_head_t,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_dentry__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<dentry__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(dentry__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<dentry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(dentry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry__bindgen_ty_1>())).d_lru as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_1),
            "::",
            stringify!(d_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry__bindgen_ty_1>())).d_wait as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_1),
            "::",
            stringify!(d_wait)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_2 {
    pub d_alias: hlist_node,
    pub d_in_lookup_hash: hlist_bl_node,
    pub d_rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_dentry__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<dentry__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(dentry__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<dentry__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(dentry__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry__bindgen_ty_2>())).d_alias as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_2),
            "::",
            stringify!(d_alias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dentry__bindgen_ty_2>())).d_in_lookup_hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_2),
            "::",
            stringify!(d_in_lookup_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry__bindgen_ty_2>())).d_rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry__bindgen_ty_2),
            "::",
            stringify!(d_rcu)
        )
    );
}
#[test]
fn bindgen_test_layout_dentry() {
    assert_eq!(
        ::std::mem::size_of::<dentry>(),
        192usize,
        concat!("Size of: ", stringify!(dentry))
    );
    assert_eq!(
        ::std::mem::align_of::<dentry>(),
        8usize,
        concat!("Alignment of ", stringify!(dentry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry>())).d_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry>())).d_seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry>())).d_hash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry>())).d_parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry>())).d_name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry>())).d_inode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry>())).d_iname as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_iname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry>())).d_lockref as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_lockref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry>())).d_op as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry>())).d_sb as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry>())).d_time as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry>())).d_fsdata as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_fsdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry>())).d_child as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry>())).d_subdirs as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_subdirs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry>())).d_u as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry),
            "::",
            stringify!(d_u)
        )
    );
}
pub const dentry_d_lock_class_DENTRY_D_LOCK_NORMAL: dentry_d_lock_class = 0;
pub const dentry_d_lock_class_DENTRY_D_LOCK_NESTED: dentry_d_lock_class = 1;
pub type dentry_d_lock_class = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct dentry_operations {
    pub d_revalidate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub d_weak_revalidate: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub d_hash: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const dentry, arg2: *mut qstr) -> ::std::os::raw::c_int,
    >,
    pub d_compare: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const dentry,
            arg2: ::std::os::raw::c_uint,
            arg3: *const ::std::os::raw::c_char,
            arg4: *const qstr,
        ) -> ::std::os::raw::c_int,
    >,
    pub d_delete:
        ::std::option::Option<unsafe extern "C" fn(arg1: *const dentry) -> ::std::os::raw::c_int>,
    pub d_init:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> ::std::os::raw::c_int>,
    pub d_release: ::std::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_prune: ::std::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_iput: ::std::option::Option<unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut inode)>,
    pub d_dname: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub d_automount: ::std::option::Option<unsafe extern "C" fn(arg1: *mut path) -> *mut vfsmount>,
    pub d_manage: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const path, arg2: bool_) -> ::std::os::raw::c_int,
    >,
    pub d_real: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *const inode) -> *mut dentry,
    >,
}
#[test]
fn bindgen_test_layout_dentry_operations() {
    assert_eq!(
        ::std::mem::size_of::<dentry_operations>(),
        128usize,
        concat!("Size of: ", stringify!(dentry_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<dentry_operations>(),
        64usize,
        concat!("Alignment of ", stringify!(dentry_operations))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry_operations>())).d_revalidate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_revalidate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dentry_operations>())).d_weak_revalidate as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_weak_revalidate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry_operations>())).d_hash as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry_operations>())).d_compare as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_compare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry_operations>())).d_delete as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_delete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry_operations>())).d_init as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry_operations>())).d_release as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry_operations>())).d_prune as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_prune)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry_operations>())).d_iput as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_iput)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry_operations>())).d_dname as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_dname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry_operations>())).d_automount as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_automount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry_operations>())).d_manage as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_manage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dentry_operations>())).d_real as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dentry_operations),
            "::",
            stringify!(d_real)
        )
    );
}
extern "C" {
    pub static mut rename_lock: seqlock_t;
}
extern "C" {
    pub fn d_instantiate(arg1: *mut dentry, arg2: *mut inode);
}
extern "C" {
    pub fn d_instantiate_new(arg1: *mut dentry, arg2: *mut inode);
}
extern "C" {
    pub fn d_instantiate_unique(arg1: *mut dentry, arg2: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_instantiate_anon(arg1: *mut dentry, arg2: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn __d_drop(dentry: *mut dentry);
}
extern "C" {
    pub fn d_drop(dentry: *mut dentry);
}
extern "C" {
    pub fn d_delete(arg1: *mut dentry);
}
extern "C" {
    pub fn d_set_d_op(dentry: *mut dentry, op: *const dentry_operations);
}
extern "C" {
    pub fn d_alloc(arg1: *mut dentry, arg2: *const qstr) -> *mut dentry;
}
extern "C" {
    pub fn d_alloc_anon(arg1: *mut super_block) -> *mut dentry;
}
extern "C" {
    pub fn d_alloc_parallel(
        arg1: *mut dentry,
        arg2: *const qstr,
        arg3: *mut wait_queue_head_t,
    ) -> *mut dentry;
}
extern "C" {
    pub fn d_splice_alias(arg1: *mut inode, arg2: *mut dentry) -> *mut dentry;
}
extern "C" {
    pub fn d_add_ci(arg1: *mut dentry, arg2: *mut inode, arg3: *mut qstr) -> *mut dentry;
}
extern "C" {
    pub fn d_same_name(dentry: *const dentry, parent: *const dentry, name: *const qstr) -> bool_;
}
extern "C" {
    pub fn d_exact_alias(arg1: *mut dentry, arg2: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_find_any_alias(inode: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_obtain_alias(arg1: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_obtain_root(arg1: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn shrink_dcache_sb(arg1: *mut super_block);
}
extern "C" {
    pub fn shrink_dcache_parent(arg1: *mut dentry);
}
extern "C" {
    pub fn shrink_dcache_for_umount(arg1: *mut super_block);
}
extern "C" {
    pub fn d_invalidate(arg1: *mut dentry);
}
extern "C" {
    pub fn d_make_root(arg1: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_genocide(arg1: *mut dentry);
}
extern "C" {
    pub fn d_tmpfile(arg1: *mut file, arg2: *mut inode);
}
extern "C" {
    pub fn d_find_alias(arg1: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_prune_aliases(arg1: *mut inode);
}
extern "C" {
    pub fn d_find_alias_rcu(arg1: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn path_has_submounts(arg1: *const path) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d_rehash(arg1: *mut dentry);
}
extern "C" {
    pub fn d_add(arg1: *mut dentry, arg2: *mut inode);
}
extern "C" {
    pub fn d_move(arg1: *mut dentry, arg2: *mut dentry);
}
extern "C" {
    pub fn d_exchange(arg1: *mut dentry, arg2: *mut dentry);
}
extern "C" {
    pub fn d_ancestor(arg1: *mut dentry, arg2: *mut dentry) -> *mut dentry;
}
extern "C" {
    pub fn d_lookup(arg1: *const dentry, arg2: *const qstr) -> *mut dentry;
}
extern "C" {
    pub fn d_hash_and_lookup(arg1: *mut dentry, arg2: *mut qstr) -> *mut dentry;
}
extern "C" {
    pub fn __d_lookup(arg1: *const dentry, arg2: *const qstr) -> *mut dentry;
}
extern "C" {
    pub fn __d_lookup_rcu(
        parent: *const dentry,
        name: *const qstr,
        seq: *mut ::std::os::raw::c_uint,
    ) -> *mut dentry;
}
extern "C" {
    pub fn dynamic_dname(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __d_path(
        arg1: *const path,
        arg2: *const path,
        arg3: *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn d_absolute_path(
        arg1: *const path,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn d_path(
        arg1: *const path,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dentry_path_raw(
        arg1: *const dentry,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dentry_path(
        arg1: *const dentry,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dget_parent(dentry: *mut dentry) -> *mut dentry;
}
extern "C" {
    pub fn __d_lookup_unhash_wake(dentry: *mut dentry);
}
extern "C" {
    pub fn dput(arg1: *mut dentry);
}
extern "C" {
    pub fn d_set_fallthru(dentry: *mut dentry);
}
extern "C" {
    pub static mut sysctl_vfs_cache_pressure: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct name_snapshot {
    pub name: qstr,
    pub inline_name: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_name_snapshot() {
    assert_eq!(
        ::std::mem::size_of::<name_snapshot>(),
        48usize,
        concat!("Size of: ", stringify!(name_snapshot))
    );
    assert_eq!(
        ::std::mem::align_of::<name_snapshot>(),
        8usize,
        concat!("Alignment of ", stringify!(name_snapshot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<name_snapshot>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(name_snapshot),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<name_snapshot>())).inline_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(name_snapshot),
            "::",
            stringify!(inline_name)
        )
    );
}
extern "C" {
    pub fn take_dentry_name_snapshot(arg1: *mut name_snapshot, arg2: *mut dentry);
}
extern "C" {
    pub fn release_dentry_name_snapshot(arg1: *mut name_snapshot);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct path {
    pub mnt: *mut vfsmount,
    pub dentry: *mut dentry,
}
#[test]
fn bindgen_test_layout_path() {
    assert_eq!(
        ::std::mem::size_of::<path>(),
        16usize,
        concat!("Size of: ", stringify!(path))
    );
    assert_eq!(
        ::std::mem::align_of::<path>(),
        8usize,
        concat!("Alignment of ", stringify!(path))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<path>())).mnt as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(path), "::", stringify!(mnt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<path>())).dentry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(path),
            "::",
            stringify!(dentry)
        )
    );
}
extern "C" {
    pub fn path_get(arg1: *const path);
}
extern "C" {
    pub fn path_put(arg1: *const path);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __kernel_ulong_t,
    pub st_ino: __kernel_ulong_t,
    pub st_nlink: __kernel_ulong_t,
    pub st_mode: ::std::os::raw::c_uint,
    pub st_uid: ::std::os::raw::c_uint,
    pub st_gid: ::std::os::raw::c_uint,
    pub __pad0: ::std::os::raw::c_uint,
    pub st_rdev: __kernel_ulong_t,
    pub st_size: __kernel_long_t,
    pub st_blksize: __kernel_long_t,
    pub st_blocks: __kernel_long_t,
    pub st_atime: __kernel_ulong_t,
    pub st_atime_nsec: __kernel_ulong_t,
    pub st_mtime: __kernel_ulong_t,
    pub st_mtime_nsec: __kernel_ulong_t,
    pub st_ctime: __kernel_ulong_t,
    pub st_ctime_nsec: __kernel_ulong_t,
    pub __unused: [__kernel_long_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_uid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__pad0 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_rdev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blksize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blocks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_atime as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_atime_nsec as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atime_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mtime as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mtime_nsec as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtime_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ctime as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ctime_nsec as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctime_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__unused as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__unused)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __old_kernel_stat {
    pub st_dev: ::std::os::raw::c_ushort,
    pub st_ino: ::std::os::raw::c_ushort,
    pub st_mode: ::std::os::raw::c_ushort,
    pub st_nlink: ::std::os::raw::c_ushort,
    pub st_uid: ::std::os::raw::c_ushort,
    pub st_gid: ::std::os::raw::c_ushort,
    pub st_rdev: ::std::os::raw::c_ushort,
    pub st_size: ::std::os::raw::c_uint,
    pub st_atime: ::std::os::raw::c_uint,
    pub st_mtime: ::std::os::raw::c_uint,
    pub st_ctime: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___old_kernel_stat() {
    assert_eq!(
        ::std::mem::size_of::<__old_kernel_stat>(),
        32usize,
        concat!("Size of: ", stringify!(__old_kernel_stat))
    );
    assert_eq!(
        ::std::mem::align_of::<__old_kernel_stat>(),
        4usize,
        concat!("Alignment of ", stringify!(__old_kernel_stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__old_kernel_stat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__old_kernel_stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__old_kernel_stat>())).st_ino as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__old_kernel_stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__old_kernel_stat>())).st_mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__old_kernel_stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__old_kernel_stat>())).st_nlink as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(__old_kernel_stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__old_kernel_stat>())).st_uid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__old_kernel_stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__old_kernel_stat>())).st_gid as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__old_kernel_stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__old_kernel_stat>())).st_rdev as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__old_kernel_stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__old_kernel_stat>())).st_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__old_kernel_stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__old_kernel_stat>())).st_atime as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__old_kernel_stat),
            "::",
            stringify!(st_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__old_kernel_stat>())).st_mtime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__old_kernel_stat),
            "::",
            stringify!(st_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__old_kernel_stat>())).st_ctime as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__old_kernel_stat),
            "::",
            stringify!(st_ctime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statx_timestamp {
    pub tv_sec: __s64,
    pub tv_nsec: __u32,
    pub __reserved: __s32,
}
#[test]
fn bindgen_test_layout_statx_timestamp() {
    assert_eq!(
        ::std::mem::size_of::<statx_timestamp>(),
        16usize,
        concat!("Size of: ", stringify!(statx_timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<statx_timestamp>(),
        8usize,
        concat!("Alignment of ", stringify!(statx_timestamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx_timestamp>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(statx_timestamp),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx_timestamp>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(statx_timestamp),
            "::",
            stringify!(tv_nsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx_timestamp>())).__reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(statx_timestamp),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct statx {
    pub stx_mask: __u32,
    pub stx_blksize: __u32,
    pub stx_attributes: __u64,
    pub stx_nlink: __u32,
    pub stx_uid: __u32,
    pub stx_gid: __u32,
    pub stx_mode: __u16,
    pub __spare0: [__u16; 1usize],
    pub stx_ino: __u64,
    pub stx_size: __u64,
    pub stx_blocks: __u64,
    pub stx_attributes_mask: __u64,
    pub stx_atime: statx_timestamp,
    pub stx_btime: statx_timestamp,
    pub stx_ctime: statx_timestamp,
    pub stx_mtime: statx_timestamp,
    pub stx_rdev_major: __u32,
    pub stx_rdev_minor: __u32,
    pub stx_dev_major: __u32,
    pub stx_dev_minor: __u32,
    pub stx_mnt_id: __u64,
    pub stx_dio_mem_align: __u32,
    pub stx_dio_offset_align: __u32,
    pub __spare3: [__u64; 12usize],
}
#[test]
fn bindgen_test_layout_statx() {
    assert_eq!(
        ::std::mem::size_of::<statx>(),
        256usize,
        concat!("Size of: ", stringify!(statx))
    );
    assert_eq!(
        ::std::mem::align_of::<statx>(),
        8usize,
        concat!("Alignment of ", stringify!(statx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_blksize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_attributes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_uid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_gid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_mode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).__spare0 as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(__spare0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_ino as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_blocks as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_attributes_mask as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_attributes_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_atime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_btime as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_btime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_ctime as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_mtime as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_rdev_major as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_rdev_major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_rdev_minor as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_rdev_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_dev_major as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_dev_major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_dev_minor as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_dev_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_mnt_id as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_mnt_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_dio_mem_align as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_dio_mem_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).stx_dio_offset_align as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_dio_offset_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<statx>())).__spare3 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(__spare3)
        )
    );
}
extern "C" {
    pub static mut sys_tz: timezone;
}
extern "C" {
    pub fn get_timespec64(
        ts: *mut timespec64,
        uts: *const __kernel_timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn put_timespec64(
        ts: *const timespec64,
        uts: *mut __kernel_timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_itimerspec64(
        it: *mut itimerspec64,
        uit: *const __kernel_itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn put_itimerspec64(
        it: *const itimerspec64,
        uit: *mut __kernel_itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktime64(
        year: ::std::os::raw::c_uint,
        mon: ::std::os::raw::c_uint,
        day: ::std::os::raw::c_uint,
        hour: ::std::os::raw::c_uint,
        min: ::std::os::raw::c_uint,
        sec: ::std::os::raw::c_uint,
    ) -> time64_t;
}
extern "C" {
    pub fn clear_itimer();
}
extern "C" {
    pub fn do_utimes(
        dfd: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        times: *mut timespec64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_long,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        40usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
}
extern "C" {
    pub fn time64_to_tm(totalsecs: time64_t, offset: ::std::os::raw::c_int, result: *mut tm);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_timex_timeval {
    pub tv_sec: __kernel_time64_t,
    pub tv_usec: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___kernel_timex_timeval() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_timex_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(__kernel_timex_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_timex_timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_timex_timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex_timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex_timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_timex {
    pub modes: ::std::os::raw::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub offset: ::std::os::raw::c_longlong,
    pub freq: ::std::os::raw::c_longlong,
    pub maxerror: ::std::os::raw::c_longlong,
    pub esterror: ::std::os::raw::c_longlong,
    pub status: ::std::os::raw::c_int,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub constant: ::std::os::raw::c_longlong,
    pub precision: ::std::os::raw::c_longlong,
    pub tolerance: ::std::os::raw::c_longlong,
    pub time: __kernel_timex_timeval,
    pub tick: ::std::os::raw::c_longlong,
    pub ppsfreq: ::std::os::raw::c_longlong,
    pub jitter: ::std::os::raw::c_longlong,
    pub shift: ::std::os::raw::c_int,
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub stabil: ::std::os::raw::c_longlong,
    pub jitcnt: ::std::os::raw::c_longlong,
    pub calcnt: ::std::os::raw::c_longlong,
    pub errcnt: ::std::os::raw::c_longlong,
    pub stbcnt: ::std::os::raw::c_longlong,
    pub tai: ::std::os::raw::c_int,
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 44usize], u8>,
}
#[test]
fn bindgen_test_layout___kernel_timex() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_timex>(),
        208usize,
        concat!("Size of: ", stringify!(__kernel_timex))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_timex>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_timex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).modes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(modes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).freq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).maxerror as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(maxerror)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).esterror as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(esterror)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).status as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).constant as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(constant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).precision as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(precision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).tolerance as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(tolerance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).time as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).tick as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).ppsfreq as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(ppsfreq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).jitter as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(jitter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).shift as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).stabil as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(stabil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).jitcnt as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(jitcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).calcnt as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(calcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).errcnt as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(errcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).stbcnt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(stbcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_timex>())).tai as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_timex),
            "::",
            stringify!(tai)
        )
    );
}
impl __kernel_timex {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_3() -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn random_get_entropy_fallback() -> ::std::os::raw::c_ulong;
}
pub type cycles_t = ::std::os::raw::c_ulonglong;
extern "C" {
    pub static mut cpu_khz: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut tsc_khz: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn disable_TSC();
}
extern "C" {
    pub fn convert_art_to_tsc(art: u64_) -> system_counterval_t;
}
extern "C" {
    pub fn convert_art_ns_to_tsc(art_ns: u64_) -> system_counterval_t;
}
extern "C" {
    pub fn tsc_early_init();
}
extern "C" {
    pub fn tsc_init();
}
extern "C" {
    pub fn calibrate_delay_is_known() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mark_tsc_unstable(reason: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn unsynchronized_tsc() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn check_tsc_unstable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mark_tsc_async_resets(reason: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn native_calibrate_cpu_early() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn native_calibrate_tsc() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn native_sched_clock_from_tsc(tsc: u64_) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut tsc_clocksource_reliable: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut tsc_async_resets: bool_;
}
extern "C" {
    pub fn tsc_store_and_check_tsc_adjust(bootcpu: bool_) -> bool_;
}
extern "C" {
    pub fn tsc_verify_tsc_adjust(resume: bool_);
}
extern "C" {
    pub fn check_tsc_sync_source(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn check_tsc_sync_target();
}
extern "C" {
    pub fn notsc_setup(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tsc_save_sched_clock_state();
}
extern "C" {
    pub fn tsc_restore_sched_clock_state();
}
extern "C" {
    pub fn cpu_khz_from_msr() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut tick_usec: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut tick_nsec: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn do_adjtimex(arg1: *mut __kernel_timex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_clock_adjtime(
        which_clock: clockid_t,
        ktx: *mut __kernel_timex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hardpps(arg1: *const timespec64, arg2: *const timespec64);
}
extern "C" {
    pub fn read_current_timer(timer_val: *mut ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
pub type old_time32_t = s32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct old_timespec32 {
    pub tv_sec: old_time32_t,
    pub tv_nsec: s32,
}
#[test]
fn bindgen_test_layout_old_timespec32() {
    assert_eq!(
        ::std::mem::size_of::<old_timespec32>(),
        8usize,
        concat!("Size of: ", stringify!(old_timespec32))
    );
    assert_eq!(
        ::std::mem::align_of::<old_timespec32>(),
        4usize,
        concat!("Alignment of ", stringify!(old_timespec32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timespec32>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timespec32),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timespec32>())).tv_nsec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timespec32),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct old_timeval32 {
    pub tv_sec: old_time32_t,
    pub tv_usec: s32,
}
#[test]
fn bindgen_test_layout_old_timeval32() {
    assert_eq!(
        ::std::mem::size_of::<old_timeval32>(),
        8usize,
        concat!("Size of: ", stringify!(old_timeval32))
    );
    assert_eq!(
        ::std::mem::align_of::<old_timeval32>(),
        4usize,
        concat!("Alignment of ", stringify!(old_timeval32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timeval32>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timeval32),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timeval32>())).tv_usec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timeval32),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct old_itimerspec32 {
    pub it_interval: old_timespec32,
    pub it_value: old_timespec32,
}
#[test]
fn bindgen_test_layout_old_itimerspec32() {
    assert_eq!(
        ::std::mem::size_of::<old_itimerspec32>(),
        16usize,
        concat!("Size of: ", stringify!(old_itimerspec32))
    );
    assert_eq!(
        ::std::mem::align_of::<old_itimerspec32>(),
        4usize,
        concat!("Alignment of ", stringify!(old_itimerspec32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_itimerspec32>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(old_itimerspec32),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_itimerspec32>())).it_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(old_itimerspec32),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct old_utimbuf32 {
    pub actime: old_time32_t,
    pub modtime: old_time32_t,
}
#[test]
fn bindgen_test_layout_old_utimbuf32() {
    assert_eq!(
        ::std::mem::size_of::<old_utimbuf32>(),
        8usize,
        concat!("Size of: ", stringify!(old_utimbuf32))
    );
    assert_eq!(
        ::std::mem::align_of::<old_utimbuf32>(),
        4usize,
        concat!("Alignment of ", stringify!(old_utimbuf32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_utimbuf32>())).actime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(old_utimbuf32),
            "::",
            stringify!(actime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_utimbuf32>())).modtime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(old_utimbuf32),
            "::",
            stringify!(modtime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct old_timex32 {
    pub modes: u32_,
    pub offset: s32,
    pub freq: s32,
    pub maxerror: s32,
    pub esterror: s32,
    pub status: s32,
    pub constant: s32,
    pub precision: s32,
    pub tolerance: s32,
    pub time: old_timeval32,
    pub tick: s32,
    pub ppsfreq: s32,
    pub jitter: s32,
    pub shift: s32,
    pub stabil: s32,
    pub jitcnt: s32,
    pub calcnt: s32,
    pub errcnt: s32,
    pub stbcnt: s32,
    pub tai: s32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 44usize], u8>,
}
#[test]
fn bindgen_test_layout_old_timex32() {
    assert_eq!(
        ::std::mem::size_of::<old_timex32>(),
        128usize,
        concat!("Size of: ", stringify!(old_timex32))
    );
    assert_eq!(
        ::std::mem::align_of::<old_timex32>(),
        4usize,
        concat!("Alignment of ", stringify!(old_timex32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).modes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(modes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).freq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).maxerror as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(maxerror)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).esterror as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(esterror)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).constant as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(constant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).precision as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(precision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).tolerance as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(tolerance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).time as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).tick as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).ppsfreq as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(ppsfreq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).jitter as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(jitter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).shift as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).stabil as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(stabil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).jitcnt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(jitcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).calcnt as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(calcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).errcnt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(errcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).stbcnt as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(stbcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<old_timex32>())).tai as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(old_timex32),
            "::",
            stringify!(tai)
        )
    );
}
extern "C" {
    pub fn get_old_timespec32(
        arg1: *mut timespec64,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn put_old_timespec32(
        arg1: *const timespec64,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_old_itimerspec32(
        its: *mut itimerspec64,
        uits: *const old_itimerspec32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn put_old_itimerspec32(
        its: *const itimerspec64,
        uits: *mut old_itimerspec32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_old_timex32(
        arg1: *mut __kernel_timex,
        arg2: *const old_timex32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn put_old_timex32(
        arg1: *mut old_timex32,
        arg2: *const __kernel_timex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ns_to_kernel_old_timeval - Convert nanoseconds to timeval"]
    #[doc = " @nsec:\tthe nanoseconds value to be converted"]
    #[doc = ""]
    #[doc = " Returns the timeval representation of the nsec parameter."]
    pub fn ns_to_kernel_old_timeval(nsec: s64) -> __kernel_old_timeval;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timens_offset {
    pub sec: s64,
    pub nsec: u64_,
}
#[test]
fn bindgen_test_layout_timens_offset() {
    assert_eq!(
        ::std::mem::size_of::<timens_offset>(),
        16usize,
        concat!("Size of: ", stringify!(timens_offset))
    );
    assert_eq!(
        ::std::mem::align_of::<timens_offset>(),
        8usize,
        concat!("Alignment of ", stringify!(timens_offset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timens_offset>())).sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timens_offset),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timens_offset>())).nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timens_offset),
            "::",
            stringify!(nsec)
        )
    );
}
extern "C" {
    pub static mut overflowuid: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut overflowgid: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __bad_uid();
}
extern "C" {
    pub fn __bad_gid();
}
extern "C" {
    pub static mut fs_overflowuid: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut fs_overflowgid: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user_namespace {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut init_user_ns: user_namespace;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kuid_t {
    pub val: uid_t,
}
#[test]
fn bindgen_test_layout_kuid_t() {
    assert_eq!(
        ::std::mem::size_of::<kuid_t>(),
        4usize,
        concat!("Size of: ", stringify!(kuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<kuid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(kuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kuid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kuid_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kgid_t {
    pub val: gid_t,
}
#[test]
fn bindgen_test_layout_kgid_t() {
    assert_eq!(
        ::std::mem::size_of::<kgid_t>(),
        4usize,
        concat!("Size of: ", stringify!(kgid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<kgid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(kgid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kgid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kgid_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kstat {
    pub result_mask: u32_,
    pub mode: umode_t,
    pub nlink: ::std::os::raw::c_uint,
    pub blksize: u32,
    pub attributes: u64_,
    pub attributes_mask: u64_,
    pub ino: u64_,
    pub dev: dev_t,
    pub rdev: dev_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub size: loff_t,
    pub atime: timespec64,
    pub mtime: timespec64,
    pub ctime: timespec64,
    pub btime: timespec64,
    pub blocks: u64_,
    pub mnt_id: u64_,
    pub dio_mem_align: u32_,
    pub dio_offset_align: u32_,
}
#[test]
fn bindgen_test_layout_kstat() {
    assert_eq!(
        ::std::mem::size_of::<kstat>(),
        152usize,
        concat!("Size of: ", stringify!(kstat))
    );
    assert_eq!(
        ::std::mem::align_of::<kstat>(),
        8usize,
        concat!("Alignment of ", stringify!(kstat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).result_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(result_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).nlink as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).blksize as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).attributes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).attributes_mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(attributes_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).ino as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).dev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).rdev as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).uid as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).gid as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).atime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).mtime as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).ctime as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).btime as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(btime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).blocks as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).mnt_id as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(mnt_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).dio_mem_align as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(dio_mem_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kstat>())).dio_offset_align as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(kstat),
            "::",
            stringify!(dio_offset_align)
        )
    );
}
extern "C" {
    pub fn __do_once_start(done: *mut bool_, flags: *mut ::std::os::raw::c_ulong) -> bool_;
}
extern "C" {
    pub fn __do_once_done(
        done: *mut bool_,
        once_key: *mut static_key_true,
        flags: *mut ::std::os::raw::c_ulong,
        mod_: *mut module,
    );
}
extern "C" {
    pub fn __do_once_sleepable_start(done: *mut bool_) -> bool_;
}
extern "C" {
    pub fn __do_once_sleepable_done(
        done: *mut bool_,
        once_key: *mut static_key_true,
        mod_: *mut module,
    );
}
extern "C" {
    pub static mut nr_irqs: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_desc {
    _unused: [u8; 0],
}
extern "C" {
    pub fn irq_to_desc(irq: ::std::os::raw::c_uint) -> *mut irq_desc;
}
extern "C" {
    pub fn irq_get_next_irq(offset: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug)]
pub struct rand_pool_info {
    pub entropy_count: ::std::os::raw::c_int,
    pub buf_size: ::std::os::raw::c_int,
    pub buf: __IncompleteArrayField<__u32>,
}
#[test]
fn bindgen_test_layout_rand_pool_info() {
    assert_eq!(
        ::std::mem::size_of::<rand_pool_info>(),
        8usize,
        concat!("Size of: ", stringify!(rand_pool_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rand_pool_info>(),
        4usize,
        concat!("Alignment of ", stringify!(rand_pool_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rand_pool_info>())).entropy_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rand_pool_info),
            "::",
            stringify!(entropy_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rand_pool_info>())).buf_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rand_pool_info),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rand_pool_info>())).buf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rand_pool_info),
            "::",
            stringify!(buf)
        )
    );
}
extern "C" {
    pub fn add_device_randomness(buf: *const ::std::os::raw::c_void, len: size_t);
}
extern "C" {
    pub fn add_bootloader_randomness(buf: *const ::std::os::raw::c_void, len: size_t);
}
extern "C" {
    pub fn add_input_randomness(
        type_: ::std::os::raw::c_uint,
        code: ::std::os::raw::c_uint,
        value: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn add_interrupt_randomness(irq: ::std::os::raw::c_int);
}
extern "C" {
    pub fn add_hwgenerator_randomness(
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        entropy: size_t,
    );
}
extern "C" {
    pub fn get_random_bytes(buf: *mut ::std::os::raw::c_void, len: size_t);
}
extern "C" {
    pub fn get_random_u8() -> u8_;
}
extern "C" {
    pub fn get_random_u16() -> u16_;
}
extern "C" {
    pub fn get_random_u32() -> u32_;
}
extern "C" {
    pub fn get_random_u64() -> u64_;
}
extern "C" {
    pub fn random_init_early(command_line: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn random_init();
}
extern "C" {
    pub fn rng_is_initialized() -> bool_;
}
extern "C" {
    pub fn wait_for_random_bytes() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dump_page(page: *mut page, reason: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn dump_vma(vma: *const vm_area_struct);
}
extern "C" {
    pub fn dump_mm(mm: *const mm_struct);
}
extern "C" {
    pub static mut pcpu_base_addr: *mut ::std::os::raw::c_void;
}
extern "C" {
    pub static mut pcpu_unit_offsets: *const ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcpu_group_info {
    pub nr_units: ::std::os::raw::c_int,
    pub base_offset: ::std::os::raw::c_ulong,
    pub cpu_map: *mut ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pcpu_group_info() {
    assert_eq!(
        ::std::mem::size_of::<pcpu_group_info>(),
        24usize,
        concat!("Size of: ", stringify!(pcpu_group_info))
    );
    assert_eq!(
        ::std::mem::align_of::<pcpu_group_info>(),
        8usize,
        concat!("Alignment of ", stringify!(pcpu_group_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu_group_info>())).nr_units as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_group_info),
            "::",
            stringify!(nr_units)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu_group_info>())).base_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_group_info),
            "::",
            stringify!(base_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu_group_info>())).cpu_map as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_group_info),
            "::",
            stringify!(cpu_map)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct pcpu_alloc_info {
    pub static_size: size_t,
    pub reserved_size: size_t,
    pub dyn_size: size_t,
    pub unit_size: size_t,
    pub atom_size: size_t,
    pub alloc_size: size_t,
    pub __ai_size: size_t,
    pub nr_groups: ::std::os::raw::c_int,
    pub groups: __IncompleteArrayField<pcpu_group_info>,
}
#[test]
fn bindgen_test_layout_pcpu_alloc_info() {
    assert_eq!(
        ::std::mem::size_of::<pcpu_alloc_info>(),
        64usize,
        concat!("Size of: ", stringify!(pcpu_alloc_info))
    );
    assert_eq!(
        ::std::mem::align_of::<pcpu_alloc_info>(),
        8usize,
        concat!("Alignment of ", stringify!(pcpu_alloc_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu_alloc_info>())).static_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_alloc_info),
            "::",
            stringify!(static_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu_alloc_info>())).reserved_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_alloc_info),
            "::",
            stringify!(reserved_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu_alloc_info>())).dyn_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_alloc_info),
            "::",
            stringify!(dyn_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu_alloc_info>())).unit_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_alloc_info),
            "::",
            stringify!(unit_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu_alloc_info>())).atom_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_alloc_info),
            "::",
            stringify!(atom_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu_alloc_info>())).alloc_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_alloc_info),
            "::",
            stringify!(alloc_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu_alloc_info>())).__ai_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_alloc_info),
            "::",
            stringify!(__ai_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu_alloc_info>())).nr_groups as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_alloc_info),
            "::",
            stringify!(nr_groups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pcpu_alloc_info>())).groups as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu_alloc_info),
            "::",
            stringify!(groups)
        )
    );
}
pub const pcpu_fc_PCPU_FC_AUTO: pcpu_fc = 0;
pub const pcpu_fc_PCPU_FC_EMBED: pcpu_fc = 1;
pub const pcpu_fc_PCPU_FC_PAGE: pcpu_fc = 2;
pub const pcpu_fc_PCPU_FC_NR: pcpu_fc = 3;
pub type pcpu_fc = ::std::os::raw::c_uint;
extern "C" {
    pub static pcpu_fc_names: [*const ::std::os::raw::c_char; 3usize];
}
extern "C" {
    pub static mut pcpu_chosen_fc: pcpu_fc;
}
pub type pcpu_fc_cpu_to_node_fn_t = ::std::option::Option<
    unsafe extern "C" fn(cpu: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
>;
pub type pcpu_fc_cpu_distance_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        from: ::std::os::raw::c_uint,
        to: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn pcpu_alloc_alloc_info(
        nr_groups: ::std::os::raw::c_int,
        nr_units: ::std::os::raw::c_int,
    ) -> *mut pcpu_alloc_info;
}
extern "C" {
    pub fn pcpu_free_alloc_info(ai: *mut pcpu_alloc_info);
}
extern "C" {
    pub fn pcpu_setup_first_chunk(
        ai: *const pcpu_alloc_info,
        base_addr: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn pcpu_embed_first_chunk(
        reserved_size: size_t,
        dyn_size: size_t,
        atom_size: size_t,
        cpu_distance_fn: pcpu_fc_cpu_distance_fn_t,
        cpu_to_nd_fn: pcpu_fc_cpu_to_node_fn_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pcpu_populate_pte(addr: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn pcpu_page_first_chunk(
        reserved_size: size_t,
        cpu_to_nd_fn: pcpu_fc_cpu_to_node_fn_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __alloc_reserved_percpu(size: size_t, align: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __is_kernel_percpu_address(
        addr: ::std::os::raw::c_ulong,
        can_addr: *mut ::std::os::raw::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn is_kernel_percpu_address(addr: ::std::os::raw::c_ulong) -> bool_;
}
extern "C" {
    pub fn __alloc_percpu_gfp(
        size: size_t,
        align: size_t,
        gfp: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __alloc_percpu(size: size_t, align: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free_percpu(__pdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn per_cpu_ptr_to_phys(addr: *mut ::std::os::raw::c_void) -> phys_addr_t;
}
extern "C" {
    pub fn pcpu_nr_pages() -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rnd_state {
    pub s1: __u32,
    pub s2: __u32,
    pub s3: __u32,
    pub s4: __u32,
}
#[test]
fn bindgen_test_layout_rnd_state() {
    assert_eq!(
        ::std::mem::size_of::<rnd_state>(),
        16usize,
        concat!("Size of: ", stringify!(rnd_state))
    );
    assert_eq!(
        ::std::mem::align_of::<rnd_state>(),
        4usize,
        concat!("Alignment of ", stringify!(rnd_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rnd_state>())).s1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rnd_state),
            "::",
            stringify!(s1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rnd_state>())).s2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rnd_state),
            "::",
            stringify!(s2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rnd_state>())).s3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rnd_state),
            "::",
            stringify!(s3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rnd_state>())).s4 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rnd_state),
            "::",
            stringify!(s4)
        )
    );
}
extern "C" {
    pub fn prandom_u32_state(state: *mut rnd_state) -> u32_;
}
extern "C" {
    pub fn prandom_bytes_state(
        state: *mut rnd_state,
        buf: *mut ::std::os::raw::c_void,
        nbytes: size_t,
    );
}
extern "C" {
    pub fn prandom_seed_full_state(pcpu_state: *mut rnd_state);
}
extern "C" {
    pub fn x86_init_rdrand(c: *mut cpuinfo_x86);
}
extern "C" {
    pub fn random_prepare_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random_online_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static random_fops: file_operations;
}
extern "C" {
    pub static urandom_fops: file_operations;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nodemask_t {
    pub bits: [::std::os::raw::c_ulong; 1usize],
}
#[test]
fn bindgen_test_layout_nodemask_t() {
    assert_eq!(
        ::std::mem::size_of::<nodemask_t>(),
        8usize,
        concat!("Size of: ", stringify!(nodemask_t))
    );
    assert_eq!(
        ::std::mem::align_of::<nodemask_t>(),
        8usize,
        concat!("Alignment of ", stringify!(nodemask_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nodemask_t>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nodemask_t),
            "::",
            stringify!(bits)
        )
    );
}
extern "C" {
    pub static mut _unused_nodemask_arg_: nodemask_t;
}
pub const node_states_N_POSSIBLE: node_states = 0;
pub const node_states_N_ONLINE: node_states = 1;
pub const node_states_N_NORMAL_MEMORY: node_states = 2;
pub const node_states_N_HIGH_MEMORY: node_states = 2;
pub const node_states_N_MEMORY: node_states = 3;
pub const node_states_N_CPU: node_states = 4;
pub const node_states_N_GENERIC_INITIATOR: node_states = 5;
pub const node_states_NR_NODE_STATES: node_states = 6;
pub type node_states = ::std::os::raw::c_uint;
extern "C" {
    pub static mut node_states: [nodemask_t; 6usize];
}
extern "C" {
    pub static mut nr_node_ids: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut nr_online_nodes: ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nodemask_scratch {
    pub mask1: nodemask_t,
    pub mask2: nodemask_t,
}
#[test]
fn bindgen_test_layout_nodemask_scratch() {
    assert_eq!(
        ::std::mem::size_of::<nodemask_scratch>(),
        16usize,
        concat!("Size of: ", stringify!(nodemask_scratch))
    );
    assert_eq!(
        ::std::mem::align_of::<nodemask_scratch>(),
        8usize,
        concat!("Alignment of ", stringify!(nodemask_scratch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nodemask_scratch>())).mask1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nodemask_scratch),
            "::",
            stringify!(mask1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nodemask_scratch>())).mask2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nodemask_scratch),
            "::",
            stringify!(mask2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrink_control {
    pub gfp_mask: gfp_t,
    pub nid: ::std::os::raw::c_int,
    pub nr_to_scan: ::std::os::raw::c_ulong,
    pub nr_scanned: ::std::os::raw::c_ulong,
    pub memcg: *mut mem_cgroup,
}
#[test]
fn bindgen_test_layout_shrink_control() {
    assert_eq!(
        ::std::mem::size_of::<shrink_control>(),
        32usize,
        concat!("Size of: ", stringify!(shrink_control))
    );
    assert_eq!(
        ::std::mem::align_of::<shrink_control>(),
        8usize,
        concat!("Alignment of ", stringify!(shrink_control))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shrink_control>())).gfp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(gfp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shrink_control>())).nid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(nid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shrink_control>())).nr_to_scan as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(nr_to_scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shrink_control>())).nr_scanned as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(nr_scanned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shrink_control>())).memcg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(shrink_control),
            "::",
            stringify!(memcg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shrinker {
    pub count_objects: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut shrinker,
            sc: *mut shrink_control,
        ) -> ::std::os::raw::c_ulong,
    >,
    pub scan_objects: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut shrinker,
            sc: *mut shrink_control,
        ) -> ::std::os::raw::c_ulong,
    >,
    pub batch: ::std::os::raw::c_long,
    pub seeks: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_uint,
    pub list: list_head,
    pub nr_deferred: *mut atomic_long_t,
}
#[test]
fn bindgen_test_layout_shrinker() {
    assert_eq!(
        ::std::mem::size_of::<shrinker>(),
        56usize,
        concat!("Size of: ", stringify!(shrinker))
    );
    assert_eq!(
        ::std::mem::align_of::<shrinker>(),
        8usize,
        concat!("Alignment of ", stringify!(shrinker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shrinker>())).count_objects as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(count_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shrinker>())).scan_objects as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(scan_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shrinker>())).batch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(batch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shrinker>())).seeks as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(seeks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shrinker>())).flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shrinker>())).list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shrinker>())).nr_deferred as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(shrinker),
            "::",
            stringify!(nr_deferred)
        )
    );
}
extern "C" {
    pub fn prealloc_shrinker(
        shrinker: *mut shrinker,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn register_shrinker_prepared(shrinker: *mut shrinker);
}
extern "C" {
    pub fn register_shrinker(
        shrinker: *mut shrinker,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unregister_shrinker(shrinker: *mut shrinker);
}
extern "C" {
    pub fn free_prealloced_shrinker(shrinker: *mut shrinker);
}
extern "C" {
    pub fn synchronize_shrinkers();
}
pub const pageblock_bits_PB_migrate: pageblock_bits = 0;
pub const pageblock_bits_PB_migrate_end: pageblock_bits = 2;
pub const pageblock_bits_PB_migrate_skip: pageblock_bits = 3;
pub const pageblock_bits_NR_PAGEBLOCK_BITS: pageblock_bits = 4;
pub type pageblock_bits = ::std::os::raw::c_uint;
extern "C" {
    pub fn get_pfnblock_flags_mask(
        page: *const page,
        pfn: ::std::os::raw::c_ulong,
        mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn set_pfnblock_flags_mask(
        page: *mut page,
        flags: ::std::os::raw::c_ulong,
        pfn: ::std::os::raw::c_ulong,
        mask: ::std::os::raw::c_ulong,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_tlbflush_unmap_batch {
    pub cpumask: cpumask,
}
#[test]
fn bindgen_test_layout_arch_tlbflush_unmap_batch() {
    assert_eq!(
        ::std::mem::size_of::<arch_tlbflush_unmap_batch>(),
        8usize,
        concat!("Size of: ", stringify!(arch_tlbflush_unmap_batch))
    );
    assert_eq!(
        ::std::mem::align_of::<arch_tlbflush_unmap_batch>(),
        8usize,
        concat!("Alignment of ", stringify!(arch_tlbflush_unmap_batch))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<arch_tlbflush_unmap_batch>())).cpumask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_tlbflush_unmap_batch),
            "::",
            stringify!(cpumask)
        )
    );
}
pub const MM_FILEPAGES: ::std::os::raw::c_uint = 0;
pub const MM_ANONPAGES: ::std::os::raw::c_uint = 1;
pub const MM_SWAPENTS: ::std::os::raw::c_uint = 2;
pub const MM_SHMEMPAGES: ::std::os::raw::c_uint = 3;
pub const NR_MM_COUNTERS: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_rss_stat {
    pub events: ::std::os::raw::c_int,
    pub count: [::std::os::raw::c_int; 4usize],
}
#[test]
fn bindgen_test_layout_task_rss_stat() {
    assert_eq!(
        ::std::mem::size_of::<task_rss_stat>(),
        20usize,
        concat!("Size of: ", stringify!(task_rss_stat))
    );
    assert_eq!(
        ::std::mem::align_of::<task_rss_stat>(),
        4usize,
        concat!("Alignment of ", stringify!(task_rss_stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_rss_stat>())).events as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_rss_stat),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_rss_stat>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(task_rss_stat),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mm_rss_stat {
    pub count: [atomic_long_t; 4usize],
}
#[test]
fn bindgen_test_layout_mm_rss_stat() {
    assert_eq!(
        ::std::mem::size_of::<mm_rss_stat>(),
        32usize,
        concat!("Size of: ", stringify!(mm_rss_stat))
    );
    assert_eq!(
        ::std::mem::align_of::<mm_rss_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_rss_stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_rss_stat>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_rss_stat),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_frag {
    pub page: *mut page,
    pub offset: __u32,
    pub size: __u32,
}
#[test]
fn bindgen_test_layout_page_frag() {
    assert_eq!(
        ::std::mem::size_of::<page_frag>(),
        16usize,
        concat!("Size of: ", stringify!(page_frag))
    );
    assert_eq!(
        ::std::mem::align_of::<page_frag>(),
        8usize,
        concat!("Alignment of ", stringify!(page_frag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<page_frag>())).page as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag),
            "::",
            stringify!(page)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<page_frag>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<page_frag>())).size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tlbflush_unmap_batch {
    pub arch: arch_tlbflush_unmap_batch,
    pub flush_required: bool_,
    pub writable: bool_,
}
#[test]
fn bindgen_test_layout_tlbflush_unmap_batch() {
    assert_eq!(
        ::std::mem::size_of::<tlbflush_unmap_batch>(),
        16usize,
        concat!("Size of: ", stringify!(tlbflush_unmap_batch))
    );
    assert_eq!(
        ::std::mem::align_of::<tlbflush_unmap_batch>(),
        8usize,
        concat!("Alignment of ", stringify!(tlbflush_unmap_batch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tlbflush_unmap_batch>())).arch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tlbflush_unmap_batch),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tlbflush_unmap_batch>())).flush_required as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tlbflush_unmap_batch),
            "::",
            stringify!(flush_required)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tlbflush_unmap_batch>())).writable as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(tlbflush_unmap_batch),
            "::",
            stringify!(writable)
        )
    );
}
#[doc = " typedef refcount_t - variant of atomic_t specialized for reference counts"]
#[doc = " @refs: atomic_t counter field"]
#[doc = ""]
#[doc = " The counter saturates at REFCOUNT_SATURATED and will not move once"]
#[doc = " there. This avoids wrapping the counter and causing 'spurious'"]
#[doc = " use-after-free bugs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct refcount_struct {
    pub refs: atomic_t,
}
#[test]
fn bindgen_test_layout_refcount_struct() {
    assert_eq!(
        ::std::mem::size_of::<refcount_struct>(),
        4usize,
        concat!("Size of: ", stringify!(refcount_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<refcount_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(refcount_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<refcount_struct>())).refs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(refcount_struct),
            "::",
            stringify!(refs)
        )
    );
}
#[doc = " typedef refcount_t - variant of atomic_t specialized for reference counts"]
#[doc = " @refs: atomic_t counter field"]
#[doc = ""]
#[doc = " The counter saturates at REFCOUNT_SATURATED and will not move once"]
#[doc = " there. This avoids wrapping the counter and causing 'spurious'"]
#[doc = " use-after-free bugs."]
pub type refcount_t = refcount_struct;
pub const refcount_saturation_type_REFCOUNT_ADD_NOT_ZERO_OVF: refcount_saturation_type = 0;
pub const refcount_saturation_type_REFCOUNT_ADD_OVF: refcount_saturation_type = 1;
pub const refcount_saturation_type_REFCOUNT_ADD_UAF: refcount_saturation_type = 2;
pub const refcount_saturation_type_REFCOUNT_SUB_UAF: refcount_saturation_type = 3;
pub const refcount_saturation_type_REFCOUNT_DEC_LEAK: refcount_saturation_type = 4;
pub type refcount_saturation_type = ::std::os::raw::c_uint;
extern "C" {
    pub fn refcount_warn_saturate(r: *mut refcount_t, t: refcount_saturation_type);
}
extern "C" {
    pub fn refcount_dec_if_one(r: *mut refcount_t) -> bool_;
}
extern "C" {
    pub fn refcount_dec_not_one(r: *mut refcount_t) -> bool_;
}
extern "C" {
    pub fn refcount_dec_and_mutex_lock(r: *mut refcount_t, lock: *mut mutex) -> bool_;
}
extern "C" {
    pub fn refcount_dec_and_lock(r: *mut refcount_t, lock: *mut spinlock_t) -> bool_;
}
extern "C" {
    pub fn refcount_dec_and_lock_irqsave(
        r: *mut refcount_t,
        lock: *mut spinlock_t,
        flags: *mut ::std::os::raw::c_ulong,
    ) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kref {
    pub refcount: refcount_t,
}
#[test]
fn bindgen_test_layout_kref() {
    assert_eq!(
        ::std::mem::size_of::<kref>(),
        4usize,
        concat!("Size of: ", stringify!(kref))
    );
    assert_eq!(
        ::std::mem::align_of::<kref>(),
        4usize,
        concat!("Alignment of ", stringify!(kref))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kref>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kref),
            "::",
            stringify!(refcount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_node {
    pub __rb_parent_color: ::std::os::raw::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_node() {
    assert_eq!(
        ::std::mem::size_of::<rb_node>(),
        24usize,
        concat!("Size of: ", stringify!(rb_node))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_node>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_node>())).__rb_parent_color as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(__rb_parent_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_node>())).rb_right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_node>())).rb_left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_node),
            "::",
            stringify!(rb_left)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root {
    pub rb_node: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_root() {
    assert_eq!(
        ::std::mem::size_of::<rb_root>(),
        8usize,
        concat!("Size of: ", stringify!(rb_root))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_root>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_root))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_root>())).rb_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root),
            "::",
            stringify!(rb_node)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_root_cached {
    pub rb_root: rb_root,
    pub rb_leftmost: *mut rb_node,
}
#[test]
fn bindgen_test_layout_rb_root_cached() {
    assert_eq!(
        ::std::mem::size_of::<rb_root_cached>(),
        16usize,
        concat!("Size of: ", stringify!(rb_root_cached))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_root_cached>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_root_cached))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_root_cached>())).rb_root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root_cached),
            "::",
            stringify!(rb_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rb_root_cached>())).rb_leftmost as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rb_root_cached),
            "::",
            stringify!(rb_leftmost)
        )
    );
}
extern "C" {
    pub fn rb_insert_color(arg1: *mut rb_node, arg2: *mut rb_root);
}
extern "C" {
    pub fn rb_erase(arg1: *mut rb_node, arg2: *mut rb_root);
}
extern "C" {
    pub fn rb_next(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_prev(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_first(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_last(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_first_postorder(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_next_postorder(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_replace_node(victim: *mut rb_node, new: *mut rb_node, root: *mut rb_root);
}
extern "C" {
    pub fn rb_replace_node_rcu(victim: *mut rb_node, new: *mut rb_node, root: *mut rb_root);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct maple_metadata {
    pub end: ::std::os::raw::c_uchar,
    pub gap: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_maple_metadata() {
    assert_eq!(
        ::std::mem::size_of::<maple_metadata>(),
        2usize,
        concat!("Size of: ", stringify!(maple_metadata))
    );
    assert_eq!(
        ::std::mem::align_of::<maple_metadata>(),
        1usize,
        concat!("Alignment of ", stringify!(maple_metadata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_metadata>())).end as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_metadata),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_metadata>())).gap as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_metadata),
            "::",
            stringify!(gap)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_range_64 {
    pub parent: *mut maple_pnode,
    pub pivot: [::std::os::raw::c_ulong; 15usize],
    pub __bindgen_anon_1: maple_range_64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union maple_range_64__bindgen_ty_1 {
    pub slot: [*mut ::std::os::raw::c_void; 16usize],
    pub __bindgen_anon_1: maple_range_64__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct maple_range_64__bindgen_ty_1__bindgen_ty_1 {
    pub pad: [*mut ::std::os::raw::c_void; 15usize],
    pub meta: maple_metadata,
}
#[test]
fn bindgen_test_layout_maple_range_64__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<maple_range_64__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(maple_range_64__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<maple_range_64__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(maple_range_64__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<maple_range_64__bindgen_ty_1__bindgen_ty_1>())).pad as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_range_64__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<maple_range_64__bindgen_ty_1__bindgen_ty_1>())).meta as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_range_64__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(meta)
        )
    );
}
#[test]
fn bindgen_test_layout_maple_range_64__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<maple_range_64__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(maple_range_64__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<maple_range_64__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(maple_range_64__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<maple_range_64__bindgen_ty_1>())).slot as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_range_64__bindgen_ty_1),
            "::",
            stringify!(slot)
        )
    );
}
#[test]
fn bindgen_test_layout_maple_range_64() {
    assert_eq!(
        ::std::mem::size_of::<maple_range_64>(),
        256usize,
        concat!("Size of: ", stringify!(maple_range_64))
    );
    assert_eq!(
        ::std::mem::align_of::<maple_range_64>(),
        8usize,
        concat!("Alignment of ", stringify!(maple_range_64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_range_64>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_range_64),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_range_64>())).pivot as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_range_64),
            "::",
            stringify!(pivot)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct maple_arange_64 {
    pub parent: *mut maple_pnode,
    pub pivot: [::std::os::raw::c_ulong; 9usize],
    pub slot: [*mut ::std::os::raw::c_void; 10usize],
    pub gap: [::std::os::raw::c_ulong; 10usize],
    pub meta: maple_metadata,
}
#[test]
fn bindgen_test_layout_maple_arange_64() {
    assert_eq!(
        ::std::mem::size_of::<maple_arange_64>(),
        248usize,
        concat!("Size of: ", stringify!(maple_arange_64))
    );
    assert_eq!(
        ::std::mem::align_of::<maple_arange_64>(),
        8usize,
        concat!("Alignment of ", stringify!(maple_arange_64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_arange_64>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_arange_64),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_arange_64>())).pivot as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_arange_64),
            "::",
            stringify!(pivot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_arange_64>())).slot as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_arange_64),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_arange_64>())).gap as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_arange_64),
            "::",
            stringify!(gap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_arange_64>())).meta as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_arange_64),
            "::",
            stringify!(meta)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct maple_alloc {
    pub total: ::std::os::raw::c_ulong,
    pub node_count: ::std::os::raw::c_uchar,
    pub request_count: ::std::os::raw::c_uint,
    pub slot: [*mut maple_alloc; 30usize],
}
#[test]
fn bindgen_test_layout_maple_alloc() {
    assert_eq!(
        ::std::mem::size_of::<maple_alloc>(),
        256usize,
        concat!("Size of: ", stringify!(maple_alloc))
    );
    assert_eq!(
        ::std::mem::align_of::<maple_alloc>(),
        8usize,
        concat!("Alignment of ", stringify!(maple_alloc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_alloc>())).total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_alloc),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_alloc>())).node_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_alloc),
            "::",
            stringify!(node_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_alloc>())).request_count as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_alloc),
            "::",
            stringify!(request_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_alloc>())).slot as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_alloc),
            "::",
            stringify!(slot)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct maple_topiary {
    pub parent: *mut maple_pnode,
    pub next: *mut maple_enode,
}
#[test]
fn bindgen_test_layout_maple_topiary() {
    assert_eq!(
        ::std::mem::size_of::<maple_topiary>(),
        16usize,
        concat!("Size of: ", stringify!(maple_topiary))
    );
    assert_eq!(
        ::std::mem::align_of::<maple_topiary>(),
        8usize,
        concat!("Alignment of ", stringify!(maple_topiary))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_topiary>())).parent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_topiary),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_topiary>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_topiary),
            "::",
            stringify!(next)
        )
    );
}
pub const maple_type_maple_dense: maple_type = 0;
pub const maple_type_maple_leaf_64: maple_type = 1;
pub const maple_type_maple_range_64: maple_type = 2;
pub const maple_type_maple_arange_64: maple_type = 3;
pub type maple_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lockdep_map_p {}
#[test]
fn bindgen_test_layout_lockdep_map_p() {
    assert_eq!(
        ::std::mem::size_of::<lockdep_map_p>(),
        0usize,
        concat!("Size of: ", stringify!(lockdep_map_p))
    );
    assert_eq!(
        ::std::mem::align_of::<lockdep_map_p>(),
        1usize,
        concat!("Alignment of ", stringify!(lockdep_map_p))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_tree {
    pub __bindgen_anon_1: maple_tree__bindgen_ty_1,
    pub ma_root: *mut ::std::os::raw::c_void,
    pub ma_flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union maple_tree__bindgen_ty_1 {
    pub ma_lock: spinlock_t,
    pub ma_external_lock: lockdep_map_p,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_maple_tree__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<maple_tree__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(maple_tree__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<maple_tree__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(maple_tree__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<maple_tree__bindgen_ty_1>())).ma_lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_tree__bindgen_ty_1),
            "::",
            stringify!(ma_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<maple_tree__bindgen_ty_1>())).ma_external_lock as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_tree__bindgen_ty_1),
            "::",
            stringify!(ma_external_lock)
        )
    );
}
#[test]
fn bindgen_test_layout_maple_tree() {
    assert_eq!(
        ::std::mem::size_of::<maple_tree>(),
        24usize,
        concat!("Size of: ", stringify!(maple_tree))
    );
    assert_eq!(
        ::std::mem::align_of::<maple_tree>(),
        8usize,
        concat!("Alignment of ", stringify!(maple_tree))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_tree>())).ma_root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_tree),
            "::",
            stringify!(ma_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_tree>())).ma_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_tree),
            "::",
            stringify!(ma_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_node {
    pub __bindgen_anon_1: maple_node__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union maple_node__bindgen_ty_1 {
    pub __bindgen_anon_1: maple_node__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: maple_node__bindgen_ty_1__bindgen_ty_2,
    pub mr64: maple_range_64,
    pub ma64: maple_arange_64,
    pub alloc: maple_alloc,
    _bindgen_union_align: [u64; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct maple_node__bindgen_ty_1__bindgen_ty_1 {
    pub parent: *mut maple_pnode,
    pub slot: [*mut ::std::os::raw::c_void; 31usize],
}
#[test]
fn bindgen_test_layout_maple_node__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<maple_node__bindgen_ty_1__bindgen_ty_1>(),
        256usize,
        concat!(
            "Size of: ",
            stringify!(maple_node__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<maple_node__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(maple_node__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<maple_node__bindgen_ty_1__bindgen_ty_1>())).parent as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_node__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<maple_node__bindgen_ty_1__bindgen_ty_1>())).slot as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_node__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(slot)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct maple_node__bindgen_ty_1__bindgen_ty_2 {
    pub pad: *mut ::std::os::raw::c_void,
    pub rcu: callback_head,
    pub piv_parent: *mut maple_enode,
    pub parent_slot: ::std::os::raw::c_uchar,
    pub type_: maple_type,
    pub slot_len: ::std::os::raw::c_uchar,
    pub ma_flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_maple_node__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<maple_node__bindgen_ty_1__bindgen_ty_2>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(maple_node__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<maple_node__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(maple_node__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<maple_node__bindgen_ty_1__bindgen_ty_2>())).pad as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_node__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<maple_node__bindgen_ty_1__bindgen_ty_2>())).rcu as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_node__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<maple_node__bindgen_ty_1__bindgen_ty_2>())).piv_parent
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_node__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(piv_parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<maple_node__bindgen_ty_1__bindgen_ty_2>())).parent_slot
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_node__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(parent_slot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<maple_node__bindgen_ty_1__bindgen_ty_2>())).type_ as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_node__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<maple_node__bindgen_ty_1__bindgen_ty_2>())).slot_len as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_node__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(slot_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<maple_node__bindgen_ty_1__bindgen_ty_2>())).ma_flags as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_node__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ma_flags)
        )
    );
}
#[test]
fn bindgen_test_layout_maple_node__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<maple_node__bindgen_ty_1>(),
        256usize,
        concat!("Size of: ", stringify!(maple_node__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<maple_node__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(maple_node__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_node__bindgen_ty_1>())).mr64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_node__bindgen_ty_1),
            "::",
            stringify!(mr64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_node__bindgen_ty_1>())).ma64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_node__bindgen_ty_1),
            "::",
            stringify!(ma64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<maple_node__bindgen_ty_1>())).alloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(maple_node__bindgen_ty_1),
            "::",
            stringify!(alloc)
        )
    );
}
#[test]
fn bindgen_test_layout_maple_node() {
    assert_eq!(
        ::std::mem::size_of::<maple_node>(),
        256usize,
        concat!("Size of: ", stringify!(maple_node))
    );
    assert_eq!(
        ::std::mem::align_of::<maple_node>(),
        8usize,
        concat!("Alignment of ", stringify!(maple_node))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ma_topiary {
    pub head: *mut maple_enode,
    pub tail: *mut maple_enode,
    pub mtree: *mut maple_tree,
}
#[test]
fn bindgen_test_layout_ma_topiary() {
    assert_eq!(
        ::std::mem::size_of::<ma_topiary>(),
        24usize,
        concat!("Size of: ", stringify!(ma_topiary))
    );
    assert_eq!(
        ::std::mem::align_of::<ma_topiary>(),
        8usize,
        concat!("Alignment of ", stringify!(ma_topiary))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_topiary>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_topiary),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_topiary>())).tail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_topiary),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_topiary>())).mtree as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_topiary),
            "::",
            stringify!(mtree)
        )
    );
}
extern "C" {
    pub fn mtree_load(
        mt: *mut maple_tree,
        index: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mtree_insert(
        mt: *mut maple_tree,
        index: ::std::os::raw::c_ulong,
        entry: *mut ::std::os::raw::c_void,
        gfp: gfp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mtree_insert_range(
        mt: *mut maple_tree,
        first: ::std::os::raw::c_ulong,
        last: ::std::os::raw::c_ulong,
        entry: *mut ::std::os::raw::c_void,
        gfp: gfp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mtree_alloc_range(
        mt: *mut maple_tree,
        startp: *mut ::std::os::raw::c_ulong,
        entry: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_ulong,
        min: ::std::os::raw::c_ulong,
        max: ::std::os::raw::c_ulong,
        gfp: gfp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mtree_alloc_rrange(
        mt: *mut maple_tree,
        startp: *mut ::std::os::raw::c_ulong,
        entry: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_ulong,
        min: ::std::os::raw::c_ulong,
        max: ::std::os::raw::c_ulong,
        gfp: gfp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mtree_store_range(
        mt: *mut maple_tree,
        first: ::std::os::raw::c_ulong,
        last: ::std::os::raw::c_ulong,
        entry: *mut ::std::os::raw::c_void,
        gfp: gfp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mtree_store(
        mt: *mut maple_tree,
        index: ::std::os::raw::c_ulong,
        entry: *mut ::std::os::raw::c_void,
        gfp: gfp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mtree_erase(
        mt: *mut maple_tree,
        index: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mtree_destroy(mt: *mut maple_tree);
}
extern "C" {
    pub fn __mt_destroy(mt: *mut maple_tree);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ma_state {
    pub tree: *mut maple_tree,
    pub index: ::std::os::raw::c_ulong,
    pub last: ::std::os::raw::c_ulong,
    pub node: *mut maple_enode,
    pub min: ::std::os::raw::c_ulong,
    pub max: ::std::os::raw::c_ulong,
    pub alloc: *mut maple_alloc,
    pub depth: ::std::os::raw::c_uchar,
    pub offset: ::std::os::raw::c_uchar,
    pub mas_flags: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_ma_state() {
    assert_eq!(
        ::std::mem::size_of::<ma_state>(),
        64usize,
        concat!("Size of: ", stringify!(ma_state))
    );
    assert_eq!(
        ::std::mem::align_of::<ma_state>(),
        8usize,
        concat!("Alignment of ", stringify!(ma_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_state>())).tree as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_state),
            "::",
            stringify!(tree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_state>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_state),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_state>())).last as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_state),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_state>())).node as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_state),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_state>())).min as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_state),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_state>())).max as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_state),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_state>())).alloc as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_state),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_state>())).depth as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_state),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_state>())).offset as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_state),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_state>())).mas_flags as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_state),
            "::",
            stringify!(mas_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ma_wr_state {
    pub mas: *mut ma_state,
    pub node: *mut maple_node,
    pub r_min: ::std::os::raw::c_ulong,
    pub r_max: ::std::os::raw::c_ulong,
    pub type_: maple_type,
    pub offset_end: ::std::os::raw::c_uchar,
    pub node_end: ::std::os::raw::c_uchar,
    pub pivots: *mut ::std::os::raw::c_ulong,
    pub end_piv: ::std::os::raw::c_ulong,
    pub slots: *mut *mut ::std::os::raw::c_void,
    pub entry: *mut ::std::os::raw::c_void,
    pub content: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ma_wr_state() {
    assert_eq!(
        ::std::mem::size_of::<ma_wr_state>(),
        80usize,
        concat!("Size of: ", stringify!(ma_wr_state))
    );
    assert_eq!(
        ::std::mem::align_of::<ma_wr_state>(),
        8usize,
        concat!("Alignment of ", stringify!(ma_wr_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_wr_state>())).mas as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_wr_state),
            "::",
            stringify!(mas)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_wr_state>())).node as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_wr_state),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_wr_state>())).r_min as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_wr_state),
            "::",
            stringify!(r_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_wr_state>())).r_max as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_wr_state),
            "::",
            stringify!(r_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_wr_state>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_wr_state),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_wr_state>())).offset_end as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_wr_state),
            "::",
            stringify!(offset_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_wr_state>())).node_end as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_wr_state),
            "::",
            stringify!(node_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_wr_state>())).pivots as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_wr_state),
            "::",
            stringify!(pivots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_wr_state>())).end_piv as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_wr_state),
            "::",
            stringify!(end_piv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_wr_state>())).slots as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_wr_state),
            "::",
            stringify!(slots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_wr_state>())).entry as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_wr_state),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ma_wr_state>())).content as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ma_wr_state),
            "::",
            stringify!(content)
        )
    );
}
extern "C" {
    pub fn mas_walk(mas: *mut ma_state) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mas_store(
        mas: *mut ma_state,
        entry: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mas_erase(mas: *mut ma_state) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mas_store_gfp(
        mas: *mut ma_state,
        entry: *mut ::std::os::raw::c_void,
        gfp: gfp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mas_store_prealloc(mas: *mut ma_state, entry: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn mas_find(
        mas: *mut ma_state,
        max: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mas_find_rev(
        mas: *mut ma_state,
        min: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mas_preallocate(
        mas: *mut ma_state,
        entry: *mut ::std::os::raw::c_void,
        gfp: gfp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mas_is_err(mas: *mut ma_state) -> bool_;
}
extern "C" {
    pub fn mas_nomem(mas: *mut ma_state, gfp: gfp_t) -> bool_;
}
extern "C" {
    pub fn mas_pause(mas: *mut ma_state);
}
extern "C" {
    pub fn maple_tree_init();
}
extern "C" {
    pub fn mas_destroy(mas: *mut ma_state);
}
extern "C" {
    pub fn mas_expected_entries(
        mas: *mut ma_state,
        nr_entries: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mas_prev(
        mas: *mut ma_state,
        min: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mas_next(
        mas: *mut ma_state,
        max: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mas_empty_area(
        mas: *mut ma_state,
        min: ::std::os::raw::c_ulong,
        max: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mas_dup_tree(oldmas: *mut ma_state, mas: *mut ma_state);
}
extern "C" {
    pub fn mas_dup_store(mas: *mut ma_state, entry: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn mas_empty_area_rev(
        mas: *mut ma_state,
        min: ::std::os::raw::c_ulong,
        max: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mt_find(
        mt: *mut maple_tree,
        index: *mut ::std::os::raw::c_ulong,
        max: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mt_find_after(
        mt: *mut maple_tree,
        index: *mut ::std::os::raw::c_ulong,
        max: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mt_prev(
        mt: *mut maple_tree,
        index: ::std::os::raw::c_ulong,
        min: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mt_next(
        mt: *mut maple_tree,
        index: ::std::os::raw::c_ulong,
        max: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rw_semaphore {
    pub count: atomic_long_t,
    pub owner: atomic_long_t,
    pub osq: optimistic_spin_queue,
    pub wait_lock: raw_spinlock_t,
    pub wait_list: list_head,
}
#[test]
fn bindgen_test_layout_rw_semaphore() {
    assert_eq!(
        ::std::mem::size_of::<rw_semaphore>(),
        40usize,
        concat!("Size of: ", stringify!(rw_semaphore))
    );
    assert_eq!(
        ::std::mem::align_of::<rw_semaphore>(),
        8usize,
        concat!("Alignment of ", stringify!(rw_semaphore))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rw_semaphore>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rw_semaphore>())).owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rw_semaphore>())).osq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(osq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rw_semaphore>())).wait_lock as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(wait_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rw_semaphore>())).wait_list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rw_semaphore),
            "::",
            stringify!(wait_list)
        )
    );
}
extern "C" {
    pub fn __init_rwsem(
        sem: *mut rw_semaphore,
        name: *const ::std::os::raw::c_char,
        key: *mut lock_class_key,
    );
}
extern "C" {
    pub fn down_read(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn down_read_interruptible(sem: *mut rw_semaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn down_read_killable(sem: *mut rw_semaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn down_read_trylock(sem: *mut rw_semaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn down_write(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn down_write_killable(sem: *mut rw_semaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn down_write_trylock(sem: *mut rw_semaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn up_read(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn up_write(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn downgrade_write(sem: *mut rw_semaphore);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swait_queue_head {
    pub lock: raw_spinlock_t,
    pub task_list: list_head,
}
#[test]
fn bindgen_test_layout_swait_queue_head() {
    assert_eq!(
        ::std::mem::size_of::<swait_queue_head>(),
        24usize,
        concat!("Size of: ", stringify!(swait_queue_head))
    );
    assert_eq!(
        ::std::mem::align_of::<swait_queue_head>(),
        8usize,
        concat!("Alignment of ", stringify!(swait_queue_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swait_queue_head>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(swait_queue_head),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swait_queue_head>())).task_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(swait_queue_head),
            "::",
            stringify!(task_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swait_queue {
    pub task: *mut task_struct,
    pub task_list: list_head,
}
#[test]
fn bindgen_test_layout_swait_queue() {
    assert_eq!(
        ::std::mem::size_of::<swait_queue>(),
        24usize,
        concat!("Size of: ", stringify!(swait_queue))
    );
    assert_eq!(
        ::std::mem::align_of::<swait_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(swait_queue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swait_queue>())).task as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(swait_queue),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swait_queue>())).task_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(swait_queue),
            "::",
            stringify!(task_list)
        )
    );
}
extern "C" {
    pub fn __init_swait_queue_head(
        q: *mut swait_queue_head,
        name: *const ::std::os::raw::c_char,
        key: *mut lock_class_key,
    );
}
extern "C" {
    pub fn swake_up_one(q: *mut swait_queue_head);
}
extern "C" {
    pub fn swake_up_all(q: *mut swait_queue_head);
}
extern "C" {
    pub fn swake_up_locked(q: *mut swait_queue_head);
}
extern "C" {
    pub fn prepare_to_swait_exclusive(
        q: *mut swait_queue_head,
        wait: *mut swait_queue,
        state: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn prepare_to_swait_event(
        q: *mut swait_queue_head,
        wait: *mut swait_queue,
        state: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __finish_swait(q: *mut swait_queue_head, wait: *mut swait_queue);
}
extern "C" {
    pub fn finish_swait(q: *mut swait_queue_head, wait: *mut swait_queue);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct completion {
    pub done: ::std::os::raw::c_uint,
    pub wait: swait_queue_head,
}
#[test]
fn bindgen_test_layout_completion() {
    assert_eq!(
        ::std::mem::size_of::<completion>(),
        32usize,
        concat!("Size of: ", stringify!(completion))
    );
    assert_eq!(
        ::std::mem::align_of::<completion>(),
        8usize,
        concat!("Alignment of ", stringify!(completion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<completion>())).done as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(completion),
            "::",
            stringify!(done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<completion>())).wait as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(completion),
            "::",
            stringify!(wait)
        )
    );
}
extern "C" {
    pub fn wait_for_completion(arg1: *mut completion);
}
extern "C" {
    pub fn wait_for_completion_io(arg1: *mut completion);
}
extern "C" {
    pub fn wait_for_completion_interruptible(x: *mut completion) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait_for_completion_killable(x: *mut completion) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait_for_completion_state(
        x: *mut completion,
        state: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait_for_completion_timeout(
        x: *mut completion,
        timeout: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wait_for_completion_io_timeout(
        x: *mut completion,
        timeout: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wait_for_completion_interruptible_timeout(
        x: *mut completion,
        timeout: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wait_for_completion_killable_timeout(
        x: *mut completion,
        timeout: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn try_wait_for_completion(x: *mut completion) -> bool_;
}
extern "C" {
    pub fn completion_done(x: *mut completion) -> bool_;
}
extern "C" {
    pub fn complete(arg1: *mut completion);
}
extern "C" {
    pub fn complete_all(arg1: *mut completion);
}
pub const uprobe_filter_ctx_UPROBE_FILTER_REGISTER: uprobe_filter_ctx = 0;
pub const uprobe_filter_ctx_UPROBE_FILTER_UNREGISTER: uprobe_filter_ctx = 1;
pub const uprobe_filter_ctx_UPROBE_FILTER_MMAP: uprobe_filter_ctx = 2;
pub type uprobe_filter_ctx = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_consumer {
    pub handler: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut uprobe_consumer,
            regs: *mut pt_regs,
        ) -> ::std::os::raw::c_int,
    >,
    pub ret_handler: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut uprobe_consumer,
            func: ::std::os::raw::c_ulong,
            regs: *mut pt_regs,
        ) -> ::std::os::raw::c_int,
    >,
    pub filter: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut uprobe_consumer,
            ctx: uprobe_filter_ctx,
            mm: *mut mm_struct,
        ) -> bool_,
    >,
    pub next: *mut uprobe_consumer,
}
#[test]
fn bindgen_test_layout_uprobe_consumer() {
    assert_eq!(
        ::std::mem::size_of::<uprobe_consumer>(),
        32usize,
        concat!("Size of: ", stringify!(uprobe_consumer))
    );
    assert_eq!(
        ::std::mem::align_of::<uprobe_consumer>(),
        8usize,
        concat!("Alignment of ", stringify!(uprobe_consumer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uprobe_consumer>())).handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_consumer),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uprobe_consumer>())).ret_handler as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_consumer),
            "::",
            stringify!(ret_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uprobe_consumer>())).filter as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_consumer),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uprobe_consumer>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_consumer),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn register_refined_jiffies(
        clock_tick_rate: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut jiffies_64: u64_;
}
extern "C" {
    pub static mut jiffies: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut preset_lpj: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn jiffies_to_msecs(j: ::std::os::raw::c_ulong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn jiffies_to_usecs(j: ::std::os::raw::c_ulong) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn jiffies64_to_nsecs(j: u64_) -> u64_;
}
extern "C" {
    pub fn jiffies64_to_msecs(j: u64_) -> u64_;
}
extern "C" {
    pub fn __msecs_to_jiffies(m: ::std::os::raw::c_uint) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __usecs_to_jiffies(u: ::std::os::raw::c_uint) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn timespec64_to_jiffies(value: *const timespec64) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn jiffies_to_timespec64(jiffies: ::std::os::raw::c_ulong, value: *mut timespec64);
}
extern "C" {
    pub fn jiffies_to_clock_t(x: ::std::os::raw::c_ulong) -> clock_t;
}
extern "C" {
    pub fn clock_t_to_jiffies(x: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn jiffies_64_to_clock_t(x: u64_) -> u64_;
}
extern "C" {
    pub fn nsec_to_clock_t(x: u64_) -> u64_;
}
extern "C" {
    pub fn nsecs_to_jiffies64(n: u64_) -> u64_;
}
extern "C" {
    pub fn nsecs_to_jiffies(n: u64_) -> ::std::os::raw::c_ulong;
}
pub type ktime_t = s64;
extern "C" {
    pub fn ktime_add_safe(lhs: ktime_t, rhs: ktime_t) -> ktime_t;
}
pub const clocksource_ids_CSID_GENERIC: clocksource_ids = 0;
pub const clocksource_ids_CSID_ARM_ARCH_COUNTER: clocksource_ids = 1;
pub const clocksource_ids_CSID_MAX: clocksource_ids = 2;
pub type clocksource_ids = ::std::os::raw::c_uint;
extern "C" {
    pub fn timekeeping_init();
}
extern "C" {
    pub static mut timekeeping_suspended: ::std::os::raw::c_int;
}
extern "C" {
    pub fn legacy_timer_tick(ticks: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn do_settimeofday64(ts: *const timespec64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_sys_settimeofday64(
        tv: *const timespec64,
        tz: *const timezone,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ktime_get_raw_ts64(ts: *mut timespec64);
}
extern "C" {
    pub fn ktime_get_ts64(ts: *mut timespec64);
}
extern "C" {
    pub fn ktime_get_real_ts64(tv: *mut timespec64);
}
extern "C" {
    pub fn ktime_get_coarse_ts64(ts: *mut timespec64);
}
extern "C" {
    pub fn ktime_get_coarse_real_ts64(ts: *mut timespec64);
}
extern "C" {
    pub fn getboottime64(ts: *mut timespec64);
}
extern "C" {
    pub fn ktime_get_seconds() -> time64_t;
}
extern "C" {
    pub fn __ktime_get_real_seconds() -> time64_t;
}
extern "C" {
    pub fn ktime_get_real_seconds() -> time64_t;
}
pub const tk_offsets_TK_OFFS_REAL: tk_offsets = 0;
pub const tk_offsets_TK_OFFS_BOOT: tk_offsets = 1;
pub const tk_offsets_TK_OFFS_TAI: tk_offsets = 2;
pub const tk_offsets_TK_OFFS_MAX: tk_offsets = 3;
pub type tk_offsets = ::std::os::raw::c_uint;
extern "C" {
    pub fn ktime_get() -> ktime_t;
}
extern "C" {
    pub fn ktime_get_with_offset(offs: tk_offsets) -> ktime_t;
}
extern "C" {
    pub fn ktime_get_coarse_with_offset(offs: tk_offsets) -> ktime_t;
}
extern "C" {
    pub fn ktime_mono_to_any(tmono: ktime_t, offs: tk_offsets) -> ktime_t;
}
extern "C" {
    pub fn ktime_get_raw() -> ktime_t;
}
extern "C" {
    pub fn ktime_get_resolution_ns() -> u32_;
}
extern "C" {
    pub fn ktime_get_mono_fast_ns() -> u64_;
}
extern "C" {
    pub fn ktime_get_raw_fast_ns() -> u64_;
}
extern "C" {
    pub fn ktime_get_boot_fast_ns() -> u64_;
}
extern "C" {
    pub fn ktime_get_tai_fast_ns() -> u64_;
}
extern "C" {
    pub fn ktime_get_real_fast_ns() -> u64_;
}
extern "C" {
    pub fn timekeeping_rtc_skipsuspend() -> bool_;
}
extern "C" {
    pub fn timekeeping_rtc_skipresume() -> bool_;
}
extern "C" {
    pub fn timekeeping_inject_sleeptime64(delta: *const timespec64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktime_timestamps {
    pub mono: u64_,
    pub boot: u64_,
    pub real: u64_,
}
#[test]
fn bindgen_test_layout_ktime_timestamps() {
    assert_eq!(
        ::std::mem::size_of::<ktime_timestamps>(),
        24usize,
        concat!("Size of: ", stringify!(ktime_timestamps))
    );
    assert_eq!(
        ::std::mem::align_of::<ktime_timestamps>(),
        8usize,
        concat!("Alignment of ", stringify!(ktime_timestamps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktime_timestamps>())).mono as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktime_timestamps),
            "::",
            stringify!(mono)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktime_timestamps>())).boot as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ktime_timestamps),
            "::",
            stringify!(boot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ktime_timestamps>())).real as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ktime_timestamps),
            "::",
            stringify!(real)
        )
    );
}
#[doc = " struct system_time_snapshot - simultaneous raw/real time capture with"]
#[doc = "\t\t\t\t counter value"]
#[doc = " @cycles:\tClocksource counter value to produce the system times"]
#[doc = " @real:\tRealtime system time"]
#[doc = " @raw:\tMonotonic raw system time"]
#[doc = " @clock_was_set_seq:\tThe sequence number of clock was set events"]
#[doc = " @cs_was_changed_seq:\tThe sequence number of clocksource change events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct system_time_snapshot {
    pub cycles: u64_,
    pub real: ktime_t,
    pub raw: ktime_t,
    pub cs_id: clocksource_ids,
    pub clock_was_set_seq: ::std::os::raw::c_uint,
    pub cs_was_changed_seq: u8_,
}
#[test]
fn bindgen_test_layout_system_time_snapshot() {
    assert_eq!(
        ::std::mem::size_of::<system_time_snapshot>(),
        40usize,
        concat!("Size of: ", stringify!(system_time_snapshot))
    );
    assert_eq!(
        ::std::mem::align_of::<system_time_snapshot>(),
        8usize,
        concat!("Alignment of ", stringify!(system_time_snapshot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<system_time_snapshot>())).cycles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(system_time_snapshot),
            "::",
            stringify!(cycles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<system_time_snapshot>())).real as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(system_time_snapshot),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<system_time_snapshot>())).raw as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(system_time_snapshot),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<system_time_snapshot>())).cs_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(system_time_snapshot),
            "::",
            stringify!(cs_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<system_time_snapshot>())).clock_was_set_seq as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(system_time_snapshot),
            "::",
            stringify!(clock_was_set_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<system_time_snapshot>())).cs_was_changed_seq as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(system_time_snapshot),
            "::",
            stringify!(cs_was_changed_seq)
        )
    );
}
#[doc = " struct system_device_crosststamp - system/device cross-timestamp"]
#[doc = "\t\t\t\t      (synchronized capture)"]
#[doc = " @device:\t\tDevice time"]
#[doc = " @sys_realtime:\tRealtime simultaneous with device time"]
#[doc = " @sys_monoraw:\tMonotonic raw simultaneous with device time"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct system_device_crosststamp {
    pub device: ktime_t,
    pub sys_realtime: ktime_t,
    pub sys_monoraw: ktime_t,
}
#[test]
fn bindgen_test_layout_system_device_crosststamp() {
    assert_eq!(
        ::std::mem::size_of::<system_device_crosststamp>(),
        24usize,
        concat!("Size of: ", stringify!(system_device_crosststamp))
    );
    assert_eq!(
        ::std::mem::align_of::<system_device_crosststamp>(),
        8usize,
        concat!("Alignment of ", stringify!(system_device_crosststamp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<system_device_crosststamp>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(system_device_crosststamp),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<system_device_crosststamp>())).sys_realtime as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(system_device_crosststamp),
            "::",
            stringify!(sys_realtime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<system_device_crosststamp>())).sys_monoraw as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(system_device_crosststamp),
            "::",
            stringify!(sys_monoraw)
        )
    );
}
#[doc = " struct system_counterval_t - system counter value with the pointer to the"]
#[doc = "\t\t\t\tcorresponding clocksource"]
#[doc = " @cycles:\tSystem counter value"]
#[doc = " @cs:\t\tClocksource corresponding to system counter value. Used by"]
#[doc = "\t\ttimekeeping code to verify comparibility of two cycle values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct system_counterval_t {
    pub cycles: u64_,
    pub cs: *mut clocksource,
}
#[test]
fn bindgen_test_layout_system_counterval_t() {
    assert_eq!(
        ::std::mem::size_of::<system_counterval_t>(),
        16usize,
        concat!("Size of: ", stringify!(system_counterval_t))
    );
    assert_eq!(
        ::std::mem::align_of::<system_counterval_t>(),
        8usize,
        concat!("Alignment of ", stringify!(system_counterval_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<system_counterval_t>())).cycles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(system_counterval_t),
            "::",
            stringify!(cycles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<system_counterval_t>())).cs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(system_counterval_t),
            "::",
            stringify!(cs)
        )
    );
}
extern "C" {
    pub fn get_device_system_crosststamp(
        get_time_fn: ::std::option::Option<
            unsafe extern "C" fn(
                device_time: *mut ktime_t,
                system_counterval: *mut system_counterval_t,
                ctx: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        ctx: *mut ::std::os::raw::c_void,
        history: *mut system_time_snapshot,
        xtstamp: *mut system_device_crosststamp,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ktime_get_snapshot(systime_snapshot: *mut system_time_snapshot);
}
extern "C" {
    pub fn ktime_get_fast_timestamps(snap: *mut ktime_timestamps);
}
extern "C" {
    pub static mut persistent_clock_is_local: ::std::os::raw::c_int;
}
extern "C" {
    pub fn read_persistent_clock64(ts: *mut timespec64);
}
extern "C" {
    pub fn read_persistent_wall_and_boot_offset(
        wall_clock: *mut timespec64,
        boot_offset: *mut timespec64,
    );
}
extern "C" {
    pub fn update_persistent_clock64(now: timespec64) -> ::std::os::raw::c_int;
}
pub const debug_obj_state_ODEBUG_STATE_NONE: debug_obj_state = 0;
pub const debug_obj_state_ODEBUG_STATE_INIT: debug_obj_state = 1;
pub const debug_obj_state_ODEBUG_STATE_INACTIVE: debug_obj_state = 2;
pub const debug_obj_state_ODEBUG_STATE_ACTIVE: debug_obj_state = 3;
pub const debug_obj_state_ODEBUG_STATE_DESTROYED: debug_obj_state = 4;
pub const debug_obj_state_ODEBUG_STATE_NOTAVAILABLE: debug_obj_state = 5;
pub const debug_obj_state_ODEBUG_STATE_MAX: debug_obj_state = 6;
pub type debug_obj_state = ::std::os::raw::c_uint;
#[doc = " struct debug_obj - representation of an tracked object"]
#[doc = " @node:\thlist node to link the object into the tracker list"]
#[doc = " @state:\ttracked object state"]
#[doc = " @astate:\tcurrent active state"]
#[doc = " @object:\tpointer to the real object"]
#[doc = " @descr:\tpointer to an object type specific debug description structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct debug_obj {
    pub node: hlist_node,
    pub state: debug_obj_state,
    pub astate: ::std::os::raw::c_uint,
    pub object: *mut ::std::os::raw::c_void,
    pub descr: *const debug_obj_descr,
}
#[test]
fn bindgen_test_layout_debug_obj() {
    assert_eq!(
        ::std::mem::size_of::<debug_obj>(),
        40usize,
        concat!("Size of: ", stringify!(debug_obj))
    );
    assert_eq!(
        ::std::mem::align_of::<debug_obj>(),
        8usize,
        concat!("Alignment of ", stringify!(debug_obj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj>())).astate as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj),
            "::",
            stringify!(astate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj>())).object as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj>())).descr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj),
            "::",
            stringify!(descr)
        )
    );
}
#[doc = " struct debug_obj_descr - object type specific debug description structure"]
#[doc = ""]
#[doc = " @name:\t\tname of the object typee"]
#[doc = " @debug_hint:\t\tfunction returning address, which have associated"]
#[doc = "\t\t\tkernel symbol, to allow identify the object"]
#[doc = " @is_static_object:\treturn true if the obj is static, otherwise return false"]
#[doc = " @fixup_init:\t\tfixup function, which is called when the init check"]
#[doc = "\t\t\tfails. All fixup functions must return true if fixup"]
#[doc = "\t\t\twas successful, otherwise return false"]
#[doc = " @fixup_activate:\tfixup function, which is called when the activate check"]
#[doc = "\t\t\tfails"]
#[doc = " @fixup_destroy:\tfixup function, which is called when the destroy check"]
#[doc = "\t\t\tfails"]
#[doc = " @fixup_free:\t\tfixup function, which is called when the free check"]
#[doc = "\t\t\tfails"]
#[doc = " @fixup_assert_init:  fixup function, which is called when the assert_init"]
#[doc = "\t\t\tcheck fails"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct debug_obj_descr {
    pub name: *const ::std::os::raw::c_char,
    pub debug_hint: ::std::option::Option<
        unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
    >,
    pub is_static_object:
        ::std::option::Option<unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void) -> bool_>,
    pub fixup_init: ::std::option::Option<
        unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_activate: ::std::option::Option<
        unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_destroy: ::std::option::Option<
        unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_free: ::std::option::Option<
        unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_assert_init: ::std::option::Option<
        unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, state: debug_obj_state) -> bool_,
    >,
}
#[test]
fn bindgen_test_layout_debug_obj_descr() {
    assert_eq!(
        ::std::mem::size_of::<debug_obj_descr>(),
        64usize,
        concat!("Size of: ", stringify!(debug_obj_descr))
    );
    assert_eq!(
        ::std::mem::align_of::<debug_obj_descr>(),
        8usize,
        concat!("Alignment of ", stringify!(debug_obj_descr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj_descr>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj_descr>())).debug_hint as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(debug_hint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<debug_obj_descr>())).is_static_object as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(is_static_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj_descr>())).fixup_init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(fixup_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj_descr>())).fixup_activate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(fixup_activate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj_descr>())).fixup_destroy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(fixup_destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debug_obj_descr>())).fixup_free as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(fixup_free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<debug_obj_descr>())).fixup_assert_init as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(debug_obj_descr),
            "::",
            stringify!(fixup_assert_init)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_list {
    pub entry: hlist_node,
    pub expires: ::std::os::raw::c_ulong,
    pub function: ::std::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
    pub flags: u32_,
}
#[test]
fn bindgen_test_layout_timer_list() {
    assert_eq!(
        ::std::mem::size_of::<timer_list>(),
        40usize,
        concat!("Size of: ", stringify!(timer_list))
    );
    assert_eq!(
        ::std::mem::align_of::<timer_list>(),
        8usize,
        concat!("Alignment of ", stringify!(timer_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timer_list>())).entry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timer_list>())).expires as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timer_list>())).function as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timer_list>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timer_list),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn init_timer_key(
        timer: *mut timer_list,
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
        flags: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
        key: *mut lock_class_key,
    );
}
extern "C" {
    pub fn add_timer_on(timer: *mut timer_list, cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn del_timer(timer: *mut timer_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mod_timer(
        timer: *mut timer_list,
        expires: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mod_timer_pending(
        timer: *mut timer_list,
        expires: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_reduce(
        timer: *mut timer_list,
        expires: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_timer(timer: *mut timer_list);
}
extern "C" {
    pub fn try_to_del_timer_sync(timer: *mut timer_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn del_timer_sync(timer: *mut timer_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn init_timers();
}
extern "C" {
    pub fn it_real_fn(arg1: *mut hrtimer) -> hrtimer_restart;
}
extern "C" {
    pub fn __round_jiffies(
        j: ::std::os::raw::c_ulong,
        cpu: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __round_jiffies_relative(
        j: ::std::os::raw::c_ulong,
        cpu: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn round_jiffies(j: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn round_jiffies_relative(j: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __round_jiffies_up(
        j: ::std::os::raw::c_ulong,
        cpu: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __round_jiffies_up_relative(
        j: ::std::os::raw::c_ulong,
        cpu: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn round_jiffies_up(j: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn round_jiffies_up_relative(j: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn timers_prepare_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timers_dead_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct workqueue_struct {
    _unused: [u8; 0],
}
pub type work_func_t = ::std::option::Option<unsafe extern "C" fn(work: *mut work_struct)>;
extern "C" {
    pub fn delayed_work_timer_fn(t: *mut timer_list);
}
pub const WORK_STRUCT_PENDING_BIT: ::std::os::raw::c_long = 0;
pub const WORK_STRUCT_INACTIVE_BIT: ::std::os::raw::c_long = 1;
pub const WORK_STRUCT_PWQ_BIT: ::std::os::raw::c_long = 2;
pub const WORK_STRUCT_LINKED_BIT: ::std::os::raw::c_long = 3;
pub const WORK_STRUCT_COLOR_SHIFT: ::std::os::raw::c_long = 4;
pub const WORK_STRUCT_COLOR_BITS: ::std::os::raw::c_long = 4;
pub const WORK_STRUCT_PENDING: ::std::os::raw::c_long = 1;
pub const WORK_STRUCT_INACTIVE: ::std::os::raw::c_long = 2;
pub const WORK_STRUCT_PWQ: ::std::os::raw::c_long = 4;
pub const WORK_STRUCT_LINKED: ::std::os::raw::c_long = 8;
pub const WORK_STRUCT_STATIC: ::std::os::raw::c_long = 0;
pub const WORK_NR_COLORS: ::std::os::raw::c_long = 16;
pub const WORK_CPU_UNBOUND: ::std::os::raw::c_long = 64;
pub const WORK_STRUCT_FLAG_BITS: ::std::os::raw::c_long = 8;
pub const WORK_OFFQ_FLAG_BASE: ::std::os::raw::c_long = 4;
pub const __WORK_OFFQ_CANCELING: ::std::os::raw::c_long = 4;
pub const WORK_OFFQ_CANCELING: ::std::os::raw::c_long = 16;
pub const WORK_OFFQ_FLAG_BITS: ::std::os::raw::c_long = 1;
pub const WORK_OFFQ_POOL_SHIFT: ::std::os::raw::c_long = 5;
pub const WORK_OFFQ_LEFT: ::std::os::raw::c_long = 59;
pub const WORK_OFFQ_POOL_BITS: ::std::os::raw::c_long = 31;
pub const WORK_OFFQ_POOL_NONE: ::std::os::raw::c_long = 2147483647;
pub const WORK_STRUCT_FLAG_MASK: ::std::os::raw::c_long = 255;
pub const WORK_STRUCT_WQ_DATA_MASK: ::std::os::raw::c_long = -256;
pub const WORK_STRUCT_NO_POOL: ::std::os::raw::c_long = 68719476704;
pub const WORK_BUSY_PENDING: ::std::os::raw::c_long = 1;
pub const WORK_BUSY_RUNNING: ::std::os::raw::c_long = 2;
pub const WORKER_DESC_LEN: ::std::os::raw::c_long = 24;
pub type _bindgen_ty_10 = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct work_struct {
    pub data: atomic_long_t,
    pub entry: list_head,
    pub func: work_func_t,
}
#[test]
fn bindgen_test_layout_work_struct() {
    assert_eq!(
        ::std::mem::size_of::<work_struct>(),
        32usize,
        concat!("Size of: ", stringify!(work_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<work_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(work_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<work_struct>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(work_struct),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<work_struct>())).entry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(work_struct),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<work_struct>())).func as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(work_struct),
            "::",
            stringify!(func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct delayed_work {
    pub work: work_struct,
    pub timer: timer_list,
    pub wq: *mut workqueue_struct,
    pub cpu: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_delayed_work() {
    assert_eq!(
        ::std::mem::size_of::<delayed_work>(),
        88usize,
        concat!("Size of: ", stringify!(delayed_work))
    );
    assert_eq!(
        ::std::mem::align_of::<delayed_work>(),
        8usize,
        concat!("Alignment of ", stringify!(delayed_work))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<delayed_work>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<delayed_work>())).timer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<delayed_work>())).wq as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<delayed_work>())).cpu as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_work),
            "::",
            stringify!(cpu)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_work {
    pub work: work_struct,
    pub rcu: callback_head,
    pub wq: *mut workqueue_struct,
}
#[test]
fn bindgen_test_layout_rcu_work() {
    assert_eq!(
        ::std::mem::size_of::<rcu_work>(),
        56usize,
        concat!("Size of: ", stringify!(rcu_work))
    );
    assert_eq!(
        ::std::mem::align_of::<rcu_work>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_work))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_work>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_work),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_work>())).rcu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_work),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_work>())).wq as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_work),
            "::",
            stringify!(wq)
        )
    );
}
#[doc = " struct workqueue_attrs - A struct for workqueue attributes."]
#[doc = ""]
#[doc = " This can be used to change attributes of an unbound workqueue."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct workqueue_attrs {
    #[doc = " @nice: nice level"]
    pub nice: ::std::os::raw::c_int,
    #[doc = " @cpumask: allowed CPUs"]
    pub cpumask: cpumask_var_t,
    #[doc = " @no_numa: disable NUMA affinity"]
    #[doc = ""]
    #[doc = " Unlike other fields, ``no_numa`` isn't a property of a worker_pool. It"]
    #[doc = " only modifies how :c:func:`apply_workqueue_attrs` select pools and thus"]
    #[doc = " doesn't participate in pool hash calculations or equality comparisons."]
    pub no_numa: bool_,
}
#[test]
fn bindgen_test_layout_workqueue_attrs() {
    assert_eq!(
        ::std::mem::size_of::<workqueue_attrs>(),
        24usize,
        concat!("Size of: ", stringify!(workqueue_attrs))
    );
    assert_eq!(
        ::std::mem::align_of::<workqueue_attrs>(),
        8usize,
        concat!("Alignment of ", stringify!(workqueue_attrs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<workqueue_attrs>())).nice as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(workqueue_attrs),
            "::",
            stringify!(nice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<workqueue_attrs>())).cpumask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(workqueue_attrs),
            "::",
            stringify!(cpumask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<workqueue_attrs>())).no_numa as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(workqueue_attrs),
            "::",
            stringify!(no_numa)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct execute_work {
    pub work: work_struct,
}
#[test]
fn bindgen_test_layout_execute_work() {
    assert_eq!(
        ::std::mem::size_of::<execute_work>(),
        32usize,
        concat!("Size of: ", stringify!(execute_work))
    );
    assert_eq!(
        ::std::mem::align_of::<execute_work>(),
        8usize,
        concat!("Alignment of ", stringify!(execute_work))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<execute_work>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(execute_work),
            "::",
            stringify!(work)
        )
    );
}
pub const WQ_UNBOUND: ::std::os::raw::c_uint = 2;
pub const WQ_FREEZABLE: ::std::os::raw::c_uint = 4;
pub const WQ_MEM_RECLAIM: ::std::os::raw::c_uint = 8;
pub const WQ_HIGHPRI: ::std::os::raw::c_uint = 16;
pub const WQ_CPU_INTENSIVE: ::std::os::raw::c_uint = 32;
pub const WQ_SYSFS: ::std::os::raw::c_uint = 64;
pub const WQ_POWER_EFFICIENT: ::std::os::raw::c_uint = 128;
pub const __WQ_DRAINING: ::std::os::raw::c_uint = 65536;
pub const __WQ_ORDERED: ::std::os::raw::c_uint = 131072;
pub const __WQ_LEGACY: ::std::os::raw::c_uint = 262144;
pub const __WQ_ORDERED_EXPLICIT: ::std::os::raw::c_uint = 524288;
pub const WQ_MAX_ACTIVE: ::std::os::raw::c_uint = 512;
pub const WQ_MAX_UNBOUND_PER_CPU: ::std::os::raw::c_uint = 4;
pub const WQ_DFL_ACTIVE: ::std::os::raw::c_uint = 256;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
extern "C" {
    pub static mut system_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_highpri_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_long_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_unbound_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_freezable_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_power_efficient_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_freezable_power_efficient_wq: *mut workqueue_struct;
}
extern "C" {
    #[doc = " alloc_workqueue - allocate a workqueue"]
    #[doc = " @fmt: printf format for the name of the workqueue"]
    #[doc = " @flags: WQ_* flags"]
    #[doc = " @max_active: max in-flight work items, 0 for default"]
    #[doc = " remaining args: args for @fmt"]
    #[doc = ""]
    #[doc = " Allocate a workqueue with the specified parameters.  For detailed"]
    #[doc = " information on WQ_* flags, please refer to"]
    #[doc = " Documentation/core-api/workqueue.rst."]
    #[doc = ""]
    #[doc = " RETURNS:"]
    #[doc = " Pointer to the allocated workqueue on success, %NULL on failure."]
    pub fn alloc_workqueue(
        fmt: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        max_active: ::std::os::raw::c_int,
        ...
    ) -> *mut workqueue_struct;
}
extern "C" {
    pub fn destroy_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn alloc_workqueue_attrs() -> *mut workqueue_attrs;
}
extern "C" {
    pub fn free_workqueue_attrs(attrs: *mut workqueue_attrs);
}
extern "C" {
    pub fn apply_workqueue_attrs(
        wq: *mut workqueue_struct,
        attrs: *const workqueue_attrs,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn workqueue_set_unbound_cpumask(cpumask: *mut cpumask) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn queue_work_on(
        cpu: ::std::os::raw::c_int,
        wq: *mut workqueue_struct,
        work: *mut work_struct,
    ) -> bool_;
}
extern "C" {
    pub fn queue_work_node(
        node: ::std::os::raw::c_int,
        wq: *mut workqueue_struct,
        work: *mut work_struct,
    ) -> bool_;
}
extern "C" {
    pub fn queue_delayed_work_on(
        cpu: ::std::os::raw::c_int,
        wq: *mut workqueue_struct,
        work: *mut delayed_work,
        delay: ::std::os::raw::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn mod_delayed_work_on(
        cpu: ::std::os::raw::c_int,
        wq: *mut workqueue_struct,
        dwork: *mut delayed_work,
        delay: ::std::os::raw::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn queue_rcu_work(wq: *mut workqueue_struct, rwork: *mut rcu_work) -> bool_;
}
extern "C" {
    pub fn __flush_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn drain_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn schedule_on_each_cpu(func: work_func_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execute_in_process_context(
        fn_: work_func_t,
        arg1: *mut execute_work,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flush_work(work: *mut work_struct) -> bool_;
}
extern "C" {
    pub fn cancel_work(work: *mut work_struct) -> bool_;
}
extern "C" {
    pub fn cancel_work_sync(work: *mut work_struct) -> bool_;
}
extern "C" {
    pub fn flush_delayed_work(dwork: *mut delayed_work) -> bool_;
}
extern "C" {
    pub fn cancel_delayed_work(dwork: *mut delayed_work) -> bool_;
}
extern "C" {
    pub fn cancel_delayed_work_sync(dwork: *mut delayed_work) -> bool_;
}
extern "C" {
    pub fn flush_rcu_work(rwork: *mut rcu_work) -> bool_;
}
extern "C" {
    pub fn workqueue_set_max_active(wq: *mut workqueue_struct, max_active: ::std::os::raw::c_int);
}
extern "C" {
    pub fn current_work() -> *mut work_struct;
}
extern "C" {
    pub fn current_is_workqueue_rescuer() -> bool_;
}
extern "C" {
    pub fn workqueue_congested(cpu: ::std::os::raw::c_int, wq: *mut workqueue_struct) -> bool_;
}
extern "C" {
    pub fn work_busy(work: *mut work_struct) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn set_worker_desc(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn print_worker_info(log_lvl: *const ::std::os::raw::c_char, task: *mut task_struct);
}
extern "C" {
    pub fn show_all_workqueues();
}
extern "C" {
    pub fn show_one_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn wq_worker_comm(buf: *mut ::std::os::raw::c_char, size: size_t, task: *mut task_struct);
}
extern "C" {
    pub fn __warn_flushing_systemwide_wq();
}
extern "C" {
    pub fn work_on_cpu(
        cpu: ::std::os::raw::c_int,
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn work_on_cpu_safe(
        cpu: ::std::os::raw::c_int,
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_long,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn freeze_workqueues_begin();
}
extern "C" {
    pub fn freeze_workqueues_busy() -> bool_;
}
extern "C" {
    pub fn thaw_workqueues();
}
extern "C" {
    pub fn workqueue_sysfs_register(wq: *mut workqueue_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn workqueue_prepare_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn workqueue_online_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn workqueue_offline_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn workqueue_init_early();
}
extern "C" {
    pub fn workqueue_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_cblist {
    pub head: *mut callback_head,
    pub tail: *mut *mut callback_head,
    pub len: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rcu_cblist() {
    assert_eq!(
        ::std::mem::size_of::<rcu_cblist>(),
        24usize,
        concat!("Size of: ", stringify!(rcu_cblist))
    );
    assert_eq!(
        ::std::mem::align_of::<rcu_cblist>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_cblist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_cblist>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_cblist),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_cblist>())).tail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_cblist),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_cblist>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_cblist),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_segcblist {
    pub head: *mut callback_head,
    pub tails: [*mut *mut callback_head; 4usize],
    pub gp_seq: [::std::os::raw::c_ulong; 4usize],
    pub len: ::std::os::raw::c_long,
    pub seglen: [::std::os::raw::c_long; 4usize],
    pub flags: u8_,
}
#[test]
fn bindgen_test_layout_rcu_segcblist() {
    assert_eq!(
        ::std::mem::size_of::<rcu_segcblist>(),
        120usize,
        concat!("Size of: ", stringify!(rcu_segcblist))
    );
    assert_eq!(
        ::std::mem::align_of::<rcu_segcblist>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_segcblist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_segcblist>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_segcblist>())).tails as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(tails)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_segcblist>())).gp_seq as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(gp_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_segcblist>())).len as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_segcblist>())).seglen as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(seglen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_segcblist>())).flags as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_segcblist),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn init_srcu_struct(ssp: *mut srcu_struct) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct srcu_data {
    pub srcu_lock_count: [::std::os::raw::c_ulong; 2usize],
    pub srcu_unlock_count: [::std::os::raw::c_ulong; 2usize],
    pub __bindgen_padding_0: [u32; 8usize],
    pub lock: spinlock_t,
    pub srcu_cblist: rcu_segcblist,
    pub srcu_gp_seq_needed: ::std::os::raw::c_ulong,
    pub srcu_gp_seq_needed_exp: ::std::os::raw::c_ulong,
    pub srcu_cblist_invoking: bool_,
    pub delay_work: timer_list,
    pub work: work_struct,
    pub srcu_barrier_head: callback_head,
    pub mynode: *mut srcu_node,
    pub grpmask: ::std::os::raw::c_ulong,
    pub cpu: ::std::os::raw::c_int,
    pub ssp: *mut srcu_struct,
}
#[test]
fn bindgen_test_layout_srcu_data() {
    assert_eq!(
        ::std::mem::size_of::<srcu_data>(),
        384usize,
        concat!("Size of: ", stringify!(srcu_data))
    );
    assert_eq!(
        ::std::mem::align_of::<srcu_data>(),
        64usize,
        concat!("Alignment of ", stringify!(srcu_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).srcu_lock_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_lock_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).srcu_unlock_count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_unlock_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).srcu_cblist as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_cblist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).srcu_gp_seq_needed as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_gp_seq_needed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srcu_data>())).srcu_gp_seq_needed_exp as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_gp_seq_needed_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).srcu_cblist_invoking as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_cblist_invoking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).delay_work as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(delay_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).work as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).srcu_barrier_head as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(srcu_barrier_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).mynode as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(mynode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).grpmask as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(grpmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).cpu as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_data>())).ssp as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_data),
            "::",
            stringify!(ssp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_node {
    pub lock: spinlock_t,
    pub srcu_have_cbs: [::std::os::raw::c_ulong; 4usize],
    pub srcu_data_have_cbs: [::std::os::raw::c_ulong; 4usize],
    pub srcu_gp_seq_needed_exp: ::std::os::raw::c_ulong,
    pub srcu_parent: *mut srcu_node,
    pub grplo: ::std::os::raw::c_int,
    pub grphi: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_srcu_node() {
    assert_eq!(
        ::std::mem::size_of::<srcu_node>(),
        96usize,
        concat!("Size of: ", stringify!(srcu_node))
    );
    assert_eq!(
        ::std::mem::align_of::<srcu_node>(),
        8usize,
        concat!("Alignment of ", stringify!(srcu_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_node>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_node>())).srcu_have_cbs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_have_cbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_node>())).srcu_data_have_cbs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_data_have_cbs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srcu_node>())).srcu_gp_seq_needed_exp as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_gp_seq_needed_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_node>())).srcu_parent as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(srcu_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_node>())).grplo as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(grplo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_node>())).grphi as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_node),
            "::",
            stringify!(grphi)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_struct {
    pub node: *mut srcu_node,
    pub level: [*mut srcu_node; 3usize],
    pub srcu_size_state: ::std::os::raw::c_int,
    pub srcu_cb_mutex: mutex,
    pub lock: spinlock_t,
    pub srcu_gp_mutex: mutex,
    pub srcu_idx: ::std::os::raw::c_uint,
    pub srcu_gp_seq: ::std::os::raw::c_ulong,
    pub srcu_gp_seq_needed: ::std::os::raw::c_ulong,
    pub srcu_gp_seq_needed_exp: ::std::os::raw::c_ulong,
    pub srcu_gp_start: ::std::os::raw::c_ulong,
    pub srcu_last_gp_end: ::std::os::raw::c_ulong,
    pub srcu_size_jiffies: ::std::os::raw::c_ulong,
    pub srcu_n_lock_retries: ::std::os::raw::c_ulong,
    pub srcu_n_exp_nodelay: ::std::os::raw::c_ulong,
    pub sda: *mut srcu_data,
    pub sda_is_static: bool_,
    pub srcu_barrier_seq: ::std::os::raw::c_ulong,
    pub srcu_barrier_mutex: mutex,
    pub srcu_barrier_completion: completion,
    pub srcu_barrier_cpu_cnt: atomic_t,
    pub reschedule_jiffies: ::std::os::raw::c_ulong,
    pub reschedule_count: ::std::os::raw::c_ulong,
    pub work: delayed_work,
    pub dep_map: lockdep_map,
}
#[test]
fn bindgen_test_layout_srcu_struct() {
    assert_eq!(
        ::std::mem::size_of::<srcu_struct>(),
        384usize,
        concat!("Size of: ", stringify!(srcu_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<srcu_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(srcu_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_size_state as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_size_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_cb_mutex as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_cb_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_gp_mutex as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_idx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_gp_seq as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_gp_seq_needed as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_seq_needed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srcu_struct>())).srcu_gp_seq_needed_exp as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_seq_needed_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_gp_start as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_gp_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_last_gp_end as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_last_gp_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_size_jiffies as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_size_jiffies)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_n_lock_retries as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_n_lock_retries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_n_exp_nodelay as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_n_exp_nodelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).sda as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(sda)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).sda_is_static as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(sda_is_static)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_barrier_seq as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).srcu_barrier_mutex as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srcu_struct>())).srcu_barrier_completion as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_completion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<srcu_struct>())).srcu_barrier_cpu_cnt as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(srcu_barrier_cpu_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).reschedule_jiffies as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(reschedule_jiffies)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).reschedule_count as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(reschedule_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).work as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_struct>())).dep_map as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_struct),
            "::",
            stringify!(dep_map)
        )
    );
}
extern "C" {
    pub fn synchronize_srcu_expedited(ssp: *mut srcu_struct);
}
extern "C" {
    pub fn srcu_barrier(ssp: *mut srcu_struct);
}
extern "C" {
    pub fn srcu_torture_stats_print(
        ssp: *mut srcu_struct,
        tt: *mut ::std::os::raw::c_char,
        tf: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn call_srcu(
        ssp: *mut srcu_struct,
        head: *mut callback_head,
        func: ::std::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
    );
}
extern "C" {
    pub fn cleanup_srcu_struct(ssp: *mut srcu_struct);
}
extern "C" {
    pub fn __srcu_read_lock(ssp: *mut srcu_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __srcu_read_unlock(ssp: *mut srcu_struct, idx: ::std::os::raw::c_int);
}
extern "C" {
    pub fn synchronize_srcu(ssp: *mut srcu_struct);
}
extern "C" {
    pub fn get_state_synchronize_srcu(ssp: *mut srcu_struct) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn start_poll_synchronize_srcu(ssp: *mut srcu_struct) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn poll_state_synchronize_srcu(
        ssp: *mut srcu_struct,
        cookie: ::std::os::raw::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn srcu_init();
}
pub type notifier_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        nb: *mut notifier_block,
        action: ::std::os::raw::c_ulong,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct notifier_block {
    pub notifier_call: notifier_fn_t,
    pub next: *mut notifier_block,
    pub priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_notifier_block() {
    assert_eq!(
        ::std::mem::size_of::<notifier_block>(),
        24usize,
        concat!("Size of: ", stringify!(notifier_block))
    );
    assert_eq!(
        ::std::mem::align_of::<notifier_block>(),
        8usize,
        concat!("Alignment of ", stringify!(notifier_block))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<notifier_block>())).notifier_call as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(notifier_block),
            "::",
            stringify!(notifier_call)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<notifier_block>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(notifier_block),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<notifier_block>())).priority as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(notifier_block),
            "::",
            stringify!(priority)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct atomic_notifier_head {
    pub lock: spinlock_t,
    pub head: *mut notifier_block,
}
#[test]
fn bindgen_test_layout_atomic_notifier_head() {
    assert_eq!(
        ::std::mem::size_of::<atomic_notifier_head>(),
        16usize,
        concat!("Size of: ", stringify!(atomic_notifier_head))
    );
    assert_eq!(
        ::std::mem::align_of::<atomic_notifier_head>(),
        8usize,
        concat!("Alignment of ", stringify!(atomic_notifier_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atomic_notifier_head>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_notifier_head),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atomic_notifier_head>())).head as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_notifier_head),
            "::",
            stringify!(head)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blocking_notifier_head {
    pub rwsem: rw_semaphore,
    pub head: *mut notifier_block,
}
#[test]
fn bindgen_test_layout_blocking_notifier_head() {
    assert_eq!(
        ::std::mem::size_of::<blocking_notifier_head>(),
        48usize,
        concat!("Size of: ", stringify!(blocking_notifier_head))
    );
    assert_eq!(
        ::std::mem::align_of::<blocking_notifier_head>(),
        8usize,
        concat!("Alignment of ", stringify!(blocking_notifier_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<blocking_notifier_head>())).rwsem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blocking_notifier_head),
            "::",
            stringify!(rwsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<blocking_notifier_head>())).head as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(blocking_notifier_head),
            "::",
            stringify!(head)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raw_notifier_head {
    pub head: *mut notifier_block,
}
#[test]
fn bindgen_test_layout_raw_notifier_head() {
    assert_eq!(
        ::std::mem::size_of::<raw_notifier_head>(),
        8usize,
        concat!("Size of: ", stringify!(raw_notifier_head))
    );
    assert_eq!(
        ::std::mem::align_of::<raw_notifier_head>(),
        8usize,
        concat!("Alignment of ", stringify!(raw_notifier_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<raw_notifier_head>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(raw_notifier_head),
            "::",
            stringify!(head)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_notifier_head {
    pub mutex: mutex,
    pub srcu: srcu_struct,
    pub head: *mut notifier_block,
}
#[test]
fn bindgen_test_layout_srcu_notifier_head() {
    assert_eq!(
        ::std::mem::size_of::<srcu_notifier_head>(),
        424usize,
        concat!("Size of: ", stringify!(srcu_notifier_head))
    );
    assert_eq!(
        ::std::mem::align_of::<srcu_notifier_head>(),
        8usize,
        concat!("Alignment of ", stringify!(srcu_notifier_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_notifier_head>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_notifier_head),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_notifier_head>())).srcu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_notifier_head),
            "::",
            stringify!(srcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<srcu_notifier_head>())).head as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(srcu_notifier_head),
            "::",
            stringify!(head)
        )
    );
}
extern "C" {
    pub fn srcu_init_notifier_head(nh: *mut srcu_notifier_head);
}
extern "C" {
    pub fn atomic_notifier_chain_register(
        nh: *mut atomic_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blocking_notifier_chain_register(
        nh: *mut blocking_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raw_notifier_chain_register(
        nh: *mut raw_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srcu_notifier_chain_register(
        nh: *mut srcu_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_notifier_chain_register_unique_prio(
        nh: *mut atomic_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blocking_notifier_chain_register_unique_prio(
        nh: *mut blocking_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_notifier_chain_unregister(
        nh: *mut atomic_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blocking_notifier_chain_unregister(
        nh: *mut blocking_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raw_notifier_chain_unregister(
        nh: *mut raw_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srcu_notifier_chain_unregister(
        nh: *mut srcu_notifier_head,
        nb: *mut notifier_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_notifier_call_chain(
        nh: *mut atomic_notifier_head,
        val: ::std::os::raw::c_ulong,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blocking_notifier_call_chain(
        nh: *mut blocking_notifier_head,
        val: ::std::os::raw::c_ulong,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raw_notifier_call_chain(
        nh: *mut raw_notifier_head,
        val: ::std::os::raw::c_ulong,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srcu_notifier_call_chain(
        nh: *mut srcu_notifier_head,
        val: ::std::os::raw::c_ulong,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blocking_notifier_call_chain_robust(
        nh: *mut blocking_notifier_head,
        val_up: ::std::os::raw::c_ulong,
        val_down: ::std::os::raw::c_ulong,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raw_notifier_call_chain_robust(
        nh: *mut raw_notifier_head,
        val_up: ::std::os::raw::c_ulong,
        val_down: ::std::os::raw::c_ulong,
        v: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_notifier_call_chain_is_empty(nh: *mut atomic_notifier_head) -> bool_;
}
extern "C" {
    pub static mut reboot_notifier_list: blocking_notifier_head;
}
pub type uprobe_opcode_t = u8_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_xol_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_uprobe {
    pub __bindgen_anon_1: arch_uprobe__bindgen_ty_1,
    pub ops: *const uprobe_xol_ops,
    pub __bindgen_anon_2: arch_uprobe__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union arch_uprobe__bindgen_ty_1 {
    pub insn: [u8_; 16usize],
    pub ixol: [u8_; 16usize],
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_arch_uprobe__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<arch_uprobe__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(arch_uprobe__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<arch_uprobe__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(arch_uprobe__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_uprobe__bindgen_ty_1>())).insn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe__bindgen_ty_1),
            "::",
            stringify!(insn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_uprobe__bindgen_ty_1>())).ixol as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe__bindgen_ty_1),
            "::",
            stringify!(ixol)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union arch_uprobe__bindgen_ty_2 {
    pub branch: arch_uprobe__bindgen_ty_2__bindgen_ty_1,
    pub defparam: arch_uprobe__bindgen_ty_2__bindgen_ty_2,
    pub push: arch_uprobe__bindgen_ty_2__bindgen_ty_3,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_uprobe__bindgen_ty_2__bindgen_ty_1 {
    pub offs: s32,
    pub ilen: u8_,
    pub opc1: u8_,
}
#[test]
fn bindgen_test_layout_arch_uprobe__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<arch_uprobe__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(arch_uprobe__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<arch_uprobe__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(arch_uprobe__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<arch_uprobe__bindgen_ty_2__bindgen_ty_1>())).offs as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(offs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<arch_uprobe__bindgen_ty_2__bindgen_ty_1>())).ilen as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(ilen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<arch_uprobe__bindgen_ty_2__bindgen_ty_1>())).opc1 as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(opc1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_uprobe__bindgen_ty_2__bindgen_ty_2 {
    pub fixups: u8_,
    pub ilen: u8_,
}
#[test]
fn bindgen_test_layout_arch_uprobe__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<arch_uprobe__bindgen_ty_2__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(arch_uprobe__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<arch_uprobe__bindgen_ty_2__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(arch_uprobe__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<arch_uprobe__bindgen_ty_2__bindgen_ty_2>())).fixups as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(fixups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<arch_uprobe__bindgen_ty_2__bindgen_ty_2>())).ilen as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(ilen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_uprobe__bindgen_ty_2__bindgen_ty_3 {
    pub reg_offset: u8_,
    pub ilen: u8_,
}
#[test]
fn bindgen_test_layout_arch_uprobe__bindgen_ty_2__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<arch_uprobe__bindgen_ty_2__bindgen_ty_3>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(arch_uprobe__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<arch_uprobe__bindgen_ty_2__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(arch_uprobe__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<arch_uprobe__bindgen_ty_2__bindgen_ty_3>())).reg_offset
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(reg_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<arch_uprobe__bindgen_ty_2__bindgen_ty_3>())).ilen as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(ilen)
        )
    );
}
#[test]
fn bindgen_test_layout_arch_uprobe__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<arch_uprobe__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(arch_uprobe__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<arch_uprobe__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(arch_uprobe__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<arch_uprobe__bindgen_ty_2>())).branch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe__bindgen_ty_2),
            "::",
            stringify!(branch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<arch_uprobe__bindgen_ty_2>())).defparam as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe__bindgen_ty_2),
            "::",
            stringify!(defparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_uprobe__bindgen_ty_2>())).push as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe__bindgen_ty_2),
            "::",
            stringify!(push)
        )
    );
}
#[test]
fn bindgen_test_layout_arch_uprobe() {
    assert_eq!(
        ::std::mem::size_of::<arch_uprobe>(),
        32usize,
        concat!("Size of: ", stringify!(arch_uprobe))
    );
    assert_eq!(
        ::std::mem::align_of::<arch_uprobe>(),
        8usize,
        concat!("Alignment of ", stringify!(arch_uprobe))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_uprobe>())).ops as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe),
            "::",
            stringify!(ops)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_uprobe_task {
    pub saved_scratch_register: ::std::os::raw::c_ulong,
    pub saved_trap_nr: ::std::os::raw::c_uint,
    pub saved_tf: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_arch_uprobe_task() {
    assert_eq!(
        ::std::mem::size_of::<arch_uprobe_task>(),
        16usize,
        concat!("Size of: ", stringify!(arch_uprobe_task))
    );
    assert_eq!(
        ::std::mem::align_of::<arch_uprobe_task>(),
        8usize,
        concat!("Alignment of ", stringify!(arch_uprobe_task))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<arch_uprobe_task>())).saved_scratch_register as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe_task),
            "::",
            stringify!(saved_scratch_register)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_uprobe_task>())).saved_trap_nr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe_task),
            "::",
            stringify!(saved_trap_nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<arch_uprobe_task>())).saved_tf as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arch_uprobe_task),
            "::",
            stringify!(saved_tf)
        )
    );
}
pub const uprobe_task_state_UTASK_RUNNING: uprobe_task_state = 0;
pub const uprobe_task_state_UTASK_SSTEP: uprobe_task_state = 1;
pub const uprobe_task_state_UTASK_SSTEP_ACK: uprobe_task_state = 2;
pub const uprobe_task_state_UTASK_SSTEP_TRAPPED: uprobe_task_state = 3;
pub type uprobe_task_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe_task {
    pub state: uprobe_task_state,
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1,
    pub active_uprobe: *mut uprobe,
    pub xol_vaddr: ::std::os::raw::c_ulong,
    pub return_instances: *mut return_instance,
    pub depth: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uprobe_task__bindgen_ty_1 {
    pub __bindgen_anon_1: uprobe_task__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: uprobe_task__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_1 {
    pub autask: arch_uprobe_task,
    pub vaddr: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_uprobe_task__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uprobe_task__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uprobe_task__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_1>())).autask as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(autask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_1>())).vaddr as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(vaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe_task__bindgen_ty_1__bindgen_ty_2 {
    pub dup_xol_work: callback_head,
    pub dup_xol_addr: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_uprobe_task__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<uprobe_task__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<uprobe_task__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_2>())).dup_xol_work
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dup_xol_work)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<uprobe_task__bindgen_ty_1__bindgen_ty_2>())).dup_xol_addr
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dup_xol_addr)
        )
    );
}
#[test]
fn bindgen_test_layout_uprobe_task__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<uprobe_task__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(uprobe_task__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<uprobe_task__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(uprobe_task__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_uprobe_task() {
    assert_eq!(
        ::std::mem::size_of::<uprobe_task>(),
        64usize,
        concat!("Size of: ", stringify!(uprobe_task))
    );
    assert_eq!(
        ::std::mem::align_of::<uprobe_task>(),
        8usize,
        concat!("Alignment of ", stringify!(uprobe_task))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uprobe_task>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uprobe_task>())).active_uprobe as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(active_uprobe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uprobe_task>())).xol_vaddr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(xol_vaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uprobe_task>())).return_instances as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(return_instances)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uprobe_task>())).depth as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobe_task),
            "::",
            stringify!(depth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct return_instance {
    pub uprobe: *mut uprobe,
    pub func: ::std::os::raw::c_ulong,
    pub stack: ::std::os::raw::c_ulong,
    pub orig_ret_vaddr: ::std::os::raw::c_ulong,
    pub chained: bool_,
    pub next: *mut return_instance,
}
#[test]
fn bindgen_test_layout_return_instance() {
    assert_eq!(
        ::std::mem::size_of::<return_instance>(),
        48usize,
        concat!("Size of: ", stringify!(return_instance))
    );
    assert_eq!(
        ::std::mem::align_of::<return_instance>(),
        8usize,
        concat!("Alignment of ", stringify!(return_instance))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<return_instance>())).uprobe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(uprobe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<return_instance>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<return_instance>())).stack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<return_instance>())).orig_ret_vaddr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(orig_ret_vaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<return_instance>())).chained as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(chained)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<return_instance>())).next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(return_instance),
            "::",
            stringify!(next)
        )
    );
}
pub const rp_check_RP_CHECK_CALL: rp_check = 0;
pub const rp_check_RP_CHECK_CHAIN_CALL: rp_check = 1;
pub const rp_check_RP_CHECK_RET: rp_check = 2;
pub type rp_check = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xol_area {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobes_state {
    pub xol_area: *mut xol_area,
}
#[test]
fn bindgen_test_layout_uprobes_state() {
    assert_eq!(
        ::std::mem::size_of::<uprobes_state>(),
        8usize,
        concat!("Size of: ", stringify!(uprobes_state))
    );
    assert_eq!(
        ::std::mem::align_of::<uprobes_state>(),
        8usize,
        concat!("Alignment of ", stringify!(uprobes_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uprobes_state>())).xol_area as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uprobes_state),
            "::",
            stringify!(xol_area)
        )
    );
}
extern "C" {
    pub fn uprobes_init();
}
extern "C" {
    pub fn set_swbp(
        aup: *mut arch_uprobe,
        mm: *mut mm_struct,
        vaddr: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_orig_insn(
        aup: *mut arch_uprobe,
        mm: *mut mm_struct,
        vaddr: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_swbp_insn(insn: *mut uprobe_opcode_t) -> bool_;
}
extern "C" {
    pub fn is_trap_insn(insn: *mut uprobe_opcode_t) -> bool_;
}
extern "C" {
    pub fn uprobe_get_swbp_addr(regs: *mut pt_regs) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn uprobe_get_trap_addr(regs: *mut pt_regs) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn uprobe_write_opcode(
        auprobe: *mut arch_uprobe,
        mm: *mut mm_struct,
        vaddr: ::std::os::raw::c_ulong,
        arg1: uprobe_opcode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uprobe_register(
        inode: *mut inode,
        offset: loff_t,
        uc: *mut uprobe_consumer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uprobe_register_refctr(
        inode: *mut inode,
        offset: loff_t,
        ref_ctr_offset: loff_t,
        uc: *mut uprobe_consumer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uprobe_apply(
        inode: *mut inode,
        offset: loff_t,
        uc: *mut uprobe_consumer,
        arg1: bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uprobe_unregister(inode: *mut inode, offset: loff_t, uc: *mut uprobe_consumer);
}
extern "C" {
    pub fn uprobe_mmap(vma: *mut vm_area_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uprobe_munmap(
        vma: *mut vm_area_struct,
        start: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn uprobe_start_dup_mmap();
}
extern "C" {
    pub fn uprobe_end_dup_mmap();
}
extern "C" {
    pub fn uprobe_dup_mmap(oldmm: *mut mm_struct, newmm: *mut mm_struct);
}
extern "C" {
    pub fn uprobe_free_utask(t: *mut task_struct);
}
extern "C" {
    pub fn uprobe_copy_process(t: *mut task_struct, flags: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn uprobe_post_sstep_notifier(regs: *mut pt_regs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uprobe_pre_sstep_notifier(regs: *mut pt_regs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uprobe_notify_resume(regs: *mut pt_regs);
}
extern "C" {
    pub fn uprobe_deny_signal() -> bool_;
}
extern "C" {
    pub fn arch_uprobe_skip_sstep(aup: *mut arch_uprobe, regs: *mut pt_regs) -> bool_;
}
extern "C" {
    pub fn uprobe_clear_state(mm: *mut mm_struct);
}
extern "C" {
    pub fn arch_uprobe_analyze_insn(
        aup: *mut arch_uprobe,
        mm: *mut mm_struct,
        addr: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_uprobe_pre_xol(aup: *mut arch_uprobe, regs: *mut pt_regs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_uprobe_post_xol(aup: *mut arch_uprobe, regs: *mut pt_regs)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_uprobe_xol_was_trapped(tsk: *mut task_struct) -> bool_;
}
extern "C" {
    pub fn arch_uprobe_exception_notify(
        self_: *mut notifier_block,
        val: ::std::os::raw::c_ulong,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_uprobe_abort_xol(aup: *mut arch_uprobe, regs: *mut pt_regs);
}
extern "C" {
    pub fn arch_uretprobe_hijack_return_addr(
        trampoline_vaddr: ::std::os::raw::c_ulong,
        regs: *mut pt_regs,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn arch_uretprobe_is_alive(
        ret: *mut return_instance,
        ctx: rp_check,
        regs: *mut pt_regs,
    ) -> bool_;
}
extern "C" {
    pub fn arch_uprobe_ignore(aup: *mut arch_uprobe, regs: *mut pt_regs) -> bool_;
}
extern "C" {
    pub fn arch_uprobe_copy_ixol(
        page: *mut page,
        vaddr: ::std::os::raw::c_ulong,
        src: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_ulong,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_context_t {
    pub ctx_id: u64_,
    pub tlb_gen: atomic64_t,
    pub ldt_usr_sem: rw_semaphore,
    pub ldt: *mut ldt_struct,
    pub flags: ::std::os::raw::c_ushort,
    pub lock: mutex,
    pub vdso: *mut ::std::os::raw::c_void,
    pub vdso_image: *mut vdso_image,
    pub perf_rdpmc_allowed: atomic_t,
    pub pkey_allocation_map: u16_,
    pub execute_only_pkey: s16,
}
#[test]
fn bindgen_test_layout_mm_context_t() {
    assert_eq!(
        ::std::mem::size_of::<mm_context_t>(),
        128usize,
        concat!("Size of: ", stringify!(mm_context_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mm_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_context_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).ctx_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ctx_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).tlb_gen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(tlb_gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).ldt_usr_sem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ldt_usr_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).ldt as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(ldt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).vdso as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(vdso)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).vdso_image as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(vdso_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).perf_rdpmc_allowed as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(perf_rdpmc_allowed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_context_t>())).pkey_allocation_map as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(pkey_allocation_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_context_t>())).execute_only_pkey as *const _ as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_context_t),
            "::",
            stringify!(execute_only_pkey)
        )
    );
}
extern "C" {
    pub fn leave_mm(cpu: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_cgroup {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct page {
    pub flags: ::std::os::raw::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_2,
    pub _refcount: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: page__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: page__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: page__bindgen_ty_1__bindgen_ty_5,
    pub __bindgen_anon_6: page__bindgen_ty_1__bindgen_ty_6,
    pub callback_head: callback_head,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub mapping: *mut address_space,
    pub index: ::std::os::raw::c_ulong,
    #[doc = " @private: Mapping-private opaque data."]
    #[doc = " Usually used for buffer_heads if PagePrivate."]
    #[doc = " Used for swp_entry_t if PageSwapCache."]
    #[doc = " Indicates order in the buddy system if PageBuddy."]
    pub private: ::std::os::raw::c_ulong,
}
#[doc = " @lru: Pageout list, eg. active_list protected by"]
#[doc = " lruvec->lru_lock.  Sometimes used as a generic list"]
#[doc = " by the page owner."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub lru: list_head,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub buddy_list: list_head,
    pub pcp_list: list_head,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __filler: *mut ::std::os::raw::c_void,
    pub mlock_count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
                .__filler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__filler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
                .mlock_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(mlock_count)
        )
    );
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).lru
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lru)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).buddy_list
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(buddy_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).pcp_list
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pcp_list)
        )
    );
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<page__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<page__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_1>())).mapping as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_1>())).index as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_1>())).private as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(private)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " @pp_magic: magic value to avoid recycling non"]
    #[doc = " page_pool allocated pages."]
    pub pp_magic: ::std::os::raw::c_ulong,
    pub pp: *mut page_pool,
    pub _pp_mapping_pad: ::std::os::raw::c_ulong,
    pub dma_addr: ::std::os::raw::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[doc = " dma_addr_upper: might require a 64-bit"]
    #[doc = " value on 32-bit architectures."]
    pub dma_addr_upper: ::std::os::raw::c_ulong,
    #[doc = " For frag page support, not supported in"]
    #[doc = " 32-bit architectures with 64-bit DMA."]
    pub pp_frag_count: atomic_long_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()))
                .dma_addr_upper as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(dma_addr_upper)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>())).pp_frag_count
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(pp_frag_count)
        )
    );
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<page__bindgen_ty_1__bindgen_ty_2>(),
        40usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<page__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_2>())).pp_magic as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(pp_magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_2>())).pp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(pp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_2>()))._pp_mapping_pad as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_pp_mapping_pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_2>())).dma_addr as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dma_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_3 {
    pub compound_head: ::std::os::raw::c_ulong,
    pub compound_dtor: ::std::os::raw::c_uchar,
    pub compound_order: ::std::os::raw::c_uchar,
    pub compound_mapcount: atomic_t,
    pub compound_pincount: atomic_t,
    pub compound_nr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<page__bindgen_ty_1__bindgen_ty_3>(),
        24usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<page__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_3>())).compound_head as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(compound_head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_3>())).compound_dtor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(compound_dtor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_3>())).compound_order as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(compound_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_3>())).compound_mapcount
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(compound_mapcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_3>())).compound_pincount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(compound_pincount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_3>())).compound_nr as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(compound_nr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_4 {
    pub _compound_pad_1: ::std::os::raw::c_ulong,
    pub _compound_pad_2: ::std::os::raw::c_ulong,
    pub deferred_list: list_head,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<page__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<page__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_4>()))._compound_pad_1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_compound_pad_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_4>()))._compound_pad_2 as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(_compound_pad_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_4>())).deferred_list as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(deferred_list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_5 {
    pub _pt_pad_1: ::std::os::raw::c_ulong,
    pub pmd_huge_pte: pgtable_t,
    pub _pt_pad_2: ::std::os::raw::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
    pub ptl: spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub pt_mm: *mut mm_struct,
    pub pt_frag_refcount: atomic_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>())).pt_mm
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(pt_mm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))
                .pt_frag_refcount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(pt_frag_refcount)
        )
    );
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<page__bindgen_ty_1__bindgen_ty_5>(),
        40usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<page__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_5>()))._pt_pad_1 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_pt_pad_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_5>())).pmd_huge_pte as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(pmd_huge_pte)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_5>()))._pt_pad_2 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_pt_pad_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_5>())).ptl as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(ptl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_6 {
    #[doc = " @pgmap: Points to the hosting device page map."]
    pub pgmap: *mut dev_pagemap,
    pub zone_device_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<page__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<page__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_6>())).pgmap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(pgmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1__bindgen_ty_6>())).zone_device_data
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(zone_device_data)
        )
    );
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<page__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<page__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(page__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<page__bindgen_ty_1>())).callback_head as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_1),
            "::",
            stringify!(callback_head)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_2 {
    pub _mapcount: atomic_t,
    pub page_type: ::std::os::raw::c_uint,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_page__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<page__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(page__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<page__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(page__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<page__bindgen_ty_2>()))._mapcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_2),
            "::",
            stringify!(_mapcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<page__bindgen_ty_2>())).page_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page__bindgen_ty_2),
            "::",
            stringify!(page_type)
        )
    );
}
#[test]
fn bindgen_test_layout_page() {
    assert_eq!(
        ::std::mem::size_of::<page>(),
        64usize,
        concat!("Size of: ", stringify!(page))
    );
    assert_eq!(
        ::std::mem::align_of::<page>(),
        16usize,
        concat!("Alignment of ", stringify!(page))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<page>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<page>()))._refcount as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(page),
            "::",
            stringify!(_refcount)
        )
    );
}
#[doc = " struct folio - Represents a contiguous set of bytes."]
#[doc = " @flags: Identical to the page flags."]
#[doc = " @lru: Least Recently Used list; tracks how recently this folio was used."]
#[doc = " @mlock_count: Number of times this folio has been pinned by mlock()."]
#[doc = " @mapping: The file this page belongs to, or refers to the anon_vma for"]
#[doc = "    anonymous memory."]
#[doc = " @index: Offset within the file, in units of pages.  For anonymous memory,"]
#[doc = "    this is the index from the beginning of the mmap."]
#[doc = " @private: Filesystem per-folio data (see folio_attach_private())."]
#[doc = "    Used for swp_entry_t if folio_test_swapcache()."]
#[doc = " @_mapcount: Do not access this member directly.  Use folio_mapcount() to"]
#[doc = "    find out how many times this folio is mapped by userspace."]
#[doc = " @_refcount: Do not access this member directly.  Use folio_ref_count()"]
#[doc = "    to find how many references there are to this folio."]
#[doc = " @memcg_data: Memory Control Group data."]
#[doc = " @_flags_1: For large folios, additional page flags."]
#[doc = " @__head: Points to the folio.  Do not use."]
#[doc = " @_folio_dtor: Which destructor to use for this folio."]
#[doc = " @_folio_order: Do not use directly, call folio_order()."]
#[doc = " @_total_mapcount: Do not use directly, call folio_entire_mapcount()."]
#[doc = " @_pincount: Do not use directly, call folio_maybe_dma_pinned()."]
#[doc = " @_folio_nr_pages: Do not use directly, call folio_nr_pages()."]
#[doc = ""]
#[doc = " A folio is a physically, virtually and logically contiguous set"]
#[doc = " of bytes.  It is a power-of-two in size, and it is aligned to that"]
#[doc = " same power-of-two.  It is at least as large as %PAGE_SIZE.  If it is"]
#[doc = " in the page cache, it is at a file offset which is a multiple of that"]
#[doc = " power-of-two.  It may be mapped into userspace at an address which is"]
#[doc = " at an arbitrary page offset, but its kernel virtual address is aligned"]
#[doc = " to its size."]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct folio {
    pub __bindgen_anon_1: folio__bindgen_ty_1,
    pub _flags_1: ::std::os::raw::c_ulong,
    pub __head: ::std::os::raw::c_ulong,
    pub _folio_dtor: ::std::os::raw::c_uchar,
    pub _folio_order: ::std::os::raw::c_uchar,
    pub _total_mapcount: atomic_t,
    pub _pincount: atomic_t,
    pub _folio_nr_pages: ::std::os::raw::c_uint,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1 {
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1,
    pub page: page,
    _bindgen_union_align: [u128; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_1__bindgen_ty_1 {
    pub flags: ::std::os::raw::c_ulong,
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub mapping: *mut address_space,
    pub index: ::std::os::raw::c_ulong,
    pub private: *mut ::std::os::raw::c_void,
    pub _mapcount: atomic_t,
    pub _refcount: atomic_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub lru: list_head,
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __filler: *mut ::std::os::raw::c_void,
    pub mlock_count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
            )))
            .__filler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__filler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
            )))
            .mlock_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(mlock_count)
        )
    );
}
#[test]
fn bindgen_test_layout_folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>())).lru
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lru)
        )
    );
}
#[test]
fn bindgen_test_layout_folio__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<folio__bindgen_ty_1__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(folio__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<folio__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(folio__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(folio__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1>())).mapping as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(folio__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1>())).index as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(folio__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1>())).private as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(folio__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(private)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1>()))._mapcount as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(folio__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mapcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<folio__bindgen_ty_1__bindgen_ty_1>()))._refcount as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(folio__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_refcount)
        )
    );
}
#[test]
fn bindgen_test_layout_folio__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<folio__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(folio__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<folio__bindgen_ty_1>(),
        16usize,
        concat!("Alignment of ", stringify!(folio__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<folio__bindgen_ty_1>())).page as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(folio__bindgen_ty_1),
            "::",
            stringify!(page)
        )
    );
}
#[test]
fn bindgen_test_layout_folio() {
    assert_eq!(
        ::std::mem::size_of::<folio>(),
        96usize,
        concat!("Size of: ", stringify!(folio))
    );
    assert_eq!(
        ::std::mem::align_of::<folio>(),
        16usize,
        concat!("Alignment of ", stringify!(folio))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<folio>()))._flags_1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(folio),
            "::",
            stringify!(_flags_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<folio>())).__head as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(folio),
            "::",
            stringify!(__head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<folio>()))._folio_dtor as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(folio),
            "::",
            stringify!(_folio_dtor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<folio>()))._folio_order as *const _ as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(folio),
            "::",
            stringify!(_folio_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<folio>()))._total_mapcount as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(folio),
            "::",
            stringify!(_total_mapcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<folio>()))._pincount as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(folio),
            "::",
            stringify!(_pincount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<folio>()))._folio_nr_pages as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(folio),
            "::",
            stringify!(_folio_nr_pages)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_frag_cache {
    pub va: *mut ::std::os::raw::c_void,
    pub offset: __u16,
    pub size: __u16,
    pub pagecnt_bias: ::std::os::raw::c_uint,
    pub pfmemalloc: bool_,
}
#[test]
fn bindgen_test_layout_page_frag_cache() {
    assert_eq!(
        ::std::mem::size_of::<page_frag_cache>(),
        24usize,
        concat!("Size of: ", stringify!(page_frag_cache))
    );
    assert_eq!(
        ::std::mem::align_of::<page_frag_cache>(),
        8usize,
        concat!("Alignment of ", stringify!(page_frag_cache))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<page_frag_cache>())).va as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag_cache),
            "::",
            stringify!(va)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<page_frag_cache>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag_cache),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<page_frag_cache>())).size as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag_cache),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<page_frag_cache>())).pagecnt_bias as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag_cache),
            "::",
            stringify!(pagecnt_bias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<page_frag_cache>())).pfmemalloc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(page_frag_cache),
            "::",
            stringify!(pfmemalloc)
        )
    );
}
pub type vm_flags_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_region {
    pub vm_rb: rb_node,
    pub vm_flags: vm_flags_t,
    pub vm_start: ::std::os::raw::c_ulong,
    pub vm_end: ::std::os::raw::c_ulong,
    pub vm_top: ::std::os::raw::c_ulong,
    pub vm_pgoff: ::std::os::raw::c_ulong,
    pub vm_file: *mut file,
    pub vm_usage: ::std::os::raw::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_vm_region() {
    assert_eq!(
        ::std::mem::size_of::<vm_region>(),
        80usize,
        concat!("Size of: ", stringify!(vm_region))
    );
    assert_eq!(
        ::std::mem::align_of::<vm_region>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_region))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_region>())).vm_rb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_region),
            "::",
            stringify!(vm_rb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_region>())).vm_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_region),
            "::",
            stringify!(vm_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_region>())).vm_start as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_region),
            "::",
            stringify!(vm_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_region>())).vm_end as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_region),
            "::",
            stringify!(vm_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_region>())).vm_top as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_region),
            "::",
            stringify!(vm_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_region>())).vm_pgoff as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_region),
            "::",
            stringify!(vm_pgoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_region>())).vm_file as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_region),
            "::",
            stringify!(vm_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_region>())).vm_usage as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_region),
            "::",
            stringify!(vm_usage)
        )
    );
}
impl vm_region {
    #[inline]
    pub fn vm_icache_flushed(&self) -> bool_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vm_icache_flushed(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(vm_icache_flushed: bool_) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vm_icache_flushed: u8 = unsafe { ::std::mem::transmute(vm_icache_flushed) };
            vm_icache_flushed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_userfaultfd_ctx {}
#[test]
fn bindgen_test_layout_vm_userfaultfd_ctx() {
    assert_eq!(
        ::std::mem::size_of::<vm_userfaultfd_ctx>(),
        0usize,
        concat!("Size of: ", stringify!(vm_userfaultfd_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<vm_userfaultfd_ctx>(),
        1usize,
        concat!("Alignment of ", stringify!(vm_userfaultfd_ctx))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct anon_vma_name {
    pub kref: kref,
    pub name: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_anon_vma_name() {
    assert_eq!(
        ::std::mem::size_of::<anon_vma_name>(),
        4usize,
        concat!("Size of: ", stringify!(anon_vma_name))
    );
    assert_eq!(
        ::std::mem::align_of::<anon_vma_name>(),
        4usize,
        concat!("Alignment of ", stringify!(anon_vma_name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anon_vma_name>())).kref as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(anon_vma_name),
            "::",
            stringify!(kref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<anon_vma_name>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(anon_vma_name),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_area_struct {
    pub vm_start: ::std::os::raw::c_ulong,
    pub vm_end: ::std::os::raw::c_ulong,
    pub vm_mm: *mut mm_struct,
    pub vm_page_prot: pgprot_t,
    pub vm_flags: ::std::os::raw::c_ulong,
    pub __bindgen_anon_1: vm_area_struct__bindgen_ty_1,
    pub anon_vma_chain: list_head,
    pub anon_vma: *mut anon_vma,
    pub vm_ops: *mut vm_operations_struct,
    pub vm_pgoff: ::std::os::raw::c_ulong,
    pub vm_file: *mut file,
    pub vm_private_data: *mut ::std::os::raw::c_void,
    pub swap_readahead_info: atomic_long_t,
    pub vm_policy: *mut mempolicy,
    pub vm_userfaultfd_ctx: vm_userfaultfd_ctx,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_area_struct__bindgen_ty_1 {
    pub shared: vm_area_struct__bindgen_ty_1__bindgen_ty_1,
    pub anon_name: *mut anon_vma_name,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_area_struct__bindgen_ty_1__bindgen_ty_1 {
    pub rb: rb_node,
    pub rb_subtree_last: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_vm_area_struct__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vm_area_struct__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(vm_area_struct__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<vm_area_struct__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vm_area_struct__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vm_area_struct__bindgen_ty_1__bindgen_ty_1>())).rb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vm_area_struct__bindgen_ty_1__bindgen_ty_1>())).rb_subtree_last
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rb_subtree_last)
        )
    );
}
#[test]
fn bindgen_test_layout_vm_area_struct__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vm_area_struct__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(vm_area_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vm_area_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_area_struct__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vm_area_struct__bindgen_ty_1>())).shared as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct__bindgen_ty_1),
            "::",
            stringify!(shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vm_area_struct__bindgen_ty_1>())).anon_name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct__bindgen_ty_1),
            "::",
            stringify!(anon_name)
        )
    );
}
#[test]
fn bindgen_test_layout_vm_area_struct() {
    assert_eq!(
        ::std::mem::size_of::<vm_area_struct>(),
        144usize,
        concat!("Size of: ", stringify!(vm_area_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<vm_area_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_area_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_area_struct>())).vm_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_area_struct>())).vm_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_area_struct>())).vm_mm as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_area_struct>())).vm_page_prot as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_page_prot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_area_struct>())).vm_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_area_struct>())).anon_vma_chain as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(anon_vma_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_area_struct>())).anon_vma as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(anon_vma)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_area_struct>())).vm_ops as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_area_struct>())).vm_pgoff as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_pgoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_area_struct>())).vm_file as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_area_struct>())).vm_private_data as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_private_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vm_area_struct>())).swap_readahead_info as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(swap_readahead_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_area_struct>())).vm_policy as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_policy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vm_area_struct>())).vm_userfaultfd_ctx as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_area_struct),
            "::",
            stringify!(vm_userfaultfd_ctx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kioctx_table {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct mm_struct {
    pub __bindgen_anon_1: mm_struct__bindgen_ty_1,
    pub cpu_bitmap: __IncompleteArrayField<::std::os::raw::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_struct__bindgen_ty_1 {
    pub mm_mt: maple_tree,
    pub get_unmapped_area: ::std::option::Option<
        unsafe extern "C" fn(
            filp: *mut file,
            addr: ::std::os::raw::c_ulong,
            len: ::std::os::raw::c_ulong,
            pgoff: ::std::os::raw::c_ulong,
            flags: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong,
    >,
    pub mmap_base: ::std::os::raw::c_ulong,
    pub mmap_legacy_base: ::std::os::raw::c_ulong,
    pub mmap_compat_base: ::std::os::raw::c_ulong,
    pub mmap_compat_legacy_base: ::std::os::raw::c_ulong,
    pub task_size: ::std::os::raw::c_ulong,
    pub pgd: *mut pgd_t,
    #[doc = " @membarrier_state: Flags controlling membarrier behavior."]
    #[doc = ""]
    #[doc = " This field is close to @pgd to hopefully fit in the same"]
    #[doc = " cache-line, which needs to be touched by switch_mm()."]
    pub membarrier_state: atomic_t,
    #[doc = " @mm_users: The number of users including userspace."]
    #[doc = ""]
    #[doc = " Use mmget()/mmget_not_zero()/mmput() to modify. When this"]
    #[doc = " drops to 0 (i.e. when the task exits and there are no other"]
    #[doc = " temporary reference holders), we also release a reference on"]
    #[doc = " @mm_count (which may then free the &struct mm_struct if"]
    #[doc = " @mm_count also drops to 0)."]
    pub mm_users: atomic_t,
    #[doc = " @mm_count: The number of references to &struct mm_struct"]
    #[doc = " (@mm_users count as 1)."]
    #[doc = ""]
    #[doc = " Use mmgrab()/mmdrop() to modify. When this drops to 0, the"]
    #[doc = " &struct mm_struct is freed."]
    pub mm_count: atomic_t,
    pub pgtables_bytes: atomic_long_t,
    pub map_count: ::std::os::raw::c_int,
    pub page_table_lock: spinlock_t,
    pub mmap_lock: rw_semaphore,
    pub mmlist: list_head,
    pub hiwater_rss: ::std::os::raw::c_ulong,
    pub hiwater_vm: ::std::os::raw::c_ulong,
    pub total_vm: ::std::os::raw::c_ulong,
    pub locked_vm: ::std::os::raw::c_ulong,
    pub pinned_vm: atomic64_t,
    pub data_vm: ::std::os::raw::c_ulong,
    pub exec_vm: ::std::os::raw::c_ulong,
    pub stack_vm: ::std::os::raw::c_ulong,
    pub def_flags: ::std::os::raw::c_ulong,
    #[doc = " @write_protect_seq: Locked when any thread is write"]
    #[doc = " protecting pages mapped by this mm to enforce a later COW,"]
    #[doc = " for instance during page table copying for fork()."]
    pub write_protect_seq: seqcount_t,
    pub arg_lock: spinlock_t,
    pub start_code: ::std::os::raw::c_ulong,
    pub end_code: ::std::os::raw::c_ulong,
    pub start_data: ::std::os::raw::c_ulong,
    pub end_data: ::std::os::raw::c_ulong,
    pub start_brk: ::std::os::raw::c_ulong,
    pub brk: ::std::os::raw::c_ulong,
    pub start_stack: ::std::os::raw::c_ulong,
    pub arg_start: ::std::os::raw::c_ulong,
    pub arg_end: ::std::os::raw::c_ulong,
    pub env_start: ::std::os::raw::c_ulong,
    pub env_end: ::std::os::raw::c_ulong,
    pub saved_auxv: [::std::os::raw::c_ulong; 48usize],
    pub rss_stat: mm_rss_stat,
    pub binfmt: *mut linux_binfmt,
    pub context: mm_context_t,
    pub flags: ::std::os::raw::c_ulong,
    pub ioctx_lock: spinlock_t,
    pub ioctx_table: *mut kioctx_table,
    pub user_ns: *mut user_namespace,
    pub exe_file: *mut file,
    pub notifier_subscriptions: *mut mmu_notifier_subscriptions,
    pub tlb_flush_pending: atomic_t,
    pub tlb_flush_batched: atomic_t,
    pub uprobes_state: uprobes_state,
    pub hugetlb_usage: atomic_long_t,
    pub async_put_work: work_struct,
}
#[test]
fn bindgen_test_layout_mm_struct__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mm_struct__bindgen_ty_1>(),
        992usize,
        concat!("Size of: ", stringify!(mm_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mm_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_struct__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).mm_mt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mm_mt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).get_unmapped_area as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(get_unmapped_area)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_base as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_legacy_base as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap_legacy_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_compat_base as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap_compat_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_compat_legacy_base as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap_compat_legacy_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).task_size as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(task_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).pgd as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(pgd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).membarrier_state as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(membarrier_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).mm_users as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mm_users)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).mm_count as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mm_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).pgtables_bytes as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(pgtables_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).map_count as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(map_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).page_table_lock as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(page_table_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).mmap_lock as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmap_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).mmlist as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(mmlist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).hiwater_rss as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(hiwater_rss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).hiwater_vm as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(hiwater_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).total_vm as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(total_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).locked_vm as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(locked_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).pinned_vm as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(pinned_vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).data_vm as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(data_vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).exec_vm as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(exec_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).stack_vm as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(stack_vm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).def_flags as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(def_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).write_protect_seq as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(write_protect_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).arg_lock as *const _ as usize
        },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(arg_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).start_code as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(start_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).end_code as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(end_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).start_data as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(start_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).end_data as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(end_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).start_brk as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(start_brk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).brk as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(brk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).start_stack as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(start_stack)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).arg_start as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(arg_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).arg_end as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(arg_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).env_start as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(env_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).env_end as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(env_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).saved_auxv as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(saved_auxv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).rss_stat as *const _ as usize
        },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(rss_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).binfmt as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(binfmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).context as *const _ as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).flags as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).ioctx_lock as *const _ as usize
        },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(ioctx_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).ioctx_table as *const _ as usize
        },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(ioctx_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).user_ns as *const _ as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(user_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).exe_file as *const _ as usize
        },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(exe_file)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).notifier_subscriptions as *const _
                as usize
        },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(notifier_subscriptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).tlb_flush_pending as *const _
                as usize
        },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(tlb_flush_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).tlb_flush_batched as *const _
                as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(tlb_flush_batched)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).uprobes_state as *const _ as usize
        },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(uprobes_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).hugetlb_usage as *const _ as usize
        },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(hugetlb_usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mm_struct__bindgen_ty_1>())).async_put_work as *const _ as usize
        },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct__bindgen_ty_1),
            "::",
            stringify!(async_put_work)
        )
    );
}
#[test]
fn bindgen_test_layout_mm_struct() {
    assert_eq!(
        ::std::mem::size_of::<mm_struct>(),
        992usize,
        concat!("Size of: ", stringify!(mm_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<mm_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(mm_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mm_struct>())).cpu_bitmap as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(mm_struct),
            "::",
            stringify!(cpu_bitmap)
        )
    );
}
extern "C" {
    pub static mut init_mm: mm_struct;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vma_iterator {
    pub mas: ma_state,
}
#[test]
fn bindgen_test_layout_vma_iterator() {
    assert_eq!(
        ::std::mem::size_of::<vma_iterator>(),
        64usize,
        concat!("Size of: ", stringify!(vma_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<vma_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(vma_iterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vma_iterator>())).mas as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vma_iterator),
            "::",
            stringify!(mas)
        )
    );
}
extern "C" {
    pub fn tlb_gather_mmu(tlb: *mut mmu_gather, mm: *mut mm_struct);
}
extern "C" {
    pub fn tlb_gather_mmu_fullmm(tlb: *mut mmu_gather, mm: *mut mm_struct);
}
extern "C" {
    pub fn tlb_finish_mmu(tlb: *mut mmu_gather);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_fault {
    _unused: [u8; 0],
}
#[doc = " typedef vm_fault_t - Return type for page fault handlers."]
#[doc = ""]
#[doc = " Page fault handlers return a bitmask of %VM_FAULT values."]
pub type vm_fault_t = ::std::os::raw::c_uint;
pub const vm_fault_reason_VM_FAULT_OOM: vm_fault_reason = 1;
pub const vm_fault_reason_VM_FAULT_SIGBUS: vm_fault_reason = 2;
pub const vm_fault_reason_VM_FAULT_MAJOR: vm_fault_reason = 4;
pub const vm_fault_reason_VM_FAULT_WRITE: vm_fault_reason = 8;
pub const vm_fault_reason_VM_FAULT_HWPOISON: vm_fault_reason = 16;
pub const vm_fault_reason_VM_FAULT_HWPOISON_LARGE: vm_fault_reason = 32;
pub const vm_fault_reason_VM_FAULT_SIGSEGV: vm_fault_reason = 64;
pub const vm_fault_reason_VM_FAULT_NOPAGE: vm_fault_reason = 256;
pub const vm_fault_reason_VM_FAULT_LOCKED: vm_fault_reason = 512;
pub const vm_fault_reason_VM_FAULT_RETRY: vm_fault_reason = 1024;
pub const vm_fault_reason_VM_FAULT_FALLBACK: vm_fault_reason = 2048;
pub const vm_fault_reason_VM_FAULT_DONE_COW: vm_fault_reason = 4096;
pub const vm_fault_reason_VM_FAULT_NEEDDSYNC: vm_fault_reason = 8192;
pub const vm_fault_reason_VM_FAULT_COMPLETED: vm_fault_reason = 16384;
pub const vm_fault_reason_VM_FAULT_HINDEX_MASK: vm_fault_reason = 983040;
#[doc = " enum vm_fault_reason - Page fault handlers return a bitmask of"]
#[doc = " these values to tell the core VM what happened when handling the"]
#[doc = " fault. Used to decide whether a process gets delivered SIGBUS or"]
#[doc = " just gets major/minor fault counters bumped up."]
#[doc = ""]
#[doc = " @VM_FAULT_OOM:\t\tOut Of Memory"]
#[doc = " @VM_FAULT_SIGBUS:\t\tBad access"]
#[doc = " @VM_FAULT_MAJOR:\t\tPage read from storage"]
#[doc = " @VM_FAULT_WRITE:\t\tSpecial case for get_user_pages"]
#[doc = " @VM_FAULT_HWPOISON:\t\tHit poisoned small page"]
#[doc = " @VM_FAULT_HWPOISON_LARGE:\tHit poisoned large page. Index encoded"]
#[doc = "\t\t\t\tin upper bits"]
#[doc = " @VM_FAULT_SIGSEGV:\t\tsegmentation fault"]
#[doc = " @VM_FAULT_NOPAGE:\t\t->fault installed the pte, not return page"]
#[doc = " @VM_FAULT_LOCKED:\t\t->fault locked the returned page"]
#[doc = " @VM_FAULT_RETRY:\t\t->fault blocked, must retry"]
#[doc = " @VM_FAULT_FALLBACK:\t\thuge page fault failed, fall back to small"]
#[doc = " @VM_FAULT_DONE_COW:\t\t->fault has fully handled COW"]
#[doc = " @VM_FAULT_NEEDDSYNC:\t\t->fault did not modify page tables and needs"]
#[doc = "\t\t\t\tfsync() to complete (for synchronous page faults"]
#[doc = "\t\t\t\tin DAX)"]
#[doc = " @VM_FAULT_COMPLETED:\t\t->fault completed, meanwhile mmap lock released"]
#[doc = " @VM_FAULT_HINDEX_MASK:\tmask HINDEX value"]
#[doc = ""]
pub type vm_fault_reason = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_special_mapping {
    pub name: *const ::std::os::raw::c_char,
    pub pages: *mut *mut page,
    pub fault: ::std::option::Option<
        unsafe extern "C" fn(
            sm: *const vm_special_mapping,
            vma: *mut vm_area_struct,
            vmf: *mut vm_fault,
        ) -> vm_fault_t,
    >,
    pub mremap: ::std::option::Option<
        unsafe extern "C" fn(
            sm: *const vm_special_mapping,
            new_vma: *mut vm_area_struct,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_vm_special_mapping() {
    assert_eq!(
        ::std::mem::size_of::<vm_special_mapping>(),
        32usize,
        concat!("Size of: ", stringify!(vm_special_mapping))
    );
    assert_eq!(
        ::std::mem::align_of::<vm_special_mapping>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_special_mapping))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_special_mapping>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_special_mapping),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_special_mapping>())).pages as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_special_mapping),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_special_mapping>())).fault as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_special_mapping),
            "::",
            stringify!(fault)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_special_mapping>())).mremap as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_special_mapping),
            "::",
            stringify!(mremap)
        )
    );
}
pub const tlb_flush_reason_TLB_FLUSH_ON_TASK_SWITCH: tlb_flush_reason = 0;
pub const tlb_flush_reason_TLB_REMOTE_SHOOTDOWN: tlb_flush_reason = 1;
pub const tlb_flush_reason_TLB_LOCAL_SHOOTDOWN: tlb_flush_reason = 2;
pub const tlb_flush_reason_TLB_LOCAL_MM_SHOOTDOWN: tlb_flush_reason = 3;
pub const tlb_flush_reason_TLB_REMOTE_SEND_IPI: tlb_flush_reason = 4;
pub const tlb_flush_reason_NR_TLB_FLUSH_REASONS: tlb_flush_reason = 5;
pub type tlb_flush_reason = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swp_entry_t {
    pub val: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_swp_entry_t() {
    assert_eq!(
        ::std::mem::size_of::<swp_entry_t>(),
        8usize,
        concat!("Size of: ", stringify!(swp_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<swp_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(swp_entry_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<swp_entry_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(swp_entry_t),
            "::",
            stringify!(val)
        )
    );
}
pub const fault_flag_FAULT_FLAG_WRITE: fault_flag = 1;
pub const fault_flag_FAULT_FLAG_MKWRITE: fault_flag = 2;
pub const fault_flag_FAULT_FLAG_ALLOW_RETRY: fault_flag = 4;
pub const fault_flag_FAULT_FLAG_RETRY_NOWAIT: fault_flag = 8;
pub const fault_flag_FAULT_FLAG_KILLABLE: fault_flag = 16;
pub const fault_flag_FAULT_FLAG_TRIED: fault_flag = 32;
pub const fault_flag_FAULT_FLAG_USER: fault_flag = 64;
pub const fault_flag_FAULT_FLAG_REMOTE: fault_flag = 128;
pub const fault_flag_FAULT_FLAG_INSTRUCTION: fault_flag = 256;
pub const fault_flag_FAULT_FLAG_INTERRUPTIBLE: fault_flag = 512;
pub const fault_flag_FAULT_FLAG_UNSHARE: fault_flag = 1024;
pub const fault_flag_FAULT_FLAG_ORIG_PTE_VALID: fault_flag = 2048;
#[doc = " enum fault_flag - Fault flag definitions."]
#[doc = " @FAULT_FLAG_WRITE: Fault was a write fault."]
#[doc = " @FAULT_FLAG_MKWRITE: Fault was mkwrite of existing PTE."]
#[doc = " @FAULT_FLAG_ALLOW_RETRY: Allow to retry the fault if blocked."]
#[doc = " @FAULT_FLAG_RETRY_NOWAIT: Don't drop mmap_lock and wait when retrying."]
#[doc = " @FAULT_FLAG_KILLABLE: The fault task is in SIGKILL killable region."]
#[doc = " @FAULT_FLAG_TRIED: The fault has been tried once."]
#[doc = " @FAULT_FLAG_USER: The fault originated in userspace."]
#[doc = " @FAULT_FLAG_REMOTE: The fault is not for current task/mm."]
#[doc = " @FAULT_FLAG_INSTRUCTION: The fault was during an instruction fetch."]
#[doc = " @FAULT_FLAG_INTERRUPTIBLE: The fault can be interrupted by non-fatal signals."]
#[doc = " @FAULT_FLAG_UNSHARE: The fault is an unsharing request to unshare (and mark"]
#[doc = "                      exclusive) a possibly shared anonymous page that is"]
#[doc = "                      mapped R/O."]
#[doc = " @FAULT_FLAG_ORIG_PTE_VALID: whether the fault has vmf->orig_pte cached."]
#[doc = "                        We should only access orig_pte if this flag set."]
#[doc = ""]
#[doc = " About @FAULT_FLAG_ALLOW_RETRY and @FAULT_FLAG_TRIED: we can specify"]
#[doc = " whether we would allow page faults to retry by specifying these two"]
#[doc = " fault flags correctly.  Currently there can be three legal combinations:"]
#[doc = ""]
#[doc = " (a) ALLOW_RETRY and !TRIED:  this means the page fault allows retry, and"]
#[doc = "                              this is the first try"]
#[doc = ""]
#[doc = " (b) ALLOW_RETRY and TRIED:   this means the page fault allows retry, and"]
#[doc = "                              we've already tried at least once"]
#[doc = ""]
#[doc = " (c) !ALLOW_RETRY and !TRIED: this means the page fault does not allow retry"]
#[doc = ""]
#[doc = " The unlisted combination (!ALLOW_RETRY && TRIED) is illegal and should never"]
#[doc = " be used.  Note that page faults can be allowed to retry for multiple times,"]
#[doc = " in which case we'll have an initial fault with flags (a) then later on"]
#[doc = " continuous faults with flags (b).  We should always try to detect pending"]
#[doc = " signals before a retry to make sure the continuous page faults can still be"]
#[doc = " interrupted if necessary."]
#[doc = ""]
#[doc = " The combination FAULT_FLAG_WRITE|FAULT_FLAG_UNSHARE is illegal."]
#[doc = " FAULT_FLAG_UNSHARE is ignored and treated like an ordinary read fault when"]
#[doc = " no existing R/O-mapped anonymous page is encountered."]
pub type fault_flag = ::std::os::raw::c_uint;
pub type zap_flags_t = ::std::os::raw::c_uint;
pub const pageflags_PG_locked: pageflags = 0;
pub const pageflags_PG_referenced: pageflags = 1;
pub const pageflags_PG_uptodate: pageflags = 2;
pub const pageflags_PG_dirty: pageflags = 3;
pub const pageflags_PG_lru: pageflags = 4;
pub const pageflags_PG_active: pageflags = 5;
pub const pageflags_PG_workingset: pageflags = 6;
pub const pageflags_PG_waiters: pageflags = 7;
pub const pageflags_PG_error: pageflags = 8;
pub const pageflags_PG_slab: pageflags = 9;
pub const pageflags_PG_owner_priv_1: pageflags = 10;
pub const pageflags_PG_arch_1: pageflags = 11;
pub const pageflags_PG_reserved: pageflags = 12;
pub const pageflags_PG_private: pageflags = 13;
pub const pageflags_PG_private_2: pageflags = 14;
pub const pageflags_PG_writeback: pageflags = 15;
pub const pageflags_PG_head: pageflags = 16;
pub const pageflags_PG_mappedtodisk: pageflags = 17;
pub const pageflags_PG_reclaim: pageflags = 18;
pub const pageflags_PG_swapbacked: pageflags = 19;
pub const pageflags_PG_unevictable: pageflags = 20;
pub const pageflags_PG_mlocked: pageflags = 21;
pub const pageflags_PG_uncached: pageflags = 22;
pub const pageflags_PG_arch_2: pageflags = 23;
pub const pageflags___NR_PAGEFLAGS: pageflags = 24;
pub const pageflags_PG_readahead: pageflags = 18;
pub const pageflags_PG_anon_exclusive: pageflags = 17;
pub const pageflags_PG_checked: pageflags = 10;
pub const pageflags_PG_swapcache: pageflags = 10;
pub const pageflags_PG_fscache: pageflags = 14;
pub const pageflags_PG_pinned: pageflags = 10;
pub const pageflags_PG_savepinned: pageflags = 3;
pub const pageflags_PG_foreign: pageflags = 10;
pub const pageflags_PG_xen_remapped: pageflags = 10;
pub const pageflags_PG_slob_free: pageflags = 13;
pub const pageflags_PG_double_map: pageflags = 6;
pub const pageflags_PG_isolated: pageflags = 18;
pub const pageflags_PG_reported: pageflags = 2;
pub type pageflags = ::std::os::raw::c_uint;
extern "C" {
    pub static mut hugetlb_optimize_vmemmap_key: static_key_false;
}
extern "C" {
    pub fn stable_page_flags(page: *mut page) -> u64_;
}
extern "C" {
    pub fn __folio_start_writeback(folio: *mut folio, keep_write: bool_) -> bool_;
}
extern "C" {
    pub fn set_page_writeback(page: *mut page) -> bool_;
}
extern "C" {
    pub fn PageHuge(page: *mut page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PageHeadHuge(page: *mut page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn page_offline_freeze();
}
extern "C" {
    pub fn page_offline_thaw();
}
extern "C" {
    pub fn page_offline_begin();
}
extern "C" {
    pub fn page_offline_end();
}
extern "C" {
    pub fn is_free_buddy_page(page: *mut page) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_lock_t {}
#[test]
fn bindgen_test_layout_local_lock_t() {
    assert_eq!(
        ::std::mem::size_of::<local_lock_t>(),
        0usize,
        concat!("Size of: ", stringify!(local_lock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<local_lock_t>(),
        1usize,
        concat!("Alignment of ", stringify!(local_lock_t))
    );
}
pub const migratetype_MIGRATE_UNMOVABLE: migratetype = 0;
pub const migratetype_MIGRATE_MOVABLE: migratetype = 1;
pub const migratetype_MIGRATE_RECLAIMABLE: migratetype = 2;
pub const migratetype_MIGRATE_PCPTYPES: migratetype = 3;
pub const migratetype_MIGRATE_HIGHATOMIC: migratetype = 3;
pub const migratetype_MIGRATE_TYPES: migratetype = 4;
pub type migratetype = ::std::os::raw::c_uint;
extern "C" {
    pub static migratetype_names: [*const ::std::os::raw::c_char; 4usize];
}
extern "C" {
    pub static mut page_group_by_mobility_disabled: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct free_area {
    pub free_list: [list_head; 4usize],
    pub nr_free: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_free_area() {
    assert_eq!(
        ::std::mem::size_of::<free_area>(),
        72usize,
        concat!("Size of: ", stringify!(free_area))
    );
    assert_eq!(
        ::std::mem::align_of::<free_area>(),
        8usize,
        concat!("Alignment of ", stringify!(free_area))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<free_area>())).free_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(free_area),
            "::",
            stringify!(free_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<free_area>())).nr_free as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(free_area),
            "::",
            stringify!(nr_free)
        )
    );
}
pub const numa_stat_item_NUMA_HIT: numa_stat_item = 0;
pub const numa_stat_item_NUMA_MISS: numa_stat_item = 1;
pub const numa_stat_item_NUMA_FOREIGN: numa_stat_item = 2;
pub const numa_stat_item_NUMA_INTERLEAVE_HIT: numa_stat_item = 3;
pub const numa_stat_item_NUMA_LOCAL: numa_stat_item = 4;
pub const numa_stat_item_NUMA_OTHER: numa_stat_item = 5;
pub const numa_stat_item_NR_VM_NUMA_EVENT_ITEMS: numa_stat_item = 6;
pub type numa_stat_item = ::std::os::raw::c_uint;
pub const zone_stat_item_NR_FREE_PAGES: zone_stat_item = 0;
pub const zone_stat_item_NR_ZONE_LRU_BASE: zone_stat_item = 1;
pub const zone_stat_item_NR_ZONE_INACTIVE_ANON: zone_stat_item = 1;
pub const zone_stat_item_NR_ZONE_ACTIVE_ANON: zone_stat_item = 2;
pub const zone_stat_item_NR_ZONE_INACTIVE_FILE: zone_stat_item = 3;
pub const zone_stat_item_NR_ZONE_ACTIVE_FILE: zone_stat_item = 4;
pub const zone_stat_item_NR_ZONE_UNEVICTABLE: zone_stat_item = 5;
pub const zone_stat_item_NR_ZONE_WRITE_PENDING: zone_stat_item = 6;
pub const zone_stat_item_NR_MLOCK: zone_stat_item = 7;
pub const zone_stat_item_NR_BOUNCE: zone_stat_item = 8;
pub const zone_stat_item_NR_FREE_CMA_PAGES: zone_stat_item = 9;
pub const zone_stat_item_NR_VM_ZONE_STAT_ITEMS: zone_stat_item = 10;
pub type zone_stat_item = ::std::os::raw::c_uint;
pub const node_stat_item_NR_LRU_BASE: node_stat_item = 0;
pub const node_stat_item_NR_INACTIVE_ANON: node_stat_item = 0;
pub const node_stat_item_NR_ACTIVE_ANON: node_stat_item = 1;
pub const node_stat_item_NR_INACTIVE_FILE: node_stat_item = 2;
pub const node_stat_item_NR_ACTIVE_FILE: node_stat_item = 3;
pub const node_stat_item_NR_UNEVICTABLE: node_stat_item = 4;
pub const node_stat_item_NR_SLAB_RECLAIMABLE_B: node_stat_item = 5;
pub const node_stat_item_NR_SLAB_UNRECLAIMABLE_B: node_stat_item = 6;
pub const node_stat_item_NR_ISOLATED_ANON: node_stat_item = 7;
pub const node_stat_item_NR_ISOLATED_FILE: node_stat_item = 8;
pub const node_stat_item_WORKINGSET_NODES: node_stat_item = 9;
pub const node_stat_item_WORKINGSET_REFAULT_BASE: node_stat_item = 10;
pub const node_stat_item_WORKINGSET_REFAULT_ANON: node_stat_item = 10;
pub const node_stat_item_WORKINGSET_REFAULT_FILE: node_stat_item = 11;
pub const node_stat_item_WORKINGSET_ACTIVATE_BASE: node_stat_item = 12;
pub const node_stat_item_WORKINGSET_ACTIVATE_ANON: node_stat_item = 12;
pub const node_stat_item_WORKINGSET_ACTIVATE_FILE: node_stat_item = 13;
pub const node_stat_item_WORKINGSET_RESTORE_BASE: node_stat_item = 14;
pub const node_stat_item_WORKINGSET_RESTORE_ANON: node_stat_item = 14;
pub const node_stat_item_WORKINGSET_RESTORE_FILE: node_stat_item = 15;
pub const node_stat_item_WORKINGSET_NODERECLAIM: node_stat_item = 16;
pub const node_stat_item_NR_ANON_MAPPED: node_stat_item = 17;
pub const node_stat_item_NR_FILE_MAPPED: node_stat_item = 18;
pub const node_stat_item_NR_FILE_PAGES: node_stat_item = 19;
pub const node_stat_item_NR_FILE_DIRTY: node_stat_item = 20;
pub const node_stat_item_NR_WRITEBACK: node_stat_item = 21;
pub const node_stat_item_NR_WRITEBACK_TEMP: node_stat_item = 22;
pub const node_stat_item_NR_SHMEM: node_stat_item = 23;
pub const node_stat_item_NR_SHMEM_THPS: node_stat_item = 24;
pub const node_stat_item_NR_SHMEM_PMDMAPPED: node_stat_item = 25;
pub const node_stat_item_NR_FILE_THPS: node_stat_item = 26;
pub const node_stat_item_NR_FILE_PMDMAPPED: node_stat_item = 27;
pub const node_stat_item_NR_ANON_THPS: node_stat_item = 28;
pub const node_stat_item_NR_VMSCAN_WRITE: node_stat_item = 29;
pub const node_stat_item_NR_VMSCAN_IMMEDIATE: node_stat_item = 30;
pub const node_stat_item_NR_DIRTIED: node_stat_item = 31;
pub const node_stat_item_NR_WRITTEN: node_stat_item = 32;
pub const node_stat_item_NR_THROTTLED_WRITTEN: node_stat_item = 33;
pub const node_stat_item_NR_KERNEL_MISC_RECLAIMABLE: node_stat_item = 34;
pub const node_stat_item_NR_FOLL_PIN_ACQUIRED: node_stat_item = 35;
pub const node_stat_item_NR_FOLL_PIN_RELEASED: node_stat_item = 36;
pub const node_stat_item_NR_KERNEL_STACK_KB: node_stat_item = 37;
pub const node_stat_item_NR_PAGETABLE: node_stat_item = 38;
pub const node_stat_item_NR_SECONDARY_PAGETABLE: node_stat_item = 39;
pub const node_stat_item_NR_SWAPCACHE: node_stat_item = 40;
pub const node_stat_item_NR_VM_NODE_STAT_ITEMS: node_stat_item = 41;
pub type node_stat_item = ::std::os::raw::c_uint;
pub const lru_list_LRU_INACTIVE_ANON: lru_list = 0;
pub const lru_list_LRU_ACTIVE_ANON: lru_list = 1;
pub const lru_list_LRU_INACTIVE_FILE: lru_list = 2;
pub const lru_list_LRU_ACTIVE_FILE: lru_list = 3;
pub const lru_list_LRU_UNEVICTABLE: lru_list = 4;
pub const lru_list_NR_LRU_LISTS: lru_list = 5;
pub type lru_list = ::std::os::raw::c_uint;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_WRITEBACK: vmscan_throttle_state = 0;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_ISOLATED: vmscan_throttle_state = 1;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_NOPROGRESS: vmscan_throttle_state = 2;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_CONGESTED: vmscan_throttle_state = 3;
pub const vmscan_throttle_state_NR_VMSCAN_THROTTLE: vmscan_throttle_state = 4;
pub type vmscan_throttle_state = ::std::os::raw::c_uint;
pub const lruvec_flags_LRUVEC_CONGESTED: lruvec_flags = 0;
pub type lruvec_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_vma_mapped_walk {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lruvec {
    pub lists: [list_head; 5usize],
    pub lru_lock: spinlock_t,
    pub anon_cost: ::std::os::raw::c_ulong,
    pub file_cost: ::std::os::raw::c_ulong,
    pub nonresident_age: atomic_long_t,
    pub refaults: [::std::os::raw::c_ulong; 2usize],
    pub flags: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_lruvec() {
    assert_eq!(
        ::std::mem::size_of::<lruvec>(),
        136usize,
        concat!("Size of: ", stringify!(lruvec))
    );
    assert_eq!(
        ::std::mem::align_of::<lruvec>(),
        8usize,
        concat!("Alignment of ", stringify!(lruvec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lruvec>())).lists as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(lists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lruvec>())).lru_lock as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(lru_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lruvec>())).anon_cost as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(anon_cost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lruvec>())).file_cost as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(file_cost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lruvec>())).nonresident_age as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(nonresident_age)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lruvec>())).refaults as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(refaults)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lruvec>())).flags as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(lruvec),
            "::",
            stringify!(flags)
        )
    );
}
pub type isolate_mode_t = ::std::os::raw::c_uint;
pub const zone_watermarks_WMARK_MIN: zone_watermarks = 0;
pub const zone_watermarks_WMARK_LOW: zone_watermarks = 1;
pub const zone_watermarks_WMARK_HIGH: zone_watermarks = 2;
pub const zone_watermarks_WMARK_PROMO: zone_watermarks = 3;
pub const zone_watermarks_NR_WMARK: zone_watermarks = 4;
pub type zone_watermarks = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct per_cpu_pages {
    pub lock: spinlock_t,
    pub count: ::std::os::raw::c_int,
    pub high: ::std::os::raw::c_int,
    pub batch: ::std::os::raw::c_int,
    pub free_factor: ::std::os::raw::c_short,
    pub expire: ::std::os::raw::c_short,
    pub lists: [list_head; 12usize],
}
#[test]
fn bindgen_test_layout_per_cpu_pages() {
    assert_eq!(
        ::std::mem::size_of::<per_cpu_pages>(),
        256usize,
        concat!("Size of: ", stringify!(per_cpu_pages))
    );
    assert_eq!(
        ::std::mem::align_of::<per_cpu_pages>(),
        64usize,
        concat!("Alignment of ", stringify!(per_cpu_pages))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_pages>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pages),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_pages>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pages),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_pages>())).high as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pages),
            "::",
            stringify!(high)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_pages>())).batch as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pages),
            "::",
            stringify!(batch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_pages>())).free_factor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pages),
            "::",
            stringify!(free_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_pages>())).expire as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pages),
            "::",
            stringify!(expire)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_pages>())).lists as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_pages),
            "::",
            stringify!(lists)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct per_cpu_zonestat {
    pub vm_stat_diff: [s8; 10usize],
    pub stat_threshold: s8,
    pub vm_numa_event: [::std::os::raw::c_ulong; 6usize],
}
#[test]
fn bindgen_test_layout_per_cpu_zonestat() {
    assert_eq!(
        ::std::mem::size_of::<per_cpu_zonestat>(),
        64usize,
        concat!("Size of: ", stringify!(per_cpu_zonestat))
    );
    assert_eq!(
        ::std::mem::align_of::<per_cpu_zonestat>(),
        8usize,
        concat!("Alignment of ", stringify!(per_cpu_zonestat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_zonestat>())).vm_stat_diff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_zonestat),
            "::",
            stringify!(vm_stat_diff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_zonestat>())).stat_threshold as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_zonestat),
            "::",
            stringify!(stat_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_zonestat>())).vm_numa_event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_zonestat),
            "::",
            stringify!(vm_numa_event)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct per_cpu_nodestat {
    pub stat_threshold: s8,
    pub vm_node_stat_diff: [s8; 41usize],
}
#[test]
fn bindgen_test_layout_per_cpu_nodestat() {
    assert_eq!(
        ::std::mem::size_of::<per_cpu_nodestat>(),
        42usize,
        concat!("Size of: ", stringify!(per_cpu_nodestat))
    );
    assert_eq!(
        ::std::mem::align_of::<per_cpu_nodestat>(),
        1usize,
        concat!("Alignment of ", stringify!(per_cpu_nodestat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<per_cpu_nodestat>())).stat_threshold as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_nodestat),
            "::",
            stringify!(stat_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<per_cpu_nodestat>())).vm_node_stat_diff as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(per_cpu_nodestat),
            "::",
            stringify!(vm_node_stat_diff)
        )
    );
}
pub const zone_type_ZONE_DMA: zone_type = 0;
pub const zone_type_ZONE_DMA32: zone_type = 1;
pub const zone_type_ZONE_NORMAL: zone_type = 2;
pub const zone_type_ZONE_MOVABLE: zone_type = 3;
pub const zone_type___MAX_NR_ZONES: zone_type = 4;
pub type zone_type = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(64))]
pub struct zone {
    pub _watermark: [::std::os::raw::c_ulong; 4usize],
    pub watermark_boost: ::std::os::raw::c_ulong,
    pub nr_reserved_highatomic: ::std::os::raw::c_ulong,
    pub lowmem_reserve: [::std::os::raw::c_long; 4usize],
    pub node: ::std::os::raw::c_int,
    pub zone_pgdat: *mut pglist_data,
    pub per_cpu_pageset: *mut per_cpu_pages,
    pub per_cpu_zonestats: *mut per_cpu_zonestat,
    pub pageset_high: ::std::os::raw::c_int,
    pub pageset_batch: ::std::os::raw::c_int,
    pub zone_start_pfn: ::std::os::raw::c_ulong,
    pub managed_pages: atomic_long_t,
    pub spanned_pages: ::std::os::raw::c_ulong,
    pub present_pages: ::std::os::raw::c_ulong,
    pub name: *const ::std::os::raw::c_char,
    pub initialized: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u64; 3usize],
    pub _pad1_: cacheline_padding,
    pub free_area: [free_area; 11usize],
    pub flags: ::std::os::raw::c_ulong,
    pub lock: spinlock_t,
    pub __bindgen_padding_1: [u64; 3usize],
    pub _pad2_: cacheline_padding,
    pub percpu_drift_mark: ::std::os::raw::c_ulong,
    pub compact_cached_free_pfn: ::std::os::raw::c_ulong,
    pub compact_cached_migrate_pfn: [::std::os::raw::c_ulong; 2usize],
    pub compact_init_migrate_pfn: ::std::os::raw::c_ulong,
    pub compact_init_free_pfn: ::std::os::raw::c_ulong,
    pub compact_considered: ::std::os::raw::c_uint,
    pub compact_defer_shift: ::std::os::raw::c_uint,
    pub compact_order_failed: ::std::os::raw::c_int,
    pub compact_blockskip_flush: bool_,
    pub contiguous: bool_,
    pub __bindgen_padding_2: [u64; 0usize],
    pub _pad3_: cacheline_padding,
    pub vm_stat: [atomic_long_t; 10usize],
    pub vm_numa_event: [atomic_long_t; 6usize],
}
#[test]
fn bindgen_test_layout_zone() {
    assert_eq!(
        ::std::mem::size_of::<zone>(),
        1216usize,
        concat!("Size of: ", stringify!(zone))
    );
    assert_eq!(
        ::std::mem::align_of::<zone>(),
        64usize,
        concat!("Alignment of ", stringify!(zone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>()))._watermark as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(_watermark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).watermark_boost as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(watermark_boost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).nr_reserved_highatomic as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(nr_reserved_highatomic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).lowmem_reserve as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(lowmem_reserve)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).node as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).zone_pgdat as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(zone_pgdat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).per_cpu_pageset as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(per_cpu_pageset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).per_cpu_zonestats as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(per_cpu_zonestats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).pageset_high as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(pageset_high)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).pageset_batch as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(pageset_batch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).zone_start_pfn as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(zone_start_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).managed_pages as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(managed_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).spanned_pages as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(spanned_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).present_pages as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(present_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).name as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).initialized as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>()))._pad1_ as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(_pad1_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).free_area as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(free_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).flags as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).lock as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>()))._pad2_ as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(_pad2_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).percpu_drift_mark as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(percpu_drift_mark)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).compact_cached_free_pfn as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_cached_free_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).compact_cached_migrate_pfn as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_cached_migrate_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).compact_init_migrate_pfn as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_init_migrate_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).compact_init_free_pfn as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_init_free_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).compact_considered as *const _ as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_considered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).compact_defer_shift as *const _ as usize },
        1076usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_defer_shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).compact_order_failed as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_order_failed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).compact_blockskip_flush as *const _ as usize },
        1084usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(compact_blockskip_flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).contiguous as *const _ as usize },
        1085usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(contiguous)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>()))._pad3_ as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(_pad3_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).vm_stat as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(vm_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zone>())).vm_numa_event as *const _ as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(zone),
            "::",
            stringify!(vm_numa_event)
        )
    );
}
pub const pgdat_flags_PGDAT_DIRTY: pgdat_flags = 0;
pub const pgdat_flags_PGDAT_WRITEBACK: pgdat_flags = 1;
pub const pgdat_flags_PGDAT_RECLAIM_LOCKED: pgdat_flags = 2;
pub type pgdat_flags = ::std::os::raw::c_uint;
pub const zone_flags_ZONE_BOOSTED_WATERMARK: zone_flags = 0;
pub const zone_flags_ZONE_RECLAIM_ACTIVE: zone_flags = 1;
pub type zone_flags = ::std::os::raw::c_uint;
pub const ZONELIST_FALLBACK: ::std::os::raw::c_uint = 0;
pub const ZONELIST_NOFALLBACK: ::std::os::raw::c_uint = 1;
pub const MAX_ZONELISTS: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zoneref {
    pub zone: *mut zone,
    pub zone_idx: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_zoneref() {
    assert_eq!(
        ::std::mem::size_of::<zoneref>(),
        16usize,
        concat!("Size of: ", stringify!(zoneref))
    );
    assert_eq!(
        ::std::mem::align_of::<zoneref>(),
        8usize,
        concat!("Alignment of ", stringify!(zoneref))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zoneref>())).zone as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zoneref),
            "::",
            stringify!(zone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zoneref>())).zone_idx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zoneref),
            "::",
            stringify!(zone_idx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zonelist {
    pub _zonerefs: [zoneref; 257usize],
}
#[test]
fn bindgen_test_layout_zonelist() {
    assert_eq!(
        ::std::mem::size_of::<zonelist>(),
        4112usize,
        concat!("Size of: ", stringify!(zonelist))
    );
    assert_eq!(
        ::std::mem::align_of::<zonelist>(),
        8usize,
        concat!("Alignment of ", stringify!(zonelist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zonelist>()))._zonerefs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zonelist),
            "::",
            stringify!(_zonerefs)
        )
    );
}
extern "C" {
    pub static mut mem_map: *mut page;
}
#[repr(C)]
#[repr(align(64))]
pub struct pglist_data {
    pub node_zones: [zone; 4usize],
    pub node_zonelists: [zonelist; 2usize],
    pub nr_zones: ::std::os::raw::c_int,
    pub node_start_pfn: ::std::os::raw::c_ulong,
    pub node_present_pages: ::std::os::raw::c_ulong,
    pub node_spanned_pages: ::std::os::raw::c_ulong,
    pub node_id: ::std::os::raw::c_int,
    pub kswapd_wait: wait_queue_head_t,
    pub pfmemalloc_wait: wait_queue_head_t,
    pub reclaim_wait: [wait_queue_head_t; 4usize],
    pub nr_writeback_throttled: atomic_t,
    pub nr_reclaim_start: ::std::os::raw::c_ulong,
    pub kswapd: *mut task_struct,
    pub kswapd_order: ::std::os::raw::c_int,
    pub kswapd_highest_zoneidx: zone_type,
    pub kswapd_failures: ::std::os::raw::c_int,
    pub kcompactd_max_order: ::std::os::raw::c_int,
    pub kcompactd_highest_zoneidx: zone_type,
    pub kcompactd_wait: wait_queue_head_t,
    pub kcompactd: *mut task_struct,
    pub proactive_compact_trigger: bool_,
    pub totalreserve_pages: ::std::os::raw::c_ulong,
    pub min_unmapped_pages: ::std::os::raw::c_ulong,
    pub min_slab_pages: ::std::os::raw::c_ulong,
    pub __bindgen_padding_0: [u64; 7usize],
    pub _pad1_: cacheline_padding,
    pub __lruvec: lruvec,
    pub flags: ::std::os::raw::c_ulong,
    pub __bindgen_padding_1: [u64; 6usize],
    pub _pad2_: cacheline_padding,
    pub per_cpu_nodestats: *mut per_cpu_nodestat,
    pub vm_stat: [atomic_long_t; 41usize],
    pub memtier: *mut memory_tier,
}
#[test]
fn bindgen_test_layout_pglist_data() {
    assert_eq!(
        ::std::mem::size_of::<pglist_data>(),
        14016usize,
        concat!("Size of: ", stringify!(pglist_data))
    );
    assert_eq!(
        ::std::mem::align_of::<pglist_data>(),
        64usize,
        concat!("Alignment of ", stringify!(pglist_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).node_zones as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_zones)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).node_zonelists as *const _ as usize },
        4864usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_zonelists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).nr_zones as *const _ as usize },
        13088usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(nr_zones)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).node_start_pfn as *const _ as usize },
        13096usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_start_pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).node_present_pages as *const _ as usize },
        13104usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_present_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).node_spanned_pages as *const _ as usize },
        13112usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_spanned_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).node_id as *const _ as usize },
        13120usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).kswapd_wait as *const _ as usize },
        13128usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kswapd_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).pfmemalloc_wait as *const _ as usize },
        13152usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(pfmemalloc_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).reclaim_wait as *const _ as usize },
        13176usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(reclaim_wait)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pglist_data>())).nr_writeback_throttled as *const _ as usize
        },
        13272usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(nr_writeback_throttled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).nr_reclaim_start as *const _ as usize },
        13280usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(nr_reclaim_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).kswapd as *const _ as usize },
        13288usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kswapd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).kswapd_order as *const _ as usize },
        13296usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kswapd_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pglist_data>())).kswapd_highest_zoneidx as *const _ as usize
        },
        13300usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kswapd_highest_zoneidx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).kswapd_failures as *const _ as usize },
        13304usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kswapd_failures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).kcompactd_max_order as *const _ as usize },
        13308usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kcompactd_max_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pglist_data>())).kcompactd_highest_zoneidx as *const _ as usize
        },
        13312usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kcompactd_highest_zoneidx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).kcompactd_wait as *const _ as usize },
        13320usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kcompactd_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).kcompactd as *const _ as usize },
        13344usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(kcompactd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pglist_data>())).proactive_compact_trigger as *const _ as usize
        },
        13352usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(proactive_compact_trigger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).totalreserve_pages as *const _ as usize },
        13360usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(totalreserve_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).min_unmapped_pages as *const _ as usize },
        13368usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(min_unmapped_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).min_slab_pages as *const _ as usize },
        13376usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(min_slab_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>()))._pad1_ as *const _ as usize },
        13440usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(_pad1_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).__lruvec as *const _ as usize },
        13440usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(__lruvec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).flags as *const _ as usize },
        13576usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>()))._pad2_ as *const _ as usize },
        13632usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(_pad2_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).per_cpu_nodestats as *const _ as usize },
        13632usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(per_cpu_nodestats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).vm_stat as *const _ as usize },
        13640usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(vm_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pglist_data>())).memtier as *const _ as usize },
        13968usize,
        concat!(
            "Offset of field: ",
            stringify!(pglist_data),
            "::",
            stringify!(memtier)
        )
    );
}
pub type pg_data_t = pglist_data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memory_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct resource {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmem_altmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dev_pagemap {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut node_data: [*mut pg_data_t; 0usize];
}
extern "C" {
    pub fn arch_get_mappable_range() -> range;
}
extern "C" {
    pub fn set_zone_contiguous(zone: *mut zone);
}
extern "C" {
    pub fn clear_zone_contiguous(zone: *mut zone);
}
extern "C" {
    pub fn build_all_zonelists(pgdat: *mut pg_data_t);
}
extern "C" {
    pub fn wakeup_kswapd(
        zone: *mut zone,
        gfp_mask: gfp_t,
        order: ::std::os::raw::c_int,
        highest_zoneidx: zone_type,
    );
}
extern "C" {
    pub fn __zone_watermark_ok(
        z: *mut zone,
        order: ::std::os::raw::c_uint,
        mark: ::std::os::raw::c_ulong,
        highest_zoneidx: ::std::os::raw::c_int,
        alloc_flags: ::std::os::raw::c_uint,
        free_pages: ::std::os::raw::c_long,
    ) -> bool_;
}
extern "C" {
    pub fn zone_watermark_ok(
        z: *mut zone,
        order: ::std::os::raw::c_uint,
        mark: ::std::os::raw::c_ulong,
        highest_zoneidx: ::std::os::raw::c_int,
        alloc_flags: ::std::os::raw::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn zone_watermark_ok_safe(
        z: *mut zone,
        order: ::std::os::raw::c_uint,
        mark: ::std::os::raw::c_ulong,
        highest_zoneidx: ::std::os::raw::c_int,
    ) -> bool_;
}
pub const meminit_context_MEMINIT_EARLY: meminit_context = 0;
pub const meminit_context_MEMINIT_HOTPLUG: meminit_context = 1;
pub type meminit_context = ::std::os::raw::c_uint;
extern "C" {
    pub fn init_currently_empty_zone(
        zone: *mut zone,
        start_pfn: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn lruvec_init(lruvec: *mut lruvec);
}
extern "C" {
    pub static mut movable_zone: ::std::os::raw::c_int;
}
extern "C" {
    pub fn has_managed_dma() -> bool_;
}
extern "C" {
    pub fn min_free_kbytes_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn watermark_scale_factor_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sysctl_lowmem_reserve_ratio: [::std::os::raw::c_int; 4usize];
}
extern "C" {
    pub fn lowmem_reserve_ratio_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn percpu_pagelist_high_fraction_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sysctl_min_unmapped_ratio_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sysctl_min_slab_ratio_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numa_zonelist_order_handler(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut percpu_pagelist_high_fraction: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut numa_zonelist_order: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn first_online_pgdat() -> *mut pglist_data;
}
extern "C" {
    pub fn next_online_pgdat(pgdat: *mut pglist_data) -> *mut pglist_data;
}
extern "C" {
    pub fn next_zone(zone: *mut zone) -> *mut zone;
}
extern "C" {
    pub fn __next_zones_zonelist(
        z: *mut zoneref,
        highest_zoneidx: zone_type,
        nodes: *mut nodemask_t,
    ) -> *mut zoneref;
}
#[repr(C)]
#[derive(Debug)]
pub struct mem_section_usage {
    pub subsection_map: [::std::os::raw::c_ulong; 1usize],
    pub pageblock_flags: __IncompleteArrayField<::std::os::raw::c_ulong>,
}
#[test]
fn bindgen_test_layout_mem_section_usage() {
    assert_eq!(
        ::std::mem::size_of::<mem_section_usage>(),
        8usize,
        concat!("Size of: ", stringify!(mem_section_usage))
    );
    assert_eq!(
        ::std::mem::align_of::<mem_section_usage>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_section_usage))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mem_section_usage>())).subsection_map as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_section_usage),
            "::",
            stringify!(subsection_map)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<mem_section_usage>())).pageblock_flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_section_usage),
            "::",
            stringify!(pageblock_flags)
        )
    );
}
extern "C" {
    pub fn subsection_map_init(pfn: ::std::os::raw::c_ulong, nr_pages: ::std::os::raw::c_ulong);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_ext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_section {
    pub section_mem_map: ::std::os::raw::c_ulong,
    pub usage: *mut mem_section_usage,
}
#[test]
fn bindgen_test_layout_mem_section() {
    assert_eq!(
        ::std::mem::size_of::<mem_section>(),
        16usize,
        concat!("Size of: ", stringify!(mem_section))
    );
    assert_eq!(
        ::std::mem::align_of::<mem_section>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_section))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_section>())).section_mem_map as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_section),
            "::",
            stringify!(section_mem_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_section>())).usage as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_section),
            "::",
            stringify!(usage)
        )
    );
}
extern "C" {
    pub static mut mem_section: *mut *mut mem_section;
}
extern "C" {
    pub fn mem_section_usage_size() -> size_t;
}
pub const SECTION_MARKED_PRESENT_BIT: ::std::os::raw::c_uint = 0;
pub const SECTION_HAS_MEM_MAP_BIT: ::std::os::raw::c_uint = 1;
pub const SECTION_IS_ONLINE_BIT: ::std::os::raw::c_uint = 2;
pub const SECTION_IS_EARLY_BIT: ::std::os::raw::c_uint = 3;
pub const SECTION_MAP_LAST_BIT: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
extern "C" {
    pub static mut __highest_present_section_nr: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn sparse_init();
}
extern "C" {
    pub fn topology_normalize_cpu_scale();
}
extern "C" {
    pub fn topology_update_cpu_topology() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn topology_init_cpu_capacity_cppc();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device_node {
    _unused: [u8; 0],
}
extern "C" {
    pub fn topology_parse_cpu_capacity(
        cpu_node: *mut device_node,
        cpu: ::std::os::raw::c_int,
    ) -> bool_;
}
extern "C" {
    pub static mut cpu_scale: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn topology_set_cpu_scale(cpu: ::std::os::raw::c_uint, capacity: ::std::os::raw::c_ulong);
}
extern "C" {
    pub static mut arch_freq_scale: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn topology_set_freq_scale(
        cpus: *const cpumask,
        cur_freq: ::std::os::raw::c_ulong,
        max_freq: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn topology_scale_freq_invariant() -> bool_;
}
pub const scale_freq_source_SCALE_FREQ_SOURCE_CPUFREQ: scale_freq_source = 0;
pub const scale_freq_source_SCALE_FREQ_SOURCE_ARCH: scale_freq_source = 1;
pub const scale_freq_source_SCALE_FREQ_SOURCE_CPPC: scale_freq_source = 2;
pub type scale_freq_source = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scale_freq_data {
    pub source: scale_freq_source,
    pub set_freq_scale: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_scale_freq_data() {
    assert_eq!(
        ::std::mem::size_of::<scale_freq_data>(),
        16usize,
        concat!("Size of: ", stringify!(scale_freq_data))
    );
    assert_eq!(
        ::std::mem::align_of::<scale_freq_data>(),
        8usize,
        concat!("Alignment of ", stringify!(scale_freq_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scale_freq_data>())).source as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scale_freq_data),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<scale_freq_data>())).set_freq_scale as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(scale_freq_data),
            "::",
            stringify!(set_freq_scale)
        )
    );
}
extern "C" {
    pub fn topology_scale_freq_tick();
}
extern "C" {
    pub fn topology_set_scale_freq_source(data: *mut scale_freq_data, cpus: *const cpumask);
}
extern "C" {
    pub fn topology_clear_scale_freq_source(source: scale_freq_source, cpus: *const cpumask);
}
extern "C" {
    pub static mut thermal_pressure: ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn topology_update_thermal_pressure(
        cpus: *const cpumask,
        capped_freq: ::std::os::raw::c_ulong,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_topology {
    pub thread_id: ::std::os::raw::c_int,
    pub core_id: ::std::os::raw::c_int,
    pub cluster_id: ::std::os::raw::c_int,
    pub package_id: ::std::os::raw::c_int,
    pub thread_sibling: cpumask_t,
    pub core_sibling: cpumask_t,
    pub cluster_sibling: cpumask_t,
    pub llc_sibling: cpumask_t,
}
#[test]
fn bindgen_test_layout_cpu_topology() {
    assert_eq!(
        ::std::mem::size_of::<cpu_topology>(),
        48usize,
        concat!("Size of: ", stringify!(cpu_topology))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_topology>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_topology))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_topology>())).thread_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_topology),
            "::",
            stringify!(thread_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_topology>())).core_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_topology),
            "::",
            stringify!(core_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_topology>())).cluster_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_topology),
            "::",
            stringify!(cluster_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_topology>())).package_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_topology),
            "::",
            stringify!(package_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_topology>())).thread_sibling as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_topology),
            "::",
            stringify!(thread_sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_topology>())).core_sibling as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_topology),
            "::",
            stringify!(core_sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_topology>())).cluster_sibling as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_topology),
            "::",
            stringify!(cluster_sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_topology>())).llc_sibling as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_topology),
            "::",
            stringify!(llc_sibling)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpf_intel {
    pub signature: [::std::os::raw::c_char; 4usize],
    pub physptr: ::std::os::raw::c_uint,
    pub length: ::std::os::raw::c_uchar,
    pub specification: ::std::os::raw::c_uchar,
    pub checksum: ::std::os::raw::c_uchar,
    pub feature1: ::std::os::raw::c_uchar,
    pub feature2: ::std::os::raw::c_uchar,
    pub feature3: ::std::os::raw::c_uchar,
    pub feature4: ::std::os::raw::c_uchar,
    pub feature5: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_mpf_intel() {
    assert_eq!(
        ::std::mem::size_of::<mpf_intel>(),
        16usize,
        concat!("Size of: ", stringify!(mpf_intel))
    );
    assert_eq!(
        ::std::mem::align_of::<mpf_intel>(),
        4usize,
        concat!("Alignment of ", stringify!(mpf_intel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).physptr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(physptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).specification as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(specification)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).checksum as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).feature1 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(feature1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).feature2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(feature2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).feature3 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(feature3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).feature4 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(feature4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpf_intel>())).feature5 as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(mpf_intel),
            "::",
            stringify!(feature5)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpc_table {
    pub signature: [::std::os::raw::c_char; 4usize],
    pub length: ::std::os::raw::c_ushort,
    pub spec: ::std::os::raw::c_char,
    pub checksum: ::std::os::raw::c_char,
    pub oem: [::std::os::raw::c_char; 8usize],
    pub productid: [::std::os::raw::c_char; 12usize],
    pub oemptr: ::std::os::raw::c_uint,
    pub oemsize: ::std::os::raw::c_ushort,
    pub oemcount: ::std::os::raw::c_ushort,
    pub lapic: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mpc_table() {
    assert_eq!(
        ::std::mem::size_of::<mpc_table>(),
        44usize,
        concat!("Size of: ", stringify!(mpc_table))
    );
    assert_eq!(
        ::std::mem::align_of::<mpc_table>(),
        4usize,
        concat!("Alignment of ", stringify!(mpc_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).spec as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(spec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).checksum as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).oem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(oem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).productid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(productid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).oemptr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(oemptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).oemsize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(oemsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).oemcount as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(oemcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).lapic as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(lapic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_table>())).reserved as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_table),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpc_cpu {
    pub type_: ::std::os::raw::c_uchar,
    pub apicid: ::std::os::raw::c_uchar,
    pub apicver: ::std::os::raw::c_uchar,
    pub cpuflag: ::std::os::raw::c_uchar,
    pub cpufeature: ::std::os::raw::c_uint,
    pub featureflag: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_mpc_cpu() {
    assert_eq!(
        ::std::mem::size_of::<mpc_cpu>(),
        20usize,
        concat!("Size of: ", stringify!(mpc_cpu))
    );
    assert_eq!(
        ::std::mem::align_of::<mpc_cpu>(),
        4usize,
        concat!("Alignment of ", stringify!(mpc_cpu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_cpu>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_cpu),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_cpu>())).apicid as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_cpu),
            "::",
            stringify!(apicid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_cpu>())).apicver as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_cpu),
            "::",
            stringify!(apicver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_cpu>())).cpuflag as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_cpu),
            "::",
            stringify!(cpuflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_cpu>())).cpufeature as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_cpu),
            "::",
            stringify!(cpufeature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_cpu>())).featureflag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_cpu),
            "::",
            stringify!(featureflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_cpu>())).reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_cpu),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpc_bus {
    pub type_: ::std::os::raw::c_uchar,
    pub busid: ::std::os::raw::c_uchar,
    pub bustype: [::std::os::raw::c_uchar; 6usize],
}
#[test]
fn bindgen_test_layout_mpc_bus() {
    assert_eq!(
        ::std::mem::size_of::<mpc_bus>(),
        8usize,
        concat!("Size of: ", stringify!(mpc_bus))
    );
    assert_eq!(
        ::std::mem::align_of::<mpc_bus>(),
        1usize,
        concat!("Alignment of ", stringify!(mpc_bus))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_bus>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_bus),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_bus>())).busid as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_bus),
            "::",
            stringify!(busid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_bus>())).bustype as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_bus),
            "::",
            stringify!(bustype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpc_ioapic {
    pub type_: ::std::os::raw::c_uchar,
    pub apicid: ::std::os::raw::c_uchar,
    pub apicver: ::std::os::raw::c_uchar,
    pub flags: ::std::os::raw::c_uchar,
    pub apicaddr: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mpc_ioapic() {
    assert_eq!(
        ::std::mem::size_of::<mpc_ioapic>(),
        8usize,
        concat!("Size of: ", stringify!(mpc_ioapic))
    );
    assert_eq!(
        ::std::mem::align_of::<mpc_ioapic>(),
        4usize,
        concat!("Alignment of ", stringify!(mpc_ioapic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_ioapic>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_ioapic),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_ioapic>())).apicid as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_ioapic),
            "::",
            stringify!(apicid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_ioapic>())).apicver as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_ioapic),
            "::",
            stringify!(apicver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_ioapic>())).flags as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_ioapic),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_ioapic>())).apicaddr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_ioapic),
            "::",
            stringify!(apicaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpc_intsrc {
    pub type_: ::std::os::raw::c_uchar,
    pub irqtype: ::std::os::raw::c_uchar,
    pub irqflag: ::std::os::raw::c_ushort,
    pub srcbus: ::std::os::raw::c_uchar,
    pub srcbusirq: ::std::os::raw::c_uchar,
    pub dstapic: ::std::os::raw::c_uchar,
    pub dstirq: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_mpc_intsrc() {
    assert_eq!(
        ::std::mem::size_of::<mpc_intsrc>(),
        8usize,
        concat!("Size of: ", stringify!(mpc_intsrc))
    );
    assert_eq!(
        ::std::mem::align_of::<mpc_intsrc>(),
        2usize,
        concat!("Alignment of ", stringify!(mpc_intsrc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_intsrc>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_intsrc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_intsrc>())).irqtype as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_intsrc),
            "::",
            stringify!(irqtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_intsrc>())).irqflag as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_intsrc),
            "::",
            stringify!(irqflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_intsrc>())).srcbus as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_intsrc),
            "::",
            stringify!(srcbus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_intsrc>())).srcbusirq as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_intsrc),
            "::",
            stringify!(srcbusirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_intsrc>())).dstapic as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_intsrc),
            "::",
            stringify!(dstapic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_intsrc>())).dstirq as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_intsrc),
            "::",
            stringify!(dstirq)
        )
    );
}
pub const mp_irq_source_types_mp_INT: mp_irq_source_types = 0;
pub const mp_irq_source_types_mp_NMI: mp_irq_source_types = 1;
pub const mp_irq_source_types_mp_SMI: mp_irq_source_types = 2;
pub const mp_irq_source_types_mp_ExtINT: mp_irq_source_types = 3;
pub type mp_irq_source_types = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpc_lintsrc {
    pub type_: ::std::os::raw::c_uchar,
    pub irqtype: ::std::os::raw::c_uchar,
    pub irqflag: ::std::os::raw::c_ushort,
    pub srcbusid: ::std::os::raw::c_uchar,
    pub srcbusirq: ::std::os::raw::c_uchar,
    pub destapic: ::std::os::raw::c_uchar,
    pub destapiclint: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_mpc_lintsrc() {
    assert_eq!(
        ::std::mem::size_of::<mpc_lintsrc>(),
        8usize,
        concat!("Size of: ", stringify!(mpc_lintsrc))
    );
    assert_eq!(
        ::std::mem::align_of::<mpc_lintsrc>(),
        2usize,
        concat!("Alignment of ", stringify!(mpc_lintsrc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_lintsrc>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_lintsrc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_lintsrc>())).irqtype as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_lintsrc),
            "::",
            stringify!(irqtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_lintsrc>())).irqflag as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_lintsrc),
            "::",
            stringify!(irqflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_lintsrc>())).srcbusid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_lintsrc),
            "::",
            stringify!(srcbusid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_lintsrc>())).srcbusirq as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_lintsrc),
            "::",
            stringify!(srcbusirq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_lintsrc>())).destapic as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_lintsrc),
            "::",
            stringify!(destapic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_lintsrc>())).destapiclint as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_lintsrc),
            "::",
            stringify!(destapiclint)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpc_oemtable {
    pub signature: [::std::os::raw::c_char; 4usize],
    pub length: ::std::os::raw::c_ushort,
    pub rev: ::std::os::raw::c_char,
    pub checksum: ::std::os::raw::c_char,
    pub mpc: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_mpc_oemtable() {
    assert_eq!(
        ::std::mem::size_of::<mpc_oemtable>(),
        16usize,
        concat!("Size of: ", stringify!(mpc_oemtable))
    );
    assert_eq!(
        ::std::mem::align_of::<mpc_oemtable>(),
        2usize,
        concat!("Alignment of ", stringify!(mpc_oemtable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_oemtable>())).signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_oemtable),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_oemtable>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_oemtable),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_oemtable>())).rev as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_oemtable),
            "::",
            stringify!(rev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_oemtable>())).checksum as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_oemtable),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mpc_oemtable>())).mpc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpc_oemtable),
            "::",
            stringify!(mpc)
        )
    );
}
pub const mp_bustype_MP_BUS_ISA: mp_bustype = 1;
pub const mp_bustype_MP_BUS_EISA: mp_bustype = 2;
pub const mp_bustype_MP_BUS_PCI: mp_bustype = 3;
pub type mp_bustype = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ghcb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct irq_domain {
    _unused: [u8; 0],
}
#[doc = " struct x86_init_mpparse - platform specific mpparse ops"]
#[doc = " @setup_ioapic_ids:\t\tplatform specific ioapic id override"]
#[doc = " @find_smp_config:\t\tfind the smp configuration"]
#[doc = " @get_smp_config:\t\tget the smp configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_init_mpparse {
    pub setup_ioapic_ids: ::std::option::Option<unsafe extern "C" fn()>,
    pub find_smp_config: ::std::option::Option<unsafe extern "C" fn()>,
    pub get_smp_config: ::std::option::Option<unsafe extern "C" fn(early: ::std::os::raw::c_uint)>,
}
#[test]
fn bindgen_test_layout_x86_init_mpparse() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_mpparse>(),
        24usize,
        concat!("Size of: ", stringify!(x86_init_mpparse))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_mpparse>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_mpparse))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_init_mpparse>())).setup_ioapic_ids as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_mpparse),
            "::",
            stringify!(setup_ioapic_ids)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_init_mpparse>())).find_smp_config as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_mpparse),
            "::",
            stringify!(find_smp_config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_mpparse>())).get_smp_config as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_mpparse),
            "::",
            stringify!(get_smp_config)
        )
    );
}
#[doc = " struct x86_init_resources - platform specific resource related ops"]
#[doc = " @probe_roms:\t\t\tprobe BIOS roms"]
#[doc = " @reserve_resources:\t\treserve the standard resources for the"]
#[doc = "\t\t\t\tplatform"]
#[doc = " @memory_setup:\t\tplatform specific memory setup"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_init_resources {
    pub probe_roms: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserve_resources: ::std::option::Option<unsafe extern "C" fn()>,
    pub memory_setup: ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_x86_init_resources() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_resources>(),
        24usize,
        concat!("Size of: ", stringify!(x86_init_resources))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_resources>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_resources))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_resources>())).probe_roms as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_resources),
            "::",
            stringify!(probe_roms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_init_resources>())).reserve_resources as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_resources),
            "::",
            stringify!(reserve_resources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_resources>())).memory_setup as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_resources),
            "::",
            stringify!(memory_setup)
        )
    );
}
#[doc = " struct x86_init_irqs - platform specific interrupt setup"]
#[doc = " @pre_vector_init:\t\tinit code to run before interrupt vectors"]
#[doc = "\t\t\t\tare set up."]
#[doc = " @intr_init:\t\t\tinterrupt init code"]
#[doc = " @intr_mode_select:\t\tinterrupt delivery mode selection"]
#[doc = " @intr_mode_init:\t\tinterrupt delivery mode setup"]
#[doc = " @create_pci_msi_domain:\tCreate the PCI/MSI interrupt domain"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_init_irqs {
    pub pre_vector_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub intr_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub intr_mode_select: ::std::option::Option<unsafe extern "C" fn()>,
    pub intr_mode_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub create_pci_msi_domain: ::std::option::Option<unsafe extern "C" fn() -> *mut irq_domain>,
}
#[test]
fn bindgen_test_layout_x86_init_irqs() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_irqs>(),
        40usize,
        concat!("Size of: ", stringify!(x86_init_irqs))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_irqs>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_irqs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_irqs>())).pre_vector_init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_irqs),
            "::",
            stringify!(pre_vector_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_irqs>())).intr_init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_irqs),
            "::",
            stringify!(intr_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_irqs>())).intr_mode_select as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_irqs),
            "::",
            stringify!(intr_mode_select)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_irqs>())).intr_mode_init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_irqs),
            "::",
            stringify!(intr_mode_init)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_init_irqs>())).create_pci_msi_domain as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_irqs),
            "::",
            stringify!(create_pci_msi_domain)
        )
    );
}
#[doc = " struct x86_init_oem - oem platform specific customizing functions"]
#[doc = " @arch_setup:\t\t\tplatform specific architecture setup"]
#[doc = " @banner:\t\t\tprint a platform specific banner"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_init_oem {
    pub arch_setup: ::std::option::Option<unsafe extern "C" fn()>,
    pub banner: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_init_oem() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_oem>(),
        16usize,
        concat!("Size of: ", stringify!(x86_init_oem))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_oem>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_oem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_oem>())).arch_setup as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_oem),
            "::",
            stringify!(arch_setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_oem>())).banner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_oem),
            "::",
            stringify!(banner)
        )
    );
}
#[doc = " struct x86_init_paging - platform specific paging functions"]
#[doc = " @pagetable_init:\tplatform specific paging initialization call to setup"]
#[doc = "\t\t\tthe kernel pagetables and prepare accessors functions."]
#[doc = "\t\t\tCallback must call paging_init(). Called once after the"]
#[doc = "\t\t\tdirect mapping for phys memory is available."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_init_paging {
    pub pagetable_init: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_init_paging() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_paging>(),
        8usize,
        concat!("Size of: ", stringify!(x86_init_paging))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_paging>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_paging))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_paging>())).pagetable_init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_paging),
            "::",
            stringify!(pagetable_init)
        )
    );
}
#[doc = " struct x86_init_timers - platform specific timer setup"]
#[doc = " @setup_perpcu_clockev:\tset up the per cpu clock event device for the"]
#[doc = "\t\t\t\tboot cpu"]
#[doc = " @timer_init:\t\t\tinitialize the platform timer (default PIT/HPET)"]
#[doc = " @wallclock_init:\t\tinit the wallclock device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_init_timers {
    pub setup_percpu_clockev: ::std::option::Option<unsafe extern "C" fn()>,
    pub timer_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub wallclock_init: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_init_timers() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_timers>(),
        24usize,
        concat!("Size of: ", stringify!(x86_init_timers))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_timers>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_timers))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_init_timers>())).setup_percpu_clockev as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_timers),
            "::",
            stringify!(setup_percpu_clockev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_timers>())).timer_init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_timers),
            "::",
            stringify!(timer_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_timers>())).wallclock_init as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_timers),
            "::",
            stringify!(wallclock_init)
        )
    );
}
#[doc = " struct x86_init_iommu - platform specific iommu setup"]
#[doc = " @iommu_init:\t\t\tplatform specific iommu setup"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_init_iommu {
    pub iommu_init: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_x86_init_iommu() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_iommu>(),
        8usize,
        concat!("Size of: ", stringify!(x86_init_iommu))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_iommu>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_iommu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_iommu>())).iommu_init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_iommu),
            "::",
            stringify!(iommu_init)
        )
    );
}
#[doc = " struct x86_init_pci - platform specific pci init functions"]
#[doc = " @arch_init:\t\t\tplatform specific pci arch init call"]
#[doc = " @init:\t\t\tplatform specific pci subsystem init"]
#[doc = " @init_irq:\t\t\tplatform specific pci irq init"]
#[doc = " @fixup_irqs:\t\t\tplatform specific pci irq fixup"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_init_pci {
    pub arch_init: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub init: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub init_irq: ::std::option::Option<unsafe extern "C" fn()>,
    pub fixup_irqs: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_init_pci() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_pci>(),
        32usize,
        concat!("Size of: ", stringify!(x86_init_pci))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_pci>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_pci))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_pci>())).arch_init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_pci),
            "::",
            stringify!(arch_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_pci>())).init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_pci),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_pci>())).init_irq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_pci),
            "::",
            stringify!(init_irq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_pci>())).fixup_irqs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_pci),
            "::",
            stringify!(fixup_irqs)
        )
    );
}
#[doc = " struct x86_hyper_init - x86 hypervisor init functions"]
#[doc = " @init_platform:\t\tplatform setup"]
#[doc = " @guest_late_init:\t\tguest late init"]
#[doc = " @x2apic_available:\t\tX2APIC detection"]
#[doc = " @msi_ext_dest_id:\t\tMSI supports 15-bit APIC IDs"]
#[doc = " @init_mem_mapping:\t\tsetup early mappings during init_mem_mapping()"]
#[doc = " @init_after_bootmem:\t\tguest init after boot allocator is finished"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_hyper_init {
    pub init_platform: ::std::option::Option<unsafe extern "C" fn()>,
    pub guest_late_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub x2apic_available: ::std::option::Option<unsafe extern "C" fn() -> bool_>,
    pub msi_ext_dest_id: ::std::option::Option<unsafe extern "C" fn() -> bool_>,
    pub init_mem_mapping: ::std::option::Option<unsafe extern "C" fn()>,
    pub init_after_bootmem: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_hyper_init() {
    assert_eq!(
        ::std::mem::size_of::<x86_hyper_init>(),
        48usize,
        concat!("Size of: ", stringify!(x86_hyper_init))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_hyper_init>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_hyper_init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hyper_init>())).init_platform as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hyper_init),
            "::",
            stringify!(init_platform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hyper_init>())).guest_late_init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hyper_init),
            "::",
            stringify!(guest_late_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hyper_init>())).x2apic_available as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hyper_init),
            "::",
            stringify!(x2apic_available)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hyper_init>())).msi_ext_dest_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hyper_init),
            "::",
            stringify!(msi_ext_dest_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hyper_init>())).init_mem_mapping as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hyper_init),
            "::",
            stringify!(init_mem_mapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_hyper_init>())).init_after_bootmem as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hyper_init),
            "::",
            stringify!(init_after_bootmem)
        )
    );
}
#[doc = " struct x86_init_acpi - x86 ACPI init functions"]
#[doc = " @set_root_poitner:\t\tset RSDP address"]
#[doc = " @get_root_pointer:\t\tget RSDP address"]
#[doc = " @reduced_hw_early_init:\thardware reduced platform early init"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_init_acpi {
    pub set_root_pointer: ::std::option::Option<unsafe extern "C" fn(addr: u64_)>,
    pub get_root_pointer: ::std::option::Option<unsafe extern "C" fn() -> u64_>,
    pub reduced_hw_early_init: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_init_acpi() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_acpi>(),
        24usize,
        concat!("Size of: ", stringify!(x86_init_acpi))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_acpi>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_acpi))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_acpi>())).set_root_pointer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_acpi),
            "::",
            stringify!(set_root_pointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_acpi>())).get_root_pointer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_acpi),
            "::",
            stringify!(get_root_pointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_init_acpi>())).reduced_hw_early_init as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_acpi),
            "::",
            stringify!(reduced_hw_early_init)
        )
    );
}
#[doc = " struct x86_guest - Functions used by misc guest incarnations like SEV, TDX, etc."]
#[doc = ""]
#[doc = " @enc_status_change_prepare\tNotify HV before the encryption status of a range is changed"]
#[doc = " @enc_status_change_finish\tNotify HV after the encryption status of a range is changed"]
#[doc = " @enc_tlb_flush_required\tReturns true if a TLB flush is needed before changing page encryption status"]
#[doc = " @enc_cache_flush_required\tReturns true if a cache flush is needed before changing page encryption status"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_guest {
    pub enc_status_change_prepare: ::std::option::Option<
        unsafe extern "C" fn(
            vaddr: ::std::os::raw::c_ulong,
            npages: ::std::os::raw::c_int,
            enc: bool_,
        ),
    >,
    pub enc_status_change_finish: ::std::option::Option<
        unsafe extern "C" fn(
            vaddr: ::std::os::raw::c_ulong,
            npages: ::std::os::raw::c_int,
            enc: bool_,
        ) -> bool_,
    >,
    pub enc_tlb_flush_required: ::std::option::Option<unsafe extern "C" fn(enc: bool_) -> bool_>,
    pub enc_cache_flush_required: ::std::option::Option<unsafe extern "C" fn() -> bool_>,
}
#[test]
fn bindgen_test_layout_x86_guest() {
    assert_eq!(
        ::std::mem::size_of::<x86_guest>(),
        32usize,
        concat!("Size of: ", stringify!(x86_guest))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_guest>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_guest))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_guest>())).enc_status_change_prepare as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_guest),
            "::",
            stringify!(enc_status_change_prepare)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_guest>())).enc_status_change_finish as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_guest),
            "::",
            stringify!(enc_status_change_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_guest>())).enc_tlb_flush_required as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_guest),
            "::",
            stringify!(enc_tlb_flush_required)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_guest>())).enc_cache_flush_required as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_guest),
            "::",
            stringify!(enc_cache_flush_required)
        )
    );
}
#[doc = " struct x86_init_ops - functions for platform specific setup"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_init_ops {
    pub resources: x86_init_resources,
    pub mpparse: x86_init_mpparse,
    pub irqs: x86_init_irqs,
    pub oem: x86_init_oem,
    pub paging: x86_init_paging,
    pub timers: x86_init_timers,
    pub iommu: x86_init_iommu,
    pub pci: x86_init_pci,
    pub hyper: x86_hyper_init,
    pub acpi: x86_init_acpi,
}
#[test]
fn bindgen_test_layout_x86_init_ops() {
    assert_eq!(
        ::std::mem::size_of::<x86_init_ops>(),
        248usize,
        concat!("Size of: ", stringify!(x86_init_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_init_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_init_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).resources as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(resources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).mpparse as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(mpparse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).irqs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(irqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).oem as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(oem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).paging as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(paging)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).timers as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(timers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).iommu as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(iommu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).pci as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(pci)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).hyper as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(hyper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_init_ops>())).acpi as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_init_ops),
            "::",
            stringify!(acpi)
        )
    );
}
#[doc = " struct x86_cpuinit_ops - platform specific cpu hotplug setups"]
#[doc = " @setup_percpu_clockev:\tset up the per cpu clock event device"]
#[doc = " @early_percpu_clock_init:\tearly init of the per cpu clock event device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_cpuinit_ops {
    pub setup_percpu_clockev: ::std::option::Option<unsafe extern "C" fn()>,
    pub early_percpu_clock_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub fixup_cpu_id: ::std::option::Option<
        unsafe extern "C" fn(c: *mut cpuinfo_x86, node: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout_x86_cpuinit_ops() {
    assert_eq!(
        ::std::mem::size_of::<x86_cpuinit_ops>(),
        24usize,
        concat!("Size of: ", stringify!(x86_cpuinit_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_cpuinit_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_cpuinit_ops))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_cpuinit_ops>())).setup_percpu_clockev as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_cpuinit_ops),
            "::",
            stringify!(setup_percpu_clockev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_cpuinit_ops>())).early_percpu_clock_init as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_cpuinit_ops),
            "::",
            stringify!(early_percpu_clock_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_cpuinit_ops>())).fixup_cpu_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_cpuinit_ops),
            "::",
            stringify!(fixup_cpu_id)
        )
    );
}
#[doc = " struct x86_legacy_devices - legacy x86 devices"]
#[doc = ""]
#[doc = " @pnpbios: this platform can have a PNPBIOS. If this is disabled the platform"]
#[doc = " \tis known to never have a PNPBIOS."]
#[doc = ""]
#[doc = " These are devices known to require LPC or ISA bus. The definition of legacy"]
#[doc = " devices adheres to the ACPI 5.2.9.3 IA-PC Boot Architecture flag"]
#[doc = " ACPI_FADT_LEGACY_DEVICES. These devices consist of user visible devices on"]
#[doc = " the LPC or ISA bus. User visible devices are devices that have end-user"]
#[doc = " accessible connectors (for example, LPT parallel port). Legacy devices on"]
#[doc = " the LPC bus consist for example of serial and parallel ports, PS/2 keyboard"]
#[doc = " / mouse, and the floppy disk controller. A system that lacks all known"]
#[doc = " legacy devices can assume all devices can be detected exclusively via"]
#[doc = " standard device enumeration mechanisms including the ACPI namespace."]
#[doc = ""]
#[doc = " A system which has does not have ACPI_FADT_LEGACY_DEVICES enabled must not"]
#[doc = " have any of the legacy devices enumerated below present."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_legacy_devices {
    pub pnpbios: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_x86_legacy_devices() {
    assert_eq!(
        ::std::mem::size_of::<x86_legacy_devices>(),
        4usize,
        concat!("Size of: ", stringify!(x86_legacy_devices))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_legacy_devices>(),
        4usize,
        concat!("Alignment of ", stringify!(x86_legacy_devices))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_legacy_devices>())).pnpbios as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_legacy_devices),
            "::",
            stringify!(pnpbios)
        )
    );
}
pub const x86_legacy_i8042_state_X86_LEGACY_I8042_PLATFORM_ABSENT: x86_legacy_i8042_state = 0;
pub const x86_legacy_i8042_state_X86_LEGACY_I8042_FIRMWARE_ABSENT: x86_legacy_i8042_state = 1;
pub const x86_legacy_i8042_state_X86_LEGACY_I8042_EXPECTED_PRESENT: x86_legacy_i8042_state = 2;
#[doc = " enum x86_legacy_i8042_state - i8042 keyboard controller state"]
#[doc = " @X86_LEGACY_I8042_PLATFORM_ABSENT: the controller is always absent on"]
#[doc = "\tgiven platform/subarch."]
#[doc = " @X86_LEGACY_I8042_FIRMWARE_ABSENT: firmware reports that the controller"]
#[doc = "\tis absent."]
#[doc = " @X86_LEGACY_i8042_EXPECTED_PRESENT: the controller is likely to be"]
#[doc = "\tpresent, the i8042 driver should probe for controller existence."]
pub type x86_legacy_i8042_state = ::std::os::raw::c_uint;
#[doc = " struct x86_legacy_features - legacy x86 features"]
#[doc = ""]
#[doc = " @i8042: indicated if we expect the device to have i8042 controller"]
#[doc = "\tpresent."]
#[doc = " @rtc: this device has a CMOS real-time clock present"]
#[doc = " @reserve_bios_regions: boot code will search for the EBDA address and the"]
#[doc = " \tstart of the 640k - 1M BIOS region.  If false, the platform must"]
#[doc = " \tensure that its memory map correctly reserves sub-1MB regions as needed."]
#[doc = " @devices: legacy x86 devices, refer to struct x86_legacy_devices"]
#[doc = " \tdocumentation for further details."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_legacy_features {
    pub i8042: x86_legacy_i8042_state,
    pub rtc: ::std::os::raw::c_int,
    pub warm_reset: ::std::os::raw::c_int,
    pub no_vga: ::std::os::raw::c_int,
    pub reserve_bios_regions: ::std::os::raw::c_int,
    pub devices: x86_legacy_devices,
}
#[test]
fn bindgen_test_layout_x86_legacy_features() {
    assert_eq!(
        ::std::mem::size_of::<x86_legacy_features>(),
        24usize,
        concat!("Size of: ", stringify!(x86_legacy_features))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_legacy_features>(),
        4usize,
        concat!("Alignment of ", stringify!(x86_legacy_features))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_legacy_features>())).i8042 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_legacy_features),
            "::",
            stringify!(i8042)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_legacy_features>())).rtc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_legacy_features),
            "::",
            stringify!(rtc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_legacy_features>())).warm_reset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_legacy_features),
            "::",
            stringify!(warm_reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_legacy_features>())).no_vga as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_legacy_features),
            "::",
            stringify!(no_vga)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_legacy_features>())).reserve_bios_regions as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_legacy_features),
            "::",
            stringify!(reserve_bios_regions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_legacy_features>())).devices as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_legacy_features),
            "::",
            stringify!(devices)
        )
    );
}
#[doc = " struct x86_hyper_runtime - x86 hypervisor specific runtime callbacks"]
#[doc = ""]
#[doc = " @pin_vcpu:\t\t\tpin current vcpu to specified physical"]
#[doc = "\t\t\t\tcpu (run rarely)"]
#[doc = " @sev_es_hcall_prepare:\tLoad additional hypervisor-specific"]
#[doc = "\t\t\t\tstate into the GHCB when doing a VMMCALL under"]
#[doc = "\t\t\t\tSEV-ES. Called from the #VC exception handler."]
#[doc = " @sev_es_hcall_finish:\tCopies state from the GHCB back into the"]
#[doc = "\t\t\t\tprocessor (or pt_regs). Also runs checks on the"]
#[doc = "\t\t\t\tstate returned from the hypervisor after a"]
#[doc = "\t\t\t\tVMMCALL under SEV-ES.  Needs to return 'false'"]
#[doc = "\t\t\t\tif the checks fail.  Called from the #VC"]
#[doc = "\t\t\t\texception handler."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_hyper_runtime {
    pub pin_vcpu: ::std::option::Option<unsafe extern "C" fn(cpu: ::std::os::raw::c_int)>,
    pub sev_es_hcall_prepare:
        ::std::option::Option<unsafe extern "C" fn(ghcb: *mut ghcb, regs: *mut pt_regs)>,
    pub sev_es_hcall_finish:
        ::std::option::Option<unsafe extern "C" fn(ghcb: *mut ghcb, regs: *mut pt_regs) -> bool_>,
}
#[test]
fn bindgen_test_layout_x86_hyper_runtime() {
    assert_eq!(
        ::std::mem::size_of::<x86_hyper_runtime>(),
        24usize,
        concat!("Size of: ", stringify!(x86_hyper_runtime))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_hyper_runtime>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_hyper_runtime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_hyper_runtime>())).pin_vcpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hyper_runtime),
            "::",
            stringify!(pin_vcpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_hyper_runtime>())).sev_es_hcall_prepare as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hyper_runtime),
            "::",
            stringify!(sev_es_hcall_prepare)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_hyper_runtime>())).sev_es_hcall_finish as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_hyper_runtime),
            "::",
            stringify!(sev_es_hcall_finish)
        )
    );
}
#[doc = " struct x86_platform_ops - platform specific runtime functions"]
#[doc = " @calibrate_cpu:\t\tcalibrate CPU"]
#[doc = " @calibrate_tsc:\t\tcalibrate TSC, if different from CPU"]
#[doc = " @get_wallclock:\t\tget time from HW clock like RTC etc."]
#[doc = " @set_wallclock:\t\tset time back to HW clock"]
#[doc = " @is_untracked_pat_range\texclude from PAT logic"]
#[doc = " @nmi_init\t\t\tenable NMI on cpus"]
#[doc = " @save_sched_clock_state:\tsave state for sched_clock() on suspend"]
#[doc = " @restore_sched_clock_state:\trestore state for sched_clock() on resume"]
#[doc = " @apic_post_init:\t\tadjust apic if needed"]
#[doc = " @legacy:\t\t\tlegacy features"]
#[doc = " @set_legacy_features:\toverride legacy features. Use of this callback"]
#[doc = " \t\t\t\tis highly discouraged. You should only need"]
#[doc = " \t\t\t\tthis if your hardware platform requires further"]
#[doc = " \t\t\t\tcustom fine tuning far beyond what may be"]
#[doc = " \t\t\t\tpossible in x86_early_init_platform_quirks() by"]
#[doc = " \t\t\t\tonly using the current x86_hardware_subarch"]
#[doc = " \t\t\t\tsemantics."]
#[doc = " @hyper:\t\t\tx86 hypervisor specific runtime callbacks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_platform_ops {
    pub calibrate_cpu: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>,
    pub calibrate_tsc: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>,
    pub get_wallclock: ::std::option::Option<unsafe extern "C" fn(ts: *mut timespec64)>,
    pub set_wallclock:
        ::std::option::Option<unsafe extern "C" fn(ts: *const timespec64) -> ::std::os::raw::c_int>,
    pub iommu_shutdown: ::std::option::Option<unsafe extern "C" fn()>,
    pub is_untracked_pat_range:
        ::std::option::Option<unsafe extern "C" fn(start: u64_, end: u64_) -> bool_>,
    pub nmi_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub get_nmi_reason: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_uchar>,
    pub save_sched_clock_state: ::std::option::Option<unsafe extern "C" fn()>,
    pub restore_sched_clock_state: ::std::option::Option<unsafe extern "C" fn()>,
    pub apic_post_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub legacy: x86_legacy_features,
    pub set_legacy_features: ::std::option::Option<unsafe extern "C" fn()>,
    pub hyper: x86_hyper_runtime,
    pub guest: x86_guest,
}
#[test]
fn bindgen_test_layout_x86_platform_ops() {
    assert_eq!(
        ::std::mem::size_of::<x86_platform_ops>(),
        176usize,
        concat!("Size of: ", stringify!(x86_platform_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_platform_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_platform_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).calibrate_cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(calibrate_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).calibrate_tsc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(calibrate_tsc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).get_wallclock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(get_wallclock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).set_wallclock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(set_wallclock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).iommu_shutdown as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(iommu_shutdown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_platform_ops>())).is_untracked_pat_range as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(is_untracked_pat_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).nmi_init as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(nmi_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).get_nmi_reason as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(get_nmi_reason)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_platform_ops>())).save_sched_clock_state as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(save_sched_clock_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_platform_ops>())).restore_sched_clock_state as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(restore_sched_clock_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).apic_post_init as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(apic_post_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).legacy as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<x86_platform_ops>())).set_legacy_features as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(set_legacy_features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).hyper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(hyper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_platform_ops>())).guest as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_platform_ops),
            "::",
            stringify!(guest)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_apic_ops {
    pub io_apic_read: ::std::option::Option<
        unsafe extern "C" fn(
            apic: ::std::os::raw::c_uint,
            reg: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint,
    >,
    pub restore: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_x86_apic_ops() {
    assert_eq!(
        ::std::mem::size_of::<x86_apic_ops>(),
        16usize,
        concat!("Size of: ", stringify!(x86_apic_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<x86_apic_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(x86_apic_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_apic_ops>())).io_apic_read as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_apic_ops),
            "::",
            stringify!(io_apic_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<x86_apic_ops>())).restore as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x86_apic_ops),
            "::",
            stringify!(restore)
        )
    );
}
extern "C" {
    pub static mut x86_init: x86_init_ops;
}
extern "C" {
    pub static mut x86_cpuinit: x86_cpuinit_ops;
}
extern "C" {
    pub static mut x86_platform: x86_platform_ops;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x86_msi_ops {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut x86_msi: x86_msi_ops;
}
extern "C" {
    pub static mut x86_apic_ops: x86_apic_ops;
}
extern "C" {
    pub fn x86_early_init_platform_quirks();
}
extern "C" {
    pub fn x86_init_noop();
}
extern "C" {
    pub fn x86_init_uint_noop(unused: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn bool_x86_init_noop() -> bool_;
}
extern "C" {
    pub fn x86_op_int_noop(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn x86_pnpbios_disabled() -> bool_;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct local_apic {
    pub __reserved_01: local_apic__bindgen_ty_1,
    pub __reserved_02: local_apic__bindgen_ty_2,
    pub id: local_apic__bindgen_ty_3,
    pub version: local_apic__bindgen_ty_4,
    pub __reserved_03: local_apic__bindgen_ty_5,
    pub __reserved_04: local_apic__bindgen_ty_6,
    pub __reserved_05: local_apic__bindgen_ty_7,
    pub __reserved_06: local_apic__bindgen_ty_8,
    pub tpr: local_apic__bindgen_ty_9,
    pub apr: local_apic__bindgen_ty_10,
    pub ppr: local_apic__bindgen_ty_11,
    pub eoi: local_apic__bindgen_ty_12,
    pub __reserved_07: local_apic__bindgen_ty_13,
    pub ldr: local_apic__bindgen_ty_14,
    pub dfr: local_apic__bindgen_ty_15,
    pub svr: local_apic__bindgen_ty_16,
    pub isr: [local_apic__bindgen_ty_17; 8usize],
    pub tmr: [local_apic__bindgen_ty_18; 8usize],
    pub irr: [local_apic__bindgen_ty_19; 8usize],
    pub esr: local_apic__bindgen_ty_20,
    pub __reserved_08: local_apic__bindgen_ty_21,
    pub __reserved_09: local_apic__bindgen_ty_22,
    pub __reserved_10: local_apic__bindgen_ty_23,
    pub __reserved_11: local_apic__bindgen_ty_24,
    pub __reserved_12: local_apic__bindgen_ty_25,
    pub __reserved_13: local_apic__bindgen_ty_26,
    pub __reserved_14: local_apic__bindgen_ty_27,
    pub icr1: local_apic__bindgen_ty_28,
    pub icr2: local_apic__bindgen_ty_29,
    pub lvt_timer: local_apic__bindgen_ty_30,
    pub lvt_thermal: local_apic__bindgen_ty_31,
    pub lvt_pc: local_apic__bindgen_ty_32,
    pub lvt_lint0: local_apic__bindgen_ty_33,
    pub lvt_lint1: local_apic__bindgen_ty_34,
    pub lvt_error: local_apic__bindgen_ty_35,
    pub timer_icr: local_apic__bindgen_ty_36,
    pub timer_ccr: local_apic__bindgen_ty_37,
    pub __reserved_16: local_apic__bindgen_ty_38,
    pub __reserved_17: local_apic__bindgen_ty_39,
    pub __reserved_18: local_apic__bindgen_ty_40,
    pub __reserved_19: local_apic__bindgen_ty_41,
    pub timer_dcr: local_apic__bindgen_ty_42,
    pub __reserved_20: local_apic__bindgen_ty_43,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_1 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_1>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_1),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_2 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_2>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_2),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_3 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_3))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_3>())).__reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_3),
            "::",
            stringify!(__reserved)
        )
    );
}
impl local_apic__bindgen_ty_3 {
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn phys_apic_id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_phys_apic_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __reserved_1: ::std::os::raw::c_uint,
        phys_apic_id: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let phys_apic_id: u32 = unsafe { ::std::mem::transmute(phys_apic_id) };
            phys_apic_id as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_4 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_4>())).__reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_4),
            "::",
            stringify!(__reserved)
        )
    );
}
impl local_apic__bindgen_ty_4 {
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn max_lvt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_lvt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        version: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        max_lvt: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let max_lvt: u32 = unsafe { ::std::mem::transmute(max_lvt) };
            max_lvt as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_5 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_5>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_5>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_5))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_5>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_5),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_6 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_6>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_6))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_6>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_6),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_7 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_7>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_7))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_7>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_7),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_8 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_8>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_8>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_8))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_8>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_8),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_9 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_9>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_9>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_9))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_9>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_9),
            "::",
            stringify!(__reserved_2)
        )
    );
}
impl local_apic__bindgen_ty_9 {
    #[inline]
    pub fn priority(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        priority: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let priority: u32 = unsafe { ::std::mem::transmute(priority) };
            priority as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_10 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_10>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_10))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_10>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_10))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_10>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_10),
            "::",
            stringify!(__reserved_2)
        )
    );
}
impl local_apic__bindgen_ty_10 {
    #[inline]
    pub fn priority(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        priority: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let priority: u32 = unsafe { ::std::mem::transmute(priority) };
            priority as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_11 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_11() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_11>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_11))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_11>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_11))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_11>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_11),
            "::",
            stringify!(__reserved_2)
        )
    );
}
impl local_apic__bindgen_ty_11 {
    #[inline]
    pub fn priority(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        priority: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let priority: u32 = unsafe { ::std::mem::transmute(priority) };
            priority as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_12 {
    pub eoi: ::std::os::raw::c_uint,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_12() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_12>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_12))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_12>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_12))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic__bindgen_ty_12>())).eoi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_12),
            "::",
            stringify!(eoi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_12>())).__reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_12),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_13 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_13() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_13>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_13))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_13>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_13))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_13>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_13),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_14 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_14() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_14>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_14))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_14>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_14))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_14>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_14),
            "::",
            stringify!(__reserved_2)
        )
    );
}
impl local_apic__bindgen_ty_14 {
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn logical_dest(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_logical_dest(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __reserved_1: ::std::os::raw::c_uint,
        logical_dest: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let logical_dest: u32 = unsafe { ::std::mem::transmute(logical_dest) };
            logical_dest as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_15 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_15() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_15>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_15))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_15>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_15))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_15>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_15),
            "::",
            stringify!(__reserved_2)
        )
    );
}
impl local_apic__bindgen_ty_15 {
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn model(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_model(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __reserved_1: ::std::os::raw::c_uint,
        model: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let model: u32 = unsafe { ::std::mem::transmute(model) };
            model as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_16 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_3: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_16() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_16>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_16))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_16>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_16))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_16>())).__reserved_3 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_16),
            "::",
            stringify!(__reserved_3)
        )
    );
}
impl local_apic__bindgen_ty_16 {
    #[inline]
    pub fn spurious_vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_spurious_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn apic_enabled(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apic_enabled(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn focus_cpu(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_focus_cpu(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        spurious_vector: ::std::os::raw::c_uint,
        apic_enabled: ::std::os::raw::c_uint,
        focus_cpu: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let spurious_vector: u32 = unsafe { ::std::mem::transmute(spurious_vector) };
            spurious_vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let apic_enabled: u32 = unsafe { ::std::mem::transmute(apic_enabled) };
            apic_enabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let focus_cpu: u32 = unsafe { ::std::mem::transmute(focus_cpu) };
            focus_cpu as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_17 {
    pub bitfield: ::std::os::raw::c_uint,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_17() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_17>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_17))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_17>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_17))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_17>())).bitfield as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_17),
            "::",
            stringify!(bitfield)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_17>())).__reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_17),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_18 {
    pub bitfield: ::std::os::raw::c_uint,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_18() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_18>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_18))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_18>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_18))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_18>())).bitfield as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_18),
            "::",
            stringify!(bitfield)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_18>())).__reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_18),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_19 {
    pub bitfield: ::std::os::raw::c_uint,
    pub __reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_19() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_19>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_19))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_19>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_19))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_19>())).bitfield as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_19),
            "::",
            stringify!(bitfield)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_19>())).__reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_19),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union local_apic__bindgen_ty_20 {
    pub error_bits: local_apic__bindgen_ty_20__bindgen_ty_1,
    pub all_errors: local_apic__bindgen_ty_20__bindgen_ty_2,
    _bindgen_union_align: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_3: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_20__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_20__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(local_apic__bindgen_ty_20__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_20__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(local_apic__bindgen_ty_20__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_20__bindgen_ty_1>())).__reserved_3
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_20__bindgen_ty_1),
            "::",
            stringify!(__reserved_3)
        )
    );
}
impl local_apic__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn send_cs_error(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_send_cs_error(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn receive_cs_error(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_receive_cs_error(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn send_accept_error(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_send_accept_error(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn receive_accept_error(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_receive_accept_error(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn send_illegal_vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_send_illegal_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn receive_illegal_vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_receive_illegal_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn illegal_register_address(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_illegal_register_address(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        send_cs_error: ::std::os::raw::c_uint,
        receive_cs_error: ::std::os::raw::c_uint,
        send_accept_error: ::std::os::raw::c_uint,
        receive_accept_error: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        send_illegal_vector: ::std::os::raw::c_uint,
        receive_illegal_vector: ::std::os::raw::c_uint,
        illegal_register_address: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let send_cs_error: u32 = unsafe { ::std::mem::transmute(send_cs_error) };
            send_cs_error as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let receive_cs_error: u32 = unsafe { ::std::mem::transmute(receive_cs_error) };
            receive_cs_error as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let send_accept_error: u32 = unsafe { ::std::mem::transmute(send_accept_error) };
            send_accept_error as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let receive_accept_error: u32 = unsafe { ::std::mem::transmute(receive_accept_error) };
            receive_accept_error as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let send_illegal_vector: u32 = unsafe { ::std::mem::transmute(send_illegal_vector) };
            send_illegal_vector as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let receive_illegal_vector: u32 =
                unsafe { ::std::mem::transmute(receive_illegal_vector) };
            receive_illegal_vector as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let illegal_register_address: u32 =
                unsafe { ::std::mem::transmute(illegal_register_address) };
            illegal_register_address as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_20__bindgen_ty_2 {
    pub errors: ::std::os::raw::c_uint,
    pub __reserved_3: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_20__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_20__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(local_apic__bindgen_ty_20__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_20__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(local_apic__bindgen_ty_20__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_20__bindgen_ty_2>())).errors as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_20__bindgen_ty_2),
            "::",
            stringify!(errors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_20__bindgen_ty_2>())).__reserved_3
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_20__bindgen_ty_2),
            "::",
            stringify!(__reserved_3)
        )
    );
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_20() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_20>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_20))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_20>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_20))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_20>())).error_bits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_20),
            "::",
            stringify!(error_bits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_20>())).all_errors as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_20),
            "::",
            stringify!(all_errors)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_21 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_21() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_21>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_21))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_21>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_21))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_21>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_21),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_22 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_22() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_22>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_22))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_22>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_22))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_22>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_22),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_23 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_23() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_23>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_23))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_23>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_23))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_23>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_23),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_24 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_24() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_24>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_24))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_24>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_24))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_24>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_24),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_25 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_25() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_25>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_25))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_25>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_25))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_25>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_25),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_26 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_26() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_26>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_26))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_26>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_26))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_26>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_26),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_27 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_27() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_27>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_27))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_27>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_27))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_27>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_27),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_28 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_28() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_28>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_28))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_28>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_28))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_28>())).__reserved_4 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_28),
            "::",
            stringify!(__reserved_4)
        )
    );
}
impl local_apic__bindgen_ty_28 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn destination_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_destination_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn level(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_level(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trigger(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trigger(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn shorthand(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_shorthand(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: ::std::os::raw::c_uint,
        delivery_mode: ::std::os::raw::c_uint,
        destination_mode: ::std::os::raw::c_uint,
        delivery_status: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        level: ::std::os::raw::c_uint,
        trigger: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
        shorthand: ::std::os::raw::c_uint,
        __reserved_3: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let delivery_mode: u32 = unsafe { ::std::mem::transmute(delivery_mode) };
            delivery_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let destination_mode: u32 = unsafe { ::std::mem::transmute(destination_mode) };
            destination_mode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u32 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let level: u32 = unsafe { ::std::mem::transmute(level) };
            level as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let trigger: u32 = unsafe { ::std::mem::transmute(trigger) };
            trigger as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let shorthand: u32 = unsafe { ::std::mem::transmute(shorthand) };
            shorthand as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let __reserved_3: u32 = unsafe { ::std::mem::transmute(__reserved_3) };
            __reserved_3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct local_apic__bindgen_ty_29 {
    pub dest: local_apic__bindgen_ty_29__bindgen_ty_1,
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union local_apic__bindgen_ty_29__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_29__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_29__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(local_apic__bindgen_ty_29__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_29__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(local_apic__bindgen_ty_29__bindgen_ty_1)
        )
    );
}
impl local_apic__bindgen_ty_29__bindgen_ty_1 {
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn phys_dest(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_phys_dest(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn logical_dest(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_logical_dest(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __reserved_1: ::std::os::raw::c_uint,
        phys_dest: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
        __reserved_3: ::std::os::raw::c_uint,
        logical_dest: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let phys_dest: u32 = unsafe { ::std::mem::transmute(phys_dest) };
            phys_dest as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let __reserved_3: u32 = unsafe { ::std::mem::transmute(__reserved_3) };
            __reserved_3 as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let logical_dest: u32 = unsafe { ::std::mem::transmute(logical_dest) };
            logical_dest as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_29() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_29>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_29))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_29>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_29))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic__bindgen_ty_29>())).dest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_29),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_29>())).__reserved_4 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_29),
            "::",
            stringify!(__reserved_4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_30 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_30() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_30>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_30))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_30>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_30))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_30>())).__reserved_4 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_30),
            "::",
            stringify!(__reserved_4)
        )
    );
}
impl local_apic__bindgen_ty_30 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        delivery_status: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
        timer_mode: ::std::os::raw::c_uint,
        __reserved_3: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u32 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let timer_mode: u32 = unsafe { ::std::mem::transmute(timer_mode) };
            timer_mode as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let __reserved_3: u32 = unsafe { ::std::mem::transmute(__reserved_3) };
            __reserved_3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_31 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_31() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_31>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_31))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_31>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_31))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_31>())).__reserved_4 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_31),
            "::",
            stringify!(__reserved_4)
        )
    );
}
impl local_apic__bindgen_ty_31 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: ::std::os::raw::c_uint,
        delivery_mode: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        delivery_status: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
        __reserved_3: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let delivery_mode: u32 = unsafe { ::std::mem::transmute(delivery_mode) };
            delivery_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u32 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let __reserved_3: u32 = unsafe { ::std::mem::transmute(__reserved_3) };
            __reserved_3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_32 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_32() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_32>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_32))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_32>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_32>())).__reserved_4 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_32),
            "::",
            stringify!(__reserved_4)
        )
    );
}
impl local_apic__bindgen_ty_32 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: ::std::os::raw::c_uint,
        delivery_mode: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        delivery_status: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
        __reserved_3: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let delivery_mode: u32 = unsafe { ::std::mem::transmute(delivery_mode) };
            delivery_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u32 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let __reserved_3: u32 = unsafe { ::std::mem::transmute(__reserved_3) };
            __reserved_3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_33 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __reserved_3: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_33() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_33>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_33))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_33>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_33))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_33>())).__reserved_3 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_33),
            "::",
            stringify!(__reserved_3)
        )
    );
}
impl local_apic__bindgen_ty_33 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn polarity(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_polarity(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remote_irr(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_remote_irr(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trigger(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trigger(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: ::std::os::raw::c_uint,
        delivery_mode: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        delivery_status: ::std::os::raw::c_uint,
        polarity: ::std::os::raw::c_uint,
        remote_irr: ::std::os::raw::c_uint,
        trigger: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let delivery_mode: u32 = unsafe { ::std::mem::transmute(delivery_mode) };
            delivery_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u32 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let polarity: u32 = unsafe { ::std::mem::transmute(polarity) };
            polarity as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let remote_irr: u32 = unsafe { ::std::mem::transmute(remote_irr) };
            remote_irr as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let trigger: u32 = unsafe { ::std::mem::transmute(trigger) };
            trigger as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_34 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __reserved_3: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_34() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_34>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_34))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_34>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_34))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_34>())).__reserved_3 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_34),
            "::",
            stringify!(__reserved_3)
        )
    );
}
impl local_apic__bindgen_ty_34 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_mode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn polarity(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_polarity(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remote_irr(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_remote_irr(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trigger(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trigger(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: ::std::os::raw::c_uint,
        delivery_mode: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        delivery_status: ::std::os::raw::c_uint,
        polarity: ::std::os::raw::c_uint,
        remote_irr: ::std::os::raw::c_uint,
        trigger: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let delivery_mode: u32 = unsafe { ::std::mem::transmute(delivery_mode) };
            delivery_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u32 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let polarity: u32 = unsafe { ::std::mem::transmute(polarity) };
            polarity as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let remote_irr: u32 = unsafe { ::std::mem::transmute(remote_irr) };
            remote_irr as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let trigger: u32 = unsafe { ::std::mem::transmute(trigger) };
            trigger as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_35 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __reserved_4: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_35() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_35>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_35))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_35>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_35))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_35>())).__reserved_4 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_35),
            "::",
            stringify!(__reserved_4)
        )
    );
}
impl local_apic__bindgen_ty_35 {
    #[inline]
    pub fn vector(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vector(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vector: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
        delivery_status: ::std::os::raw::c_uint,
        __reserved_2: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
        __reserved_3: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let vector: u32 = unsafe { ::std::mem::transmute(vector) };
            vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let delivery_status: u32 = unsafe { ::std::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let __reserved_2: u32 = unsafe { ::std::mem::transmute(__reserved_2) };
            __reserved_2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let __reserved_3: u32 = unsafe { ::std::mem::transmute(__reserved_3) };
            __reserved_3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_36 {
    pub initial_count: ::std::os::raw::c_uint,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_36() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_36>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_36))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_36>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_36))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_36>())).initial_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_36),
            "::",
            stringify!(initial_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_36>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_36),
            "::",
            stringify!(__reserved_2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_37 {
    pub curr_count: ::std::os::raw::c_uint,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_37() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_37>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_37))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_37>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_37))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_37>())).curr_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_37),
            "::",
            stringify!(curr_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_37>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_37),
            "::",
            stringify!(__reserved_2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_38 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_38() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_38>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_38))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_38>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_38))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_38>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_38),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_39 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_39() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_39>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_39))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_39>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_39))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_39>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_39),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_40 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_40() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_40>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_40))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_40>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_40))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_40>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_40),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_41 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_41() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_41>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_41))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_41>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_41))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_41>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_41),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_42 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __reserved_2: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_42() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_42>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_42))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_42>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_42))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_42>())).__reserved_2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_42),
            "::",
            stringify!(__reserved_2)
        )
    );
}
impl local_apic__bindgen_ty_42 {
    #[inline]
    pub fn divisor(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_divisor(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved_1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set___reserved_1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        divisor: ::std::os::raw::c_uint,
        __reserved_1: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let divisor: u32 = unsafe { ::std::mem::transmute(divisor) };
            divisor as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let __reserved_1: u32 = unsafe { ::std::mem::transmute(__reserved_1) };
            __reserved_1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_apic__bindgen_ty_43 {
    pub __reserved: [::std::os::raw::c_uint; 4usize],
}
#[test]
fn bindgen_test_layout_local_apic__bindgen_ty_43() {
    assert_eq!(
        ::std::mem::size_of::<local_apic__bindgen_ty_43>(),
        16usize,
        concat!("Size of: ", stringify!(local_apic__bindgen_ty_43))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic__bindgen_ty_43>(),
        4usize,
        concat!("Alignment of ", stringify!(local_apic__bindgen_ty_43))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<local_apic__bindgen_ty_43>())).__reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic__bindgen_ty_43),
            "::",
            stringify!(__reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_local_apic() {
    assert_eq!(
        ::std::mem::size_of::<local_apic>(),
        1024usize,
        concat!("Size of: ", stringify!(local_apic))
    );
    assert_eq!(
        ::std::mem::align_of::<local_apic>(),
        1usize,
        concat!("Alignment of ", stringify!(local_apic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_01 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_01)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_02 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_02)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).version as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_03 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_03)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_04 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_04)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_05 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_05)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_06 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_06)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).tpr as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(tpr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).apr as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(apr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).ppr as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(ppr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).eoi as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(eoi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_07 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_07)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).ldr as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(ldr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).dfr as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(dfr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).svr as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(svr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).isr as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(isr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).tmr as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(tmr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).irr as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(irr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).esr as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(esr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_08 as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_08)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_09 as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_09)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_10 as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_11 as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_12 as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_13 as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_14 as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).icr1 as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(icr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).icr2 as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(icr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).lvt_timer as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(lvt_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).lvt_thermal as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(lvt_thermal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).lvt_pc as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(lvt_pc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).lvt_lint0 as *const _ as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(lvt_lint0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).lvt_lint1 as *const _ as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(lvt_lint1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).lvt_error as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(lvt_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).timer_icr as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(timer_icr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).timer_ccr as *const _ as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(timer_ccr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_16 as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_17 as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_17)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_18 as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_18)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_19 as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_19)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).timer_dcr as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(timer_dcr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<local_apic>())).__reserved_20 as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(local_apic),
            "::",
            stringify!(__reserved_20)
        )
    );
}
pub const apic_delivery_modes_APIC_DELIVERY_MODE_FIXED: apic_delivery_modes = 0;
pub const apic_delivery_modes_APIC_DELIVERY_MODE_LOWESTPRIO: apic_delivery_modes = 1;
pub const apic_delivery_modes_APIC_DELIVERY_MODE_SMI: apic_delivery_modes = 2;
pub const apic_delivery_modes_APIC_DELIVERY_MODE_NMI: apic_delivery_modes = 4;
pub const apic_delivery_modes_APIC_DELIVERY_MODE_INIT: apic_delivery_modes = 5;
pub const apic_delivery_modes_APIC_DELIVERY_MODE_EXTINT: apic_delivery_modes = 7;
pub type apic_delivery_modes = ::std::os::raw::c_uint;
extern "C" {
    pub static mut pic_mode: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut mp_bus_id_to_type: [::std::os::raw::c_int; 256usize];
}
extern "C" {
    pub static mut mp_bus_not_pci: [::std::os::raw::c_ulong; 4usize];
}
extern "C" {
    pub static mut boot_cpu_physical_apicid: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut boot_cpu_apic_version: u8_;
}
extern "C" {
    pub static mut mp_lapic_addr: ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut smp_found_config: ::std::os::raw::c_int;
}
extern "C" {
    pub fn e820__memblock_alloc_reserved_mpc_new();
}
extern "C" {
    pub static mut enable_update_mptable: ::std::os::raw::c_int;
}
extern "C" {
    pub fn default_find_smp_config();
}
extern "C" {
    pub fn default_get_smp_config(early: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn generic_processor_info(
        apicid: ::std::os::raw::c_int,
        version: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct physid_mask {
    pub mask: [::std::os::raw::c_ulong; 512usize],
}
#[test]
fn bindgen_test_layout_physid_mask() {
    assert_eq!(
        ::std::mem::size_of::<physid_mask>(),
        4096usize,
        concat!("Size of: ", stringify!(physid_mask))
    );
    assert_eq!(
        ::std::mem::align_of::<physid_mask>(),
        8usize,
        concat!("Alignment of ", stringify!(physid_mask))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<physid_mask>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(physid_mask),
            "::",
            stringify!(mask)
        )
    );
}
pub type physid_mask_t = physid_mask;
extern "C" {
    pub static mut phys_cpu_present_map: physid_mask_t;
}
extern "C" {
    pub static mut x86_cpu_to_node_map: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut x86_cpu_to_node_map_early_ptr: *mut ::std::os::raw::c_int;
}
extern "C" {
    pub static mut x86_cpu_to_node_map_early_map: [::std::os::raw::c_int; 0usize];
}
extern "C" {
    pub static mut node_to_cpumask_map: [cpumask_var_t; 64usize];
}
extern "C" {
    pub fn setup_node_to_cpumask_map();
}
extern "C" {
    pub fn __node_distance(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cpu_coregroup_mask(cpu: ::std::os::raw::c_int) -> *const cpumask;
}
extern "C" {
    pub fn cpu_clustergroup_mask(cpu: ::std::os::raw::c_int) -> *const cpumask;
}
extern "C" {
    pub static mut __max_die_per_package: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut __max_logical_packages: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut __max_smt_threads: ::std::os::raw::c_int;
}
extern "C" {
    pub fn topology_update_package_map(
        apicid: ::std::os::raw::c_uint,
        cpu: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn topology_update_die_map(
        dieid: ::std::os::raw::c_uint,
        cpu: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn topology_phys_to_logical_pkg(pkg: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn topology_phys_to_logical_die(
        die: ::std::os::raw::c_uint,
        cpu: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn topology_is_primary_thread(cpu: ::std::os::raw::c_uint) -> bool_;
}
extern "C" {
    pub fn topology_smt_supported() -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pci_bus {
    _unused: [u8; 0],
}
extern "C" {
    pub fn x86_pci_root_bus_node(bus: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn x86_pci_root_bus_resources(bus: ::std::os::raw::c_int, resources: *mut list_head);
}
extern "C" {
    pub static mut x86_topology_update: bool_;
}
extern "C" {
    pub static mut sched_core_priority: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sysctl_sched_itmt_enabled: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sched_set_itmt_core_prio(prio: ::std::os::raw::c_int, core_cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sched_set_itmt_support() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_clear_itmt_support();
}
extern "C" {
    pub static mut arch_scale_freq_key: static_key_false;
}
extern "C" {
    pub fn arch_set_max_freq_ratio(turbo_disabled: bool_);
}
extern "C" {
    pub fn freq_invariance_set_perf_ratio(ratio: u64_, turbo_disabled: bool_);
}
extern "C" {
    pub fn arch_scale_freq_tick();
}
extern "C" {
    pub fn init_freq_invariance_cppc();
}
extern "C" {
    pub fn arch_update_cpu_topology() -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut node_reclaim_distance: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut numa_node: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __alloc_pages(
        gfp: gfp_t,
        order: ::std::os::raw::c_uint,
        preferred_nid: ::std::os::raw::c_int,
        nodemask: *mut nodemask_t,
    ) -> *mut page;
}
extern "C" {
    pub fn __folio_alloc(
        gfp: gfp_t,
        order: ::std::os::raw::c_uint,
        preferred_nid: ::std::os::raw::c_int,
        nodemask: *mut nodemask_t,
    ) -> *mut folio;
}
extern "C" {
    pub fn __alloc_pages_bulk(
        gfp: gfp_t,
        preferred_nid: ::std::os::raw::c_int,
        nodemask: *mut nodemask_t,
        nr_pages: ::std::os::raw::c_int,
        page_list: *mut list_head,
        page_array: *mut *mut page,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn alloc_pages_bulk_array_mempolicy(
        gfp: gfp_t,
        nr_pages: ::std::os::raw::c_ulong,
        page_array: *mut *mut page,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn alloc_pages(gfp: gfp_t, order: ::std::os::raw::c_uint) -> *mut page;
}
extern "C" {
    pub fn folio_alloc(gfp: gfp_t, order: ::std::os::raw::c_uint) -> *mut folio;
}
extern "C" {
    pub fn vma_alloc_folio(
        gfp: gfp_t,
        order: ::std::os::raw::c_int,
        vma: *mut vm_area_struct,
        addr: ::std::os::raw::c_ulong,
        hugepage: bool_,
    ) -> *mut folio;
}
extern "C" {
    pub fn __get_free_pages(
        gfp_mask: gfp_t,
        order: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn get_zeroed_page(gfp_mask: gfp_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn alloc_pages_exact(size: size_t, gfp_mask: gfp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free_pages_exact(virt: *mut ::std::os::raw::c_void, size: size_t);
}
extern "C" {
    pub fn alloc_pages_exact_nid(
        nid: ::std::os::raw::c_int,
        size: size_t,
        gfp_mask: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __free_pages(page: *mut page, order: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn free_pages(addr: ::std::os::raw::c_ulong, order: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn __page_frag_cache_drain(page: *mut page, count: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn page_frag_alloc_align(
        nc: *mut page_frag_cache,
        fragsz: ::std::os::raw::c_uint,
        gfp_mask: gfp_t,
        align_mask: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn page_frag_free(addr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn page_alloc_init();
}
extern "C" {
    pub fn drain_zone_pages(zone: *mut zone, pcp: *mut per_cpu_pages);
}
extern "C" {
    pub fn drain_all_pages(zone: *mut zone);
}
extern "C" {
    pub fn drain_local_pages(zone: *mut zone);
}
extern "C" {
    pub fn page_alloc_init_late();
}
extern "C" {
    pub static mut gfp_allowed_mask: gfp_t;
}
extern "C" {
    pub fn gfp_pfmemalloc_allowed(gfp_mask: gfp_t) -> bool_;
}
extern "C" {
    pub fn pm_restrict_gfp_mask();
}
extern "C" {
    pub fn pm_restore_gfp_mask();
}
extern "C" {
    pub fn vma_thp_gfp_mask(vma: *mut vm_area_struct) -> gfp_t;
}
extern "C" {
    pub fn pm_suspended_storage() -> bool_;
}
extern "C" {
    pub fn free_contig_range(pfn: ::std::os::raw::c_ulong, nr_pages: ::std::os::raw::c_ulong);
}
#[doc = " struct clone_args - arguments for the clone3 syscall"]
#[doc = " @flags:        Flags for the new process as listed above."]
#[doc = "                All flags are valid except for CSIGNAL and"]
#[doc = "                CLONE_DETACHED."]
#[doc = " @pidfd:        If CLONE_PIDFD is set, a pidfd will be"]
#[doc = "                returned in this argument."]
#[doc = " @child_tid:    If CLONE_CHILD_SETTID is set, the TID of the"]
#[doc = "                child process will be returned in the child's"]
#[doc = "                memory."]
#[doc = " @parent_tid:   If CLONE_PARENT_SETTID is set, the TID of"]
#[doc = "                the child process will be returned in the"]
#[doc = "                parent's memory."]
#[doc = " @exit_signal:  The exit_signal the parent process will be"]
#[doc = "                sent when the child exits."]
#[doc = " @stack:        Specify the location of the stack for the"]
#[doc = "                child process."]
#[doc = "                Note, @stack is expected to point to the"]
#[doc = "                lowest address. The stack direction will be"]
#[doc = "                determined by the kernel and set up"]
#[doc = "                appropriately based on @stack_size."]
#[doc = " @stack_size:   The size of the stack for the child process."]
#[doc = " @tls:          If CLONE_SETTLS is set, the tls descriptor"]
#[doc = "                is set to tls."]
#[doc = " @set_tid:      Pointer to an array of type *pid_t. The size"]
#[doc = "                of the array is defined using @set_tid_size."]
#[doc = "                This array is used to select PIDs/TIDs for"]
#[doc = "                newly created processes. The first element in"]
#[doc = "                this defines the PID in the most nested PID"]
#[doc = "                namespace. Each additional element in the array"]
#[doc = "                defines the PID in the parent PID namespace of"]
#[doc = "                the original PID namespace. If the array has"]
#[doc = "                less entries than the number of currently"]
#[doc = "                nested PID namespaces only the PIDs in the"]
#[doc = "                corresponding namespaces are set."]
#[doc = " @set_tid_size: This defines the size of the array referenced"]
#[doc = "                in @set_tid. This cannot be larger than the"]
#[doc = "                kernel's limit of nested PID namespaces."]
#[doc = " @cgroup:       If CLONE_INTO_CGROUP is specified set this to"]
#[doc = "                a file descriptor for the cgroup."]
#[doc = ""]
#[doc = " The structure is versioned by size and thus extensible."]
#[doc = " New struct members must go at the end of the struct and"]
#[doc = " must be properly 64bit aligned."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clone_args {
    pub flags: __u64,
    pub pidfd: __u64,
    pub child_tid: __u64,
    pub parent_tid: __u64,
    pub exit_signal: __u64,
    pub stack: __u64,
    pub stack_size: __u64,
    pub tls: __u64,
    pub set_tid: __u64,
    pub set_tid_size: __u64,
    pub cgroup: __u64,
}
#[test]
fn bindgen_test_layout_clone_args() {
    assert_eq!(
        ::std::mem::size_of::<clone_args>(),
        88usize,
        concat!("Size of: ", stringify!(clone_args))
    );
    assert_eq!(
        ::std::mem::align_of::<clone_args>(),
        8usize,
        concat!("Alignment of ", stringify!(clone_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).pidfd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(pidfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).child_tid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(child_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).parent_tid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(parent_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).exit_signal as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(exit_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).stack as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).stack_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(stack_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).tls as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(tls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).set_tid as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(set_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).set_tid_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(set_tid_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clone_args>())).cgroup as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(clone_args),
            "::",
            stringify!(cgroup)
        )
    );
}
pub const pid_type_PIDTYPE_PID: pid_type = 0;
pub const pid_type_PIDTYPE_TGID: pid_type = 1;
pub const pid_type_PIDTYPE_PGID: pid_type = 2;
pub const pid_type_PIDTYPE_SID: pid_type = 3;
pub const pid_type_PIDTYPE_MAX: pid_type = 4;
pub type pid_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct upid {
    pub nr: ::std::os::raw::c_int,
    pub ns: *mut pid_namespace,
}
#[test]
fn bindgen_test_layout_upid() {
    assert_eq!(
        ::std::mem::size_of::<upid>(),
        16usize,
        concat!("Size of: ", stringify!(upid))
    );
    assert_eq!(
        ::std::mem::align_of::<upid>(),
        8usize,
        concat!("Alignment of ", stringify!(upid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<upid>())).nr as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(upid), "::", stringify!(nr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<upid>())).ns as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(upid), "::", stringify!(ns))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pid {
    pub count: refcount_t,
    pub level: ::std::os::raw::c_uint,
    pub lock: spinlock_t,
    pub tasks: [hlist_head; 4usize],
    pub inodes: hlist_head,
    pub wait_pidfd: wait_queue_head_t,
    pub rcu: callback_head,
    pub numbers: [upid; 1usize],
}
#[test]
fn bindgen_test_layout_pid() {
    assert_eq!(
        ::std::mem::size_of::<pid>(),
        112usize,
        concat!("Size of: ", stringify!(pid))
    );
    assert_eq!(
        ::std::mem::align_of::<pid>(),
        8usize,
        concat!("Alignment of ", stringify!(pid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pid>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pid>())).level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pid>())).lock as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(pid), "::", stringify!(lock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pid>())).tasks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pid>())).inodes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(inodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pid>())).wait_pidfd as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(wait_pidfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pid>())).rcu as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(pid), "::", stringify!(rcu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pid>())).numbers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(pid),
            "::",
            stringify!(numbers)
        )
    );
}
extern "C" {
    pub static mut init_struct_pid: pid;
}
extern "C" {
    pub static pidfd_fops: file_operations;
}
extern "C" {
    pub fn pidfd_pid(file: *const file) -> *mut pid;
}
extern "C" {
    pub fn pidfd_get_pid(
        fd: ::std::os::raw::c_uint,
        flags: *mut ::std::os::raw::c_uint,
    ) -> *mut pid;
}
extern "C" {
    pub fn pidfd_get_task(
        pidfd: ::std::os::raw::c_int,
        flags: *mut ::std::os::raw::c_uint,
    ) -> *mut task_struct;
}
extern "C" {
    pub fn pidfd_create(pid: *mut pid, flags: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn put_pid(pid: *mut pid);
}
extern "C" {
    pub fn pid_task(pid: *mut pid, arg1: pid_type) -> *mut task_struct;
}
extern "C" {
    pub fn get_pid_task(pid: *mut pid, arg1: pid_type) -> *mut task_struct;
}
extern "C" {
    pub fn get_task_pid(task: *mut task_struct, type_: pid_type) -> *mut pid;
}
extern "C" {
    pub fn attach_pid(task: *mut task_struct, arg1: pid_type);
}
extern "C" {
    pub fn detach_pid(task: *mut task_struct, arg1: pid_type);
}
extern "C" {
    pub fn change_pid(task: *mut task_struct, arg1: pid_type, pid: *mut pid);
}
extern "C" {
    pub fn exchange_tids(task: *mut task_struct, old: *mut task_struct);
}
extern "C" {
    pub fn transfer_pid(old: *mut task_struct, new: *mut task_struct, arg1: pid_type);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pid_namespace {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut init_pid_ns: pid_namespace;
}
extern "C" {
    pub static mut pid_max: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut pid_max_min: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut pid_max_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn find_pid_ns(nr: ::std::os::raw::c_int, ns: *mut pid_namespace) -> *mut pid;
}
extern "C" {
    pub fn find_vpid(nr: ::std::os::raw::c_int) -> *mut pid;
}
extern "C" {
    pub fn find_get_pid(nr: ::std::os::raw::c_int) -> *mut pid;
}
extern "C" {
    pub fn find_ge_pid(nr: ::std::os::raw::c_int, arg1: *mut pid_namespace) -> *mut pid;
}
extern "C" {
    pub fn alloc_pid(ns: *mut pid_namespace, set_tid: *mut pid_t, set_tid_size: size_t)
        -> *mut pid;
}
extern "C" {
    pub fn free_pid(pid: *mut pid);
}
extern "C" {
    pub fn disable_pid_allocation(ns: *mut pid_namespace);
}
extern "C" {
    pub fn pid_nr_ns(pid: *mut pid, ns: *mut pid_namespace) -> pid_t;
}
extern "C" {
    pub fn pid_vnr(pid: *mut pid) -> pid_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhash_head {
    pub next: *mut rhash_head,
}
#[test]
fn bindgen_test_layout_rhash_head() {
    assert_eq!(
        ::std::mem::size_of::<rhash_head>(),
        8usize,
        concat!("Size of: ", stringify!(rhash_head))
    );
    assert_eq!(
        ::std::mem::align_of::<rhash_head>(),
        8usize,
        concat!("Alignment of ", stringify!(rhash_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhash_head>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rhash_head),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhlist_head {
    pub rhead: rhash_head,
    pub next: *mut rhlist_head,
}
#[test]
fn bindgen_test_layout_rhlist_head() {
    assert_eq!(
        ::std::mem::size_of::<rhlist_head>(),
        16usize,
        concat!("Size of: ", stringify!(rhlist_head))
    );
    assert_eq!(
        ::std::mem::align_of::<rhlist_head>(),
        8usize,
        concat!("Alignment of ", stringify!(rhlist_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhlist_head>())).rhead as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rhlist_head),
            "::",
            stringify!(rhead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhlist_head>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rhlist_head),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bucket_table {
    _unused: [u8; 0],
}
#[doc = " struct rhashtable_compare_arg - Key for the function rhashtable_compare"]
#[doc = " @ht: Hash table"]
#[doc = " @key: Key to compare against"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhashtable_compare_arg {
    pub ht: *mut rhashtable,
    pub key: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rhashtable_compare_arg() {
    assert_eq!(
        ::std::mem::size_of::<rhashtable_compare_arg>(),
        16usize,
        concat!("Size of: ", stringify!(rhashtable_compare_arg))
    );
    assert_eq!(
        ::std::mem::align_of::<rhashtable_compare_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(rhashtable_compare_arg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_compare_arg>())).ht as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_compare_arg),
            "::",
            stringify!(ht)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_compare_arg>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_compare_arg),
            "::",
            stringify!(key)
        )
    );
}
pub type rht_hashfn_t = ::std::option::Option<
    unsafe extern "C" fn(data: *const ::std::os::raw::c_void, len: u32_, seed: u32_) -> u32_,
>;
pub type rht_obj_hashfn_t = ::std::option::Option<
    unsafe extern "C" fn(data: *const ::std::os::raw::c_void, len: u32_, seed: u32_) -> u32_,
>;
pub type rht_obj_cmpfn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut rhashtable_compare_arg,
        obj: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " struct rhashtable_params - Hash table construction parameters"]
#[doc = " @nelem_hint: Hint on number of elements, should be 75% of desired size"]
#[doc = " @key_len: Length of key"]
#[doc = " @key_offset: Offset of key in struct to be hashed"]
#[doc = " @head_offset: Offset of rhash_head in struct to be hashed"]
#[doc = " @max_size: Maximum size while expanding"]
#[doc = " @min_size: Minimum size while shrinking"]
#[doc = " @automatic_shrinking: Enable automatic shrinking of tables"]
#[doc = " @hashfn: Hash function (default: jhash2 if !(key_len % 4), or jhash)"]
#[doc = " @obj_hashfn: Function to hash object"]
#[doc = " @obj_cmpfn: Function to compare key with object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhashtable_params {
    pub nelem_hint: u16_,
    pub key_len: u16_,
    pub key_offset: u16_,
    pub head_offset: u16_,
    pub max_size: ::std::os::raw::c_uint,
    pub min_size: u16_,
    pub automatic_shrinking: bool_,
    pub hashfn: rht_hashfn_t,
    pub obj_hashfn: rht_obj_hashfn_t,
    pub obj_cmpfn: rht_obj_cmpfn_t,
}
#[test]
fn bindgen_test_layout_rhashtable_params() {
    assert_eq!(
        ::std::mem::size_of::<rhashtable_params>(),
        40usize,
        concat!("Size of: ", stringify!(rhashtable_params))
    );
    assert_eq!(
        ::std::mem::align_of::<rhashtable_params>(),
        8usize,
        concat!("Alignment of ", stringify!(rhashtable_params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_params>())).nelem_hint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(nelem_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_params>())).key_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_params>())).key_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(key_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_params>())).head_offset as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(head_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_params>())).max_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(max_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_params>())).min_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(min_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rhashtable_params>())).automatic_shrinking as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(automatic_shrinking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_params>())).hashfn as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(hashfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_params>())).obj_hashfn as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(obj_hashfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_params>())).obj_cmpfn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_params),
            "::",
            stringify!(obj_cmpfn)
        )
    );
}
#[doc = " struct rhashtable - Hash table handle"]
#[doc = " @tbl: Bucket table"]
#[doc = " @key_len: Key length for hashfn"]
#[doc = " @max_elems: Maximum number of elements in table"]
#[doc = " @p: Configuration parameters"]
#[doc = " @rhlist: True if this is an rhltable"]
#[doc = " @run_work: Deferred worker to expand/shrink asynchronously"]
#[doc = " @mutex: Mutex to protect current/future table swapping"]
#[doc = " @lock: Spin lock to protect walker list"]
#[doc = " @nelems: Number of elements in table"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable {
    pub tbl: *mut bucket_table,
    pub key_len: ::std::os::raw::c_uint,
    pub max_elems: ::std::os::raw::c_uint,
    pub p: rhashtable_params,
    pub rhlist: bool_,
    pub run_work: work_struct,
    pub mutex: mutex,
    pub lock: spinlock_t,
    pub nelems: atomic_t,
}
#[test]
fn bindgen_test_layout_rhashtable() {
    assert_eq!(
        ::std::mem::size_of::<rhashtable>(),
        136usize,
        concat!("Size of: ", stringify!(rhashtable))
    );
    assert_eq!(
        ::std::mem::align_of::<rhashtable>(),
        8usize,
        concat!("Alignment of ", stringify!(rhashtable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable>())).tbl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(tbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable>())).key_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable>())).max_elems as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(max_elems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable>())).p as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable>())).rhlist as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(rhlist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable>())).run_work as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(run_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable>())).mutex as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable>())).lock as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable>())).nelems as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable),
            "::",
            stringify!(nelems)
        )
    );
}
#[doc = " struct rhltable - Hash table with duplicate objects in a list"]
#[doc = " @ht: Underlying rhtable"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhltable {
    pub ht: rhashtable,
}
#[test]
fn bindgen_test_layout_rhltable() {
    assert_eq!(
        ::std::mem::size_of::<rhltable>(),
        136usize,
        concat!("Size of: ", stringify!(rhltable))
    );
    assert_eq!(
        ::std::mem::align_of::<rhltable>(),
        8usize,
        concat!("Alignment of ", stringify!(rhltable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhltable>())).ht as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rhltable),
            "::",
            stringify!(ht)
        )
    );
}
#[doc = " struct rhashtable_walker - Hash table walker"]
#[doc = " @list: List entry on list of walkers"]
#[doc = " @tbl: The table that we were walking over"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhashtable_walker {
    pub list: list_head,
    pub tbl: *mut bucket_table,
}
#[test]
fn bindgen_test_layout_rhashtable_walker() {
    assert_eq!(
        ::std::mem::size_of::<rhashtable_walker>(),
        24usize,
        concat!("Size of: ", stringify!(rhashtable_walker))
    );
    assert_eq!(
        ::std::mem::align_of::<rhashtable_walker>(),
        8usize,
        concat!("Alignment of ", stringify!(rhashtable_walker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_walker>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_walker),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_walker>())).tbl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_walker),
            "::",
            stringify!(tbl)
        )
    );
}
#[doc = " struct rhashtable_iter - Hash table iterator"]
#[doc = " @ht: Table to iterate through"]
#[doc = " @p: Current pointer"]
#[doc = " @list: Current hash list pointer"]
#[doc = " @walker: Associated rhashtable walker"]
#[doc = " @slot: Current slot"]
#[doc = " @skip: Number of entries to skip in slot"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rhashtable_iter {
    pub ht: *mut rhashtable,
    pub p: *mut rhash_head,
    pub list: *mut rhlist_head,
    pub walker: rhashtable_walker,
    pub slot: ::std::os::raw::c_uint,
    pub skip: ::std::os::raw::c_uint,
    pub end_of_table: bool_,
}
#[test]
fn bindgen_test_layout_rhashtable_iter() {
    assert_eq!(
        ::std::mem::size_of::<rhashtable_iter>(),
        64usize,
        concat!("Size of: ", stringify!(rhashtable_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<rhashtable_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(rhashtable_iter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_iter>())).ht as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_iter),
            "::",
            stringify!(ht)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_iter>())).p as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_iter),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_iter>())).list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_iter),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_iter>())).walker as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_iter),
            "::",
            stringify!(walker)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_iter>())).slot as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_iter),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_iter>())).skip as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_iter),
            "::",
            stringify!(skip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rhashtable_iter>())).end_of_table as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rhashtable_iter),
            "::",
            stringify!(end_of_table)
        )
    );
}
extern "C" {
    pub fn rhashtable_init(
        ht: *mut rhashtable,
        params: *const rhashtable_params,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rhltable_init(
        hlt: *mut rhltable,
        params: *const rhashtable_params,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipc_perm {
    pub key: __kernel_key_t,
    pub uid: __kernel_uid_t,
    pub gid: __kernel_gid_t,
    pub cuid: __kernel_uid_t,
    pub cgid: __kernel_gid_t,
    pub mode: __kernel_mode_t,
    pub seq: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_ipc_perm() {
    assert_eq!(
        ::std::mem::size_of::<ipc_perm>(),
        28usize,
        concat!("Size of: ", stringify!(ipc_perm))
    );
    assert_eq!(
        ::std::mem::align_of::<ipc_perm>(),
        4usize,
        concat!("Alignment of ", stringify!(ipc_perm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_perm>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_perm),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_perm>())).uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_perm),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_perm>())).gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_perm),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_perm>())).cuid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_perm),
            "::",
            stringify!(cuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_perm>())).cgid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_perm),
            "::",
            stringify!(cgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_perm>())).mode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_perm),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_perm>())).seq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_perm),
            "::",
            stringify!(seq)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct ipc64_perm {
    pub key: __kernel_key_t,
    pub uid: __kernel_uid32_t,
    pub gid: __kernel_gid32_t,
    pub cuid: __kernel_uid32_t,
    pub cgid: __kernel_gid32_t,
    pub mode: __kernel_mode_t,
    pub __pad1: __IncompleteArrayField<::std::os::raw::c_uchar>,
    pub seq: ::std::os::raw::c_ushort,
    pub __pad2: ::std::os::raw::c_ushort,
    pub __unused1: __kernel_ulong_t,
    pub __unused2: __kernel_ulong_t,
}
#[test]
fn bindgen_test_layout_ipc64_perm() {
    assert_eq!(
        ::std::mem::size_of::<ipc64_perm>(),
        48usize,
        concat!("Size of: ", stringify!(ipc64_perm))
    );
    assert_eq!(
        ::std::mem::align_of::<ipc64_perm>(),
        8usize,
        concat!("Alignment of ", stringify!(ipc64_perm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc64_perm>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc64_perm),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc64_perm>())).uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc64_perm),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc64_perm>())).gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc64_perm),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc64_perm>())).cuid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc64_perm),
            "::",
            stringify!(cuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc64_perm>())).cgid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc64_perm),
            "::",
            stringify!(cgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc64_perm>())).mode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc64_perm),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc64_perm>())).__pad1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc64_perm),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc64_perm>())).seq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc64_perm),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc64_perm>())).__pad2 as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc64_perm),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc64_perm>())).__unused1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc64_perm),
            "::",
            stringify!(__unused1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc64_perm>())).__unused2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc64_perm),
            "::",
            stringify!(__unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ipc_kludge {
    pub msgp: *mut msgbuf,
    pub msgtyp: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ipc_kludge() {
    assert_eq!(
        ::std::mem::size_of::<ipc_kludge>(),
        16usize,
        concat!("Size of: ", stringify!(ipc_kludge))
    );
    assert_eq!(
        ::std::mem::align_of::<ipc_kludge>(),
        8usize,
        concat!("Alignment of ", stringify!(ipc_kludge))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_kludge>())).msgp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_kludge),
            "::",
            stringify!(msgp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipc_kludge>())).msgtyp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ipc_kludge),
            "::",
            stringify!(msgtyp)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct kern_ipc_perm {
    pub lock: spinlock_t,
    pub deleted: bool_,
    pub id: ::std::os::raw::c_int,
    pub key: key_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub cuid: kuid_t,
    pub cgid: kgid_t,
    pub mode: umode_t,
    pub seq: ::std::os::raw::c_ulong,
    pub security: *mut ::std::os::raw::c_void,
    pub khtnode: rhash_head,
    pub rcu: callback_head,
    pub refcount: refcount_t,
}
#[test]
fn bindgen_test_layout_kern_ipc_perm() {
    assert_eq!(
        ::std::mem::size_of::<kern_ipc_perm>(),
        128usize,
        concat!("Size of: ", stringify!(kern_ipc_perm))
    );
    assert_eq!(
        ::std::mem::align_of::<kern_ipc_perm>(),
        64usize,
        concat!("Alignment of ", stringify!(kern_ipc_perm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kern_ipc_perm>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kern_ipc_perm),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kern_ipc_perm>())).deleted as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kern_ipc_perm),
            "::",
            stringify!(deleted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kern_ipc_perm>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kern_ipc_perm),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kern_ipc_perm>())).key as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(kern_ipc_perm),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kern_ipc_perm>())).uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kern_ipc_perm),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kern_ipc_perm>())).gid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(kern_ipc_perm),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kern_ipc_perm>())).cuid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kern_ipc_perm),
            "::",
            stringify!(cuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kern_ipc_perm>())).cgid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(kern_ipc_perm),
            "::",
            stringify!(cgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kern_ipc_perm>())).mode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kern_ipc_perm),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kern_ipc_perm>())).seq as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kern_ipc_perm),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kern_ipc_perm>())).security as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kern_ipc_perm),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kern_ipc_perm>())).khtnode as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kern_ipc_perm),
            "::",
            stringify!(khtnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kern_ipc_perm>())).rcu as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(kern_ipc_perm),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kern_ipc_perm>())).refcount as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(kern_ipc_perm),
            "::",
            stringify!(refcount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct semid_ds {
    pub sem_perm: ipc_perm,
    pub sem_otime: __kernel_old_time_t,
    pub sem_ctime: __kernel_old_time_t,
    pub sem_base: *mut sem,
    pub sem_pending: *mut sem_queue,
    pub sem_pending_last: *mut *mut sem_queue,
    pub undo: *mut sem_undo,
    pub sem_nsems: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_semid_ds() {
    assert_eq!(
        ::std::mem::size_of::<semid_ds>(),
        88usize,
        concat!("Size of: ", stringify!(semid_ds))
    );
    assert_eq!(
        ::std::mem::align_of::<semid_ds>(),
        8usize,
        concat!("Alignment of ", stringify!(semid_ds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid_ds>())).sem_perm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(semid_ds),
            "::",
            stringify!(sem_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid_ds>())).sem_otime as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(semid_ds),
            "::",
            stringify!(sem_otime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid_ds>())).sem_ctime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(semid_ds),
            "::",
            stringify!(sem_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid_ds>())).sem_base as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(semid_ds),
            "::",
            stringify!(sem_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid_ds>())).sem_pending as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(semid_ds),
            "::",
            stringify!(sem_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid_ds>())).sem_pending_last as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(semid_ds),
            "::",
            stringify!(sem_pending_last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid_ds>())).undo as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(semid_ds),
            "::",
            stringify!(undo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid_ds>())).sem_nsems as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(semid_ds),
            "::",
            stringify!(sem_nsems)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct semid64_ds {
    pub sem_perm: ipc64_perm,
    pub sem_otime: __kernel_long_t,
    pub __unused1: __kernel_ulong_t,
    pub sem_ctime: __kernel_long_t,
    pub __unused2: __kernel_ulong_t,
    pub sem_nsems: __kernel_ulong_t,
    pub __unused3: __kernel_ulong_t,
    pub __unused4: __kernel_ulong_t,
}
#[test]
fn bindgen_test_layout_semid64_ds() {
    assert_eq!(
        ::std::mem::size_of::<semid64_ds>(),
        104usize,
        concat!("Size of: ", stringify!(semid64_ds))
    );
    assert_eq!(
        ::std::mem::align_of::<semid64_ds>(),
        8usize,
        concat!("Alignment of ", stringify!(semid64_ds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid64_ds>())).sem_perm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(semid64_ds),
            "::",
            stringify!(sem_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid64_ds>())).sem_otime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(semid64_ds),
            "::",
            stringify!(sem_otime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid64_ds>())).__unused1 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(semid64_ds),
            "::",
            stringify!(__unused1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid64_ds>())).sem_ctime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(semid64_ds),
            "::",
            stringify!(sem_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid64_ds>())).__unused2 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(semid64_ds),
            "::",
            stringify!(__unused2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid64_ds>())).sem_nsems as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(semid64_ds),
            "::",
            stringify!(sem_nsems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid64_ds>())).__unused3 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(semid64_ds),
            "::",
            stringify!(__unused3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semid64_ds>())).__unused4 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(semid64_ds),
            "::",
            stringify!(__unused4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sembuf {
    pub sem_num: ::std::os::raw::c_ushort,
    pub sem_op: ::std::os::raw::c_short,
    pub sem_flg: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_sembuf() {
    assert_eq!(
        ::std::mem::size_of::<sembuf>(),
        6usize,
        concat!("Size of: ", stringify!(sembuf))
    );
    assert_eq!(
        ::std::mem::align_of::<sembuf>(),
        2usize,
        concat!("Alignment of ", stringify!(sembuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sembuf>())).sem_num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sembuf),
            "::",
            stringify!(sem_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sembuf>())).sem_op as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sembuf),
            "::",
            stringify!(sem_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sembuf>())).sem_flg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sembuf),
            "::",
            stringify!(sem_flg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union semun {
    pub val: ::std::os::raw::c_int,
    pub buf: *mut semid_ds,
    pub array: *mut ::std::os::raw::c_ushort,
    pub __buf: *mut seminfo,
    pub __pad: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_semun() {
    assert_eq!(
        ::std::mem::size_of::<semun>(),
        8usize,
        concat!("Size of: ", stringify!(semun))
    );
    assert_eq!(
        ::std::mem::align_of::<semun>(),
        8usize,
        concat!("Alignment of ", stringify!(semun))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semun>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(semun),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semun>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(semun),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semun>())).array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(semun),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semun>())).__buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(semun),
            "::",
            stringify!(__buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semun>())).__pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(semun),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seminfo {
    pub semmap: ::std::os::raw::c_int,
    pub semmni: ::std::os::raw::c_int,
    pub semmns: ::std::os::raw::c_int,
    pub semmnu: ::std::os::raw::c_int,
    pub semmsl: ::std::os::raw::c_int,
    pub semopm: ::std::os::raw::c_int,
    pub semume: ::std::os::raw::c_int,
    pub semusz: ::std::os::raw::c_int,
    pub semvmx: ::std::os::raw::c_int,
    pub semaem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_seminfo() {
    assert_eq!(
        ::std::mem::size_of::<seminfo>(),
        40usize,
        concat!("Size of: ", stringify!(seminfo))
    );
    assert_eq!(
        ::std::mem::align_of::<seminfo>(),
        4usize,
        concat!("Alignment of ", stringify!(seminfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seminfo>())).semmap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seminfo),
            "::",
            stringify!(semmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seminfo>())).semmni as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(seminfo),
            "::",
            stringify!(semmni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seminfo>())).semmns as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seminfo),
            "::",
            stringify!(semmns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seminfo>())).semmnu as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(seminfo),
            "::",
            stringify!(semmnu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seminfo>())).semmsl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seminfo),
            "::",
            stringify!(semmsl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seminfo>())).semopm as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(seminfo),
            "::",
            stringify!(semopm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seminfo>())).semume as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(seminfo),
            "::",
            stringify!(semume)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seminfo>())).semusz as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(seminfo),
            "::",
            stringify!(semusz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seminfo>())).semvmx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(seminfo),
            "::",
            stringify!(semvmx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seminfo>())).semaem as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(seminfo),
            "::",
            stringify!(semaem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sem_undo_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysv_sem {
    pub undo_list: *mut sem_undo_list,
}
#[test]
fn bindgen_test_layout_sysv_sem() {
    assert_eq!(
        ::std::mem::size_of::<sysv_sem>(),
        8usize,
        concat!("Size of: ", stringify!(sysv_sem))
    );
    assert_eq!(
        ::std::mem::align_of::<sysv_sem>(),
        8usize,
        concat!("Alignment of ", stringify!(sysv_sem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysv_sem>())).undo_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysv_sem),
            "::",
            stringify!(undo_list)
        )
    );
}
extern "C" {
    pub fn copy_semundo(
        clone_flags: ::std::os::raw::c_ulong,
        tsk: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit_sem(tsk: *mut task_struct);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shmid_ds {
    pub shm_perm: ipc_perm,
    pub shm_segsz: ::std::os::raw::c_int,
    pub shm_atime: __kernel_old_time_t,
    pub shm_dtime: __kernel_old_time_t,
    pub shm_ctime: __kernel_old_time_t,
    pub shm_cpid: __kernel_ipc_pid_t,
    pub shm_lpid: __kernel_ipc_pid_t,
    pub shm_nattch: ::std::os::raw::c_ushort,
    pub shm_unused: ::std::os::raw::c_ushort,
    pub shm_unused2: *mut ::std::os::raw::c_void,
    pub shm_unused3: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_shmid_ds() {
    assert_eq!(
        ::std::mem::size_of::<shmid_ds>(),
        88usize,
        concat!("Size of: ", stringify!(shmid_ds))
    );
    assert_eq!(
        ::std::mem::align_of::<shmid_ds>(),
        8usize,
        concat!("Alignment of ", stringify!(shmid_ds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid_ds>())).shm_perm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid_ds),
            "::",
            stringify!(shm_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid_ds>())).shm_segsz as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid_ds),
            "::",
            stringify!(shm_segsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid_ds>())).shm_atime as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid_ds),
            "::",
            stringify!(shm_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid_ds>())).shm_dtime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid_ds),
            "::",
            stringify!(shm_dtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid_ds>())).shm_ctime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid_ds),
            "::",
            stringify!(shm_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid_ds>())).shm_cpid as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid_ds),
            "::",
            stringify!(shm_cpid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid_ds>())).shm_lpid as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid_ds),
            "::",
            stringify!(shm_lpid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid_ds>())).shm_nattch as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid_ds),
            "::",
            stringify!(shm_nattch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid_ds>())).shm_unused as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid_ds),
            "::",
            stringify!(shm_unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid_ds>())).shm_unused2 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid_ds),
            "::",
            stringify!(shm_unused2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid_ds>())).shm_unused3 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid_ds),
            "::",
            stringify!(shm_unused3)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct shmid64_ds {
    pub shm_perm: ipc64_perm,
    pub shm_segsz: __kernel_size_t,
    pub shm_atime: ::std::os::raw::c_long,
    pub shm_dtime: ::std::os::raw::c_long,
    pub shm_ctime: ::std::os::raw::c_long,
    pub shm_cpid: __kernel_pid_t,
    pub shm_lpid: __kernel_pid_t,
    pub shm_nattch: ::std::os::raw::c_ulong,
    pub __unused4: ::std::os::raw::c_ulong,
    pub __unused5: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_shmid64_ds() {
    assert_eq!(
        ::std::mem::size_of::<shmid64_ds>(),
        112usize,
        concat!("Size of: ", stringify!(shmid64_ds))
    );
    assert_eq!(
        ::std::mem::align_of::<shmid64_ds>(),
        8usize,
        concat!("Alignment of ", stringify!(shmid64_ds))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid64_ds>())).shm_perm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid64_ds),
            "::",
            stringify!(shm_perm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid64_ds>())).shm_segsz as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid64_ds),
            "::",
            stringify!(shm_segsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid64_ds>())).shm_atime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid64_ds),
            "::",
            stringify!(shm_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid64_ds>())).shm_dtime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid64_ds),
            "::",
            stringify!(shm_dtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid64_ds>())).shm_ctime as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid64_ds),
            "::",
            stringify!(shm_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid64_ds>())).shm_cpid as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid64_ds),
            "::",
            stringify!(shm_cpid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid64_ds>())).shm_lpid as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid64_ds),
            "::",
            stringify!(shm_lpid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid64_ds>())).shm_nattch as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid64_ds),
            "::",
            stringify!(shm_nattch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid64_ds>())).__unused4 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid64_ds),
            "::",
            stringify!(__unused4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shmid64_ds>())).__unused5 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(shmid64_ds),
            "::",
            stringify!(__unused5)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shminfo64 {
    pub shmmax: ::std::os::raw::c_ulong,
    pub shmmin: ::std::os::raw::c_ulong,
    pub shmmni: ::std::os::raw::c_ulong,
    pub shmseg: ::std::os::raw::c_ulong,
    pub shmall: ::std::os::raw::c_ulong,
    pub __unused1: ::std::os::raw::c_ulong,
    pub __unused2: ::std::os::raw::c_ulong,
    pub __unused3: ::std::os::raw::c_ulong,
    pub __unused4: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_shminfo64() {
    assert_eq!(
        ::std::mem::size_of::<shminfo64>(),
        72usize,
        concat!("Size of: ", stringify!(shminfo64))
    );
    assert_eq!(
        ::std::mem::align_of::<shminfo64>(),
        8usize,
        concat!("Alignment of ", stringify!(shminfo64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shminfo64>())).shmmax as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shminfo64),
            "::",
            stringify!(shmmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shminfo64>())).shmmin as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(shminfo64),
            "::",
            stringify!(shmmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shminfo64>())).shmmni as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(shminfo64),
            "::",
            stringify!(shmmni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shminfo64>())).shmseg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(shminfo64),
            "::",
            stringify!(shmseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shminfo64>())).shmall as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(shminfo64),
            "::",
            stringify!(shmall)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shminfo64>())).__unused1 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(shminfo64),
            "::",
            stringify!(__unused1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shminfo64>())).__unused2 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(shminfo64),
            "::",
            stringify!(__unused2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shminfo64>())).__unused3 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(shminfo64),
            "::",
            stringify!(__unused3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shminfo64>())).__unused4 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(shminfo64),
            "::",
            stringify!(__unused4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shminfo {
    pub shmmax: ::std::os::raw::c_int,
    pub shmmin: ::std::os::raw::c_int,
    pub shmmni: ::std::os::raw::c_int,
    pub shmseg: ::std::os::raw::c_int,
    pub shmall: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_shminfo() {
    assert_eq!(
        ::std::mem::size_of::<shminfo>(),
        20usize,
        concat!("Size of: ", stringify!(shminfo))
    );
    assert_eq!(
        ::std::mem::align_of::<shminfo>(),
        4usize,
        concat!("Alignment of ", stringify!(shminfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shminfo>())).shmmax as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shminfo),
            "::",
            stringify!(shmmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shminfo>())).shmmin as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(shminfo),
            "::",
            stringify!(shmmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shminfo>())).shmmni as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(shminfo),
            "::",
            stringify!(shmmni)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shminfo>())).shmseg as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(shminfo),
            "::",
            stringify!(shmseg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shminfo>())).shmall as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(shminfo),
            "::",
            stringify!(shmall)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_info {
    pub used_ids: ::std::os::raw::c_int,
    pub shm_tot: __kernel_ulong_t,
    pub shm_rss: __kernel_ulong_t,
    pub shm_swp: __kernel_ulong_t,
    pub swap_attempts: __kernel_ulong_t,
    pub swap_successes: __kernel_ulong_t,
}
#[test]
fn bindgen_test_layout_shm_info() {
    assert_eq!(
        ::std::mem::size_of::<shm_info>(),
        48usize,
        concat!("Size of: ", stringify!(shm_info))
    );
    assert_eq!(
        ::std::mem::align_of::<shm_info>(),
        8usize,
        concat!("Alignment of ", stringify!(shm_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shm_info>())).used_ids as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(shm_info),
            "::",
            stringify!(used_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shm_info>())).shm_tot as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(shm_info),
            "::",
            stringify!(shm_tot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shm_info>())).shm_rss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(shm_info),
            "::",
            stringify!(shm_rss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shm_info>())).shm_swp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(shm_info),
            "::",
            stringify!(shm_swp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shm_info>())).swap_attempts as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(shm_info),
            "::",
            stringify!(swap_attempts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<shm_info>())).swap_successes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(shm_info),
            "::",
            stringify!(swap_successes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysv_shm {
    pub shm_clist: list_head,
}
#[test]
fn bindgen_test_layout_sysv_shm() {
    assert_eq!(
        ::std::mem::size_of::<sysv_shm>(),
        16usize,
        concat!("Size of: ", stringify!(sysv_shm))
    );
    assert_eq!(
        ::std::mem::align_of::<sysv_shm>(),
        8usize,
        concat!("Alignment of ", stringify!(sysv_shm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysv_shm>())).shm_clist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysv_shm),
            "::",
            stringify!(shm_clist)
        )
    );
}
extern "C" {
    pub fn do_shmat(
        shmid: ::std::os::raw::c_int,
        shmaddr: *mut ::std::os::raw::c_char,
        shmflg: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_ulong,
        shmlba: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn is_file_shm_hugepages(file: *mut file) -> bool_;
}
extern "C" {
    pub fn exit_shm(task: *mut task_struct);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmsan_context_state {
    pub param_tls: [::std::os::raw::c_char; 800usize],
    pub retval_tls: [::std::os::raw::c_char; 800usize],
    pub va_arg_tls: [::std::os::raw::c_char; 800usize],
    pub va_arg_origin_tls: [::std::os::raw::c_char; 800usize],
    pub va_arg_overflow_size_tls: u64_,
    pub param_origin_tls: [::std::os::raw::c_char; 800usize],
    pub retval_origin_tls: u32_,
}
#[test]
fn bindgen_test_layout_kmsan_context_state() {
    assert_eq!(
        ::std::mem::size_of::<kmsan_context_state>(),
        4016usize,
        concat!("Size of: ", stringify!(kmsan_context_state))
    );
    assert_eq!(
        ::std::mem::align_of::<kmsan_context_state>(),
        8usize,
        concat!("Alignment of ", stringify!(kmsan_context_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kmsan_context_state>())).param_tls as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kmsan_context_state),
            "::",
            stringify!(param_tls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kmsan_context_state>())).retval_tls as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(kmsan_context_state),
            "::",
            stringify!(retval_tls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kmsan_context_state>())).va_arg_tls as *const _ as usize },
        1600usize,
        concat!(
            "Offset of field: ",
            stringify!(kmsan_context_state),
            "::",
            stringify!(va_arg_tls)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kmsan_context_state>())).va_arg_origin_tls as *const _ as usize
        },
        2400usize,
        concat!(
            "Offset of field: ",
            stringify!(kmsan_context_state),
            "::",
            stringify!(va_arg_origin_tls)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kmsan_context_state>())).va_arg_overflow_size_tls as *const _
                as usize
        },
        3200usize,
        concat!(
            "Offset of field: ",
            stringify!(kmsan_context_state),
            "::",
            stringify!(va_arg_overflow_size_tls)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kmsan_context_state>())).param_origin_tls as *const _ as usize
        },
        3208usize,
        concat!(
            "Offset of field: ",
            stringify!(kmsan_context_state),
            "::",
            stringify!(param_origin_tls)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kmsan_context_state>())).retval_origin_tls as *const _ as usize
        },
        4008usize,
        concat!(
            "Offset of field: ",
            stringify!(kmsan_context_state),
            "::",
            stringify!(retval_origin_tls)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmsan_ctx {
    pub cstate: kmsan_context_state,
    pub kmsan_in_runtime: ::std::os::raw::c_int,
    pub allow_reporting: bool_,
}
#[test]
fn bindgen_test_layout_kmsan_ctx() {
    assert_eq!(
        ::std::mem::size_of::<kmsan_ctx>(),
        4024usize,
        concat!("Size of: ", stringify!(kmsan_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<kmsan_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(kmsan_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kmsan_ctx>())).cstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kmsan_ctx),
            "::",
            stringify!(cstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kmsan_ctx>())).kmsan_in_runtime as *const _ as usize },
        4016usize,
        concat!(
            "Offset of field: ",
            stringify!(kmsan_ctx),
            "::",
            stringify!(kmsan_in_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kmsan_ctx>())).allow_reporting as *const _ as usize },
        4020usize,
        concat!(
            "Offset of field: ",
            stringify!(kmsan_ctx),
            "::",
            stringify!(allow_reporting)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plist_head {
    pub node_list: list_head,
}
#[test]
fn bindgen_test_layout_plist_head() {
    assert_eq!(
        ::std::mem::size_of::<plist_head>(),
        16usize,
        concat!("Size of: ", stringify!(plist_head))
    );
    assert_eq!(
        ::std::mem::align_of::<plist_head>(),
        8usize,
        concat!("Alignment of ", stringify!(plist_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<plist_head>())).node_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(plist_head),
            "::",
            stringify!(node_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plist_node {
    pub prio: ::std::os::raw::c_int,
    pub prio_list: list_head,
    pub node_list: list_head,
}
#[test]
fn bindgen_test_layout_plist_node() {
    assert_eq!(
        ::std::mem::size_of::<plist_node>(),
        40usize,
        concat!("Size of: ", stringify!(plist_node))
    );
    assert_eq!(
        ::std::mem::align_of::<plist_node>(),
        8usize,
        concat!("Alignment of ", stringify!(plist_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<plist_node>())).prio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(plist_node),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<plist_node>())).prio_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(plist_node),
            "::",
            stringify!(prio_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<plist_node>())).node_list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(plist_node),
            "::",
            stringify!(node_list)
        )
    );
}
extern "C" {
    pub fn plist_add(node: *mut plist_node, head: *mut plist_head);
}
extern "C" {
    pub fn plist_del(node: *mut plist_node, head: *mut plist_head);
}
extern "C" {
    pub fn plist_requeue(node: *mut plist_node, head: *mut plist_head);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timerqueue_node {
    pub node: rb_node,
    pub expires: ktime_t,
}
#[test]
fn bindgen_test_layout_timerqueue_node() {
    assert_eq!(
        ::std::mem::size_of::<timerqueue_node>(),
        32usize,
        concat!("Size of: ", stringify!(timerqueue_node))
    );
    assert_eq!(
        ::std::mem::align_of::<timerqueue_node>(),
        8usize,
        concat!("Alignment of ", stringify!(timerqueue_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timerqueue_node>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_node),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timerqueue_node>())).expires as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_node),
            "::",
            stringify!(expires)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timerqueue_head {
    pub rb_root: rb_root_cached,
}
#[test]
fn bindgen_test_layout_timerqueue_head() {
    assert_eq!(
        ::std::mem::size_of::<timerqueue_head>(),
        16usize,
        concat!("Size of: ", stringify!(timerqueue_head))
    );
    assert_eq!(
        ::std::mem::align_of::<timerqueue_head>(),
        8usize,
        concat!("Alignment of ", stringify!(timerqueue_head))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timerqueue_head>())).rb_root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timerqueue_head),
            "::",
            stringify!(rb_root)
        )
    );
}
extern "C" {
    pub fn timerqueue_add(head: *mut timerqueue_head, node: *mut timerqueue_node) -> bool_;
}
extern "C" {
    pub fn timerqueue_del(head: *mut timerqueue_head, node: *mut timerqueue_node) -> bool_;
}
extern "C" {
    pub fn timerqueue_iterate_next(node: *mut timerqueue_node) -> *mut timerqueue_node;
}
pub const hrtimer_mode_HRTIMER_MODE_ABS: hrtimer_mode = 0;
pub const hrtimer_mode_HRTIMER_MODE_REL: hrtimer_mode = 1;
pub const hrtimer_mode_HRTIMER_MODE_PINNED: hrtimer_mode = 2;
pub const hrtimer_mode_HRTIMER_MODE_SOFT: hrtimer_mode = 4;
pub const hrtimer_mode_HRTIMER_MODE_HARD: hrtimer_mode = 8;
pub const hrtimer_mode_HRTIMER_MODE_ABS_PINNED: hrtimer_mode = 2;
pub const hrtimer_mode_HRTIMER_MODE_REL_PINNED: hrtimer_mode = 3;
pub const hrtimer_mode_HRTIMER_MODE_ABS_SOFT: hrtimer_mode = 4;
pub const hrtimer_mode_HRTIMER_MODE_REL_SOFT: hrtimer_mode = 5;
pub const hrtimer_mode_HRTIMER_MODE_ABS_PINNED_SOFT: hrtimer_mode = 6;
pub const hrtimer_mode_HRTIMER_MODE_REL_PINNED_SOFT: hrtimer_mode = 7;
pub const hrtimer_mode_HRTIMER_MODE_ABS_HARD: hrtimer_mode = 8;
pub const hrtimer_mode_HRTIMER_MODE_REL_HARD: hrtimer_mode = 9;
pub const hrtimer_mode_HRTIMER_MODE_ABS_PINNED_HARD: hrtimer_mode = 10;
pub const hrtimer_mode_HRTIMER_MODE_REL_PINNED_HARD: hrtimer_mode = 11;
pub type hrtimer_mode = ::std::os::raw::c_uint;
pub const hrtimer_restart_HRTIMER_NORESTART: hrtimer_restart = 0;
pub const hrtimer_restart_HRTIMER_RESTART: hrtimer_restart = 1;
pub type hrtimer_restart = i32;
#[doc = " struct hrtimer - the basic hrtimer structure"]
#[doc = " @node:\ttimerqueue node, which also manages node.expires,"]
#[doc = "\t\tthe absolute expiry time in the hrtimers internal"]
#[doc = "\t\trepresentation. The time is related to the clock on"]
#[doc = "\t\twhich the timer is based. Is setup by adding"]
#[doc = "\t\tslack to the _softexpires value. For non range timers"]
#[doc = "\t\tidentical to _softexpires."]
#[doc = " @_softexpires: the absolute earliest expiry time of the hrtimer."]
#[doc = "\t\tThe time which was given as expiry time when the timer"]
#[doc = "\t\twas armed."]
#[doc = " @function:\ttimer expiry callback function"]
#[doc = " @base:\tpointer to the timer base (per cpu and per clock)"]
#[doc = " @state:\tstate information (See bit values above)"]
#[doc = " @is_rel:\tSet if the timer was armed relative"]
#[doc = " @is_soft:\tSet if hrtimer will be expired in soft interrupt context."]
#[doc = " @is_hard:\tSet if hrtimer will be expired in hard interrupt context"]
#[doc = "\t\teven on RT."]
#[doc = ""]
#[doc = " The hrtimer structure must be initialized by hrtimer_init()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hrtimer {
    pub node: timerqueue_node,
    pub _softexpires: ktime_t,
    pub function:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut hrtimer) -> hrtimer_restart>,
    pub base: *mut hrtimer_clock_base,
    pub state: u8_,
    pub is_rel: u8_,
    pub is_soft: u8_,
    pub is_hard: u8_,
}
#[test]
fn bindgen_test_layout_hrtimer() {
    assert_eq!(
        ::std::mem::size_of::<hrtimer>(),
        64usize,
        concat!("Size of: ", stringify!(hrtimer))
    );
    assert_eq!(
        ::std::mem::align_of::<hrtimer>(),
        8usize,
        concat!("Alignment of ", stringify!(hrtimer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer>()))._softexpires as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(_softexpires)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer>())).function as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer>())).base as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer>())).state as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer>())).is_rel as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(is_rel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer>())).is_soft as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(is_soft)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer>())).is_hard as *const _ as usize },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer),
            "::",
            stringify!(is_hard)
        )
    );
}
#[doc = " struct hrtimer_sleeper - simple sleeper structure"]
#[doc = " @timer:\tembedded timer structure"]
#[doc = " @task:\ttask to wake up"]
#[doc = ""]
#[doc = " task is set to NULL, when the timer expires."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hrtimer_sleeper {
    pub timer: hrtimer,
    pub task: *mut task_struct,
}
#[test]
fn bindgen_test_layout_hrtimer_sleeper() {
    assert_eq!(
        ::std::mem::size_of::<hrtimer_sleeper>(),
        72usize,
        concat!("Size of: ", stringify!(hrtimer_sleeper))
    );
    assert_eq!(
        ::std::mem::align_of::<hrtimer_sleeper>(),
        8usize,
        concat!("Alignment of ", stringify!(hrtimer_sleeper))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_sleeper>())).timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_sleeper),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_sleeper>())).task as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_sleeper),
            "::",
            stringify!(task)
        )
    );
}
#[doc = " struct hrtimer_clock_base - the timer base for a specific clock"]
#[doc = " @cpu_base:\t\tper cpu clock base"]
#[doc = " @index:\t\tclock type index for per_cpu support when moving a"]
#[doc = "\t\t\ttimer to a base on another cpu."]
#[doc = " @clockid:\t\tclock id for per_cpu support"]
#[doc = " @seq:\t\tseqcount around __run_hrtimer"]
#[doc = " @running:\t\tpointer to the currently running hrtimer"]
#[doc = " @active:\t\tred black tree root node for the active timers"]
#[doc = " @get_time:\t\tfunction to retrieve the current time of the clock"]
#[doc = " @offset:\t\toffset of this clock to the monotonic base"]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_clock_base {
    pub cpu_base: *mut hrtimer_cpu_base,
    pub index: ::std::os::raw::c_uint,
    pub clockid: clockid_t,
    pub seq: seqcount_raw_spinlock_t,
    pub running: *mut hrtimer,
    pub active: timerqueue_head,
    pub get_time: ::std::option::Option<unsafe extern "C" fn() -> ktime_t>,
    pub offset: ktime_t,
}
#[test]
fn bindgen_test_layout_hrtimer_clock_base() {
    assert_eq!(
        ::std::mem::size_of::<hrtimer_clock_base>(),
        64usize,
        concat!("Size of: ", stringify!(hrtimer_clock_base))
    );
    assert_eq!(
        ::std::mem::align_of::<hrtimer_clock_base>(),
        64usize,
        concat!("Alignment of ", stringify!(hrtimer_clock_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_clock_base>())).cpu_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(cpu_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_clock_base>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_clock_base>())).clockid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(clockid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_clock_base>())).seq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_clock_base>())).running as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(running)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_clock_base>())).active as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_clock_base>())).get_time as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(get_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_clock_base>())).offset as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_clock_base),
            "::",
            stringify!(offset)
        )
    );
}
pub const hrtimer_base_type_HRTIMER_BASE_MONOTONIC: hrtimer_base_type = 0;
pub const hrtimer_base_type_HRTIMER_BASE_REALTIME: hrtimer_base_type = 1;
pub const hrtimer_base_type_HRTIMER_BASE_BOOTTIME: hrtimer_base_type = 2;
pub const hrtimer_base_type_HRTIMER_BASE_TAI: hrtimer_base_type = 3;
pub const hrtimer_base_type_HRTIMER_BASE_MONOTONIC_SOFT: hrtimer_base_type = 4;
pub const hrtimer_base_type_HRTIMER_BASE_REALTIME_SOFT: hrtimer_base_type = 5;
pub const hrtimer_base_type_HRTIMER_BASE_BOOTTIME_SOFT: hrtimer_base_type = 6;
pub const hrtimer_base_type_HRTIMER_BASE_TAI_SOFT: hrtimer_base_type = 7;
pub const hrtimer_base_type_HRTIMER_MAX_CLOCK_BASES: hrtimer_base_type = 8;
pub type hrtimer_base_type = ::std::os::raw::c_uint;
#[doc = " struct hrtimer_cpu_base - the per cpu clock bases"]
#[doc = " @lock:\t\tlock protecting the base and associated clock bases"]
#[doc = "\t\t\tand timers"]
#[doc = " @cpu:\t\tcpu number"]
#[doc = " @active_bases:\tBitfield to mark bases with active timers"]
#[doc = " @clock_was_set_seq:\tSequence counter of clock was set events"]
#[doc = " @hres_active:\tState of high resolution mode"]
#[doc = " @in_hrtirq:\t\thrtimer_interrupt() is currently executing"]
#[doc = " @hang_detected:\tThe last hrtimer interrupt detected a hang"]
#[doc = " @softirq_activated:\tdisplays, if the softirq is raised - update of softirq"]
#[doc = "\t\t\trelated settings is not required then."]
#[doc = " @nr_events:\t\tTotal number of hrtimer interrupt events"]
#[doc = " @nr_retries:\t\tTotal number of hrtimer interrupt retries"]
#[doc = " @nr_hangs:\t\tTotal number of hrtimer interrupt hangs"]
#[doc = " @max_hang_time:\tMaximum time spent in hrtimer_interrupt"]
#[doc = " @softirq_expiry_lock: Lock which is taken while softirq based hrtimer are"]
#[doc = "\t\t\t expired"]
#[doc = " @timer_waiters:\tA hrtimer_cancel() invocation waits for the timer"]
#[doc = "\t\t\tcallback to finish."]
#[doc = " @expires_next:\tabsolute time of the next event, is required for remote"]
#[doc = "\t\t\thrtimer enqueue; it is the total first expiry time (hard"]
#[doc = "\t\t\tand soft hrtimer are taken into account)"]
#[doc = " @next_timer:\t\tPointer to the first expiring timer"]
#[doc = " @softirq_expires_next: Time to check, if soft queues needs also to be expired"]
#[doc = " @softirq_next_timer: Pointer to the first expiring softirq based timer"]
#[doc = " @clock_base:\t\tarray of clock bases for this cpu"]
#[doc = ""]
#[doc = " Note: next_timer is just an optimization for __remove_hrtimer()."]
#[doc = "\t Do not dereference the pointer because it is not reliable on"]
#[doc = "\t cross cpu removals."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_cpu_base {
    pub lock: raw_spinlock_t,
    pub cpu: ::std::os::raw::c_uint,
    pub active_bases: ::std::os::raw::c_uint,
    pub clock_was_set_seq: ::std::os::raw::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub nr_events: ::std::os::raw::c_uint,
    pub nr_retries: ::std::os::raw::c_ushort,
    pub nr_hangs: ::std::os::raw::c_ushort,
    pub max_hang_time: ::std::os::raw::c_uint,
    pub expires_next: ktime_t,
    pub next_timer: *mut hrtimer,
    pub softirq_expires_next: ktime_t,
    pub softirq_next_timer: *mut hrtimer,
    pub clock_base: [hrtimer_clock_base; 8usize],
}
#[test]
fn bindgen_test_layout_hrtimer_cpu_base() {
    assert_eq!(
        ::std::mem::size_of::<hrtimer_cpu_base>(),
        576usize,
        concat!("Size of: ", stringify!(hrtimer_cpu_base))
    );
    assert_eq!(
        ::std::mem::align_of::<hrtimer_cpu_base>(),
        64usize,
        concat!("Alignment of ", stringify!(hrtimer_cpu_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).cpu as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).active_bases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(active_bases)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hrtimer_cpu_base>())).clock_was_set_seq as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(clock_was_set_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).nr_events as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nr_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).nr_retries as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nr_retries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).nr_hangs as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(nr_hangs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).max_hang_time as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(max_hang_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).expires_next as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(expires_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).next_timer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(next_timer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hrtimer_cpu_base>())).softirq_expires_next as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(softirq_expires_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hrtimer_cpu_base>())).softirq_next_timer as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(softirq_next_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hrtimer_cpu_base>())).clock_base as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hrtimer_cpu_base),
            "::",
            stringify!(clock_base)
        )
    );
}
impl hrtimer_cpu_base {
    #[inline]
    pub fn hres_active(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hres_active(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_hrtirq(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_hrtirq(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hang_detected(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hang_detected(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn softirq_activated(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_softirq_activated(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hres_active: ::std::os::raw::c_uint,
        in_hrtirq: ::std::os::raw::c_uint,
        hang_detected: ::std::os::raw::c_uint,
        softirq_activated: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hres_active: u32 = unsafe { ::std::mem::transmute(hres_active) };
            hres_active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_hrtirq: u32 = unsafe { ::std::mem::transmute(in_hrtirq) };
            in_hrtirq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hang_detected: u32 = unsafe { ::std::mem::transmute(hang_detected) };
            hang_detected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let softirq_activated: u32 = unsafe { ::std::mem::transmute(softirq_activated) };
            softirq_activated as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clock_event_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hrtimer_interrupt(dev: *mut clock_event_device);
}
extern "C" {
    pub static mut hrtimer_resolution: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn timerfd_clock_was_set();
}
extern "C" {
    pub fn timerfd_resume();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tick_device {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut tick_cpu_device: tick_device;
}
extern "C" {
    pub fn hrtimer_init(timer: *mut hrtimer, which_clock: clockid_t, mode: hrtimer_mode);
}
extern "C" {
    pub fn hrtimer_init_sleeper(sl: *mut hrtimer_sleeper, clock_id: clockid_t, mode: hrtimer_mode);
}
extern "C" {
    pub fn hrtimer_start_range_ns(
        timer: *mut hrtimer,
        tim: ktime_t,
        range_ns: u64_,
        mode: hrtimer_mode,
    );
}
extern "C" {
    pub fn hrtimer_cancel(timer: *mut hrtimer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hrtimer_try_to_cancel(timer: *mut hrtimer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hrtimer_sleeper_start_expires(sl: *mut hrtimer_sleeper, mode: hrtimer_mode);
}
extern "C" {
    pub fn __hrtimer_get_remaining(timer: *const hrtimer, adjust: bool_) -> ktime_t;
}
extern "C" {
    pub fn hrtimer_get_next_event() -> u64_;
}
extern "C" {
    pub fn hrtimer_next_event_without(exclude: *const hrtimer) -> u64_;
}
extern "C" {
    pub fn hrtimer_active(timer: *const hrtimer) -> bool_;
}
extern "C" {
    pub fn hrtimer_forward(timer: *mut hrtimer, now: ktime_t, interval: ktime_t) -> u64_;
}
extern "C" {
    pub fn nanosleep_copyout(
        arg1: *mut restart_block,
        arg2: *mut timespec64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hrtimer_nanosleep(
        rqtp: ktime_t,
        mode: hrtimer_mode,
        clockid: clockid_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn schedule_hrtimeout_range(
        expires: *mut ktime_t,
        delta: u64_,
        mode: hrtimer_mode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn schedule_hrtimeout_range_clock(
        expires: *mut ktime_t,
        delta: u64_,
        mode: hrtimer_mode,
        clock_id: clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn schedule_hrtimeout(expires: *mut ktime_t, mode: hrtimer_mode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hrtimer_run_queues();
}
extern "C" {
    pub fn hrtimers_init();
}
extern "C" {
    pub fn sysrq_timer_list_show();
}
extern "C" {
    pub fn hrtimers_prepare_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hrtimers_dead_cpu(cpu: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
#[doc = " struct seccomp_data - the format the BPF program executes over."]
#[doc = " @nr: the system call number"]
#[doc = " @arch: indicates system call convention as an AUDIT_ARCH_* value"]
#[doc = "        as defined in <linux/audit.h>."]
#[doc = " @instruction_pointer: at the time of the system call."]
#[doc = " @args: up to 6 system call arguments always stored as 64-bit values"]
#[doc = "        regardless of the architecture."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp_data {
    pub nr: ::std::os::raw::c_int,
    pub arch: __u32,
    pub instruction_pointer: __u64,
    pub args: [__u64; 6usize],
}
#[test]
fn bindgen_test_layout_seccomp_data() {
    assert_eq!(
        ::std::mem::size_of::<seccomp_data>(),
        64usize,
        concat!("Size of: ", stringify!(seccomp_data))
    );
    assert_eq!(
        ::std::mem::align_of::<seccomp_data>(),
        8usize,
        concat!("Alignment of ", stringify!(seccomp_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_data>())).nr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_data),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_data>())).arch as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_data),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seccomp_data>())).instruction_pointer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_data),
            "::",
            stringify!(instruction_pointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_data>())).args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_data),
            "::",
            stringify!(args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp_notif_sizes {
    pub seccomp_notif: __u16,
    pub seccomp_notif_resp: __u16,
    pub seccomp_data: __u16,
}
#[test]
fn bindgen_test_layout_seccomp_notif_sizes() {
    assert_eq!(
        ::std::mem::size_of::<seccomp_notif_sizes>(),
        6usize,
        concat!("Size of: ", stringify!(seccomp_notif_sizes))
    );
    assert_eq!(
        ::std::mem::align_of::<seccomp_notif_sizes>(),
        2usize,
        concat!("Alignment of ", stringify!(seccomp_notif_sizes))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seccomp_notif_sizes>())).seccomp_notif as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif_sizes),
            "::",
            stringify!(seccomp_notif)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seccomp_notif_sizes>())).seccomp_notif_resp as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif_sizes),
            "::",
            stringify!(seccomp_notif_resp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<seccomp_notif_sizes>())).seccomp_data as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif_sizes),
            "::",
            stringify!(seccomp_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp_notif {
    pub id: __u64,
    pub pid: __u32,
    pub flags: __u32,
    pub data: seccomp_data,
}
#[test]
fn bindgen_test_layout_seccomp_notif() {
    assert_eq!(
        ::std::mem::size_of::<seccomp_notif>(),
        80usize,
        concat!("Size of: ", stringify!(seccomp_notif))
    );
    assert_eq!(
        ::std::mem::align_of::<seccomp_notif>(),
        8usize,
        concat!("Alignment of ", stringify!(seccomp_notif))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_notif>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_notif>())).pid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_notif>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_notif>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp_notif_resp {
    pub id: __u64,
    pub val: __s64,
    pub error: __s32,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_seccomp_notif_resp() {
    assert_eq!(
        ::std::mem::size_of::<seccomp_notif_resp>(),
        24usize,
        concat!("Size of: ", stringify!(seccomp_notif_resp))
    );
    assert_eq!(
        ::std::mem::align_of::<seccomp_notif_resp>(),
        8usize,
        concat!("Alignment of ", stringify!(seccomp_notif_resp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_notif_resp>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif_resp),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_notif_resp>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif_resp),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_notif_resp>())).error as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif_resp),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_notif_resp>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif_resp),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " struct seccomp_notif_addfd"]
#[doc = " @id: The ID of the seccomp notification"]
#[doc = " @flags: SECCOMP_ADDFD_FLAG_*"]
#[doc = " @srcfd: The local fd number"]
#[doc = " @newfd: Optional remote FD number if SETFD option is set, otherwise 0."]
#[doc = " @newfd_flags: The O_* flags the remote FD should have applied"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp_notif_addfd {
    pub id: __u64,
    pub flags: __u32,
    pub srcfd: __u32,
    pub newfd: __u32,
    pub newfd_flags: __u32,
}
#[test]
fn bindgen_test_layout_seccomp_notif_addfd() {
    assert_eq!(
        ::std::mem::size_of::<seccomp_notif_addfd>(),
        24usize,
        concat!("Size of: ", stringify!(seccomp_notif_addfd))
    );
    assert_eq!(
        ::std::mem::align_of::<seccomp_notif_addfd>(),
        8usize,
        concat!("Alignment of ", stringify!(seccomp_notif_addfd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_notif_addfd>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif_addfd),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_notif_addfd>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif_addfd),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_notif_addfd>())).srcfd as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif_addfd),
            "::",
            stringify!(srcfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_notif_addfd>())).newfd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif_addfd),
            "::",
            stringify!(newfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp_notif_addfd>())).newfd_flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp_notif_addfd),
            "::",
            stringify!(newfd_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp_filter {
    _unused: [u8; 0],
}
#[doc = " struct seccomp - the state of a seccomp'ed process"]
#[doc = ""]
#[doc = " @mode:  indicates one of the valid values above for controlled"]
#[doc = "         system calls available to a process."]
#[doc = " @filter: must always point to a valid seccomp-filter or NULL as it is"]
#[doc = "          accessed without locking during system call entry."]
#[doc = ""]
#[doc = "          @filter must only be accessed from the context of current as there"]
#[doc = "          is no read locking."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct seccomp {
    pub mode: ::std::os::raw::c_int,
    pub filter_count: atomic_t,
    pub filter: *mut seccomp_filter,
}
#[test]
fn bindgen_test_layout_seccomp() {
    assert_eq!(
        ::std::mem::size_of::<seccomp>(),
        16usize,
        concat!("Size of: ", stringify!(seccomp))
    );
    assert_eq!(
        ::std::mem::align_of::<seccomp>(),
        8usize,
        concat!("Alignment of ", stringify!(seccomp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp>())).filter_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp),
            "::",
            stringify!(filter_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<seccomp>())).filter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(seccomp),
            "::",
            stringify!(filter)
        )
    );
}
extern "C" {
    pub fn __secure_computing(sd: *const seccomp_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn prctl_get_seccomp() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn prctl_set_seccomp(
        arg1: ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn seccomp_filter_release(tsk: *mut task_struct);
}
extern "C" {
    pub fn get_seccomp_filter(tsk: *mut task_struct);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: __kernel_old_timeval,
    pub ru_stime: __kernel_old_timeval,
    pub ru_maxrss: __kernel_long_t,
    pub ru_ixrss: __kernel_long_t,
    pub ru_idrss: __kernel_long_t,
    pub ru_isrss: __kernel_long_t,
    pub ru_minflt: __kernel_long_t,
    pub ru_majflt: __kernel_long_t,
    pub ru_nswap: __kernel_long_t,
    pub ru_inblock: __kernel_long_t,
    pub ru_oublock: __kernel_long_t,
    pub ru_msgsnd: __kernel_long_t,
    pub ru_msgrcv: __kernel_long_t,
    pub ru_nsignals: __kernel_long_t,
    pub ru_nvcsw: __kernel_long_t,
    pub ru_nivcsw: __kernel_long_t,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_stime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_maxrss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_ixrss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_idrss as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_isrss as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_minflt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_majflt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nswap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_inblock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_oublock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgsnd as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgrcv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nsignals as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nvcsw as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nivcsw as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: __kernel_ulong_t,
    pub rlim_max: __kernel_ulong_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit64 {
    pub rlim_cur: __u64,
    pub rlim_max: __u64,
}
#[test]
fn bindgen_test_layout_rlimit64() {
    assert_eq!(
        ::std::mem::size_of::<rlimit64>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit64))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit64>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit64>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit64),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit64>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit64),
            "::",
            stringify!(rlim_max)
        )
    );
}
extern "C" {
    pub fn getrusage(p: *mut task_struct, who: ::std::os::raw::c_int, ru: *mut rusage);
}
#[doc = " struct task_cputime - collected CPU time counts"]
#[doc = " @stime:\t\ttime spent in kernel mode, in nanoseconds"]
#[doc = " @utime:\t\ttime spent in user mode, in nanoseconds"]
#[doc = " @sum_exec_runtime:\ttotal time spent on the CPU, in nanoseconds"]
#[doc = ""]
#[doc = " This structure groups together three kinds of CPU time that are tracked for"]
#[doc = " threads and thread groups.  Most things considering CPU time want to group"]
#[doc = " these counts together and treat all three of them in parallel."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_cputime {
    pub stime: u64_,
    pub utime: u64_,
    pub sum_exec_runtime: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_task_cputime() {
    assert_eq!(
        ::std::mem::size_of::<task_cputime>(),
        24usize,
        concat!("Size of: ", stringify!(task_cputime))
    );
    assert_eq!(
        ::std::mem::align_of::<task_cputime>(),
        8usize,
        concat!("Alignment of ", stringify!(task_cputime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_cputime>())).stime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_cputime>())).utime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_cputime>())).sum_exec_runtime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime),
            "::",
            stringify!(sum_exec_runtime)
        )
    );
}
pub type old_sigset_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigset_t {
    pub sig: [::std::os::raw::c_ulong; 1usize],
}
#[test]
fn bindgen_test_layout_sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<sigset_t>(),
        8usize,
        concat!("Size of: ", stringify!(sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigset_t>())).sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigset_t),
            "::",
            stringify!(sig)
        )
    );
}
pub type __signalfn_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __sighandler_t = __signalfn_t;
pub type __restorefn_t = ::std::option::Option<unsafe extern "C" fn()>;
pub type __sigrestore_t = __restorefn_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: __kernel_size_t,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
}
pub type stack_t = sigaltstack;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
pub type sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields {
    pub _kill: __sifields__bindgen_ty_1,
    pub _timer: __sifields__bindgen_ty_2,
    pub _rt: __sifields__bindgen_ty_3,
    pub _sigchld: __sifields__bindgen_ty_4,
    pub _sigfault: __sifields__bindgen_ty_5,
    pub _sigpoll: __sifields__bindgen_ty_6,
    pub _sigsys: __sifields__bindgen_ty_7,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_1 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_1>()))._pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_1),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_1>()))._uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_1),
            "::",
            stringify!(_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_2 {
    pub _tid: __kernel_timer_t,
    pub _overrun: ::std::os::raw::c_int,
    pub _sigval: sigval_t,
    pub _sys_private: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_2>()))._tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_2>()))._overrun as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_2>()))._sigval as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_sigval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_2>()))._sys_private as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_2),
            "::",
            stringify!(_sys_private)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_3 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _sigval: sigval_t,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_3>()))._pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_3),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_3>()))._uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_3),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_3>()))._sigval as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_3),
            "::",
            stringify!(_sigval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_4 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _status: ::std::os::raw::c_int,
    pub _utime: __kernel_clock_t,
    pub _stime: __kernel_clock_t,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_4>()))._pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_4>()))._uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_4>()))._status as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_4>()))._utime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_4>()))._stime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_4),
            "::",
            stringify!(_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_5 {
    pub _addr: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: __sifields__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields__bindgen_ty_5__bindgen_ty_1 {
    pub _trapno: ::std::os::raw::c_int,
    pub _addr_lsb: ::std::os::raw::c_short,
    pub _addr_bnd: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
    pub _perf: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [::std::os::raw::c_char; 8usize],
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))
                ._dummy_bnd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_dummy_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))._lower
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>()))._upper
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [::std::os::raw::c_char; 8usize],
    pub _pkey: __u32,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>()))
                ._dummy_pkey as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_dummy_pkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2>()))._pkey
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_pkey)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
    pub _data: ::std::os::raw::c_ulong,
    pub _type: __u32,
    pub _flags: __u32,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>()))._data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>()))._type
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3>()))._flags
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(_flags)
        )
    );
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._trapno as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_lsb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_lsb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_bnd as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._addr_pkey
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_pkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_5__bindgen_ty_1>()))._perf as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_perf)
        )
    );
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_5>(),
        32usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_5>()))._addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_5),
            "::",
            stringify!(_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_6 {
    pub _band: ::std::os::raw::c_long,
    pub _fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_6>(),
        16usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_6>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_6>()))._band as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_6),
            "::",
            stringify!(_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_6>()))._fd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_6),
            "::",
            stringify!(_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sifields__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___sifields__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<__sifields__bindgen_ty_7>(),
        16usize,
        concat!("Size of: ", stringify!(__sifields__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields__bindgen_ty_7>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields__bindgen_ty_7))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_7>()))._call_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sifields__bindgen_ty_7>()))._syscall as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields__bindgen_ty_7>()))._arch as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
#[test]
fn bindgen_test_layout___sifields() {
    assert_eq!(
        ::std::mem::size_of::<__sifields>(),
        32usize,
        concat!("Size of: ", stringify!(__sifields))
    );
    assert_eq!(
        ::std::mem::align_of::<__sifields>(),
        8usize,
        concat!("Alignment of ", stringify!(__sifields))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._kill as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._sigchld as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._sigfault as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._sigpoll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sifields>()))._sigsys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sifields),
            "::",
            stringify!(_sigsys)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo {
    pub __bindgen_anon_1: siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo__bindgen_ty_1 {
    pub __bindgen_anon_1: siginfo__bindgen_ty_1__bindgen_ty_1,
    pub _si_pad: [::std::os::raw::c_int; 32usize],
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub _sifields: __sifields,
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo__bindgen_ty_1__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>())).si_signo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>())).si_errno as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>())).si_code as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo__bindgen_ty_1__bindgen_ty_1>()))._sifields as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_sifields)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo__bindgen_ty_1>()))._si_pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo__bindgen_ty_1),
            "::",
            stringify!(_si_pad)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo() {
    assert_eq!(
        ::std::mem::size_of::<siginfo>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo))
    );
}
pub type siginfo_t = siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: ::std::os::raw::c_int,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval_t)>,
    pub _attribute: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._function as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._attribute as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._sigev_thread as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>()))._sigev_un as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
pub type sigevent_t = sigevent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo {
    pub __bindgen_anon_1: kernel_siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo__bindgen_ty_1 {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub _sifields: __sifields,
}
#[test]
fn bindgen_test_layout_kernel_siginfo__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<kernel_siginfo__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(kernel_siginfo__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<kernel_siginfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_siginfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kernel_siginfo__bindgen_ty_1>())).si_signo as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_siginfo__bindgen_ty_1),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kernel_siginfo__bindgen_ty_1>())).si_errno as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_siginfo__bindgen_ty_1),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kernel_siginfo__bindgen_ty_1>())).si_code as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_siginfo__bindgen_ty_1),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<kernel_siginfo__bindgen_ty_1>()))._sifields as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_siginfo__bindgen_ty_1),
            "::",
            stringify!(_sifields)
        )
    );
}
#[test]
fn bindgen_test_layout_kernel_siginfo() {
    assert_eq!(
        ::std::mem::size_of::<kernel_siginfo>(),
        48usize,
        concat!("Size of: ", stringify!(kernel_siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<kernel_siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_siginfo))
    );
}
pub type kernel_siginfo_t = kernel_siginfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucounts {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigqueue {
    pub list: list_head,
    pub flags: ::std::os::raw::c_int,
    pub info: kernel_siginfo_t,
    pub ucounts: *mut ucounts,
}
#[test]
fn bindgen_test_layout_sigqueue() {
    assert_eq!(
        ::std::mem::size_of::<sigqueue>(),
        80usize,
        concat!("Size of: ", stringify!(sigqueue))
    );
    assert_eq!(
        ::std::mem::align_of::<sigqueue>(),
        8usize,
        concat!("Alignment of ", stringify!(sigqueue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigqueue>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigqueue),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigqueue>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigqueue),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigqueue>())).info as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigqueue),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigqueue>())).ucounts as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigqueue),
            "::",
            stringify!(ucounts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigpending {
    pub list: list_head,
    pub signal: sigset_t,
}
#[test]
fn bindgen_test_layout_sigpending() {
    assert_eq!(
        ::std::mem::size_of::<sigpending>(),
        24usize,
        concat!("Size of: ", stringify!(sigpending))
    );
    assert_eq!(
        ::std::mem::align_of::<sigpending>(),
        8usize,
        concat!("Alignment of ", stringify!(sigpending))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigpending>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigpending),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigpending>())).signal as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigpending),
            "::",
            stringify!(signal)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: __sighandler_t,
    pub sa_flags: ::std::os::raw::c_ulong,
    pub sa_restorer: __sigrestore_t,
    pub sa_mask: sigset_t,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        32usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_restorer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_sigaction {
    pub sa: sigaction,
}
#[test]
fn bindgen_test_layout_k_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<k_sigaction>(),
        32usize,
        concat!("Size of: ", stringify!(k_sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<k_sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(k_sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_sigaction>())).sa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_sigaction),
            "::",
            stringify!(sa)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ksignal {
    pub ka: k_sigaction,
    pub info: kernel_siginfo_t,
    pub sig: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ksignal() {
    assert_eq!(
        ::std::mem::size_of::<ksignal>(),
        88usize,
        concat!("Size of: ", stringify!(ksignal))
    );
    assert_eq!(
        ::std::mem::align_of::<ksignal>(),
        8usize,
        concat!("Alignment of ", stringify!(ksignal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ksignal>())).ka as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ksignal),
            "::",
            stringify!(ka)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ksignal>())).info as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ksignal),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ksignal>())).sig as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ksignal),
            "::",
            stringify!(sig)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct syscall_user_dispatch {
    pub selector: *mut ::std::os::raw::c_char,
    pub offset: ::std::os::raw::c_ulong,
    pub len: ::std::os::raw::c_ulong,
    pub on_dispatch: bool_,
}
#[test]
fn bindgen_test_layout_syscall_user_dispatch() {
    assert_eq!(
        ::std::mem::size_of::<syscall_user_dispatch>(),
        32usize,
        concat!("Size of: ", stringify!(syscall_user_dispatch))
    );
    assert_eq!(
        ::std::mem::align_of::<syscall_user_dispatch>(),
        8usize,
        concat!("Alignment of ", stringify!(syscall_user_dispatch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syscall_user_dispatch>())).selector as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(syscall_user_dispatch),
            "::",
            stringify!(selector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syscall_user_dispatch>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(syscall_user_dispatch),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syscall_user_dispatch>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(syscall_user_dispatch),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<syscall_user_dispatch>())).on_dispatch as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(syscall_user_dispatch),
            "::",
            stringify!(on_dispatch)
        )
    );
}
extern "C" {
    pub fn set_syscall_user_dispatch(
        mode: ::std::os::raw::c_ulong,
        offset: ::std::os::raw::c_ulong,
        len: ::std::os::raw::c_ulong,
        selector: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_io_accounting {
    pub rchar: u64_,
    pub wchar: u64_,
    pub syscr: u64_,
    pub syscw: u64_,
    pub read_bytes: u64_,
    pub write_bytes: u64_,
    pub cancelled_write_bytes: u64_,
}
#[test]
fn bindgen_test_layout_task_io_accounting() {
    assert_eq!(
        ::std::mem::size_of::<task_io_accounting>(),
        56usize,
        concat!("Size of: ", stringify!(task_io_accounting))
    );
    assert_eq!(
        ::std::mem::align_of::<task_io_accounting>(),
        8usize,
        concat!("Alignment of ", stringify!(task_io_accounting))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_io_accounting>())).rchar as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(rchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_io_accounting>())).wchar as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(wchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_io_accounting>())).syscr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(syscr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_io_accounting>())).syscw as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(syscw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_io_accounting>())).read_bytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(read_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_io_accounting>())).write_bytes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(write_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<task_io_accounting>())).cancelled_write_bytes as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(task_io_accounting),
            "::",
            stringify!(cancelled_write_bytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtc_device {
    _unused: [u8; 0],
}
pub const alarmtimer_type_ALARM_REALTIME: alarmtimer_type = 0;
pub const alarmtimer_type_ALARM_BOOTTIME: alarmtimer_type = 1;
pub const alarmtimer_type_ALARM_NUMTYPE: alarmtimer_type = 2;
pub const alarmtimer_type_ALARM_REALTIME_FREEZER: alarmtimer_type = 3;
pub const alarmtimer_type_ALARM_BOOTTIME_FREEZER: alarmtimer_type = 4;
pub type alarmtimer_type = ::std::os::raw::c_uint;
pub const alarmtimer_restart_ALARMTIMER_NORESTART: alarmtimer_restart = 0;
pub const alarmtimer_restart_ALARMTIMER_RESTART: alarmtimer_restart = 1;
pub type alarmtimer_restart = ::std::os::raw::c_uint;
#[doc = " struct alarm - Alarm timer structure"]
#[doc = " @node:\ttimerqueue node for adding to the event list this value"]
#[doc = "\t\talso includes the expiration time."]
#[doc = " @timer:\thrtimer used to schedule events while running"]
#[doc = " @function:\tFunction pointer to be executed when the timer fires."]
#[doc = " @type:\tAlarm type (BOOTTIME/REALTIME)."]
#[doc = " @state:\tFlag that represents if the alarm is set to fire or not."]
#[doc = " @data:\tInternal data value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alarm {
    pub node: timerqueue_node,
    pub timer: hrtimer,
    pub function: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut alarm, now: ktime_t) -> alarmtimer_restart,
    >,
    pub type_: alarmtimer_type,
    pub state: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_alarm() {
    assert_eq!(
        ::std::mem::size_of::<alarm>(),
        120usize,
        concat!("Size of: ", stringify!(alarm))
    );
    assert_eq!(
        ::std::mem::align_of::<alarm>(),
        8usize,
        concat!("Alignment of ", stringify!(alarm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alarm>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(alarm),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alarm>())).timer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(alarm),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alarm>())).function as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(alarm),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alarm>())).type_ as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(alarm),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alarm>())).state as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(alarm),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alarm>())).data as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(alarm),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn alarm_init(
        alarm: *mut alarm,
        type_: alarmtimer_type,
        function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut alarm, arg2: ktime_t) -> alarmtimer_restart,
        >,
    );
}
extern "C" {
    pub fn alarm_start(alarm: *mut alarm, start: ktime_t);
}
extern "C" {
    pub fn alarm_start_relative(alarm: *mut alarm, start: ktime_t);
}
extern "C" {
    pub fn alarm_restart(alarm: *mut alarm);
}
extern "C" {
    pub fn alarm_try_to_cancel(alarm: *mut alarm) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm_cancel(alarm: *mut alarm) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm_forward(alarm: *mut alarm, now: ktime_t, interval: ktime_t) -> u64_;
}
extern "C" {
    pub fn alarm_forward_now(alarm: *mut alarm, interval: ktime_t) -> u64_;
}
extern "C" {
    pub fn alarm_expires_remaining(alarm: *const alarm) -> ktime_t;
}
extern "C" {
    pub fn alarmtimer_get_rtcdev() -> *mut rtc_device;
}
#[doc = " cpu_timer - Posix CPU timer representation for k_itimer"]
#[doc = " @node:\ttimerqueue node to queue in the task/sig"]
#[doc = " @head:\ttimerqueue head on which this timer is queued"]
#[doc = " @task:\tPointer to target task"]
#[doc = " @elist:\tList head for the expiry list"]
#[doc = " @firing:\tTimer is currently firing"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_timer {
    pub node: timerqueue_node,
    pub head: *mut timerqueue_head,
    pub pid: *mut pid,
    pub elist: list_head,
    pub firing: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cpu_timer() {
    assert_eq!(
        ::std::mem::size_of::<cpu_timer>(),
        72usize,
        concat!("Size of: ", stringify!(cpu_timer))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_timer>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_timer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_timer>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_timer),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_timer>())).head as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_timer),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_timer>())).pid as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_timer),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_timer>())).elist as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_timer),
            "::",
            stringify!(elist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_timer>())).firing as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_timer),
            "::",
            stringify!(firing)
        )
    );
}
#[doc = " posix_cputimer_base - Container per posix CPU clock"]
#[doc = " @nextevt:\t\tEarliest-expiration cache"]
#[doc = " @tqhead:\t\ttimerqueue head for cpu_timers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cputimer_base {
    pub nextevt: u64_,
    pub tqhead: timerqueue_head,
}
#[test]
fn bindgen_test_layout_posix_cputimer_base() {
    assert_eq!(
        ::std::mem::size_of::<posix_cputimer_base>(),
        24usize,
        concat!("Size of: ", stringify!(posix_cputimer_base))
    );
    assert_eq!(
        ::std::mem::align_of::<posix_cputimer_base>(),
        8usize,
        concat!("Alignment of ", stringify!(posix_cputimer_base))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<posix_cputimer_base>())).nextevt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_cputimer_base),
            "::",
            stringify!(nextevt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<posix_cputimer_base>())).tqhead as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_cputimer_base),
            "::",
            stringify!(tqhead)
        )
    );
}
#[doc = " posix_cputimers - Container for posix CPU timer related data"]
#[doc = " @bases:\t\tBase container for posix CPU clocks"]
#[doc = " @timers_active:\tTimers are queued."]
#[doc = " @expiry_active:\tTimer expiry is active. Used for"]
#[doc = "\t\t\tprocess wide timers to avoid multiple"]
#[doc = "\t\t\ttask trying to handle expiry concurrently"]
#[doc = ""]
#[doc = " Used in task_struct and signal_struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cputimers {
    pub bases: [posix_cputimer_base; 3usize],
    pub timers_active: ::std::os::raw::c_uint,
    pub expiry_active: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_posix_cputimers() {
    assert_eq!(
        ::std::mem::size_of::<posix_cputimers>(),
        80usize,
        concat!("Size of: ", stringify!(posix_cputimers))
    );
    assert_eq!(
        ::std::mem::align_of::<posix_cputimers>(),
        8usize,
        concat!("Alignment of ", stringify!(posix_cputimers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<posix_cputimers>())).bases as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_cputimers),
            "::",
            stringify!(bases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<posix_cputimers>())).timers_active as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_cputimers),
            "::",
            stringify!(timers_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<posix_cputimers>())).expiry_active as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_cputimers),
            "::",
            stringify!(expiry_active)
        )
    );
}
#[doc = " posix_cputimers_work - Container for task work based posix CPU timer expiry"]
#[doc = " @work:\tThe task work to be scheduled"]
#[doc = " @scheduled:  @work has been scheduled already, no further processing"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cputimers_work {
    pub work: callback_head,
    pub scheduled: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_posix_cputimers_work() {
    assert_eq!(
        ::std::mem::size_of::<posix_cputimers_work>(),
        24usize,
        concat!("Size of: ", stringify!(posix_cputimers_work))
    );
    assert_eq!(
        ::std::mem::align_of::<posix_cputimers_work>(),
        8usize,
        concat!("Alignment of ", stringify!(posix_cputimers_work))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<posix_cputimers_work>())).work as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_cputimers_work),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<posix_cputimers_work>())).scheduled as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(posix_cputimers_work),
            "::",
            stringify!(scheduled)
        )
    );
}
extern "C" {
    pub fn posix_cputimers_group_init(pct: *mut posix_cputimers, cpu_limit: u64_);
}
extern "C" {
    pub fn clear_posix_cputimers_work(p: *mut task_struct);
}
extern "C" {
    pub fn posix_cputimers_init_work();
}
#[doc = " struct k_itimer - POSIX.1b interval timer structure."]
#[doc = " @list:\t\tList head for binding the timer to signals->posix_timers"]
#[doc = " @t_hash:\t\tEntry in the posix timer hash table"]
#[doc = " @it_lock:\t\tLock protecting the timer"]
#[doc = " @kclock:\t\tPointer to the k_clock struct handling this timer"]
#[doc = " @it_clock:\t\tThe posix timer clock id"]
#[doc = " @it_id:\t\tThe posix timer id for identifying the timer"]
#[doc = " @it_active:\t\tMarker that timer is active"]
#[doc = " @it_overrun:\t\tThe overrun counter for pending signals"]
#[doc = " @it_overrun_last:\tThe overrun at the time of the last delivered signal"]
#[doc = " @it_requeue_pending:\tIndicator that timer waits for being requeued on"]
#[doc = "\t\t\tsignal delivery"]
#[doc = " @it_sigev_notify:\tThe notify word of sigevent struct for signal delivery"]
#[doc = " @it_interval:\tThe interval for periodic timers"]
#[doc = " @it_signal:\t\tPointer to the creators signal struct"]
#[doc = " @it_pid:\t\tThe pid of the process/task targeted by the signal"]
#[doc = " @it_process:\t\tThe task to wakeup on clock_nanosleep (CPU timers)"]
#[doc = " @sigq:\t\tPointer to preallocated sigqueue"]
#[doc = " @it:\t\t\tUnion representing the various posix timer type"]
#[doc = "\t\t\tinternals."]
#[doc = " @rcu:\t\tRCU head for freeing the timer."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_itimer {
    pub list: list_head,
    pub t_hash: hlist_node,
    pub it_lock: spinlock_t,
    pub kclock: *mut k_clock,
    pub it_clock: clockid_t,
    pub it_id: timer_t,
    pub it_active: ::std::os::raw::c_int,
    pub it_overrun: s64,
    pub it_overrun_last: s64,
    pub it_requeue_pending: ::std::os::raw::c_int,
    pub it_sigev_notify: ::std::os::raw::c_int,
    pub it_interval: ktime_t,
    pub it_signal: *mut signal_struct,
    pub __bindgen_anon_1: k_itimer__bindgen_ty_1,
    pub sigq: *mut sigqueue,
    pub it: k_itimer__bindgen_ty_2,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_itimer__bindgen_ty_1 {
    pub it_pid: *mut pid,
    pub it_process: *mut task_struct,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_k_itimer__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<k_itimer__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(k_itimer__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<k_itimer__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(k_itimer__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer__bindgen_ty_1>())).it_pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer__bindgen_ty_1),
            "::",
            stringify!(it_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k_itimer__bindgen_ty_1>())).it_process as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer__bindgen_ty_1),
            "::",
            stringify!(it_process)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_itimer__bindgen_ty_2 {
    pub real: k_itimer__bindgen_ty_2__bindgen_ty_1,
    pub cpu: cpu_timer,
    pub alarm: k_itimer__bindgen_ty_2__bindgen_ty_2,
    _bindgen_union_align: [u64; 15usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_itimer__bindgen_ty_2__bindgen_ty_1 {
    pub timer: hrtimer,
}
#[test]
fn bindgen_test_layout_k_itimer__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<k_itimer__bindgen_ty_2__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(k_itimer__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<k_itimer__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(k_itimer__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k_itimer__bindgen_ty_2__bindgen_ty_1>())).timer as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(timer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_itimer__bindgen_ty_2__bindgen_ty_2 {
    pub alarmtimer: alarm,
}
#[test]
fn bindgen_test_layout_k_itimer__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<k_itimer__bindgen_ty_2__bindgen_ty_2>(),
        120usize,
        concat!(
            "Size of: ",
            stringify!(k_itimer__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<k_itimer__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(k_itimer__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<k_itimer__bindgen_ty_2__bindgen_ty_2>())).alarmtimer as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(alarmtimer)
        )
    );
}
#[test]
fn bindgen_test_layout_k_itimer__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<k_itimer__bindgen_ty_2>(),
        120usize,
        concat!("Size of: ", stringify!(k_itimer__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<k_itimer__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(k_itimer__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer__bindgen_ty_2>())).real as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer__bindgen_ty_2),
            "::",
            stringify!(real)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer__bindgen_ty_2>())).cpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer__bindgen_ty_2),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer__bindgen_ty_2>())).alarm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer__bindgen_ty_2),
            "::",
            stringify!(alarm)
        )
    );
}
#[test]
fn bindgen_test_layout_k_itimer() {
    assert_eq!(
        ::std::mem::size_of::<k_itimer>(),
        256usize,
        concat!("Size of: ", stringify!(k_itimer))
    );
    assert_eq!(
        ::std::mem::align_of::<k_itimer>(),
        8usize,
        concat!("Alignment of ", stringify!(k_itimer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).t_hash as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(t_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).it_lock as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(it_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).kclock as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(kclock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).it_clock as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(it_clock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).it_id as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(it_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).it_active as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(it_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).it_overrun as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(it_overrun)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).it_overrun_last as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(it_overrun_last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).it_requeue_pending as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(it_requeue_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).it_sigev_notify as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(it_sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).it_interval as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).it_signal as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(it_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).sigq as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(sigq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).it as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(it)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<k_itimer>())).rcu as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(k_itimer),
            "::",
            stringify!(rcu)
        )
    );
}
extern "C" {
    pub fn run_posix_cpu_timers();
}
extern "C" {
    pub fn posix_cpu_timers_exit(task: *mut task_struct);
}
extern "C" {
    pub fn posix_cpu_timers_exit_group(task: *mut task_struct);
}
extern "C" {
    pub fn set_process_cpu_timer(
        task: *mut task_struct,
        clock_idx: ::std::os::raw::c_uint,
        newval: *mut u64_,
        oldval: *mut u64_,
    );
}
extern "C" {
    pub fn update_rlimit_cpu(
        task: *mut task_struct,
        rlim_new: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posixtimer_rearm(info: *mut kernel_siginfo);
}
pub const rseq_cpu_id_state_RSEQ_CPU_ID_UNINITIALIZED: rseq_cpu_id_state = -1;
pub const rseq_cpu_id_state_RSEQ_CPU_ID_REGISTRATION_FAILED: rseq_cpu_id_state = -2;
pub type rseq_cpu_id_state = ::std::os::raw::c_int;
pub const rseq_flags_RSEQ_FLAG_UNREGISTER: rseq_flags = 1;
pub type rseq_flags = ::std::os::raw::c_uint;
pub const rseq_cs_flags_bit_RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT: rseq_cs_flags_bit = 0;
pub const rseq_cs_flags_bit_RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT: rseq_cs_flags_bit = 1;
pub const rseq_cs_flags_bit_RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT: rseq_cs_flags_bit = 2;
pub type rseq_cs_flags_bit = ::std::os::raw::c_uint;
pub const rseq_cs_flags_RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT: rseq_cs_flags = 1;
pub const rseq_cs_flags_RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL: rseq_cs_flags = 2;
pub const rseq_cs_flags_RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE: rseq_cs_flags = 4;
pub type rseq_cs_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct rseq_cs {
    pub version: __u32,
    pub flags: __u32,
    pub start_ip: __u64,
    pub post_commit_offset: __u64,
    pub abort_ip: __u64,
}
#[test]
fn bindgen_test_layout_rseq_cs() {
    assert_eq!(
        ::std::mem::size_of::<rseq_cs>(),
        32usize,
        concat!("Size of: ", stringify!(rseq_cs))
    );
    assert_eq!(
        ::std::mem::align_of::<rseq_cs>(),
        32usize,
        concat!("Alignment of ", stringify!(rseq_cs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rseq_cs>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq_cs),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rseq_cs>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq_cs),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rseq_cs>())).start_ip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq_cs),
            "::",
            stringify!(start_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rseq_cs>())).post_commit_offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq_cs),
            "::",
            stringify!(post_commit_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rseq_cs>())).abort_ip as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq_cs),
            "::",
            stringify!(abort_ip)
        )
    );
}
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct rseq {
    pub cpu_id_start: __u32,
    pub cpu_id: __u32,
    pub rseq_cs: __u64,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_rseq() {
    assert_eq!(
        ::std::mem::size_of::<rseq>(),
        32usize,
        concat!("Size of: ", stringify!(rseq))
    );
    assert_eq!(
        ::std::mem::align_of::<rseq>(),
        32usize,
        concat!("Alignment of ", stringify!(rseq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rseq>())).cpu_id_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq),
            "::",
            stringify!(cpu_id_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rseq>())).cpu_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq),
            "::",
            stringify!(cpu_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rseq>())).rseq_cs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq),
            "::",
            stringify!(rseq_cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rseq>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rseq),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct backing_dev_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blk_plug {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_local_storage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_run_ctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct capture_control {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfs_rq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct futex_pi_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_uring_task {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mempolicy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nameidata {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nsproxy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct perf_event_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pipe_inode_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct reclaim_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct robust_list_head {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct root_domain {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_delay_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_group {
    _unused: [u8; 0],
}
pub const TASK_COMM_LEN: ::std::os::raw::c_uint = 16;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
extern "C" {
    pub fn scheduler_tick();
}
extern "C" {
    pub fn schedule_timeout(timeout: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn schedule_timeout_interruptible(
        timeout: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn schedule_timeout_killable(timeout: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn schedule_timeout_uninterruptible(
        timeout: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn schedule_timeout_idle(timeout: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn schedule();
}
extern "C" {
    pub fn schedule_preempt_disabled();
}
extern "C" {
    pub fn preempt_schedule_irq();
}
extern "C" {
    pub fn io_schedule_prepare() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn io_schedule_finish(token: ::std::os::raw::c_int);
}
extern "C" {
    pub fn io_schedule_timeout(timeout: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn io_schedule();
}
#[doc = " struct prev_cputime - snapshot of system and user cputime"]
#[doc = " @utime: time spent in user mode"]
#[doc = " @stime: time spent in system mode"]
#[doc = " @lock: protects the above two fields"]
#[doc = ""]
#[doc = " Stores previous user/system time values such that we can guarantee"]
#[doc = " monotonicity."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prev_cputime {
    pub utime: u64_,
    pub stime: u64_,
    pub lock: raw_spinlock_t,
}
#[test]
fn bindgen_test_layout_prev_cputime() {
    assert_eq!(
        ::std::mem::size_of::<prev_cputime>(),
        24usize,
        concat!("Size of: ", stringify!(prev_cputime))
    );
    assert_eq!(
        ::std::mem::align_of::<prev_cputime>(),
        8usize,
        concat!("Alignment of ", stringify!(prev_cputime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<prev_cputime>())).utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(prev_cputime),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<prev_cputime>())).stime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(prev_cputime),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<prev_cputime>())).lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(prev_cputime),
            "::",
            stringify!(lock)
        )
    );
}
pub const vtime_state_VTIME_INACTIVE: vtime_state = 0;
pub const vtime_state_VTIME_IDLE: vtime_state = 1;
pub const vtime_state_VTIME_SYS: vtime_state = 2;
pub const vtime_state_VTIME_USER: vtime_state = 3;
pub const vtime_state_VTIME_GUEST: vtime_state = 4;
pub type vtime_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vtime {
    pub seqcount: seqcount_t,
    pub starttime: ::std::os::raw::c_ulonglong,
    pub state: vtime_state,
    pub cpu: ::std::os::raw::c_uint,
    pub utime: u64_,
    pub stime: u64_,
    pub gtime: u64_,
}
#[test]
fn bindgen_test_layout_vtime() {
    assert_eq!(
        ::std::mem::size_of::<vtime>(),
        48usize,
        concat!("Size of: ", stringify!(vtime))
    );
    assert_eq!(
        ::std::mem::align_of::<vtime>(),
        8usize,
        concat!("Alignment of ", stringify!(vtime))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vtime>())).seqcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vtime),
            "::",
            stringify!(seqcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vtime>())).starttime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vtime),
            "::",
            stringify!(starttime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vtime>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vtime),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vtime>())).cpu as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vtime),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vtime>())).utime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vtime),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vtime>())).stime as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vtime),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vtime>())).gtime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vtime),
            "::",
            stringify!(gtime)
        )
    );
}
pub const uclamp_id_UCLAMP_MIN: uclamp_id = 0;
pub const uclamp_id_UCLAMP_MAX: uclamp_id = 1;
pub const uclamp_id_UCLAMP_CNT: uclamp_id = 2;
pub type uclamp_id = ::std::os::raw::c_uint;
extern "C" {
    pub static mut def_root_domain: root_domain;
}
extern "C" {
    pub static mut sched_domains_mutex: mutex;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_info {
    pub pcount: ::std::os::raw::c_ulong,
    pub run_delay: ::std::os::raw::c_ulonglong,
    pub last_arrival: ::std::os::raw::c_ulonglong,
    pub last_queued: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_sched_info() {
    assert_eq!(
        ::std::mem::size_of::<sched_info>(),
        32usize,
        concat!("Size of: ", stringify!(sched_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_info>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_info>())).pcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(pcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_info>())).run_delay as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(run_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_info>())).last_arrival as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(last_arrival)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_info>())).last_queued as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_info),
            "::",
            stringify!(last_queued)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct load_weight {
    pub weight: ::std::os::raw::c_ulong,
    pub inv_weight: u32_,
}
#[test]
fn bindgen_test_layout_load_weight() {
    assert_eq!(
        ::std::mem::size_of::<load_weight>(),
        16usize,
        concat!("Size of: ", stringify!(load_weight))
    );
    assert_eq!(
        ::std::mem::align_of::<load_weight>(),
        8usize,
        concat!("Alignment of ", stringify!(load_weight))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<load_weight>())).weight as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(load_weight),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<load_weight>())).inv_weight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(load_weight),
            "::",
            stringify!(inv_weight)
        )
    );
}
#[doc = " struct util_est - Estimation utilization of FAIR tasks"]
#[doc = " @enqueued: instantaneous estimated utilization of a task/cpu"]
#[doc = " @ewma:     the Exponential Weighted Moving Average (EWMA)"]
#[doc = "            utilization of a task"]
#[doc = ""]
#[doc = " Support data structure to track an Exponential Weighted Moving Average"]
#[doc = " (EWMA) of a FAIR task's utilization. New samples are added to the moving"]
#[doc = " average each time a task completes an activation. Sample's weight is chosen"]
#[doc = " so that the EWMA will be relatively insensitive to transient changes to the"]
#[doc = " task's workload."]
#[doc = ""]
#[doc = " The enqueued attribute has a slightly different meaning for tasks and cpus:"]
#[doc = " - task:   the task's util_avg at last task dequeue time"]
#[doc = " - cfs_rq: the sum of util_est.enqueued for each RUNNABLE task on that CPU"]
#[doc = " Thus, the util_est.enqueued of a task represents the contribution on the"]
#[doc = " estimated utilization of the CPU where that task is currently enqueued."]
#[doc = ""]
#[doc = " Only for tasks we track a moving average of the past instantaneous"]
#[doc = " estimated utilization. This allows to absorb sporadic drops in utilization"]
#[doc = " of an otherwise almost periodic task."]
#[doc = ""]
#[doc = " The UTIL_AVG_UNCHANGED flag is used to synchronize util_est with util_avg"]
#[doc = " updates. When a task is dequeued, its util_est should not be updated if its"]
#[doc = " util_avg has not been updated in the meantime."]
#[doc = " This information is mapped into the MSB bit of util_est.enqueued at dequeue"]
#[doc = " time. Since max value of util_est.enqueued for a task is 1024 (PELT util_avg"]
#[doc = " for a task) it is safe to use MSB."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct util_est {
    pub enqueued: ::std::os::raw::c_uint,
    pub ewma: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_util_est() {
    assert_eq!(
        ::std::mem::size_of::<util_est>(),
        8usize,
        concat!("Size of: ", stringify!(util_est))
    );
    assert_eq!(
        ::std::mem::align_of::<util_est>(),
        8usize,
        concat!("Alignment of ", stringify!(util_est))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<util_est>())).enqueued as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(util_est),
            "::",
            stringify!(enqueued)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<util_est>())).ewma as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(util_est),
            "::",
            stringify!(ewma)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_avg {
    pub last_update_time: u64_,
    pub load_sum: u64_,
    pub runnable_sum: u64_,
    pub util_sum: u32_,
    pub period_contrib: u32_,
    pub load_avg: ::std::os::raw::c_ulong,
    pub runnable_avg: ::std::os::raw::c_ulong,
    pub util_avg: ::std::os::raw::c_ulong,
    pub util_est: util_est,
}
#[test]
fn bindgen_test_layout_sched_avg() {
    assert_eq!(
        ::std::mem::size_of::<sched_avg>(),
        64usize,
        concat!("Size of: ", stringify!(sched_avg))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_avg>(),
        64usize,
        concat!("Alignment of ", stringify!(sched_avg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_avg>())).last_update_time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(last_update_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_avg>())).load_sum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(load_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_avg>())).runnable_sum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(runnable_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_avg>())).util_sum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(util_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_avg>())).period_contrib as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(period_contrib)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_avg>())).load_avg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(load_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_avg>())).runnable_avg as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(runnable_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_avg>())).util_avg as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(util_avg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_avg>())).util_est as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_avg),
            "::",
            stringify!(util_est)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_statistics {
    pub wait_start: u64_,
    pub wait_max: u64_,
    pub wait_count: u64_,
    pub wait_sum: u64_,
    pub iowait_count: u64_,
    pub iowait_sum: u64_,
    pub sleep_start: u64_,
    pub sleep_max: u64_,
    pub sum_sleep_runtime: s64,
    pub block_start: u64_,
    pub block_max: u64_,
    pub sum_block_runtime: s64,
    pub exec_max: u64_,
    pub slice_max: u64_,
    pub nr_migrations_cold: u64_,
    pub nr_failed_migrations_affine: u64_,
    pub nr_failed_migrations_running: u64_,
    pub nr_failed_migrations_hot: u64_,
    pub nr_forced_migrations: u64_,
    pub nr_wakeups: u64_,
    pub nr_wakeups_sync: u64_,
    pub nr_wakeups_migrate: u64_,
    pub nr_wakeups_local: u64_,
    pub nr_wakeups_remote: u64_,
    pub nr_wakeups_affine: u64_,
    pub nr_wakeups_affine_attempts: u64_,
    pub nr_wakeups_passive: u64_,
    pub nr_wakeups_idle: u64_,
}
#[test]
fn bindgen_test_layout_sched_statistics() {
    assert_eq!(
        ::std::mem::size_of::<sched_statistics>(),
        256usize,
        concat!("Size of: ", stringify!(sched_statistics))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_statistics>(),
        64usize,
        concat!("Alignment of ", stringify!(sched_statistics))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_statistics>())).wait_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_statistics>())).wait_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_statistics>())).wait_count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_statistics>())).wait_sum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(wait_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_statistics>())).iowait_count as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(iowait_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_statistics>())).iowait_sum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(iowait_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_statistics>())).sleep_start as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(sleep_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_statistics>())).sleep_max as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(sleep_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_statistics>())).sum_sleep_runtime as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(sum_sleep_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_statistics>())).block_start as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(block_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_statistics>())).block_max as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(block_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_statistics>())).sum_block_runtime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(sum_block_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_statistics>())).exec_max as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(exec_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_statistics>())).slice_max as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(slice_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_statistics>())).nr_migrations_cold as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_migrations_cold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_statistics>())).nr_failed_migrations_affine as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_failed_migrations_affine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_statistics>())).nr_failed_migrations_running as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_failed_migrations_running)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_statistics>())).nr_failed_migrations_hot as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_failed_migrations_hot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_statistics>())).nr_forced_migrations as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_forced_migrations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_statistics>())).nr_wakeups as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_statistics>())).nr_wakeups_sync as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_sync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_statistics>())).nr_wakeups_migrate as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_migrate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_statistics>())).nr_wakeups_local as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_local)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_statistics>())).nr_wakeups_remote as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_remote)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_statistics>())).nr_wakeups_affine as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_affine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_statistics>())).nr_wakeups_affine_attempts as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_affine_attempts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_statistics>())).nr_wakeups_passive as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_passive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_statistics>())).nr_wakeups_idle as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_statistics),
            "::",
            stringify!(nr_wakeups_idle)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_entity {
    pub load: load_weight,
    pub run_node: rb_node,
    pub group_node: list_head,
    pub on_rq: ::std::os::raw::c_uint,
    pub exec_start: u64_,
    pub sum_exec_runtime: u64_,
    pub vruntime: u64_,
    pub prev_sum_exec_runtime: u64_,
    pub nr_migrations: u64_,
    pub depth: ::std::os::raw::c_int,
    pub parent: *mut sched_entity,
    pub cfs_rq: *mut cfs_rq,
    pub my_q: *mut cfs_rq,
    pub runnable_weight: ::std::os::raw::c_ulong,
    pub __bindgen_padding_0: [u64; 6usize],
    pub avg: sched_avg,
}
#[test]
fn bindgen_test_layout_sched_entity() {
    assert_eq!(
        ::std::mem::size_of::<sched_entity>(),
        256usize,
        concat!("Size of: ", stringify!(sched_entity))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_entity>(),
        64usize,
        concat!("Alignment of ", stringify!(sched_entity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_entity>())).load as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_entity>())).run_node as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(run_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_entity>())).group_node as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(group_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_entity>())).on_rq as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(on_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_entity>())).exec_start as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(exec_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_entity>())).sum_exec_runtime as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(sum_exec_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_entity>())).vruntime as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(vruntime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_entity>())).prev_sum_exec_runtime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(prev_sum_exec_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_entity>())).nr_migrations as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(nr_migrations)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_entity>())).depth as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_entity>())).parent as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_entity>())).cfs_rq as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(cfs_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_entity>())).my_q as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(my_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_entity>())).runnable_weight as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(runnable_weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_entity>())).avg as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_entity),
            "::",
            stringify!(avg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_rt_entity {
    pub run_list: list_head,
    pub timeout: ::std::os::raw::c_ulong,
    pub watchdog_stamp: ::std::os::raw::c_ulong,
    pub time_slice: ::std::os::raw::c_uint,
    pub on_rq: ::std::os::raw::c_ushort,
    pub on_list: ::std::os::raw::c_ushort,
    pub back: *mut sched_rt_entity,
}
#[test]
fn bindgen_test_layout_sched_rt_entity() {
    assert_eq!(
        ::std::mem::size_of::<sched_rt_entity>(),
        48usize,
        concat!("Size of: ", stringify!(sched_rt_entity))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_rt_entity>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_rt_entity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_rt_entity>())).run_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(run_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_rt_entity>())).timeout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_rt_entity>())).watchdog_stamp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(watchdog_stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_rt_entity>())).time_slice as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(time_slice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_rt_entity>())).on_rq as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(on_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_rt_entity>())).on_list as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(on_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_rt_entity>())).back as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_rt_entity),
            "::",
            stringify!(back)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_dl_entity {
    pub rb_node: rb_node,
    pub dl_runtime: u64_,
    pub dl_deadline: u64_,
    pub dl_period: u64_,
    pub dl_bw: u64_,
    pub dl_density: u64_,
    pub runtime: s64,
    pub deadline: u64_,
    pub flags: ::std::os::raw::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub dl_timer: hrtimer,
    pub inactive_timer: hrtimer,
    pub pi_se: *mut sched_dl_entity,
}
#[test]
fn bindgen_test_layout_sched_dl_entity() {
    assert_eq!(
        ::std::mem::size_of::<sched_dl_entity>(),
        224usize,
        concat!("Size of: ", stringify!(sched_dl_entity))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_dl_entity>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_dl_entity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_dl_entity>())).rb_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(rb_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_dl_entity>())).dl_runtime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_dl_entity>())).dl_deadline as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_deadline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_dl_entity>())).dl_period as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_period)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_dl_entity>())).dl_bw as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_bw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_dl_entity>())).dl_density as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_density)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_dl_entity>())).runtime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_dl_entity>())).deadline as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(deadline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_dl_entity>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_dl_entity>())).dl_timer as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(dl_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_dl_entity>())).inactive_timer as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(inactive_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_dl_entity>())).pi_se as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_dl_entity),
            "::",
            stringify!(pi_se)
        )
    );
}
impl sched_dl_entity {
    #[inline]
    pub fn dl_throttled(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_throttled(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_yielded(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_yielded(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_non_contending(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_non_contending(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_overrun(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_overrun(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dl_throttled: ::std::os::raw::c_uint,
        dl_yielded: ::std::os::raw::c_uint,
        dl_non_contending: ::std::os::raw::c_uint,
        dl_overrun: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dl_throttled: u32 = unsafe { ::std::mem::transmute(dl_throttled) };
            dl_throttled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dl_yielded: u32 = unsafe { ::std::mem::transmute(dl_yielded) };
            dl_yielded as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dl_non_contending: u32 = unsafe { ::std::mem::transmute(dl_non_contending) };
            dl_non_contending as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dl_overrun: u32 = unsafe { ::std::mem::transmute(dl_overrun) };
            dl_overrun as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rcu_special {
    pub b: rcu_special__bindgen_ty_1,
    pub s: u32_,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_special__bindgen_ty_1 {
    pub blocked: u8_,
    pub need_qs: u8_,
    pub exp_hint: u8_,
    pub need_mb: u8_,
}
#[test]
fn bindgen_test_layout_rcu_special__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rcu_special__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(rcu_special__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rcu_special__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(rcu_special__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rcu_special__bindgen_ty_1>())).blocked as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_special__bindgen_ty_1),
            "::",
            stringify!(blocked)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rcu_special__bindgen_ty_1>())).need_qs as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_special__bindgen_ty_1),
            "::",
            stringify!(need_qs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rcu_special__bindgen_ty_1>())).exp_hint as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_special__bindgen_ty_1),
            "::",
            stringify!(exp_hint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rcu_special__bindgen_ty_1>())).need_mb as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_special__bindgen_ty_1),
            "::",
            stringify!(need_mb)
        )
    );
}
#[test]
fn bindgen_test_layout_rcu_special() {
    assert_eq!(
        ::std::mem::size_of::<rcu_special>(),
        4usize,
        concat!("Size of: ", stringify!(rcu_special))
    );
    assert_eq!(
        ::std::mem::align_of::<rcu_special>(),
        4usize,
        concat!("Alignment of ", stringify!(rcu_special))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_special>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_special),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_special>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_special),
            "::",
            stringify!(s)
        )
    );
}
pub const perf_event_task_context_perf_invalid_context: perf_event_task_context = -1;
pub const perf_event_task_context_perf_hw_context: perf_event_task_context = 0;
pub const perf_event_task_context_perf_sw_context: perf_event_task_context = 1;
pub const perf_event_task_context_perf_nr_task_contexts: perf_event_task_context = 2;
pub type perf_event_task_context = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wake_q_node {
    pub next: *mut wake_q_node,
}
#[test]
fn bindgen_test_layout_wake_q_node() {
    assert_eq!(
        ::std::mem::size_of::<wake_q_node>(),
        8usize,
        concat!("Size of: ", stringify!(wake_q_node))
    );
    assert_eq!(
        ::std::mem::align_of::<wake_q_node>(),
        8usize,
        concat!("Alignment of ", stringify!(wake_q_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wake_q_node>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wake_q_node),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmap_ctrl {}
#[test]
fn bindgen_test_layout_kmap_ctrl() {
    assert_eq!(
        ::std::mem::size_of::<kmap_ctrl>(),
        0usize,
        concat!("Size of: ", stringify!(kmap_ctrl))
    );
    assert_eq!(
        ::std::mem::align_of::<kmap_ctrl>(),
        1usize,
        concat!("Alignment of ", stringify!(kmap_ctrl))
    );
}
#[repr(C)]
#[repr(align(64))]
pub struct task_struct {
    pub thread_info: thread_info,
    pub __state: ::std::os::raw::c_uint,
    pub stack: *mut ::std::os::raw::c_void,
    pub usage: refcount_t,
    pub flags: ::std::os::raw::c_uint,
    pub ptrace: ::std::os::raw::c_uint,
    pub on_cpu: ::std::os::raw::c_int,
    pub wake_entry: __call_single_node,
    pub wakee_flips: ::std::os::raw::c_uint,
    pub wakee_flip_decay_ts: ::std::os::raw::c_ulong,
    pub last_wakee: *mut task_struct,
    pub recent_used_cpu: ::std::os::raw::c_int,
    pub wake_cpu: ::std::os::raw::c_int,
    pub on_rq: ::std::os::raw::c_int,
    pub prio: ::std::os::raw::c_int,
    pub static_prio: ::std::os::raw::c_int,
    pub normal_prio: ::std::os::raw::c_int,
    pub rt_priority: ::std::os::raw::c_uint,
    pub __bindgen_padding_0: [u64; 0usize],
    pub se: sched_entity,
    pub rt: sched_rt_entity,
    pub dl: sched_dl_entity,
    pub sched_class: *mut sched_class,
    pub sched_task_group: *mut task_group,
    pub __bindgen_padding_1: [u64; 4usize],
    pub stats: sched_statistics,
    pub btrace_seq: ::std::os::raw::c_uint,
    pub policy: ::std::os::raw::c_uint,
    pub nr_cpus_allowed: ::std::os::raw::c_int,
    pub cpus_ptr: *const cpumask_t,
    pub user_cpus_ptr: *mut cpumask_t,
    pub cpus_mask: cpumask_t,
    pub migration_pending: *mut ::std::os::raw::c_void,
    pub migration_disabled: ::std::os::raw::c_ushort,
    pub migration_flags: ::std::os::raw::c_ushort,
    pub rcu_read_lock_nesting: ::std::os::raw::c_int,
    pub rcu_read_unlock_special: rcu_special,
    pub rcu_node_entry: list_head,
    pub rcu_blocked_node: *mut rcu_node,
    pub rcu_tasks_nvcsw: ::std::os::raw::c_ulong,
    pub rcu_tasks_holdout: u8_,
    pub rcu_tasks_idx: u8_,
    pub rcu_tasks_idle_cpu: ::std::os::raw::c_int,
    pub rcu_tasks_holdout_list: list_head,
    pub sched_info: sched_info,
    pub tasks: list_head,
    pub pushable_tasks: plist_node,
    pub pushable_dl_tasks: rb_node,
    pub mm: *mut mm_struct,
    pub active_mm: *mut mm_struct,
    pub rss_stat: task_rss_stat,
    pub exit_state: ::std::os::raw::c_int,
    pub exit_code: ::std::os::raw::c_int,
    pub exit_signal: ::std::os::raw::c_int,
    pub pdeath_signal: ::std::os::raw::c_int,
    pub jobctl: ::std::os::raw::c_ulong,
    pub personality: ::std::os::raw::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 6usize], u8>,
    pub atomic_flags: ::std::os::raw::c_ulong,
    pub restart_block: restart_block,
    pub pid: pid_t,
    pub tgid: pid_t,
    pub stack_canary: ::std::os::raw::c_ulong,
    pub real_parent: *mut task_struct,
    pub parent: *mut task_struct,
    pub children: list_head,
    pub sibling: list_head,
    pub group_leader: *mut task_struct,
    pub ptraced: list_head,
    pub ptrace_entry: list_head,
    pub thread_pid: *mut pid,
    pub pid_links: [hlist_node; 4usize],
    pub thread_group: list_head,
    pub thread_node: list_head,
    pub vfork_done: *mut completion,
    pub set_child_tid: *mut ::std::os::raw::c_int,
    pub clear_child_tid: *mut ::std::os::raw::c_int,
    pub worker_private: *mut ::std::os::raw::c_void,
    pub utime: u64_,
    pub stime: u64_,
    pub gtime: u64_,
    pub prev_cputime: prev_cputime,
    pub nvcsw: ::std::os::raw::c_ulong,
    pub nivcsw: ::std::os::raw::c_ulong,
    pub start_time: u64_,
    pub start_boottime: u64_,
    pub min_flt: ::std::os::raw::c_ulong,
    pub maj_flt: ::std::os::raw::c_ulong,
    pub posix_cputimers: posix_cputimers,
    pub posix_cputimers_work: posix_cputimers_work,
    pub ptracer_cred: *const cred,
    pub real_cred: *const cred,
    pub cred: *const cred,
    pub cached_requested_key: *mut key,
    pub comm: [::std::os::raw::c_char; 16usize],
    pub nameidata: *mut nameidata,
    pub sysvsem: sysv_sem,
    pub sysvshm: sysv_shm,
    pub fs: *mut fs_struct,
    pub files: *mut files_struct,
    pub io_uring: *mut io_uring_task,
    pub nsproxy: *mut nsproxy,
    pub signal: *mut signal_struct,
    pub sighand: *mut sighand_struct,
    pub blocked: sigset_t,
    pub real_blocked: sigset_t,
    pub saved_sigmask: sigset_t,
    pub pending: sigpending,
    pub sas_ss_sp: ::std::os::raw::c_ulong,
    pub sas_ss_size: size_t,
    pub sas_ss_flags: ::std::os::raw::c_uint,
    pub task_works: *mut callback_head,
    pub audit_context: *mut audit_context,
    pub loginuid: kuid_t,
    pub sessionid: ::std::os::raw::c_uint,
    pub seccomp: seccomp,
    pub syscall_dispatch: syscall_user_dispatch,
    pub parent_exec_id: u64_,
    pub self_exec_id: u64_,
    pub alloc_lock: spinlock_t,
    pub pi_lock: raw_spinlock_t,
    pub wake_q: wake_q_node,
    pub pi_waiters: rb_root_cached,
    pub pi_top_task: *mut task_struct,
    pub pi_blocked_on: *mut rt_mutex_waiter,
    pub journal_info: *mut ::std::os::raw::c_void,
    pub bio_list: *mut bio_list,
    pub plug: *mut blk_plug,
    pub reclaim_state: *mut reclaim_state,
    pub backing_dev_info: *mut backing_dev_info,
    pub io_context: *mut io_context,
    pub capture_control: *mut capture_control,
    pub ptrace_message: ::std::os::raw::c_ulong,
    pub last_siginfo: *mut kernel_siginfo_t,
    pub ioac: task_io_accounting,
    pub acct_rss_mem1: u64_,
    pub acct_vm_mem1: u64_,
    pub acct_timexpd: u64_,
    pub mems_allowed: nodemask_t,
    pub mems_allowed_seq: seqcount_spinlock_t,
    pub cpuset_mem_spread_rotor: ::std::os::raw::c_int,
    pub cpuset_slab_spread_rotor: ::std::os::raw::c_int,
    pub cgroups: *mut css_set,
    pub cg_list: list_head,
    pub robust_list: *mut robust_list_head,
    pub compat_robust_list: *mut compat_robust_list_head,
    pub pi_state_list: list_head,
    pub pi_state_cache: *mut futex_pi_state,
    pub futex_exit_mutex: mutex,
    pub futex_state: ::std::os::raw::c_uint,
    pub perf_event_ctxp: [*mut perf_event_context; 2usize],
    pub perf_event_mutex: mutex,
    pub perf_event_list: list_head,
    pub preempt_disable_ip: ::std::os::raw::c_ulong,
    pub mempolicy: *mut mempolicy,
    pub il_prev: ::std::os::raw::c_short,
    pub pref_node_fork: ::std::os::raw::c_short,
    pub rseq: *mut rseq,
    pub rseq_sig: u32_,
    pub rseq_event_mask: ::std::os::raw::c_ulong,
    pub tlb_ubc: tlbflush_unmap_batch,
    pub __bindgen_anon_1: task_struct__bindgen_ty_1,
    pub splice_pipe: *mut pipe_inode_info,
    pub task_frag: page_frag,
    pub delays: *mut task_delay_info,
    pub nr_dirtied: ::std::os::raw::c_int,
    pub nr_dirtied_pause: ::std::os::raw::c_int,
    pub dirty_paused_when: ::std::os::raw::c_ulong,
    pub timer_slack_ns: u64_,
    pub default_timer_slack_ns: u64_,
    pub kasan_depth: ::std::os::raw::c_uint,
    pub trace_recursion: ::std::os::raw::c_ulong,
    pub throttle_queue: *mut request_queue,
    pub utask: *mut uprobe_task,
    pub kmap_ctrl: kmap_ctrl,
    pub pagefault_disabled: ::std::os::raw::c_int,
    pub oom_reaper_list: *mut task_struct,
    pub oom_reaper_timer: timer_list,
    pub stack_refcount: refcount_t,
    pub security: *mut ::std::os::raw::c_void,
    pub mce_vaddr: *mut ::std::os::raw::c_void,
    pub mce_kflags: __u64,
    pub mce_addr: u64_,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 8usize], u64>,
    pub mce_kill_me: callback_head,
    pub mce_count: ::std::os::raw::c_int,
    pub kretprobe_instances: llist_head,
    pub rethooks: llist_head,
    pub l1d_flush_kill: callback_head,
    pub __bindgen_padding_2: [u64; 3usize],
    pub thread: thread_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union task_struct__bindgen_ty_1 {
    pub rcu_users: refcount_t,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_task_struct__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<task_struct__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(task_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<task_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(task_struct__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<task_struct__bindgen_ty_1>())).rcu_users as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct__bindgen_ty_1),
            "::",
            stringify!(rcu_users)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct__bindgen_ty_1>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct__bindgen_ty_1),
            "::",
            stringify!(rcu)
        )
    );
}
#[test]
fn bindgen_test_layout_task_struct() {
    assert_eq!(
        ::std::mem::size_of::<task_struct>(),
        7232usize,
        concat!("Size of: ", stringify!(task_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<task_struct>(),
        64usize,
        concat!("Alignment of ", stringify!(task_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).thread_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).__state as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(__state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).stack as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).usage as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).ptrace as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).on_cpu as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(on_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).wake_entry as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wake_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).wakee_flips as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wakee_flips)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).wakee_flip_decay_ts as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wakee_flip_decay_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).last_wakee as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_wakee)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).recent_used_cpu as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(recent_used_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).wake_cpu as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wake_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).on_rq as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(on_rq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).prio as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).static_prio as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(static_prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).normal_prio as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(normal_prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).rt_priority as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rt_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).se as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(se)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).rt as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).dl as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(dl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).sched_class as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sched_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).sched_task_group as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sched_task_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).stats as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).btrace_seq as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(btrace_seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).policy as *const _ as usize },
        964usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).nr_cpus_allowed as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nr_cpus_allowed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).cpus_ptr as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpus_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).user_cpus_ptr as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(user_cpus_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).cpus_mask as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpus_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).migration_pending as *const _ as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(migration_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).migration_disabled as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(migration_disabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).migration_flags as *const _ as usize },
        1010usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(migration_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<task_struct>())).rcu_read_lock_nesting as *const _ as usize
        },
        1012usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_read_lock_nesting)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<task_struct>())).rcu_read_unlock_special as *const _ as usize
        },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_read_unlock_special)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).rcu_node_entry as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_node_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).rcu_blocked_node as *const _ as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_blocked_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).rcu_tasks_nvcsw as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).rcu_tasks_holdout as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_holdout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).rcu_tasks_idx as *const _ as usize },
        1057usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).rcu_tasks_idle_cpu as *const _ as usize },
        1060usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_idle_cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<task_struct>())).rcu_tasks_holdout_list as *const _ as usize
        },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rcu_tasks_holdout_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).sched_info as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sched_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).tasks as *const _ as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).pushable_tasks as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pushable_tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).pushable_dl_tasks as *const _ as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pushable_dl_tasks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).mm as *const _ as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).active_mm as *const _ as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(active_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).rss_stat as *const _ as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rss_stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).exit_state as *const _ as usize },
        1228usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(exit_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).exit_code as *const _ as usize },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(exit_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).exit_signal as *const _ as usize },
        1236usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(exit_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).pdeath_signal as *const _ as usize },
        1240usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pdeath_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).jobctl as *const _ as usize },
        1248usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(jobctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).personality as *const _ as usize },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(personality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).atomic_flags as *const _ as usize },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(atomic_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).restart_block as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(restart_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).pid as *const _ as usize },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).tgid as *const _ as usize },
        1340usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(tgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).stack_canary as *const _ as usize },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stack_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).real_parent as *const _ as usize },
        1352usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(real_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).parent as *const _ as usize },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).children as *const _ as usize },
        1368usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).sibling as *const _ as usize },
        1384usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).group_leader as *const _ as usize },
        1400usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(group_leader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).ptraced as *const _ as usize },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptraced)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).ptrace_entry as *const _ as usize },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptrace_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).thread_pid as *const _ as usize },
        1440usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).pid_links as *const _ as usize },
        1448usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pid_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).thread_group as *const _ as usize },
        1512usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).thread_node as *const _ as usize },
        1528usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).vfork_done as *const _ as usize },
        1544usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(vfork_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).set_child_tid as *const _ as usize },
        1552usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(set_child_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).clear_child_tid as *const _ as usize },
        1560usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(clear_child_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).worker_private as *const _ as usize },
        1568usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(worker_private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).utime as *const _ as usize },
        1576usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).stime as *const _ as usize },
        1584usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).gtime as *const _ as usize },
        1592usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(gtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).prev_cputime as *const _ as usize },
        1600usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(prev_cputime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).nvcsw as *const _ as usize },
        1624usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).nivcsw as *const _ as usize },
        1632usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nivcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).start_time as *const _ as usize },
        1640usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).start_boottime as *const _ as usize },
        1648usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(start_boottime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).min_flt as *const _ as usize },
        1656usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(min_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).maj_flt as *const _ as usize },
        1664usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(maj_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).posix_cputimers as *const _ as usize },
        1672usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(posix_cputimers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<task_struct>())).posix_cputimers_work as *const _ as usize
        },
        1752usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(posix_cputimers_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).ptracer_cred as *const _ as usize },
        1776usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptracer_cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).real_cred as *const _ as usize },
        1784usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(real_cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).cred as *const _ as usize },
        1792usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cred)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<task_struct>())).cached_requested_key as *const _ as usize
        },
        1800usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cached_requested_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).comm as *const _ as usize },
        1808usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(comm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).nameidata as *const _ as usize },
        1824usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nameidata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).sysvsem as *const _ as usize },
        1832usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sysvsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).sysvshm as *const _ as usize },
        1840usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sysvshm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).fs as *const _ as usize },
        1856usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).files as *const _ as usize },
        1864usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(files)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).io_uring as *const _ as usize },
        1872usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(io_uring)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).nsproxy as *const _ as usize },
        1880usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nsproxy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).signal as *const _ as usize },
        1888usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).sighand as *const _ as usize },
        1896usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sighand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).blocked as *const _ as usize },
        1904usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(blocked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).real_blocked as *const _ as usize },
        1912usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(real_blocked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).saved_sigmask as *const _ as usize },
        1920usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(saved_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).pending as *const _ as usize },
        1928usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).sas_ss_sp as *const _ as usize },
        1952usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sas_ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).sas_ss_size as *const _ as usize },
        1960usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sas_ss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).sas_ss_flags as *const _ as usize },
        1968usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sas_ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).task_works as *const _ as usize },
        1976usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(task_works)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).audit_context as *const _ as usize },
        1984usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(audit_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).loginuid as *const _ as usize },
        1992usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(loginuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).sessionid as *const _ as usize },
        1996usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(sessionid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).seccomp as *const _ as usize },
        2000usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(seccomp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).syscall_dispatch as *const _ as usize },
        2016usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(syscall_dispatch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).parent_exec_id as *const _ as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(parent_exec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).self_exec_id as *const _ as usize },
        2056usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(self_exec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).alloc_lock as *const _ as usize },
        2064usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(alloc_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).pi_lock as *const _ as usize },
        2068usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).wake_q as *const _ as usize },
        2072usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(wake_q)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).pi_waiters as *const _ as usize },
        2080usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_waiters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).pi_top_task as *const _ as usize },
        2096usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_top_task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).pi_blocked_on as *const _ as usize },
        2104usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_blocked_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).journal_info as *const _ as usize },
        2112usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(journal_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).bio_list as *const _ as usize },
        2120usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(bio_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).plug as *const _ as usize },
        2128usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(plug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).reclaim_state as *const _ as usize },
        2136usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(reclaim_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).backing_dev_info as *const _ as usize },
        2144usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(backing_dev_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).io_context as *const _ as usize },
        2152usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(io_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).capture_control as *const _ as usize },
        2160usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(capture_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).ptrace_message as *const _ as usize },
        2168usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ptrace_message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).last_siginfo as *const _ as usize },
        2176usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(last_siginfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).ioac as *const _ as usize },
        2184usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(ioac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).acct_rss_mem1 as *const _ as usize },
        2240usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(acct_rss_mem1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).acct_vm_mem1 as *const _ as usize },
        2248usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(acct_vm_mem1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).acct_timexpd as *const _ as usize },
        2256usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(acct_timexpd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).mems_allowed as *const _ as usize },
        2264usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mems_allowed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).mems_allowed_seq as *const _ as usize },
        2272usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mems_allowed_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<task_struct>())).cpuset_mem_spread_rotor as *const _ as usize
        },
        2276usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpuset_mem_spread_rotor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<task_struct>())).cpuset_slab_spread_rotor as *const _ as usize
        },
        2280usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cpuset_slab_spread_rotor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).cgroups as *const _ as usize },
        2288usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cgroups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).cg_list as *const _ as usize },
        2296usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(cg_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).robust_list as *const _ as usize },
        2312usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(robust_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).compat_robust_list as *const _ as usize },
        2320usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(compat_robust_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).pi_state_list as *const _ as usize },
        2328usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_state_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).pi_state_cache as *const _ as usize },
        2344usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pi_state_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).futex_exit_mutex as *const _ as usize },
        2352usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(futex_exit_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).futex_state as *const _ as usize },
        2384usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(futex_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).perf_event_ctxp as *const _ as usize },
        2392usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(perf_event_ctxp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).perf_event_mutex as *const _ as usize },
        2408usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(perf_event_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).perf_event_list as *const _ as usize },
        2440usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(perf_event_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).preempt_disable_ip as *const _ as usize },
        2456usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(preempt_disable_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).mempolicy as *const _ as usize },
        2464usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mempolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).il_prev as *const _ as usize },
        2472usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(il_prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).pref_node_fork as *const _ as usize },
        2474usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pref_node_fork)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).rseq as *const _ as usize },
        2480usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rseq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).rseq_sig as *const _ as usize },
        2488usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rseq_sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).rseq_event_mask as *const _ as usize },
        2496usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rseq_event_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).tlb_ubc as *const _ as usize },
        2504usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(tlb_ubc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).splice_pipe as *const _ as usize },
        2536usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(splice_pipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).task_frag as *const _ as usize },
        2544usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(task_frag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).delays as *const _ as usize },
        2560usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(delays)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).nr_dirtied as *const _ as usize },
        2568usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nr_dirtied)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).nr_dirtied_pause as *const _ as usize },
        2572usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(nr_dirtied_pause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).dirty_paused_when as *const _ as usize },
        2576usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(dirty_paused_when)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).timer_slack_ns as *const _ as usize },
        2584usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(timer_slack_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<task_struct>())).default_timer_slack_ns as *const _ as usize
        },
        2592usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(default_timer_slack_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).kasan_depth as *const _ as usize },
        2600usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(kasan_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).trace_recursion as *const _ as usize },
        2608usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(trace_recursion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).throttle_queue as *const _ as usize },
        2616usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(throttle_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).utask as *const _ as usize },
        2624usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(utask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).kmap_ctrl as *const _ as usize },
        2632usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(kmap_ctrl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).pagefault_disabled as *const _ as usize },
        2632usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(pagefault_disabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).oom_reaper_list as *const _ as usize },
        2640usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(oom_reaper_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).oom_reaper_timer as *const _ as usize },
        2648usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(oom_reaper_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).stack_refcount as *const _ as usize },
        2688usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(stack_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).security as *const _ as usize },
        2696usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).mce_vaddr as *const _ as usize },
        2704usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mce_vaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).mce_kflags as *const _ as usize },
        2712usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mce_kflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).mce_addr as *const _ as usize },
        2720usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mce_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).mce_kill_me as *const _ as usize },
        2736usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mce_kill_me)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).mce_count as *const _ as usize },
        2752usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(mce_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).kretprobe_instances as *const _ as usize },
        2760usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(kretprobe_instances)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).rethooks as *const _ as usize },
        2768usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(rethooks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).l1d_flush_kill as *const _ as usize },
        2776usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(l1d_flush_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_struct>())).thread as *const _ as usize },
        2816usize,
        concat!(
            "Offset of field: ",
            stringify!(task_struct),
            "::",
            stringify!(thread)
        )
    );
}
impl task_struct {
    #[inline]
    pub fn sched_reset_on_fork(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_reset_on_fork(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_contributes_to_load(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_contributes_to_load(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_migrated(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_migrated(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_remote_wakeup(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_remote_wakeup(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_execve(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_execve(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_iowait(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_iowait(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn restore_sigmask(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_restore_sigmask(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cgroup_migration(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_migration(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frozen(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_memdelay(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_memdelay(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_eventfd(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_eventfd(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reported_split_lock(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reported_split_lock(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_thrashing(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_thrashing(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sched_reset_on_fork: ::std::os::raw::c_uint,
        sched_contributes_to_load: ::std::os::raw::c_uint,
        sched_migrated: ::std::os::raw::c_uint,
        sched_remote_wakeup: ::std::os::raw::c_uint,
        in_execve: ::std::os::raw::c_uint,
        in_iowait: ::std::os::raw::c_uint,
        restore_sigmask: ::std::os::raw::c_uint,
        no_cgroup_migration: ::std::os::raw::c_uint,
        frozen: ::std::os::raw::c_uint,
        use_memdelay: ::std::os::raw::c_uint,
        in_eventfd: ::std::os::raw::c_uint,
        reported_split_lock: ::std::os::raw::c_uint,
        in_thrashing: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 6usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 6usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sched_reset_on_fork: u32 = unsafe { ::std::mem::transmute(sched_reset_on_fork) };
            sched_reset_on_fork as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sched_contributes_to_load: u32 =
                unsafe { ::std::mem::transmute(sched_contributes_to_load) };
            sched_contributes_to_load as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sched_migrated: u32 = unsafe { ::std::mem::transmute(sched_migrated) };
            sched_migrated as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let sched_remote_wakeup: u32 = unsafe { ::std::mem::transmute(sched_remote_wakeup) };
            sched_remote_wakeup as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let in_execve: u32 = unsafe { ::std::mem::transmute(in_execve) };
            in_execve as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let in_iowait: u32 = unsafe { ::std::mem::transmute(in_iowait) };
            in_iowait as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let restore_sigmask: u32 = unsafe { ::std::mem::transmute(restore_sigmask) };
            restore_sigmask as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let no_cgroup_migration: u32 = unsafe { ::std::mem::transmute(no_cgroup_migration) };
            no_cgroup_migration as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let frozen: u32 = unsafe { ::std::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let use_memdelay: u32 = unsafe { ::std::mem::transmute(use_memdelay) };
            use_memdelay as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let in_eventfd: u32 = unsafe { ::std::mem::transmute(in_eventfd) };
            in_eventfd as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let reported_split_lock: u32 = unsafe { ::std::mem::transmute(reported_split_lock) };
            reported_split_lock as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let in_thrashing: u32 = unsafe { ::std::mem::transmute(in_thrashing) };
            in_thrashing as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn mce_ripv(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mce_ripv(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mce_whole_page(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_mce_whole_page(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __mce_reserved(&self) -> __u64 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set___mce_reserved(&mut self, val: __u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        mce_ripv: __u64,
        mce_whole_page: __u64,
        __mce_reserved: __u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mce_ripv: u64 = unsafe { ::std::mem::transmute(mce_ripv) };
            mce_ripv as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mce_whole_page: u64 = unsafe { ::std::mem::transmute(mce_whole_page) };
            mce_whole_page as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let __mce_reserved: u64 = unsafe { ::std::mem::transmute(__mce_reserved) };
            __mce_reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn __task_pid_nr_ns(
        task: *mut task_struct,
        type_: pid_type,
        ns: *mut pid_namespace,
    ) -> pid_t;
}
extern "C" {
    pub static mut cad_pid: *mut pid;
}
extern "C" {
    pub fn cpuset_cpumask_can_shrink(
        cur: *const cpumask,
        trial: *const cpumask,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn task_can_attach(
        p: *mut task_struct,
        cs_effective_cpus: *const cpumask,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_set_cpus_allowed(p: *mut task_struct, new_mask: *const cpumask);
}
extern "C" {
    pub fn set_cpus_allowed_ptr(
        p: *mut task_struct,
        new_mask: *const cpumask,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup_user_cpus_ptr(
        dst: *mut task_struct,
        src: *mut task_struct,
        node: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn release_user_cpus_ptr(p: *mut task_struct);
}
extern "C" {
    pub fn dl_task_check_affinity(
        p: *mut task_struct,
        mask: *const cpumask,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn force_compatible_cpus_allowed_ptr(p: *mut task_struct);
}
extern "C" {
    pub fn relax_compatible_cpus_allowed_ptr(p: *mut task_struct);
}
extern "C" {
    pub fn yield_to(p: *mut task_struct, preempt: bool_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_user_nice(p: *mut task_struct, nice: ::std::os::raw::c_long);
}
extern "C" {
    pub fn task_prio(p: *const task_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn can_nice(p: *const task_struct, nice: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn task_curr(p: *const task_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn idle_cpu(cpu: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn available_idle_cpu(cpu: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        arg1: *mut task_struct,
        arg2: ::std::os::raw::c_int,
        arg3: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler_nocheck(
        arg1: *mut task_struct,
        arg2: ::std::os::raw::c_int,
        arg3: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_set_fifo(p: *mut task_struct);
}
extern "C" {
    pub fn sched_set_fifo_low(p: *mut task_struct);
}
extern "C" {
    pub fn sched_set_normal(p: *mut task_struct, nice: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sched_setattr(arg1: *mut task_struct, arg2: *const sched_attr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setattr_nocheck(
        arg1: *mut task_struct,
        arg2: *const sched_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn idle_task(cpu: ::std::os::raw::c_int) -> *mut task_struct;
}
extern "C" {
    pub fn curr_task(cpu: ::std::os::raw::c_int) -> *mut task_struct;
}
extern "C" {
    pub fn ia64_set_curr_task(cpu: ::std::os::raw::c_int, p: *mut task_struct);
}
extern "C" {
    #[link_name = "\u{1}yield"]
    pub fn yield_();
}
#[repr(C)]
#[repr(align(64))]
pub struct thread_union {
    pub task: __BindgenUnionField<task_struct>,
    pub stack: __BindgenUnionField<[::std::os::raw::c_ulong; 4096usize]>,
    pub bindgen_union_field: [u8; 32768usize],
}
#[test]
fn bindgen_test_layout_thread_union() {
    assert_eq!(
        ::std::mem::size_of::<thread_union>(),
        32768usize,
        concat!("Size of: ", stringify!(thread_union))
    );
    assert_eq!(
        ::std::mem::align_of::<thread_union>(),
        64usize,
        concat!("Alignment of ", stringify!(thread_union))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_union>())).task as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_union),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<thread_union>())).stack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_union),
            "::",
            stringify!(stack)
        )
    );
}
extern "C" {
    pub static mut init_stack: [::std::os::raw::c_ulong; 4096usize];
}
extern "C" {
    pub fn find_task_by_vpid(nr: pid_t) -> *mut task_struct;
}
extern "C" {
    pub fn find_task_by_pid_ns(nr: pid_t, ns: *mut pid_namespace) -> *mut task_struct;
}
extern "C" {
    pub fn find_get_task_by_vpid(nr: pid_t) -> *mut task_struct;
}
extern "C" {
    pub fn wake_up_state(
        tsk: *mut task_struct,
        state: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wake_up_process(tsk: *mut task_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wake_up_new_task(tsk: *mut task_struct);
}
extern "C" {
    pub fn kick_process(tsk: *mut task_struct);
}
extern "C" {
    pub fn __set_task_comm(tsk: *mut task_struct, from: *const ::std::os::raw::c_char, exec: bool_);
}
extern "C" {
    pub fn __get_task_comm(
        to: *mut ::std::os::raw::c_char,
        len: size_t,
        tsk: *mut task_struct,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wait_task_inactive(
        arg1: *mut task_struct,
        match_state: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut __SCK__cond_resched: static_call_key;
}
extern "C" {
    pub fn __SCT__cond_resched() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cond_resched_lock(lock: *mut spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cond_resched_rwlock_read(lock: *mut rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cond_resched_rwlock_write(lock: *mut rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn preempt_model_none() -> bool_;
}
extern "C" {
    pub fn preempt_model_voluntary() -> bool_;
}
extern "C" {
    pub fn preempt_model_full() -> bool_;
}
extern "C" {
    pub fn set_task_cpu(p: *mut task_struct, cpu: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn sched_task_on_rq(p: *mut task_struct) -> bool_;
}
extern "C" {
    pub fn get_wchan(p: *mut task_struct) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn cpu_curr_snapshot(cpu: ::std::os::raw::c_int) -> *mut task_struct;
}
extern "C" {
    pub fn sched_setaffinity(pid: pid_t, new_mask: *const cpumask) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sched_getaffinity(pid: pid_t, mask: *mut cpumask) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sched_cpu_util(cpu: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
pub const rseq_event_mask_bits_RSEQ_EVENT_PREEMPT_BIT: rseq_event_mask_bits = 0;
pub const rseq_event_mask_bits_RSEQ_EVENT_SIGNAL_BIT: rseq_event_mask_bits = 1;
pub const rseq_event_mask_bits_RSEQ_EVENT_MIGRATE_BIT: rseq_event_mask_bits = 2;
pub type rseq_event_mask_bits = ::std::os::raw::c_uint;
pub const rseq_event_mask_RSEQ_EVENT_PREEMPT: rseq_event_mask = 1;
pub const rseq_event_mask_RSEQ_EVENT_SIGNAL: rseq_event_mask = 2;
pub const rseq_event_mask_RSEQ_EVENT_MIGRATE: rseq_event_mask = 4;
pub type rseq_event_mask = ::std::os::raw::c_uint;
extern "C" {
    pub fn __rseq_handle_notify_resume(sig: *mut ksignal, regs: *mut pt_regs);
}
extern "C" {
    pub fn sched_set_stop_task(cpu: ::std::os::raw::c_int, stop: *mut task_struct);
}
pub type ioasid_t = ::std::os::raw::c_uint;
pub type ioasid_alloc_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        min: ioasid_t,
        max: ioasid_t,
        data: *mut ::std::os::raw::c_void,
    ) -> ioasid_t,
>;
pub type ioasid_free_fn_t = ::std::option::Option<
    unsafe extern "C" fn(ioasid: ioasid_t, data: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ioasid_set {
    pub dummy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ioasid_set() {
    assert_eq!(
        ::std::mem::size_of::<ioasid_set>(),
        4usize,
        concat!("Size of: ", stringify!(ioasid_set))
    );
    assert_eq!(
        ::std::mem::align_of::<ioasid_set>(),
        4usize,
        concat!("Alignment of ", stringify!(ioasid_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ioasid_set>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ioasid_set),
            "::",
            stringify!(dummy)
        )
    );
}
#[doc = " struct ioasid_allocator_ops - IOASID allocator helper functions and data"]
#[doc = ""]
#[doc = " @alloc:\thelper function to allocate IOASID"]
#[doc = " @free:\thelper function to free IOASID"]
#[doc = " @list:\tfor tracking ops that share helper functions but not data"]
#[doc = " @pdata:\tdata belong to the allocator, provided when calling alloc()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ioasid_allocator_ops {
    pub alloc: ioasid_alloc_fn_t,
    pub free: ioasid_free_fn_t,
    pub list: list_head,
    pub pdata: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ioasid_allocator_ops() {
    assert_eq!(
        ::std::mem::size_of::<ioasid_allocator_ops>(),
        40usize,
        concat!("Size of: ", stringify!(ioasid_allocator_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<ioasid_allocator_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(ioasid_allocator_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ioasid_allocator_ops>())).alloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ioasid_allocator_ops),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ioasid_allocator_ops>())).free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ioasid_allocator_ops),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ioasid_allocator_ops>())).list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ioasid_allocator_ops),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ioasid_allocator_ops>())).pdata as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ioasid_allocator_ops),
            "::",
            stringify!(pdata)
        )
    );
}
extern "C" {
    pub fn ioasid_alloc(
        set: *mut ioasid_set,
        min: ioasid_t,
        max: ioasid_t,
        private: *mut ::std::os::raw::c_void,
    ) -> ioasid_t;
}
extern "C" {
    pub fn ioasid_free(ioasid: ioasid_t);
}
extern "C" {
    pub fn ioasid_find(
        set: *mut ioasid_set,
        ioasid: ioasid_t,
        getter: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> bool_,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ioasid_register_allocator(allocator: *mut ioasid_allocator_ops)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ioasid_unregister_allocator(allocator: *mut ioasid_allocator_ops);
}
extern "C" {
    pub fn ioasid_set_data(
        ioasid: ioasid_t,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mm_alloc() -> *mut mm_struct;
}
extern "C" {
    pub fn __mmdrop(mm: *mut mm_struct);
}
extern "C" {
    pub fn mmput(arg1: *mut mm_struct);
}
extern "C" {
    pub fn mmput_async(arg1: *mut mm_struct);
}
extern "C" {
    pub fn get_task_mm(task: *mut task_struct) -> *mut mm_struct;
}
extern "C" {
    pub fn mm_access(task: *mut task_struct, mode: ::std::os::raw::c_uint) -> *mut mm_struct;
}
extern "C" {
    pub fn exit_mm_release(arg1: *mut task_struct, arg2: *mut mm_struct);
}
extern "C" {
    pub fn exec_mm_release(arg1: *mut task_struct, arg2: *mut mm_struct);
}
extern "C" {
    pub fn arch_pick_mmap_layout(mm: *mut mm_struct, rlim_stack: *mut rlimit);
}
extern "C" {
    pub fn arch_get_unmapped_area(
        arg1: *mut file,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_ulong,
        arg5: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn arch_get_unmapped_area_topdown(
        filp: *mut file,
        addr: ::std::os::raw::c_ulong,
        len: ::std::os::raw::c_ulong,
        pgoff: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn generic_get_unmapped_area(
        filp: *mut file,
        addr: ::std::os::raw::c_ulong,
        len: ::std::os::raw::c_ulong,
        pgoff: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn generic_get_unmapped_area_topdown(
        filp: *mut file,
        addr: ::std::os::raw::c_ulong,
        len: ::std::os::raw::c_ulong,
        pgoff: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY: ::std::os::raw::c_uint = 1;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED: ::std::os::raw::c_uint = 2;
pub const MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY: ::std::os::raw::c_uint = 4;
pub const MEMBARRIER_STATE_GLOBAL_EXPEDITED: ::std::os::raw::c_uint = 8;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY: ::std::os::raw::c_uint = 16;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE: ::std::os::raw::c_uint = 32;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY: ::std::os::raw::c_uint = 64;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ: ::std::os::raw::c_uint = 128;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const MEMBARRIER_FLAG_SYNC_CORE: ::std::os::raw::c_uint = 1;
pub const MEMBARRIER_FLAG_RSEQ: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
extern "C" {
    pub fn membarrier_exec_mmap(mm: *mut mm_struct);
}
extern "C" {
    pub fn membarrier_update_current_mm(next_mm: *mut mm_struct);
}
#[doc = " struct xa_limit - Represents a range of IDs."]
#[doc = " @min: The lowest ID to allocate (inclusive)."]
#[doc = " @max: The maximum ID to allocate (inclusive)."]
#[doc = ""]
#[doc = " This structure is used either directly or via the XA_LIMIT() macro"]
#[doc = " to communicate the range of IDs that are valid for allocation."]
#[doc = " Three common ranges are predefined for you:"]
#[doc = " * xa_limit_32b\t- [0 - UINT_MAX]"]
#[doc = " * xa_limit_31b\t- [0 - INT_MAX]"]
#[doc = " * xa_limit_16b\t- [0 - USHRT_MAX]"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xa_limit {
    pub max: u32_,
    pub min: u32_,
}
#[test]
fn bindgen_test_layout_xa_limit() {
    assert_eq!(
        ::std::mem::size_of::<xa_limit>(),
        8usize,
        concat!("Size of: ", stringify!(xa_limit))
    );
    assert_eq!(
        ::std::mem::align_of::<xa_limit>(),
        4usize,
        concat!("Alignment of ", stringify!(xa_limit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_limit>())).max as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_limit),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_limit>())).min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_limit),
            "::",
            stringify!(min)
        )
    );
}
pub type xa_mark_t = ::std::os::raw::c_uint;
pub const xa_lock_type_XA_LOCK_IRQ: xa_lock_type = 1;
pub const xa_lock_type_XA_LOCK_BH: xa_lock_type = 2;
pub type xa_lock_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xarray {
    pub xa_lock: spinlock_t,
    pub xa_flags: gfp_t,
    pub xa_head: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_xarray() {
    assert_eq!(
        ::std::mem::size_of::<xarray>(),
        16usize,
        concat!("Size of: ", stringify!(xarray))
    );
    assert_eq!(
        ::std::mem::align_of::<xarray>(),
        8usize,
        concat!("Alignment of ", stringify!(xarray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xarray>())).xa_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xarray),
            "::",
            stringify!(xa_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xarray>())).xa_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xarray),
            "::",
            stringify!(xa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xarray>())).xa_head as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xarray),
            "::",
            stringify!(xa_head)
        )
    );
}
extern "C" {
    pub fn xa_load(
        arg1: *mut xarray,
        index: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xa_store(
        arg1: *mut xarray,
        index: ::std::os::raw::c_ulong,
        entry: *mut ::std::os::raw::c_void,
        arg2: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xa_erase(
        arg1: *mut xarray,
        index: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xa_store_range(
        arg1: *mut xarray,
        first: ::std::os::raw::c_ulong,
        last: ::std::os::raw::c_ulong,
        entry: *mut ::std::os::raw::c_void,
        arg2: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xa_get_mark(arg1: *mut xarray, index: ::std::os::raw::c_ulong, arg2: xa_mark_t)
        -> bool_;
}
extern "C" {
    pub fn xa_set_mark(arg1: *mut xarray, index: ::std::os::raw::c_ulong, arg2: xa_mark_t);
}
extern "C" {
    pub fn xa_clear_mark(arg1: *mut xarray, index: ::std::os::raw::c_ulong, arg2: xa_mark_t);
}
extern "C" {
    pub fn xa_find(
        xa: *mut xarray,
        index: *mut ::std::os::raw::c_ulong,
        max: ::std::os::raw::c_ulong,
        arg1: xa_mark_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xa_find_after(
        xa: *mut xarray,
        index: *mut ::std::os::raw::c_ulong,
        max: ::std::os::raw::c_ulong,
        arg1: xa_mark_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xa_extract(
        arg1: *mut xarray,
        dst: *mut *mut ::std::os::raw::c_void,
        start: ::std::os::raw::c_ulong,
        max: ::std::os::raw::c_ulong,
        n: ::std::os::raw::c_uint,
        arg2: xa_mark_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xa_destroy(arg1: *mut xarray);
}
extern "C" {
    pub fn __xa_erase(
        arg1: *mut xarray,
        index: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __xa_store(
        arg1: *mut xarray,
        index: ::std::os::raw::c_ulong,
        entry: *mut ::std::os::raw::c_void,
        arg2: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __xa_cmpxchg(
        arg1: *mut xarray,
        index: ::std::os::raw::c_ulong,
        old: *mut ::std::os::raw::c_void,
        entry: *mut ::std::os::raw::c_void,
        arg2: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __xa_insert(
        arg1: *mut xarray,
        index: ::std::os::raw::c_ulong,
        entry: *mut ::std::os::raw::c_void,
        arg2: gfp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xa_alloc(
        arg1: *mut xarray,
        id: *mut u32_,
        entry: *mut ::std::os::raw::c_void,
        arg2: xa_limit,
        arg3: gfp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xa_alloc_cyclic(
        arg1: *mut xarray,
        id: *mut u32_,
        entry: *mut ::std::os::raw::c_void,
        arg2: xa_limit,
        next: *mut u32_,
        arg3: gfp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xa_set_mark(arg1: *mut xarray, index: ::std::os::raw::c_ulong, arg2: xa_mark_t);
}
extern "C" {
    pub fn __xa_clear_mark(arg1: *mut xarray, index: ::std::os::raw::c_ulong, arg2: xa_mark_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xa_node {
    pub shift: ::std::os::raw::c_uchar,
    pub offset: ::std::os::raw::c_uchar,
    pub count: ::std::os::raw::c_uchar,
    pub nr_values: ::std::os::raw::c_uchar,
    pub parent: *mut xa_node,
    pub array: *mut xarray,
    pub __bindgen_anon_1: xa_node__bindgen_ty_1,
    pub slots: [*mut ::std::os::raw::c_void; 64usize],
    pub __bindgen_anon_2: xa_node__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xa_node__bindgen_ty_1 {
    pub private_list: list_head,
    pub callback_head: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_xa_node__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<xa_node__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(xa_node__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<xa_node__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(xa_node__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xa_node__bindgen_ty_1>())).private_list as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_node__bindgen_ty_1),
            "::",
            stringify!(private_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xa_node__bindgen_ty_1>())).callback_head as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_node__bindgen_ty_1),
            "::",
            stringify!(callback_head)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xa_node__bindgen_ty_2 {
    pub tags: [[::std::os::raw::c_ulong; 1usize]; 3usize],
    pub marks: [[::std::os::raw::c_ulong; 1usize]; 3usize],
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_xa_node__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<xa_node__bindgen_ty_2>(),
        24usize,
        concat!("Size of: ", stringify!(xa_node__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<xa_node__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(xa_node__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_node__bindgen_ty_2>())).tags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_node__bindgen_ty_2),
            "::",
            stringify!(tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_node__bindgen_ty_2>())).marks as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_node__bindgen_ty_2),
            "::",
            stringify!(marks)
        )
    );
}
#[test]
fn bindgen_test_layout_xa_node() {
    assert_eq!(
        ::std::mem::size_of::<xa_node>(),
        576usize,
        concat!("Size of: ", stringify!(xa_node))
    );
    assert_eq!(
        ::std::mem::align_of::<xa_node>(),
        8usize,
        concat!("Alignment of ", stringify!(xa_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_node>())).shift as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_node),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_node>())).offset as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_node),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_node>())).count as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_node),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_node>())).nr_values as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_node),
            "::",
            stringify!(nr_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_node>())).parent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_node),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_node>())).array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_node),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_node>())).slots as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_node),
            "::",
            stringify!(slots)
        )
    );
}
extern "C" {
    pub fn xa_dump(arg1: *const xarray);
}
extern "C" {
    pub fn xa_dump_node(arg1: *const xa_node);
}
#[doc = " typedef xa_update_node_t - A callback function from the XArray."]
#[doc = " @node: The node which is being processed"]
#[doc = ""]
#[doc = " This function is called every time the XArray updates the count of"]
#[doc = " present and value entries in a node.  It allows advanced users to"]
#[doc = " maintain the private_list in the node."]
#[doc = ""]
#[doc = " Context: The xa_lock is held and interrupts may be disabled."]
#[doc = "\t    Implementations should not drop the xa_lock, nor re-enable"]
#[doc = "\t    interrupts."]
pub type xa_update_node_t = ::std::option::Option<unsafe extern "C" fn(node: *mut xa_node)>;
extern "C" {
    pub fn xa_delete_node(arg1: *mut xa_node, arg2: xa_update_node_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xa_state {
    pub xa: *mut xarray,
    pub xa_index: ::std::os::raw::c_ulong,
    pub xa_shift: ::std::os::raw::c_uchar,
    pub xa_sibs: ::std::os::raw::c_uchar,
    pub xa_offset: ::std::os::raw::c_uchar,
    pub xa_pad: ::std::os::raw::c_uchar,
    pub xa_node: *mut xa_node,
    pub xa_alloc: *mut xa_node,
    pub xa_update: xa_update_node_t,
    pub xa_lru: *mut list_lru,
}
#[test]
fn bindgen_test_layout_xa_state() {
    assert_eq!(
        ::std::mem::size_of::<xa_state>(),
        56usize,
        concat!("Size of: ", stringify!(xa_state))
    );
    assert_eq!(
        ::std::mem::align_of::<xa_state>(),
        8usize,
        concat!("Alignment of ", stringify!(xa_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_state>())).xa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_state),
            "::",
            stringify!(xa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_state>())).xa_index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_state),
            "::",
            stringify!(xa_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_state>())).xa_shift as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_state),
            "::",
            stringify!(xa_shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_state>())).xa_sibs as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_state),
            "::",
            stringify!(xa_sibs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_state>())).xa_offset as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_state),
            "::",
            stringify!(xa_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_state>())).xa_pad as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_state),
            "::",
            stringify!(xa_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_state>())).xa_node as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_state),
            "::",
            stringify!(xa_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_state>())).xa_alloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_state),
            "::",
            stringify!(xa_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_state>())).xa_update as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_state),
            "::",
            stringify!(xa_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xa_state>())).xa_lru as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xa_state),
            "::",
            stringify!(xa_lru)
        )
    );
}
extern "C" {
    pub fn xas_load(arg1: *mut xa_state) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xas_store(
        arg1: *mut xa_state,
        entry: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xas_find(
        arg1: *mut xa_state,
        max: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xas_find_conflict(arg1: *mut xa_state) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xas_get_mark(arg1: *const xa_state, arg2: xa_mark_t) -> bool_;
}
extern "C" {
    pub fn xas_set_mark(arg1: *const xa_state, arg2: xa_mark_t);
}
extern "C" {
    pub fn xas_clear_mark(arg1: *const xa_state, arg2: xa_mark_t);
}
extern "C" {
    pub fn xas_find_marked(
        arg1: *mut xa_state,
        max: ::std::os::raw::c_ulong,
        arg2: xa_mark_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xas_init_marks(arg1: *const xa_state);
}
extern "C" {
    pub fn xas_nomem(arg1: *mut xa_state, arg2: gfp_t) -> bool_;
}
extern "C" {
    pub fn xas_destroy(arg1: *mut xa_state);
}
extern "C" {
    pub fn xas_pause(arg1: *mut xa_state);
}
extern "C" {
    pub fn xas_create_range(arg1: *mut xa_state);
}
extern "C" {
    pub fn xa_get_order(arg1: *mut xarray, index: ::std::os::raw::c_ulong)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xas_split(
        arg1: *mut xa_state,
        entry: *mut ::std::os::raw::c_void,
        order: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn xas_split_alloc(
        arg1: *mut xa_state,
        entry: *mut ::std::os::raw::c_void,
        order: ::std::os::raw::c_uint,
        arg2: gfp_t,
    );
}
pub const XA_CHECK_SCHED: ::std::os::raw::c_uint = 4096;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
extern "C" {
    pub fn __xas_next(arg1: *mut xa_state) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __xas_prev(arg1: *mut xa_state) -> *mut ::std::os::raw::c_void;
}
pub const lru_status_LRU_REMOVED: lru_status = 0;
pub const lru_status_LRU_REMOVED_RETRY: lru_status = 1;
pub const lru_status_LRU_ROTATE: lru_status = 2;
pub const lru_status_LRU_SKIP: lru_status = 3;
pub const lru_status_LRU_RETRY: lru_status = 4;
pub type lru_status = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_lru_one {
    pub list: list_head,
    pub nr_items: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_list_lru_one() {
    assert_eq!(
        ::std::mem::size_of::<list_lru_one>(),
        24usize,
        concat!("Size of: ", stringify!(list_lru_one))
    );
    assert_eq!(
        ::std::mem::align_of::<list_lru_one>(),
        8usize,
        concat!("Alignment of ", stringify!(list_lru_one))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_lru_one>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_one),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_lru_one>())).nr_items as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_one),
            "::",
            stringify!(nr_items)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct list_lru_memcg {
    pub rcu: callback_head,
    pub node: __IncompleteArrayField<list_lru_one>,
}
#[test]
fn bindgen_test_layout_list_lru_memcg() {
    assert_eq!(
        ::std::mem::size_of::<list_lru_memcg>(),
        16usize,
        concat!("Size of: ", stringify!(list_lru_memcg))
    );
    assert_eq!(
        ::std::mem::align_of::<list_lru_memcg>(),
        8usize,
        concat!("Alignment of ", stringify!(list_lru_memcg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_lru_memcg>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_memcg),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_lru_memcg>())).node as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_memcg),
            "::",
            stringify!(node)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct list_lru_node {
    pub lock: spinlock_t,
    pub lru: list_lru_one,
    pub nr_items: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_list_lru_node() {
    assert_eq!(
        ::std::mem::size_of::<list_lru_node>(),
        64usize,
        concat!("Size of: ", stringify!(list_lru_node))
    );
    assert_eq!(
        ::std::mem::align_of::<list_lru_node>(),
        64usize,
        concat!("Alignment of ", stringify!(list_lru_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_lru_node>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_node),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_lru_node>())).lru as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_node),
            "::",
            stringify!(lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_lru_node>())).nr_items as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru_node),
            "::",
            stringify!(nr_items)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_lru {
    pub node: *mut list_lru_node,
}
#[test]
fn bindgen_test_layout_list_lru() {
    assert_eq!(
        ::std::mem::size_of::<list_lru>(),
        8usize,
        concat!("Size of: ", stringify!(list_lru))
    );
    assert_eq!(
        ::std::mem::align_of::<list_lru>(),
        8usize,
        concat!("Alignment of ", stringify!(list_lru))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<list_lru>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(list_lru),
            "::",
            stringify!(node)
        )
    );
}
extern "C" {
    pub fn list_lru_destroy(lru: *mut list_lru);
}
extern "C" {
    pub fn __list_lru_init(
        lru: *mut list_lru,
        memcg_aware: bool_,
        key: *mut lock_class_key,
        shrinker: *mut shrinker,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcg_list_lru_alloc(
        memcg: *mut mem_cgroup,
        lru: *mut list_lru,
        gfp: gfp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcg_reparent_list_lrus(memcg: *mut mem_cgroup, parent: *mut mem_cgroup);
}
extern "C" {
    #[doc = " list_lru_add: add an element to the lru list's tail"]
    #[doc = " @list_lru: the lru pointer"]
    #[doc = " @item: the item to be added."]
    #[doc = ""]
    #[doc = " If the element is already part of a list, this function returns doing"]
    #[doc = " nothing. Therefore the caller does not need to keep state about whether or"]
    #[doc = " not the element already belongs in the list and is allowed to lazy update"]
    #[doc = " it. Note however that this is valid for *a* list, not *this* list. If"]
    #[doc = " the caller organize itself in a way that elements can be in more than"]
    #[doc = " one type of list, it is up to the caller to fully remove the item from"]
    #[doc = " the previous list (with list_lru_del() for instance) before moving it"]
    #[doc = " to @list_lru"]
    #[doc = ""]
    #[doc = " Return value: true if the list was updated, false otherwise"]
    pub fn list_lru_add(lru: *mut list_lru, item: *mut list_head) -> bool_;
}
extern "C" {
    #[doc = " list_lru_del: delete an element to the lru list"]
    #[doc = " @list_lru: the lru pointer"]
    #[doc = " @item: the item to be deleted."]
    #[doc = ""]
    #[doc = " This function works analogously as list_lru_add in terms of list"]
    #[doc = " manipulation. The comments about an element already pertaining to"]
    #[doc = " a list are also valid for list_lru_del."]
    #[doc = ""]
    #[doc = " Return value: true if the list was updated, false otherwise"]
    pub fn list_lru_del(lru: *mut list_lru, item: *mut list_head) -> bool_;
}
extern "C" {
    #[doc = " list_lru_count_one: return the number of objects currently held by @lru"]
    #[doc = " @lru: the lru pointer."]
    #[doc = " @nid: the node id to count from."]
    #[doc = " @memcg: the cgroup to count from."]
    #[doc = ""]
    #[doc = " Always return a non-negative number, 0 for empty lists. There is no"]
    #[doc = " guarantee that the list is not updated while the count is being computed."]
    #[doc = " Callers that want such a guarantee need to provide an outer lock."]
    pub fn list_lru_count_one(
        lru: *mut list_lru,
        nid: ::std::os::raw::c_int,
        memcg: *mut mem_cgroup,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn list_lru_count_node(
        lru: *mut list_lru,
        nid: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn list_lru_isolate(list: *mut list_lru_one, item: *mut list_head);
}
extern "C" {
    pub fn list_lru_isolate_move(
        list: *mut list_lru_one,
        item: *mut list_head,
        head: *mut list_head,
    );
}
pub type list_lru_walk_cb = ::std::option::Option<
    unsafe extern "C" fn(
        item: *mut list_head,
        list: *mut list_lru_one,
        lock: *mut spinlock_t,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> lru_status,
>;
extern "C" {
    #[doc = " list_lru_walk_one: walk a list_lru, isolating and disposing freeable items."]
    #[doc = " @lru: the lru pointer."]
    #[doc = " @nid: the node id to scan from."]
    #[doc = " @memcg: the cgroup to scan from."]
    #[doc = " @isolate: callback function that is responsible for deciding what to do with"]
    #[doc = "  the item currently being scanned"]
    #[doc = " @cb_arg: opaque type that will be passed to @isolate"]
    #[doc = " @nr_to_walk: how many items to scan."]
    #[doc = ""]
    #[doc = " This function will scan all elements in a particular list_lru, calling the"]
    #[doc = " @isolate callback for each of those items, along with the current list"]
    #[doc = " spinlock and a caller-provided opaque. The @isolate callback can choose to"]
    #[doc = " drop the lock internally, but *must* return with the lock held. The callback"]
    #[doc = " will return an enum lru_status telling the list_lru infrastructure what to"]
    #[doc = " do with the object being scanned."]
    #[doc = ""]
    #[doc = " Please note that nr_to_walk does not mean how many objects will be freed,"]
    #[doc = " just how many objects will be scanned."]
    #[doc = ""]
    #[doc = " Return value: the number of objects effectively removed from the LRU."]
    pub fn list_lru_walk_one(
        lru: *mut list_lru,
        nid: ::std::os::raw::c_int,
        memcg: *mut mem_cgroup,
        isolate: list_lru_walk_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        nr_to_walk: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " list_lru_walk_one_irq: walk a list_lru, isolating and disposing freeable items."]
    #[doc = " @lru: the lru pointer."]
    #[doc = " @nid: the node id to scan from."]
    #[doc = " @memcg: the cgroup to scan from."]
    #[doc = " @isolate: callback function that is responsible for deciding what to do with"]
    #[doc = "  the item currently being scanned"]
    #[doc = " @cb_arg: opaque type that will be passed to @isolate"]
    #[doc = " @nr_to_walk: how many items to scan."]
    #[doc = ""]
    #[doc = " Same as @list_lru_walk_one except that the spinlock is acquired with"]
    #[doc = " spin_lock_irq()."]
    pub fn list_lru_walk_one_irq(
        lru: *mut list_lru,
        nid: ::std::os::raw::c_int,
        memcg: *mut mem_cgroup,
        isolate: list_lru_walk_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        nr_to_walk: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn list_lru_walk_node(
        lru: *mut list_lru,
        nid: ::std::os::raw::c_int,
        isolate: list_lru_walk_cb,
        cb_arg: *mut ::std::os::raw::c_void,
        nr_to_walk: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct radix_tree_preload {
    pub lock: local_lock_t,
    pub nr: ::std::os::raw::c_uint,
    pub nodes: *mut xa_node,
}
#[test]
fn bindgen_test_layout_radix_tree_preload() {
    assert_eq!(
        ::std::mem::size_of::<radix_tree_preload>(),
        16usize,
        concat!("Size of: ", stringify!(radix_tree_preload))
    );
    assert_eq!(
        ::std::mem::align_of::<radix_tree_preload>(),
        8usize,
        concat!("Alignment of ", stringify!(radix_tree_preload))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<radix_tree_preload>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_preload),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<radix_tree_preload>())).nr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_preload),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<radix_tree_preload>())).nodes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_preload),
            "::",
            stringify!(nodes)
        )
    );
}
extern "C" {
    pub static mut radix_tree_preloads: radix_tree_preload;
}
#[doc = " struct radix_tree_iter - radix tree iterator state"]
#[doc = ""]
#[doc = " @index:\tindex of current slot"]
#[doc = " @next_index:\tone beyond the last index for this chunk"]
#[doc = " @tags:\tbit-mask for tag-iterating"]
#[doc = " @node:\tnode that contains current slot"]
#[doc = ""]
#[doc = " This radix tree iterator works in terms of \"chunks\" of slots.  A chunk is a"]
#[doc = " subinterval of slots contained within one radix tree leaf node.  It is"]
#[doc = " described by a pointer to its first slot and a struct radix_tree_iter"]
#[doc = " which holds the chunk's position in the tree and its size.  For tagged"]
#[doc = " iteration radix_tree_iter also holds the slots' bit-mask for one chosen"]
#[doc = " radix tree tag."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct radix_tree_iter {
    pub index: ::std::os::raw::c_ulong,
    pub next_index: ::std::os::raw::c_ulong,
    pub tags: ::std::os::raw::c_ulong,
    pub node: *mut xa_node,
}
#[test]
fn bindgen_test_layout_radix_tree_iter() {
    assert_eq!(
        ::std::mem::size_of::<radix_tree_iter>(),
        32usize,
        concat!("Size of: ", stringify!(radix_tree_iter))
    );
    assert_eq!(
        ::std::mem::align_of::<radix_tree_iter>(),
        8usize,
        concat!("Alignment of ", stringify!(radix_tree_iter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<radix_tree_iter>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_iter),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<radix_tree_iter>())).next_index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_iter),
            "::",
            stringify!(next_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<radix_tree_iter>())).tags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_iter),
            "::",
            stringify!(tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<radix_tree_iter>())).node as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(radix_tree_iter),
            "::",
            stringify!(node)
        )
    );
}
extern "C" {
    pub fn radix_tree_insert(
        arg1: *mut xarray,
        index: ::std::os::raw::c_ulong,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __radix_tree_lookup(
        arg1: *const xarray,
        index: ::std::os::raw::c_ulong,
        nodep: *mut *mut xa_node,
        slotp: *mut *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn radix_tree_lookup(
        arg1: *const xarray,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn radix_tree_lookup_slot(
        arg1: *const xarray,
        index: ::std::os::raw::c_ulong,
    ) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __radix_tree_replace(
        arg1: *mut xarray,
        arg2: *mut xa_node,
        slot: *mut *mut ::std::os::raw::c_void,
        entry: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn radix_tree_iter_replace(
        arg1: *mut xarray,
        arg2: *const radix_tree_iter,
        slot: *mut *mut ::std::os::raw::c_void,
        entry: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn radix_tree_replace_slot(
        arg1: *mut xarray,
        slot: *mut *mut ::std::os::raw::c_void,
        entry: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn radix_tree_iter_delete(
        arg1: *mut xarray,
        iter: *mut radix_tree_iter,
        slot: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn radix_tree_delete_item(
        arg1: *mut xarray,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn radix_tree_delete(
        arg1: *mut xarray,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn radix_tree_gang_lookup(
        arg1: *const xarray,
        results: *mut *mut ::std::os::raw::c_void,
        first_index: ::std::os::raw::c_ulong,
        max_items: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn radix_tree_preload(gfp_mask: gfp_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn radix_tree_maybe_preload(gfp_mask: gfp_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn radix_tree_init();
}
extern "C" {
    pub fn radix_tree_tag_set(
        arg1: *mut xarray,
        index: ::std::os::raw::c_ulong,
        tag: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn radix_tree_tag_clear(
        arg1: *mut xarray,
        index: ::std::os::raw::c_ulong,
        tag: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn radix_tree_tag_get(
        arg1: *const xarray,
        index: ::std::os::raw::c_ulong,
        tag: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn radix_tree_iter_tag_clear(
        arg1: *mut xarray,
        iter: *const radix_tree_iter,
        tag: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn radix_tree_gang_lookup_tag(
        arg1: *const xarray,
        results: *mut *mut ::std::os::raw::c_void,
        first_index: ::std::os::raw::c_ulong,
        max_items: ::std::os::raw::c_uint,
        tag: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn radix_tree_gang_lookup_tag_slot(
        arg1: *const xarray,
        results: *mut *mut *mut ::std::os::raw::c_void,
        first_index: ::std::os::raw::c_ulong,
        max_items: ::std::os::raw::c_uint,
        tag: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn radix_tree_tagged(
        arg1: *const xarray,
        tag: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn idr_get_free(
        root: *mut xarray,
        iter: *mut radix_tree_iter,
        gfp: gfp_t,
        max: ::std::os::raw::c_ulong,
    ) -> *mut *mut ::std::os::raw::c_void;
}
pub const RADIX_TREE_ITER_TAG_MASK: ::std::os::raw::c_uint = 15;
pub const RADIX_TREE_ITER_TAGGED: ::std::os::raw::c_uint = 16;
pub const RADIX_TREE_ITER_CONTIG: ::std::os::raw::c_uint = 32;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " radix_tree_next_chunk - find next chunk of slots for iteration"]
    #[doc = ""]
    #[doc = " @root:\tradix tree root"]
    #[doc = " @iter:\titerator state"]
    #[doc = " @flags:\tRADIX_TREE_ITER_* flags and tag index"]
    #[doc = " Returns:\tpointer to chunk first slot, or NULL if there no more left"]
    #[doc = ""]
    #[doc = " This function looks up the next chunk in the radix tree starting from"]
    #[doc = " @iter->next_index.  It returns a pointer to the chunk's first slot."]
    #[doc = " Also it fills @iter with data about chunk: position in the tree (index),"]
    #[doc = " its end (next_index), and constructs a bit mask for tagged iterating (tags)."]
    pub fn radix_tree_next_chunk(
        arg1: *const xarray,
        iter: *mut radix_tree_iter,
        flags: ::std::os::raw::c_uint,
    ) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " radix_tree_iter_resume - resume iterating when the chunk may be invalid"]
    #[doc = " @slot: pointer to current slot"]
    #[doc = " @iter: iterator state"]
    #[doc = " Returns: New slot pointer"]
    #[doc = ""]
    #[doc = " If the iterator needs to release then reacquire a lock, the chunk may"]
    #[doc = " have been invalidated by an insertion or deletion.  Call this function"]
    #[doc = " before releasing the lock to continue the iteration from the next index."]
    pub fn radix_tree_iter_resume(
        slot: *mut *mut ::std::os::raw::c_void,
        iter: *mut radix_tree_iter,
    ) -> *mut *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __user_cap_header_struct {
    pub version: __u32,
    pub pid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___user_cap_header_struct() {
    assert_eq!(
        ::std::mem::size_of::<__user_cap_header_struct>(),
        8usize,
        concat!("Size of: ", stringify!(__user_cap_header_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__user_cap_header_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(__user_cap_header_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__user_cap_header_struct>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__user_cap_header_struct),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__user_cap_header_struct>())).pid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__user_cap_header_struct),
            "::",
            stringify!(pid)
        )
    );
}
pub type cap_user_header_t = *mut __user_cap_header_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __user_cap_data_struct {
    pub effective: __u32,
    pub permitted: __u32,
    pub inheritable: __u32,
}
#[test]
fn bindgen_test_layout___user_cap_data_struct() {
    assert_eq!(
        ::std::mem::size_of::<__user_cap_data_struct>(),
        12usize,
        concat!("Size of: ", stringify!(__user_cap_data_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__user_cap_data_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(__user_cap_data_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__user_cap_data_struct>())).effective as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__user_cap_data_struct),
            "::",
            stringify!(effective)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__user_cap_data_struct>())).permitted as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__user_cap_data_struct),
            "::",
            stringify!(permitted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__user_cap_data_struct>())).inheritable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__user_cap_data_struct),
            "::",
            stringify!(inheritable)
        )
    );
}
pub type cap_user_data_t = *mut __user_cap_data_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_cap_data {
    pub magic_etc: __le32,
    pub data: [vfs_cap_data__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_cap_data__bindgen_ty_1 {
    pub permitted: __le32,
    pub inheritable: __le32,
}
#[test]
fn bindgen_test_layout_vfs_cap_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfs_cap_data__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(vfs_cap_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfs_cap_data__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(vfs_cap_data__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfs_cap_data__bindgen_ty_1>())).permitted as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_cap_data__bindgen_ty_1),
            "::",
            stringify!(permitted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfs_cap_data__bindgen_ty_1>())).inheritable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_cap_data__bindgen_ty_1),
            "::",
            stringify!(inheritable)
        )
    );
}
#[test]
fn bindgen_test_layout_vfs_cap_data() {
    assert_eq!(
        ::std::mem::size_of::<vfs_cap_data>(),
        20usize,
        concat!("Size of: ", stringify!(vfs_cap_data))
    );
    assert_eq!(
        ::std::mem::align_of::<vfs_cap_data>(),
        4usize,
        concat!("Alignment of ", stringify!(vfs_cap_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfs_cap_data>())).magic_etc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_cap_data),
            "::",
            stringify!(magic_etc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfs_cap_data>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_cap_data),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_ns_cap_data {
    pub magic_etc: __le32,
    pub data: [vfs_ns_cap_data__bindgen_ty_1; 2usize],
    pub rootid: __le32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfs_ns_cap_data__bindgen_ty_1 {
    pub permitted: __le32,
    pub inheritable: __le32,
}
#[test]
fn bindgen_test_layout_vfs_ns_cap_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfs_ns_cap_data__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(vfs_ns_cap_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfs_ns_cap_data__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(vfs_ns_cap_data__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfs_ns_cap_data__bindgen_ty_1>())).permitted as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_ns_cap_data__bindgen_ty_1),
            "::",
            stringify!(permitted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfs_ns_cap_data__bindgen_ty_1>())).inheritable as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_ns_cap_data__bindgen_ty_1),
            "::",
            stringify!(inheritable)
        )
    );
}
#[test]
fn bindgen_test_layout_vfs_ns_cap_data() {
    assert_eq!(
        ::std::mem::size_of::<vfs_ns_cap_data>(),
        24usize,
        concat!("Size of: ", stringify!(vfs_ns_cap_data))
    );
    assert_eq!(
        ::std::mem::align_of::<vfs_ns_cap_data>(),
        4usize,
        concat!("Alignment of ", stringify!(vfs_ns_cap_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfs_ns_cap_data>())).magic_etc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_ns_cap_data),
            "::",
            stringify!(magic_etc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfs_ns_cap_data>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_ns_cap_data),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfs_ns_cap_data>())).rootid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vfs_ns_cap_data),
            "::",
            stringify!(rootid)
        )
    );
}
extern "C" {
    pub static mut file_caps_enabled: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_cap_struct {
    pub cap: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_kernel_cap_struct() {
    assert_eq!(
        ::std::mem::size_of::<kernel_cap_struct>(),
        8usize,
        concat!("Size of: ", stringify!(kernel_cap_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<kernel_cap_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(kernel_cap_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_cap_struct>())).cap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_cap_struct),
            "::",
            stringify!(cap)
        )
    );
}
pub type kernel_cap_t = kernel_cap_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_vfs_cap_data {
    pub magic_etc: __u32,
    pub permitted: kernel_cap_t,
    pub inheritable: kernel_cap_t,
    pub rootid: kuid_t,
}
#[test]
fn bindgen_test_layout_cpu_vfs_cap_data() {
    assert_eq!(
        ::std::mem::size_of::<cpu_vfs_cap_data>(),
        24usize,
        concat!("Size of: ", stringify!(cpu_vfs_cap_data))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_vfs_cap_data>(),
        4usize,
        concat!("Alignment of ", stringify!(cpu_vfs_cap_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_vfs_cap_data>())).magic_etc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_vfs_cap_data),
            "::",
            stringify!(magic_etc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_vfs_cap_data>())).permitted as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_vfs_cap_data),
            "::",
            stringify!(permitted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_vfs_cap_data>())).inheritable as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_vfs_cap_data),
            "::",
            stringify!(inheritable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_vfs_cap_data>())).rootid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_vfs_cap_data),
            "::",
            stringify!(rootid)
        )
    );
}
extern "C" {
    pub static __cap_empty_set: kernel_cap_t;
}
extern "C" {
    pub static __cap_init_eff_set: kernel_cap_t;
}
extern "C" {
    pub fn has_capability(t: *mut task_struct, cap: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn has_ns_capability(
        t: *mut task_struct,
        ns: *mut user_namespace,
        cap: ::std::os::raw::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn has_capability_noaudit(t: *mut task_struct, cap: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn has_ns_capability_noaudit(
        t: *mut task_struct,
        ns: *mut user_namespace,
        cap: ::std::os::raw::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn capable(cap: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn ns_capable(ns: *mut user_namespace, cap: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn ns_capable_noaudit(ns: *mut user_namespace, cap: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn ns_capable_setid(ns: *mut user_namespace, cap: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn privileged_wrt_inode_uidgid(
        ns: *mut user_namespace,
        mnt_userns: *mut user_namespace,
        inode: *const inode,
    ) -> bool_;
}
extern "C" {
    pub fn capable_wrt_inode_uidgid(
        mnt_userns: *mut user_namespace,
        inode: *const inode,
        cap: ::std::os::raw::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn file_ns_capable(
        file: *const file,
        ns: *mut user_namespace,
        cap: ::std::os::raw::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn ptracer_capable(tsk: *mut task_struct, ns: *mut user_namespace) -> bool_;
}
extern "C" {
    pub fn get_vfs_caps_from_disk(
        mnt_userns: *mut user_namespace,
        dentry: *const dentry,
        cpu_caps: *mut cpu_vfs_cap_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cap_convert_nscap(
        mnt_userns: *mut user_namespace,
        dentry: *mut dentry,
        ivalue: *mut *const ::std::os::raw::c_void,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct semaphore {
    pub lock: raw_spinlock_t,
    pub count: ::std::os::raw::c_uint,
    pub wait_list: list_head,
}
#[test]
fn bindgen_test_layout_semaphore() {
    assert_eq!(
        ::std::mem::size_of::<semaphore>(),
        24usize,
        concat!("Size of: ", stringify!(semaphore))
    );
    assert_eq!(
        ::std::mem::align_of::<semaphore>(),
        8usize,
        concat!("Alignment of ", stringify!(semaphore))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semaphore>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(semaphore),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semaphore>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(semaphore),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<semaphore>())).wait_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(semaphore),
            "::",
            stringify!(wait_list)
        )
    );
}
extern "C" {
    pub fn down(sem: *mut semaphore);
}
extern "C" {
    pub fn down_interruptible(sem: *mut semaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn down_killable(sem: *mut semaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn down_trylock(sem: *mut semaphore) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn down_timeout(
        sem: *mut semaphore,
        jiffies: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn up(sem: *mut semaphore);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct f_owner_ex {
    pub type_: ::std::os::raw::c_int,
    pub pid: __kernel_pid_t,
}
#[test]
fn bindgen_test_layout_f_owner_ex() {
    assert_eq!(
        ::std::mem::size_of::<f_owner_ex>(),
        8usize,
        concat!("Size of: ", stringify!(f_owner_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<f_owner_ex>(),
        4usize,
        concat!("Alignment of ", stringify!(f_owner_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<f_owner_ex>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(f_owner_ex),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<f_owner_ex>())).pid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(f_owner_ex),
            "::",
            stringify!(pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __kernel_off_t,
    pub l_len: __kernel_off_t,
    pub l_pid: __kernel_pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        32usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_whence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_pid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock64 {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __kernel_loff_t,
    pub l_len: __kernel_loff_t,
    pub l_pid: __kernel_pid_t,
}
#[test]
fn bindgen_test_layout_flock64() {
    assert_eq!(
        ::std::mem::size_of::<flock64>(),
        32usize,
        concat!("Size of: ", stringify!(flock64))
    );
    assert_eq!(
        ::std::mem::align_of::<flock64>(),
        8usize,
        concat!("Alignment of ", stringify!(flock64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock64>())).l_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock64>())).l_whence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock64>())).l_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock64>())).l_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock64>())).l_pid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flock64),
            "::",
            stringify!(l_pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct open_how {
    pub flags: __u64,
    pub mode: __u64,
    pub resolve: __u64,
}
#[test]
fn bindgen_test_layout_open_how() {
    assert_eq!(
        ::std::mem::size_of::<open_how>(),
        24usize,
        concat!("Size of: ", stringify!(open_how))
    );
    assert_eq!(
        ::std::mem::align_of::<open_how>(),
        8usize,
        concat!("Alignment of ", stringify!(open_how))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<open_how>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(open_how),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<open_how>())).mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(open_how),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<open_how>())).resolve as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(open_how),
            "::",
            stringify!(resolve)
        )
    );
}
pub const migrate_mode_MIGRATE_ASYNC: migrate_mode = 0;
pub const migrate_mode_MIGRATE_SYNC_LIGHT: migrate_mode = 1;
pub const migrate_mode_MIGRATE_SYNC: migrate_mode = 2;
pub const migrate_mode_MIGRATE_SYNC_NO_COPY: migrate_mode = 3;
pub type migrate_mode = ::std::os::raw::c_uint;
pub const migrate_reason_MR_COMPACTION: migrate_reason = 0;
pub const migrate_reason_MR_MEMORY_FAILURE: migrate_reason = 1;
pub const migrate_reason_MR_MEMORY_HOTPLUG: migrate_reason = 2;
pub const migrate_reason_MR_SYSCALL: migrate_reason = 3;
pub const migrate_reason_MR_MEMPOLICY_MBIND: migrate_reason = 4;
pub const migrate_reason_MR_NUMA_MISPLACED: migrate_reason = 5;
pub const migrate_reason_MR_CONTIG_RANGE: migrate_reason = 6;
pub const migrate_reason_MR_LONGTERM_PIN: migrate_reason = 7;
pub const migrate_reason_MR_DEMOTION: migrate_reason = 8;
pub const migrate_reason_MR_TYPES: migrate_reason = 9;
pub type migrate_reason = ::std::os::raw::c_uint;
extern "C" {
    pub static mut print_fatal_signals: ::std::os::raw::c_int;
}
extern "C" {
    pub fn copy_siginfo_to_user(
        to: *mut siginfo_t,
        from: *const kernel_siginfo_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copy_siginfo_from_user(
        to: *mut kernel_siginfo_t,
        from: *const siginfo_t,
    ) -> ::std::os::raw::c_int;
}
pub const siginfo_layout_SIL_KILL: siginfo_layout = 0;
pub const siginfo_layout_SIL_TIMER: siginfo_layout = 1;
pub const siginfo_layout_SIL_POLL: siginfo_layout = 2;
pub const siginfo_layout_SIL_FAULT: siginfo_layout = 3;
pub const siginfo_layout_SIL_FAULT_TRAPNO: siginfo_layout = 4;
pub const siginfo_layout_SIL_FAULT_MCEERR: siginfo_layout = 5;
pub const siginfo_layout_SIL_FAULT_BNDERR: siginfo_layout = 6;
pub const siginfo_layout_SIL_FAULT_PKUERR: siginfo_layout = 7;
pub const siginfo_layout_SIL_FAULT_PERF_EVENT: siginfo_layout = 8;
pub const siginfo_layout_SIL_CHLD: siginfo_layout = 9;
pub const siginfo_layout_SIL_RT: siginfo_layout = 10;
pub const siginfo_layout_SIL_SYS: siginfo_layout = 11;
pub type siginfo_layout = ::std::os::raw::c_uint;
extern "C" {
    pub fn siginfo_layout(
        sig: ::std::os::raw::c_uint,
        si_code: ::std::os::raw::c_int,
    ) -> siginfo_layout;
}
extern "C" {
    pub fn flush_sigqueue(queue: *mut sigpending);
}
extern "C" {
    pub fn next_signal(pending: *mut sigpending, mask: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_send_sig_info(
        sig: ::std::os::raw::c_int,
        info: *mut kernel_siginfo,
        p: *mut task_struct,
        type_: pid_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn group_send_sig_info(
        sig: ::std::os::raw::c_int,
        info: *mut kernel_siginfo,
        p: *mut task_struct,
        type_: pid_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send_signal_locked(
        sig: ::std::os::raw::c_int,
        info: *mut kernel_siginfo,
        p: *mut task_struct,
        type_: pid_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigprocmask(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_current_blocked(arg1: *mut sigset_t);
}
extern "C" {
    pub fn __set_current_blocked(arg1: *const sigset_t);
}
extern "C" {
    pub static mut show_unhandled_signals: ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_signal(ksig: *mut ksignal) -> bool_;
}
extern "C" {
    pub fn signal_setup_done(
        failed: ::std::os::raw::c_int,
        ksig: *mut ksignal,
        stepping: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit_signals(tsk: *mut task_struct);
}
extern "C" {
    pub fn kernel_sigaction(arg1: ::std::os::raw::c_int, arg2: __sighandler_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kmem_cache {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut sighand_cachep: *mut kmem_cache;
}
extern "C" {
    pub fn unhandled_signal(tsk: *mut task_struct, sig: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn signals_init();
}
extern "C" {
    pub fn restore_altstack(arg1: *const stack_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __save_altstack(
        arg1: *mut stack_t,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack_size_valid(ss_size: size_t) -> bool_;
}
extern "C" {
    pub fn render_sigset_t(
        arg1: *mut seq_file,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut sigset_t,
    );
}
extern "C" {
    pub fn task_set_jobctl_pending(task: *mut task_struct, mask: ::std::os::raw::c_ulong) -> bool_;
}
extern "C" {
    pub fn task_clear_jobctl_trapping(task: *mut task_struct);
}
extern "C" {
    pub fn task_clear_jobctl_pending(task: *mut task_struct, mask: ::std::os::raw::c_ulong);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception_table_entry {
    pub insn: ::std::os::raw::c_int,
    pub fixup: ::std::os::raw::c_int,
    pub data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_exception_table_entry() {
    assert_eq!(
        ::std::mem::size_of::<exception_table_entry>(),
        12usize,
        concat!("Size of: ", stringify!(exception_table_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<exception_table_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(exception_table_entry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception_table_entry>())).insn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_table_entry),
            "::",
            stringify!(insn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception_table_entry>())).fixup as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_table_entry),
            "::",
            stringify!(fixup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception_table_entry>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception_table_entry),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn fixup_exception(
        regs: *mut pt_regs,
        trapnr: ::std::os::raw::c_int,
        error_code: ::std::os::raw::c_ulong,
        fault_addr: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fixup_bug(regs: *mut pt_regs, trapnr: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ex_get_fixup_type(ip: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn early_fixup_exception(regs: *mut pt_regs, trapnr: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ex_handler_msr_mce(regs: *mut pt_regs, wrmsr: bool_);
}
extern "C" {
    pub fn __get_user_1() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __get_user_2() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __get_user_4() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __get_user_8() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __get_user_nocheck_1() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __get_user_nocheck_2() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __get_user_nocheck_4() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __get_user_nocheck_8() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __get_user_bad() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __put_user_bad();
}
extern "C" {
    pub fn __put_user_1();
}
extern "C" {
    pub fn __put_user_2();
}
extern "C" {
    pub fn __put_user_4();
}
extern "C" {
    pub fn __put_user_8();
}
extern "C" {
    pub fn __put_user_nocheck_1();
}
extern "C" {
    pub fn __put_user_nocheck_2();
}
extern "C" {
    pub fn __put_user_nocheck_4();
}
extern "C" {
    pub fn __put_user_nocheck_8();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __large_struct {
    pub buf: [::std::os::raw::c_ulong; 100usize],
}
#[test]
fn bindgen_test_layout___large_struct() {
    assert_eq!(
        ::std::mem::size_of::<__large_struct>(),
        800usize,
        concat!("Size of: ", stringify!(__large_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__large_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__large_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__large_struct>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__large_struct),
            "::",
            stringify!(buf)
        )
    );
}
extern "C" {
    pub fn copy_from_user_nmi(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncpy_from_user(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strnlen_user(
        str_: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn copy_mc_to_kernel(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn copy_mc_to_user(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn copy_user_enhanced_fast_string(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn copy_user_generic_string(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn copy_user_generic_unrolled(
        to: *mut ::std::os::raw::c_void,
        from: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __copy_user_nocache(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
        zerorest: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __copy_user_flushcache(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn memcpy_page_flushcache(
        to: *mut ::std::os::raw::c_char,
        page: *mut page,
        offset: size_t,
        len: size_t,
    );
}
extern "C" {
    pub fn clear_user_original(
        addr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn clear_user_rep_good(
        addr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn clear_user_erms(
        addr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __try_cmpxchg_user_wrong_size();
}
extern "C" {
    pub fn _copy_from_user(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _copy_to_user(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn check_zeroed_user(
        from: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copy_from_kernel_nofault_allowed(
        unsafe_src: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> bool_;
}
extern "C" {
    pub fn copy_to_kernel_nofault(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn copy_from_user_nofault(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn copy_to_user_nofault(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strncpy_from_kernel_nofault(
        dst: *mut ::std::os::raw::c_char,
        unsafe_addr: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strncpy_from_user_nofault(
        dst: *mut ::std::os::raw::c_char,
        unsafe_addr: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strnlen_user_nofault(
        unsafe_addr: *const ::std::os::raw::c_void,
        count: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct css_set {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kernel_clone_args {
    pub flags: u64_,
    pub pidfd: *mut ::std::os::raw::c_int,
    pub child_tid: *mut ::std::os::raw::c_int,
    pub parent_tid: *mut ::std::os::raw::c_int,
    pub exit_signal: ::std::os::raw::c_int,
    pub stack: ::std::os::raw::c_ulong,
    pub stack_size: ::std::os::raw::c_ulong,
    pub tls: ::std::os::raw::c_ulong,
    pub set_tid: *mut pid_t,
    pub set_tid_size: size_t,
    pub cgroup: ::std::os::raw::c_int,
    pub io_thread: ::std::os::raw::c_int,
    pub kthread: ::std::os::raw::c_int,
    pub idle: ::std::os::raw::c_int,
    pub fn_: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub fn_arg: *mut ::std::os::raw::c_void,
    pub cgrp: *mut cgroup,
    pub cset: *mut css_set,
}
#[test]
fn bindgen_test_layout_kernel_clone_args() {
    assert_eq!(
        ::std::mem::size_of::<kernel_clone_args>(),
        128usize,
        concat!("Size of: ", stringify!(kernel_clone_args))
    );
    assert_eq!(
        ::std::mem::align_of::<kernel_clone_args>(),
        8usize,
        concat!("Alignment of ", stringify!(kernel_clone_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).pidfd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(pidfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).child_tid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(child_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).parent_tid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(parent_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).exit_signal as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(exit_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).stack as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).stack_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(stack_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).tls as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(tls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).set_tid as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(set_tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).set_tid_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(set_tid_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).cgroup as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(cgroup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).io_thread as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(io_thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).kthread as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(kthread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).idle as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(idle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).fn_ as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).fn_arg as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(fn_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).cgrp as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(cgrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kernel_clone_args>())).cset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(kernel_clone_args),
            "::",
            stringify!(cset)
        )
    );
}
extern "C" {
    pub static mut tasklist_lock: rwlock_t;
}
extern "C" {
    pub static mut mmlist_lock: spinlock_t;
}
extern "C" {
    pub static mut init_thread_union: thread_union;
}
extern "C" {
    pub static mut init_task: task_struct;
}
extern "C" {
    pub fn lockdep_tasklist_lock_is_held() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn schedule_tail(prev: *mut task_struct);
}
extern "C" {
    pub fn init_idle(idle: *mut task_struct, cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sched_fork(
        clone_flags: ::std::os::raw::c_ulong,
        p: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_cgroup_fork(p: *mut task_struct, kargs: *mut kernel_clone_args);
}
extern "C" {
    pub fn sched_post_fork(p: *mut task_struct);
}
extern "C" {
    pub fn sched_dead(p: *mut task_struct);
}
extern "C" {
    pub fn do_task_dead();
}
extern "C" {
    pub fn make_task_dead(signr: ::std::os::raw::c_int);
}
extern "C" {
    pub fn proc_caches_init();
}
extern "C" {
    pub fn fork_init();
}
extern "C" {
    pub fn release_task(p: *mut task_struct);
}
extern "C" {
    pub fn copy_thread(
        arg1: *mut task_struct,
        arg2: *const kernel_clone_args,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flush_thread();
}
extern "C" {
    pub fn exit_thread(tsk: *mut task_struct);
}
extern "C" {
    pub fn do_group_exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn exit_files(arg1: *mut task_struct);
}
extern "C" {
    pub fn exit_itimers(arg1: *mut task_struct);
}
extern "C" {
    pub fn kernel_clone(kargs: *mut kernel_clone_args) -> pid_t;
}
extern "C" {
    pub fn create_io_thread(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
        node: ::std::os::raw::c_int,
    ) -> *mut task_struct;
}
extern "C" {
    pub fn fork_idle(arg1: ::std::os::raw::c_int) -> *mut task_struct;
}
extern "C" {
    pub fn copy_init_mm() -> *mut mm_struct;
}
extern "C" {
    pub fn kernel_thread(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_ulong,
    ) -> pid_t;
}
extern "C" {
    pub fn user_mode_thread(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_ulong,
    ) -> pid_t;
}
extern "C" {
    pub fn kernel_wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn kernel_wait(pid: pid_t, stat: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn free_task(tsk: *mut task_struct);
}
extern "C" {
    pub fn sched_exec();
}
extern "C" {
    pub fn __put_task_struct(t: *mut task_struct);
}
extern "C" {
    pub fn put_task_struct_rcu_user(task: *mut task_struct);
}
extern "C" {
    pub fn release_thread(dead_task: *mut task_struct);
}
extern "C" {
    pub static mut arch_task_struct_size: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sysctl_args {
    pub name: *mut ::std::os::raw::c_int,
    pub nlen: ::std::os::raw::c_int,
    pub oldval: *mut ::std::os::raw::c_void,
    pub oldlenp: *mut size_t,
    pub newval: *mut ::std::os::raw::c_void,
    pub newlen: size_t,
    pub __unused: [::std::os::raw::c_ulong; 4usize],
}
#[test]
fn bindgen_test_layout___sysctl_args() {
    assert_eq!(
        ::std::mem::size_of::<__sysctl_args>(),
        80usize,
        concat!("Size of: ", stringify!(__sysctl_args))
    );
    assert_eq!(
        ::std::mem::align_of::<__sysctl_args>(),
        8usize,
        concat!("Alignment of ", stringify!(__sysctl_args))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sysctl_args>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sysctl_args),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sysctl_args>())).nlen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sysctl_args),
            "::",
            stringify!(nlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sysctl_args>())).oldval as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sysctl_args),
            "::",
            stringify!(oldval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sysctl_args>())).oldlenp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sysctl_args),
            "::",
            stringify!(oldlenp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sysctl_args>())).newval as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__sysctl_args),
            "::",
            stringify!(newval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sysctl_args>())).newlen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sysctl_args),
            "::",
            stringify!(newlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sysctl_args>())).__unused as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sysctl_args),
            "::",
            stringify!(__unused)
        )
    );
}
pub const CTL_KERN: ::std::os::raw::c_uint = 1;
pub const CTL_VM: ::std::os::raw::c_uint = 2;
pub const CTL_NET: ::std::os::raw::c_uint = 3;
pub const CTL_PROC: ::std::os::raw::c_uint = 4;
pub const CTL_FS: ::std::os::raw::c_uint = 5;
pub const CTL_DEBUG: ::std::os::raw::c_uint = 6;
pub const CTL_DEV: ::std::os::raw::c_uint = 7;
pub const CTL_BUS: ::std::os::raw::c_uint = 8;
pub const CTL_ABI: ::std::os::raw::c_uint = 9;
pub const CTL_CPU: ::std::os::raw::c_uint = 10;
pub const CTL_ARLAN: ::std::os::raw::c_uint = 254;
pub const CTL_S390DBF: ::std::os::raw::c_uint = 5677;
pub const CTL_SUNRPC: ::std::os::raw::c_uint = 7249;
pub const CTL_PM: ::std::os::raw::c_uint = 9899;
pub const CTL_FRV: ::std::os::raw::c_uint = 9898;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const CTL_BUS_ISA: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
pub const INOTIFY_MAX_USER_INSTANCES: ::std::os::raw::c_uint = 1;
pub const INOTIFY_MAX_USER_WATCHES: ::std::os::raw::c_uint = 2;
pub const INOTIFY_MAX_QUEUED_EVENTS: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const KERN_OSTYPE: ::std::os::raw::c_uint = 1;
pub const KERN_OSRELEASE: ::std::os::raw::c_uint = 2;
pub const KERN_OSREV: ::std::os::raw::c_uint = 3;
pub const KERN_VERSION: ::std::os::raw::c_uint = 4;
pub const KERN_SECUREMASK: ::std::os::raw::c_uint = 5;
pub const KERN_PROF: ::std::os::raw::c_uint = 6;
pub const KERN_NODENAME: ::std::os::raw::c_uint = 7;
pub const KERN_DOMAINNAME: ::std::os::raw::c_uint = 8;
pub const KERN_PANIC: ::std::os::raw::c_uint = 15;
pub const KERN_REALROOTDEV: ::std::os::raw::c_uint = 16;
pub const KERN_SPARC_REBOOT: ::std::os::raw::c_uint = 21;
pub const KERN_CTLALTDEL: ::std::os::raw::c_uint = 22;
pub const KERN_PRINTK: ::std::os::raw::c_uint = 23;
pub const KERN_NAMETRANS: ::std::os::raw::c_uint = 24;
pub const KERN_PPC_HTABRECLAIM: ::std::os::raw::c_uint = 25;
pub const KERN_PPC_ZEROPAGED: ::std::os::raw::c_uint = 26;
pub const KERN_PPC_POWERSAVE_NAP: ::std::os::raw::c_uint = 27;
pub const KERN_MODPROBE: ::std::os::raw::c_uint = 28;
pub const KERN_SG_BIG_BUFF: ::std::os::raw::c_uint = 29;
pub const KERN_ACCT: ::std::os::raw::c_uint = 30;
pub const KERN_PPC_L2CR: ::std::os::raw::c_uint = 31;
pub const KERN_RTSIGNR: ::std::os::raw::c_uint = 32;
pub const KERN_RTSIGMAX: ::std::os::raw::c_uint = 33;
pub const KERN_SHMMAX: ::std::os::raw::c_uint = 34;
pub const KERN_MSGMAX: ::std::os::raw::c_uint = 35;
pub const KERN_MSGMNB: ::std::os::raw::c_uint = 36;
pub const KERN_MSGPOOL: ::std::os::raw::c_uint = 37;
pub const KERN_SYSRQ: ::std::os::raw::c_uint = 38;
pub const KERN_MAX_THREADS: ::std::os::raw::c_uint = 39;
pub const KERN_RANDOM: ::std::os::raw::c_uint = 40;
pub const KERN_SHMALL: ::std::os::raw::c_uint = 41;
pub const KERN_MSGMNI: ::std::os::raw::c_uint = 42;
pub const KERN_SEM: ::std::os::raw::c_uint = 43;
pub const KERN_SPARC_STOP_A: ::std::os::raw::c_uint = 44;
pub const KERN_SHMMNI: ::std::os::raw::c_uint = 45;
pub const KERN_OVERFLOWUID: ::std::os::raw::c_uint = 46;
pub const KERN_OVERFLOWGID: ::std::os::raw::c_uint = 47;
pub const KERN_SHMPATH: ::std::os::raw::c_uint = 48;
pub const KERN_HOTPLUG: ::std::os::raw::c_uint = 49;
pub const KERN_IEEE_EMULATION_WARNINGS: ::std::os::raw::c_uint = 50;
pub const KERN_S390_USER_DEBUG_LOGGING: ::std::os::raw::c_uint = 51;
pub const KERN_CORE_USES_PID: ::std::os::raw::c_uint = 52;
pub const KERN_TAINTED: ::std::os::raw::c_uint = 53;
pub const KERN_CADPID: ::std::os::raw::c_uint = 54;
pub const KERN_PIDMAX: ::std::os::raw::c_uint = 55;
pub const KERN_CORE_PATTERN: ::std::os::raw::c_uint = 56;
pub const KERN_PANIC_ON_OOPS: ::std::os::raw::c_uint = 57;
pub const KERN_HPPA_PWRSW: ::std::os::raw::c_uint = 58;
pub const KERN_HPPA_UNALIGNED: ::std::os::raw::c_uint = 59;
pub const KERN_PRINTK_RATELIMIT: ::std::os::raw::c_uint = 60;
pub const KERN_PRINTK_RATELIMIT_BURST: ::std::os::raw::c_uint = 61;
pub const KERN_PTY: ::std::os::raw::c_uint = 62;
pub const KERN_NGROUPS_MAX: ::std::os::raw::c_uint = 63;
pub const KERN_SPARC_SCONS_PWROFF: ::std::os::raw::c_uint = 64;
pub const KERN_HZ_TIMER: ::std::os::raw::c_uint = 65;
pub const KERN_UNKNOWN_NMI_PANIC: ::std::os::raw::c_uint = 66;
pub const KERN_BOOTLOADER_TYPE: ::std::os::raw::c_uint = 67;
pub const KERN_RANDOMIZE: ::std::os::raw::c_uint = 68;
pub const KERN_SETUID_DUMPABLE: ::std::os::raw::c_uint = 69;
pub const KERN_SPIN_RETRY: ::std::os::raw::c_uint = 70;
pub const KERN_ACPI_VIDEO_FLAGS: ::std::os::raw::c_uint = 71;
pub const KERN_IA64_UNALIGNED: ::std::os::raw::c_uint = 72;
pub const KERN_COMPAT_LOG: ::std::os::raw::c_uint = 73;
pub const KERN_MAX_LOCK_DEPTH: ::std::os::raw::c_uint = 74;
pub const KERN_NMI_WATCHDOG: ::std::os::raw::c_uint = 75;
pub const KERN_PANIC_ON_NMI: ::std::os::raw::c_uint = 76;
pub const KERN_PANIC_ON_WARN: ::std::os::raw::c_uint = 77;
pub const KERN_PANIC_PRINT: ::std::os::raw::c_uint = 78;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub const VM_UNUSED1: ::std::os::raw::c_uint = 1;
pub const VM_UNUSED2: ::std::os::raw::c_uint = 2;
pub const VM_UNUSED3: ::std::os::raw::c_uint = 3;
pub const VM_UNUSED4: ::std::os::raw::c_uint = 4;
pub const VM_OVERCOMMIT_MEMORY: ::std::os::raw::c_uint = 5;
pub const VM_UNUSED5: ::std::os::raw::c_uint = 6;
pub const VM_UNUSED7: ::std::os::raw::c_uint = 7;
pub const VM_UNUSED8: ::std::os::raw::c_uint = 8;
pub const VM_UNUSED9: ::std::os::raw::c_uint = 9;
pub const VM_PAGE_CLUSTER: ::std::os::raw::c_uint = 10;
pub const VM_DIRTY_BACKGROUND: ::std::os::raw::c_uint = 11;
pub const VM_DIRTY_RATIO: ::std::os::raw::c_uint = 12;
pub const VM_DIRTY_WB_CS: ::std::os::raw::c_uint = 13;
pub const VM_DIRTY_EXPIRE_CS: ::std::os::raw::c_uint = 14;
pub const VM_NR_PDFLUSH_THREADS: ::std::os::raw::c_uint = 15;
pub const VM_OVERCOMMIT_RATIO: ::std::os::raw::c_uint = 16;
pub const VM_PAGEBUF: ::std::os::raw::c_uint = 17;
pub const VM_HUGETLB_PAGES: ::std::os::raw::c_uint = 18;
pub const VM_SWAPPINESS: ::std::os::raw::c_uint = 19;
pub const VM_LOWMEM_RESERVE_RATIO: ::std::os::raw::c_uint = 20;
pub const VM_MIN_FREE_KBYTES: ::std::os::raw::c_uint = 21;
pub const VM_MAX_MAP_COUNT: ::std::os::raw::c_uint = 22;
pub const VM_LAPTOP_MODE: ::std::os::raw::c_uint = 23;
pub const VM_BLOCK_DUMP: ::std::os::raw::c_uint = 24;
pub const VM_HUGETLB_GROUP: ::std::os::raw::c_uint = 25;
pub const VM_VFS_CACHE_PRESSURE: ::std::os::raw::c_uint = 26;
pub const VM_LEGACY_VA_LAYOUT: ::std::os::raw::c_uint = 27;
pub const VM_SWAP_TOKEN_TIMEOUT: ::std::os::raw::c_uint = 28;
pub const VM_DROP_PAGECACHE: ::std::os::raw::c_uint = 29;
pub const VM_PERCPU_PAGELIST_FRACTION: ::std::os::raw::c_uint = 30;
pub const VM_ZONE_RECLAIM_MODE: ::std::os::raw::c_uint = 31;
pub const VM_MIN_UNMAPPED: ::std::os::raw::c_uint = 32;
pub const VM_PANIC_ON_OOM: ::std::os::raw::c_uint = 33;
pub const VM_VDSO_ENABLED: ::std::os::raw::c_uint = 34;
pub const VM_MIN_SLAB: ::std::os::raw::c_uint = 35;
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
pub const NET_CORE: ::std::os::raw::c_uint = 1;
pub const NET_ETHER: ::std::os::raw::c_uint = 2;
pub const NET_802: ::std::os::raw::c_uint = 3;
pub const NET_UNIX: ::std::os::raw::c_uint = 4;
pub const NET_IPV4: ::std::os::raw::c_uint = 5;
pub const NET_IPX: ::std::os::raw::c_uint = 6;
pub const NET_ATALK: ::std::os::raw::c_uint = 7;
pub const NET_NETROM: ::std::os::raw::c_uint = 8;
pub const NET_AX25: ::std::os::raw::c_uint = 9;
pub const NET_BRIDGE: ::std::os::raw::c_uint = 10;
pub const NET_ROSE: ::std::os::raw::c_uint = 11;
pub const NET_IPV6: ::std::os::raw::c_uint = 12;
pub const NET_X25: ::std::os::raw::c_uint = 13;
pub const NET_TR: ::std::os::raw::c_uint = 14;
pub const NET_DECNET: ::std::os::raw::c_uint = 15;
pub const NET_ECONET: ::std::os::raw::c_uint = 16;
pub const NET_SCTP: ::std::os::raw::c_uint = 17;
pub const NET_LLC: ::std::os::raw::c_uint = 18;
pub const NET_NETFILTER: ::std::os::raw::c_uint = 19;
pub const NET_DCCP: ::std::os::raw::c_uint = 20;
pub const NET_IRDA: ::std::os::raw::c_uint = 412;
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
pub const RANDOM_POOLSIZE: ::std::os::raw::c_uint = 1;
pub const RANDOM_ENTROPY_COUNT: ::std::os::raw::c_uint = 2;
pub const RANDOM_READ_THRESH: ::std::os::raw::c_uint = 3;
pub const RANDOM_WRITE_THRESH: ::std::os::raw::c_uint = 4;
pub const RANDOM_BOOT_ID: ::std::os::raw::c_uint = 5;
pub const RANDOM_UUID: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
pub const PTY_MAX: ::std::os::raw::c_uint = 1;
pub const PTY_NR: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_26 = ::std::os::raw::c_uint;
pub const BUS_ISA_MEM_BASE: ::std::os::raw::c_uint = 1;
pub const BUS_ISA_PORT_BASE: ::std::os::raw::c_uint = 2;
pub const BUS_ISA_PORT_SHIFT: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_27 = ::std::os::raw::c_uint;
pub const NET_CORE_WMEM_MAX: ::std::os::raw::c_uint = 1;
pub const NET_CORE_RMEM_MAX: ::std::os::raw::c_uint = 2;
pub const NET_CORE_WMEM_DEFAULT: ::std::os::raw::c_uint = 3;
pub const NET_CORE_RMEM_DEFAULT: ::std::os::raw::c_uint = 4;
pub const NET_CORE_MAX_BACKLOG: ::std::os::raw::c_uint = 6;
pub const NET_CORE_FASTROUTE: ::std::os::raw::c_uint = 7;
pub const NET_CORE_MSG_COST: ::std::os::raw::c_uint = 8;
pub const NET_CORE_MSG_BURST: ::std::os::raw::c_uint = 9;
pub const NET_CORE_OPTMEM_MAX: ::std::os::raw::c_uint = 10;
pub const NET_CORE_HOT_LIST_LENGTH: ::std::os::raw::c_uint = 11;
pub const NET_CORE_DIVERT_VERSION: ::std::os::raw::c_uint = 12;
pub const NET_CORE_NO_CONG_THRESH: ::std::os::raw::c_uint = 13;
pub const NET_CORE_NO_CONG: ::std::os::raw::c_uint = 14;
pub const NET_CORE_LO_CONG: ::std::os::raw::c_uint = 15;
pub const NET_CORE_MOD_CONG: ::std::os::raw::c_uint = 16;
pub const NET_CORE_DEV_WEIGHT: ::std::os::raw::c_uint = 17;
pub const NET_CORE_SOMAXCONN: ::std::os::raw::c_uint = 18;
pub const NET_CORE_BUDGET: ::std::os::raw::c_uint = 19;
pub const NET_CORE_AEVENT_ETIME: ::std::os::raw::c_uint = 20;
pub const NET_CORE_AEVENT_RSEQTH: ::std::os::raw::c_uint = 21;
pub const NET_CORE_WARNINGS: ::std::os::raw::c_uint = 22;
pub type _bindgen_ty_28 = ::std::os::raw::c_uint;
pub const NET_UNIX_DESTROY_DELAY: ::std::os::raw::c_uint = 1;
pub const NET_UNIX_DELETE_DELAY: ::std::os::raw::c_uint = 2;
pub const NET_UNIX_MAX_DGRAM_QLEN: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_29 = ::std::os::raw::c_uint;
pub const NET_NF_CONNTRACK_MAX: ::std::os::raw::c_uint = 1;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT: ::std::os::raw::c_uint = 2;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV: ::std::os::raw::c_uint = 3;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED: ::std::os::raw::c_uint = 4;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT: ::std::os::raw::c_uint = 5;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT: ::std::os::raw::c_uint = 6;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK: ::std::os::raw::c_uint = 7;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT: ::std::os::raw::c_uint = 8;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE: ::std::os::raw::c_uint = 9;
pub const NET_NF_CONNTRACK_UDP_TIMEOUT: ::std::os::raw::c_uint = 10;
pub const NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM: ::std::os::raw::c_uint = 11;
pub const NET_NF_CONNTRACK_ICMP_TIMEOUT: ::std::os::raw::c_uint = 12;
pub const NET_NF_CONNTRACK_GENERIC_TIMEOUT: ::std::os::raw::c_uint = 13;
pub const NET_NF_CONNTRACK_BUCKETS: ::std::os::raw::c_uint = 14;
pub const NET_NF_CONNTRACK_LOG_INVALID: ::std::os::raw::c_uint = 15;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS: ::std::os::raw::c_uint = 16;
pub const NET_NF_CONNTRACK_TCP_LOOSE: ::std::os::raw::c_uint = 17;
pub const NET_NF_CONNTRACK_TCP_BE_LIBERAL: ::std::os::raw::c_uint = 18;
pub const NET_NF_CONNTRACK_TCP_MAX_RETRANS: ::std::os::raw::c_uint = 19;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED: ::std::os::raw::c_uint = 20;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT: ::std::os::raw::c_uint = 21;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED: ::std::os::raw::c_uint = 22;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED: ::std::os::raw::c_uint = 23;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT: ::std::os::raw::c_uint = 24;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD: ::std::os::raw::c_uint = 25;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT: ::std::os::raw::c_uint = 26;
pub const NET_NF_CONNTRACK_COUNT: ::std::os::raw::c_uint = 27;
pub const NET_NF_CONNTRACK_ICMPV6_TIMEOUT: ::std::os::raw::c_uint = 28;
pub const NET_NF_CONNTRACK_FRAG6_TIMEOUT: ::std::os::raw::c_uint = 29;
pub const NET_NF_CONNTRACK_FRAG6_LOW_THRESH: ::std::os::raw::c_uint = 30;
pub const NET_NF_CONNTRACK_FRAG6_HIGH_THRESH: ::std::os::raw::c_uint = 31;
pub const NET_NF_CONNTRACK_CHECKSUM: ::std::os::raw::c_uint = 32;
pub type _bindgen_ty_30 = ::std::os::raw::c_uint;
pub const NET_IPV4_FORWARD: ::std::os::raw::c_uint = 8;
pub const NET_IPV4_DYNADDR: ::std::os::raw::c_uint = 9;
pub const NET_IPV4_CONF: ::std::os::raw::c_uint = 16;
pub const NET_IPV4_NEIGH: ::std::os::raw::c_uint = 17;
pub const NET_IPV4_ROUTE: ::std::os::raw::c_uint = 18;
pub const NET_IPV4_FIB_HASH: ::std::os::raw::c_uint = 19;
pub const NET_IPV4_NETFILTER: ::std::os::raw::c_uint = 20;
pub const NET_IPV4_TCP_TIMESTAMPS: ::std::os::raw::c_uint = 33;
pub const NET_IPV4_TCP_WINDOW_SCALING: ::std::os::raw::c_uint = 34;
pub const NET_IPV4_TCP_SACK: ::std::os::raw::c_uint = 35;
pub const NET_IPV4_TCP_RETRANS_COLLAPSE: ::std::os::raw::c_uint = 36;
pub const NET_IPV4_DEFAULT_TTL: ::std::os::raw::c_uint = 37;
pub const NET_IPV4_AUTOCONFIG: ::std::os::raw::c_uint = 38;
pub const NET_IPV4_NO_PMTU_DISC: ::std::os::raw::c_uint = 39;
pub const NET_IPV4_TCP_SYN_RETRIES: ::std::os::raw::c_uint = 40;
pub const NET_IPV4_IPFRAG_HIGH_THRESH: ::std::os::raw::c_uint = 41;
pub const NET_IPV4_IPFRAG_LOW_THRESH: ::std::os::raw::c_uint = 42;
pub const NET_IPV4_IPFRAG_TIME: ::std::os::raw::c_uint = 43;
pub const NET_IPV4_TCP_MAX_KA_PROBES: ::std::os::raw::c_uint = 44;
pub const NET_IPV4_TCP_KEEPALIVE_TIME: ::std::os::raw::c_uint = 45;
pub const NET_IPV4_TCP_KEEPALIVE_PROBES: ::std::os::raw::c_uint = 46;
pub const NET_IPV4_TCP_RETRIES1: ::std::os::raw::c_uint = 47;
pub const NET_IPV4_TCP_RETRIES2: ::std::os::raw::c_uint = 48;
pub const NET_IPV4_TCP_FIN_TIMEOUT: ::std::os::raw::c_uint = 49;
pub const NET_IPV4_IP_MASQ_DEBUG: ::std::os::raw::c_uint = 50;
pub const NET_TCP_SYNCOOKIES: ::std::os::raw::c_uint = 51;
pub const NET_TCP_STDURG: ::std::os::raw::c_uint = 52;
pub const NET_TCP_RFC1337: ::std::os::raw::c_uint = 53;
pub const NET_TCP_SYN_TAILDROP: ::std::os::raw::c_uint = 54;
pub const NET_TCP_MAX_SYN_BACKLOG: ::std::os::raw::c_uint = 55;
pub const NET_IPV4_LOCAL_PORT_RANGE: ::std::os::raw::c_uint = 56;
pub const NET_IPV4_ICMP_ECHO_IGNORE_ALL: ::std::os::raw::c_uint = 57;
pub const NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS: ::std::os::raw::c_uint = 58;
pub const NET_IPV4_ICMP_SOURCEQUENCH_RATE: ::std::os::raw::c_uint = 59;
pub const NET_IPV4_ICMP_DESTUNREACH_RATE: ::std::os::raw::c_uint = 60;
pub const NET_IPV4_ICMP_TIMEEXCEED_RATE: ::std::os::raw::c_uint = 61;
pub const NET_IPV4_ICMP_PARAMPROB_RATE: ::std::os::raw::c_uint = 62;
pub const NET_IPV4_ICMP_ECHOREPLY_RATE: ::std::os::raw::c_uint = 63;
pub const NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES: ::std::os::raw::c_uint = 64;
pub const NET_IPV4_IGMP_MAX_MEMBERSHIPS: ::std::os::raw::c_uint = 65;
pub const NET_TCP_TW_RECYCLE: ::std::os::raw::c_uint = 66;
pub const NET_IPV4_ALWAYS_DEFRAG: ::std::os::raw::c_uint = 67;
pub const NET_IPV4_TCP_KEEPALIVE_INTVL: ::std::os::raw::c_uint = 68;
pub const NET_IPV4_INET_PEER_THRESHOLD: ::std::os::raw::c_uint = 69;
pub const NET_IPV4_INET_PEER_MINTTL: ::std::os::raw::c_uint = 70;
pub const NET_IPV4_INET_PEER_MAXTTL: ::std::os::raw::c_uint = 71;
pub const NET_IPV4_INET_PEER_GC_MINTIME: ::std::os::raw::c_uint = 72;
pub const NET_IPV4_INET_PEER_GC_MAXTIME: ::std::os::raw::c_uint = 73;
pub const NET_TCP_ORPHAN_RETRIES: ::std::os::raw::c_uint = 74;
pub const NET_TCP_ABORT_ON_OVERFLOW: ::std::os::raw::c_uint = 75;
pub const NET_TCP_SYNACK_RETRIES: ::std::os::raw::c_uint = 76;
pub const NET_TCP_MAX_ORPHANS: ::std::os::raw::c_uint = 77;
pub const NET_TCP_MAX_TW_BUCKETS: ::std::os::raw::c_uint = 78;
pub const NET_TCP_FACK: ::std::os::raw::c_uint = 79;
pub const NET_TCP_REORDERING: ::std::os::raw::c_uint = 80;
pub const NET_TCP_ECN: ::std::os::raw::c_uint = 81;
pub const NET_TCP_DSACK: ::std::os::raw::c_uint = 82;
pub const NET_TCP_MEM: ::std::os::raw::c_uint = 83;
pub const NET_TCP_WMEM: ::std::os::raw::c_uint = 84;
pub const NET_TCP_RMEM: ::std::os::raw::c_uint = 85;
pub const NET_TCP_APP_WIN: ::std::os::raw::c_uint = 86;
pub const NET_TCP_ADV_WIN_SCALE: ::std::os::raw::c_uint = 87;
pub const NET_IPV4_NONLOCAL_BIND: ::std::os::raw::c_uint = 88;
pub const NET_IPV4_ICMP_RATELIMIT: ::std::os::raw::c_uint = 89;
pub const NET_IPV4_ICMP_RATEMASK: ::std::os::raw::c_uint = 90;
pub const NET_TCP_TW_REUSE: ::std::os::raw::c_uint = 91;
pub const NET_TCP_FRTO: ::std::os::raw::c_uint = 92;
pub const NET_TCP_LOW_LATENCY: ::std::os::raw::c_uint = 93;
pub const NET_IPV4_IPFRAG_SECRET_INTERVAL: ::std::os::raw::c_uint = 94;
pub const NET_IPV4_IGMP_MAX_MSF: ::std::os::raw::c_uint = 96;
pub const NET_TCP_NO_METRICS_SAVE: ::std::os::raw::c_uint = 97;
pub const NET_TCP_DEFAULT_WIN_SCALE: ::std::os::raw::c_uint = 105;
pub const NET_TCP_MODERATE_RCVBUF: ::std::os::raw::c_uint = 106;
pub const NET_TCP_TSO_WIN_DIVISOR: ::std::os::raw::c_uint = 107;
pub const NET_TCP_BIC_BETA: ::std::os::raw::c_uint = 108;
pub const NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR: ::std::os::raw::c_uint = 109;
pub const NET_TCP_CONG_CONTROL: ::std::os::raw::c_uint = 110;
pub const NET_TCP_ABC: ::std::os::raw::c_uint = 111;
pub const NET_IPV4_IPFRAG_MAX_DIST: ::std::os::raw::c_uint = 112;
pub const NET_TCP_MTU_PROBING: ::std::os::raw::c_uint = 113;
pub const NET_TCP_BASE_MSS: ::std::os::raw::c_uint = 114;
pub const NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS: ::std::os::raw::c_uint = 115;
pub const NET_TCP_DMA_COPYBREAK: ::std::os::raw::c_uint = 116;
pub const NET_TCP_SLOW_START_AFTER_IDLE: ::std::os::raw::c_uint = 117;
pub const NET_CIPSOV4_CACHE_ENABLE: ::std::os::raw::c_uint = 118;
pub const NET_CIPSOV4_CACHE_BUCKET_SIZE: ::std::os::raw::c_uint = 119;
pub const NET_CIPSOV4_RBM_OPTFMT: ::std::os::raw::c_uint = 120;
pub const NET_CIPSOV4_RBM_STRICTVALID: ::std::os::raw::c_uint = 121;
pub const NET_TCP_AVAIL_CONG_CONTROL: ::std::os::raw::c_uint = 122;
pub const NET_TCP_ALLOWED_CONG_CONTROL: ::std::os::raw::c_uint = 123;
pub const NET_TCP_MAX_SSTHRESH: ::std::os::raw::c_uint = 124;
pub const NET_TCP_FRTO_RESPONSE: ::std::os::raw::c_uint = 125;
pub type _bindgen_ty_31 = ::std::os::raw::c_uint;
pub const NET_IPV4_ROUTE_FLUSH: ::std::os::raw::c_uint = 1;
pub const NET_IPV4_ROUTE_MIN_DELAY: ::std::os::raw::c_uint = 2;
pub const NET_IPV4_ROUTE_MAX_DELAY: ::std::os::raw::c_uint = 3;
pub const NET_IPV4_ROUTE_GC_THRESH: ::std::os::raw::c_uint = 4;
pub const NET_IPV4_ROUTE_MAX_SIZE: ::std::os::raw::c_uint = 5;
pub const NET_IPV4_ROUTE_GC_MIN_INTERVAL: ::std::os::raw::c_uint = 6;
pub const NET_IPV4_ROUTE_GC_TIMEOUT: ::std::os::raw::c_uint = 7;
pub const NET_IPV4_ROUTE_GC_INTERVAL: ::std::os::raw::c_uint = 8;
pub const NET_IPV4_ROUTE_REDIRECT_LOAD: ::std::os::raw::c_uint = 9;
pub const NET_IPV4_ROUTE_REDIRECT_NUMBER: ::std::os::raw::c_uint = 10;
pub const NET_IPV4_ROUTE_REDIRECT_SILENCE: ::std::os::raw::c_uint = 11;
pub const NET_IPV4_ROUTE_ERROR_COST: ::std::os::raw::c_uint = 12;
pub const NET_IPV4_ROUTE_ERROR_BURST: ::std::os::raw::c_uint = 13;
pub const NET_IPV4_ROUTE_GC_ELASTICITY: ::std::os::raw::c_uint = 14;
pub const NET_IPV4_ROUTE_MTU_EXPIRES: ::std::os::raw::c_uint = 15;
pub const NET_IPV4_ROUTE_MIN_PMTU: ::std::os::raw::c_uint = 16;
pub const NET_IPV4_ROUTE_MIN_ADVMSS: ::std::os::raw::c_uint = 17;
pub const NET_IPV4_ROUTE_SECRET_INTERVAL: ::std::os::raw::c_uint = 18;
pub const NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS: ::std::os::raw::c_uint = 19;
pub type _bindgen_ty_32 = ::std::os::raw::c_uint;
pub const NET_PROTO_CONF_ALL: ::std::os::raw::c_int = -2;
pub const NET_PROTO_CONF_DEFAULT: ::std::os::raw::c_int = -3;
pub type _bindgen_ty_33 = ::std::os::raw::c_int;
pub const NET_IPV4_CONF_FORWARDING: ::std::os::raw::c_uint = 1;
pub const NET_IPV4_CONF_MC_FORWARDING: ::std::os::raw::c_uint = 2;
pub const NET_IPV4_CONF_PROXY_ARP: ::std::os::raw::c_uint = 3;
pub const NET_IPV4_CONF_ACCEPT_REDIRECTS: ::std::os::raw::c_uint = 4;
pub const NET_IPV4_CONF_SECURE_REDIRECTS: ::std::os::raw::c_uint = 5;
pub const NET_IPV4_CONF_SEND_REDIRECTS: ::std::os::raw::c_uint = 6;
pub const NET_IPV4_CONF_SHARED_MEDIA: ::std::os::raw::c_uint = 7;
pub const NET_IPV4_CONF_RP_FILTER: ::std::os::raw::c_uint = 8;
pub const NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE: ::std::os::raw::c_uint = 9;
pub const NET_IPV4_CONF_BOOTP_RELAY: ::std::os::raw::c_uint = 10;
pub const NET_IPV4_CONF_LOG_MARTIANS: ::std::os::raw::c_uint = 11;
pub const NET_IPV4_CONF_TAG: ::std::os::raw::c_uint = 12;
pub const NET_IPV4_CONF_ARPFILTER: ::std::os::raw::c_uint = 13;
pub const NET_IPV4_CONF_MEDIUM_ID: ::std::os::raw::c_uint = 14;
pub const NET_IPV4_CONF_NOXFRM: ::std::os::raw::c_uint = 15;
pub const NET_IPV4_CONF_NOPOLICY: ::std::os::raw::c_uint = 16;
pub const NET_IPV4_CONF_FORCE_IGMP_VERSION: ::std::os::raw::c_uint = 17;
pub const NET_IPV4_CONF_ARP_ANNOUNCE: ::std::os::raw::c_uint = 18;
pub const NET_IPV4_CONF_ARP_IGNORE: ::std::os::raw::c_uint = 19;
pub const NET_IPV4_CONF_PROMOTE_SECONDARIES: ::std::os::raw::c_uint = 20;
pub const NET_IPV4_CONF_ARP_ACCEPT: ::std::os::raw::c_uint = 21;
pub const NET_IPV4_CONF_ARP_NOTIFY: ::std::os::raw::c_uint = 22;
pub const NET_IPV4_CONF_ARP_EVICT_NOCARRIER: ::std::os::raw::c_uint = 23;
pub type _bindgen_ty_34 = ::std::os::raw::c_uint;
pub const NET_IPV4_NF_CONNTRACK_MAX: ::std::os::raw::c_uint = 1;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT: ::std::os::raw::c_uint = 2;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV: ::std::os::raw::c_uint = 3;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED: ::std::os::raw::c_uint = 4;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT: ::std::os::raw::c_uint = 5;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT: ::std::os::raw::c_uint = 6;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK: ::std::os::raw::c_uint = 7;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT: ::std::os::raw::c_uint = 8;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE: ::std::os::raw::c_uint = 9;
pub const NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT: ::std::os::raw::c_uint = 10;
pub const NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM: ::std::os::raw::c_uint = 11;
pub const NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT: ::std::os::raw::c_uint = 12;
pub const NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT: ::std::os::raw::c_uint = 13;
pub const NET_IPV4_NF_CONNTRACK_BUCKETS: ::std::os::raw::c_uint = 14;
pub const NET_IPV4_NF_CONNTRACK_LOG_INVALID: ::std::os::raw::c_uint = 15;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS: ::std::os::raw::c_uint = 16;
pub const NET_IPV4_NF_CONNTRACK_TCP_LOOSE: ::std::os::raw::c_uint = 17;
pub const NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL: ::std::os::raw::c_uint = 18;
pub const NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS: ::std::os::raw::c_uint = 19;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED: ::std::os::raw::c_uint = 20;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT: ::std::os::raw::c_uint = 21;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED: ::std::os::raw::c_uint = 22;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED: ::std::os::raw::c_uint = 23;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT: ::std::os::raw::c_uint = 24;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD: ::std::os::raw::c_uint = 25;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT: ::std::os::raw::c_uint = 26;
pub const NET_IPV4_NF_CONNTRACK_COUNT: ::std::os::raw::c_uint = 27;
pub const NET_IPV4_NF_CONNTRACK_CHECKSUM: ::std::os::raw::c_uint = 28;
pub type _bindgen_ty_35 = ::std::os::raw::c_uint;
pub const NET_IPV6_CONF: ::std::os::raw::c_uint = 16;
pub const NET_IPV6_NEIGH: ::std::os::raw::c_uint = 17;
pub const NET_IPV6_ROUTE: ::std::os::raw::c_uint = 18;
pub const NET_IPV6_ICMP: ::std::os::raw::c_uint = 19;
pub const NET_IPV6_BINDV6ONLY: ::std::os::raw::c_uint = 20;
pub const NET_IPV6_IP6FRAG_HIGH_THRESH: ::std::os::raw::c_uint = 21;
pub const NET_IPV6_IP6FRAG_LOW_THRESH: ::std::os::raw::c_uint = 22;
pub const NET_IPV6_IP6FRAG_TIME: ::std::os::raw::c_uint = 23;
pub const NET_IPV6_IP6FRAG_SECRET_INTERVAL: ::std::os::raw::c_uint = 24;
pub const NET_IPV6_MLD_MAX_MSF: ::std::os::raw::c_uint = 25;
pub type _bindgen_ty_36 = ::std::os::raw::c_uint;
pub const NET_IPV6_ROUTE_FLUSH: ::std::os::raw::c_uint = 1;
pub const NET_IPV6_ROUTE_GC_THRESH: ::std::os::raw::c_uint = 2;
pub const NET_IPV6_ROUTE_MAX_SIZE: ::std::os::raw::c_uint = 3;
pub const NET_IPV6_ROUTE_GC_MIN_INTERVAL: ::std::os::raw::c_uint = 4;
pub const NET_IPV6_ROUTE_GC_TIMEOUT: ::std::os::raw::c_uint = 5;
pub const NET_IPV6_ROUTE_GC_INTERVAL: ::std::os::raw::c_uint = 6;
pub const NET_IPV6_ROUTE_GC_ELASTICITY: ::std::os::raw::c_uint = 7;
pub const NET_IPV6_ROUTE_MTU_EXPIRES: ::std::os::raw::c_uint = 8;
pub const NET_IPV6_ROUTE_MIN_ADVMSS: ::std::os::raw::c_uint = 9;
pub const NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS: ::std::os::raw::c_uint = 10;
pub type _bindgen_ty_37 = ::std::os::raw::c_uint;
pub const NET_IPV6_FORWARDING: ::std::os::raw::c_uint = 1;
pub const NET_IPV6_HOP_LIMIT: ::std::os::raw::c_uint = 2;
pub const NET_IPV6_MTU: ::std::os::raw::c_uint = 3;
pub const NET_IPV6_ACCEPT_RA: ::std::os::raw::c_uint = 4;
pub const NET_IPV6_ACCEPT_REDIRECTS: ::std::os::raw::c_uint = 5;
pub const NET_IPV6_AUTOCONF: ::std::os::raw::c_uint = 6;
pub const NET_IPV6_DAD_TRANSMITS: ::std::os::raw::c_uint = 7;
pub const NET_IPV6_RTR_SOLICITS: ::std::os::raw::c_uint = 8;
pub const NET_IPV6_RTR_SOLICIT_INTERVAL: ::std::os::raw::c_uint = 9;
pub const NET_IPV6_RTR_SOLICIT_DELAY: ::std::os::raw::c_uint = 10;
pub const NET_IPV6_USE_TEMPADDR: ::std::os::raw::c_uint = 11;
pub const NET_IPV6_TEMP_VALID_LFT: ::std::os::raw::c_uint = 12;
pub const NET_IPV6_TEMP_PREFERED_LFT: ::std::os::raw::c_uint = 13;
pub const NET_IPV6_REGEN_MAX_RETRY: ::std::os::raw::c_uint = 14;
pub const NET_IPV6_MAX_DESYNC_FACTOR: ::std::os::raw::c_uint = 15;
pub const NET_IPV6_MAX_ADDRESSES: ::std::os::raw::c_uint = 16;
pub const NET_IPV6_FORCE_MLD_VERSION: ::std::os::raw::c_uint = 17;
pub const NET_IPV6_ACCEPT_RA_DEFRTR: ::std::os::raw::c_uint = 18;
pub const NET_IPV6_ACCEPT_RA_PINFO: ::std::os::raw::c_uint = 19;
pub const NET_IPV6_ACCEPT_RA_RTR_PREF: ::std::os::raw::c_uint = 20;
pub const NET_IPV6_RTR_PROBE_INTERVAL: ::std::os::raw::c_uint = 21;
pub const NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN: ::std::os::raw::c_uint = 22;
pub const NET_IPV6_PROXY_NDP: ::std::os::raw::c_uint = 23;
pub const NET_IPV6_ACCEPT_SOURCE_ROUTE: ::std::os::raw::c_uint = 25;
pub const NET_IPV6_ACCEPT_RA_FROM_LOCAL: ::std::os::raw::c_uint = 26;
pub const NET_IPV6_ACCEPT_RA_RT_INFO_MIN_PLEN: ::std::os::raw::c_uint = 27;
pub const NET_IPV6_RA_DEFRTR_METRIC: ::std::os::raw::c_uint = 28;
pub const __NET_IPV6_MAX: ::std::os::raw::c_uint = 29;
pub type _bindgen_ty_38 = ::std::os::raw::c_uint;
pub const NET_IPV6_ICMP_RATELIMIT: ::std::os::raw::c_uint = 1;
pub const NET_IPV6_ICMP_ECHO_IGNORE_ALL: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_39 = ::std::os::raw::c_uint;
pub const NET_NEIGH_MCAST_SOLICIT: ::std::os::raw::c_uint = 1;
pub const NET_NEIGH_UCAST_SOLICIT: ::std::os::raw::c_uint = 2;
pub const NET_NEIGH_APP_SOLICIT: ::std::os::raw::c_uint = 3;
pub const NET_NEIGH_RETRANS_TIME: ::std::os::raw::c_uint = 4;
pub const NET_NEIGH_REACHABLE_TIME: ::std::os::raw::c_uint = 5;
pub const NET_NEIGH_DELAY_PROBE_TIME: ::std::os::raw::c_uint = 6;
pub const NET_NEIGH_GC_STALE_TIME: ::std::os::raw::c_uint = 7;
pub const NET_NEIGH_UNRES_QLEN: ::std::os::raw::c_uint = 8;
pub const NET_NEIGH_PROXY_QLEN: ::std::os::raw::c_uint = 9;
pub const NET_NEIGH_ANYCAST_DELAY: ::std::os::raw::c_uint = 10;
pub const NET_NEIGH_PROXY_DELAY: ::std::os::raw::c_uint = 11;
pub const NET_NEIGH_LOCKTIME: ::std::os::raw::c_uint = 12;
pub const NET_NEIGH_GC_INTERVAL: ::std::os::raw::c_uint = 13;
pub const NET_NEIGH_GC_THRESH1: ::std::os::raw::c_uint = 14;
pub const NET_NEIGH_GC_THRESH2: ::std::os::raw::c_uint = 15;
pub const NET_NEIGH_GC_THRESH3: ::std::os::raw::c_uint = 16;
pub const NET_NEIGH_RETRANS_TIME_MS: ::std::os::raw::c_uint = 17;
pub const NET_NEIGH_REACHABLE_TIME_MS: ::std::os::raw::c_uint = 18;
pub const NET_NEIGH_INTERVAL_PROBE_TIME_MS: ::std::os::raw::c_uint = 19;
pub type _bindgen_ty_40 = ::std::os::raw::c_uint;
pub const NET_DCCP_DEFAULT: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_41 = ::std::os::raw::c_uint;
pub const NET_IPX_PPROP_BROADCASTING: ::std::os::raw::c_uint = 1;
pub const NET_IPX_FORWARDING: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_42 = ::std::os::raw::c_uint;
pub const NET_LLC2: ::std::os::raw::c_uint = 1;
pub const NET_LLC_STATION: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
pub const NET_LLC2_TIMEOUT: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
pub const NET_LLC_STATION_ACK_TIMEOUT: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
pub const NET_LLC2_ACK_TIMEOUT: ::std::os::raw::c_uint = 1;
pub const NET_LLC2_P_TIMEOUT: ::std::os::raw::c_uint = 2;
pub const NET_LLC2_REJ_TIMEOUT: ::std::os::raw::c_uint = 3;
pub const NET_LLC2_BUSY_TIMEOUT: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
pub const NET_ATALK_AARP_EXPIRY_TIME: ::std::os::raw::c_uint = 1;
pub const NET_ATALK_AARP_TICK_TIME: ::std::os::raw::c_uint = 2;
pub const NET_ATALK_AARP_RETRANSMIT_LIMIT: ::std::os::raw::c_uint = 3;
pub const NET_ATALK_AARP_RESOLVE_TIME: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_47 = ::std::os::raw::c_uint;
pub const NET_NETROM_DEFAULT_PATH_QUALITY: ::std::os::raw::c_uint = 1;
pub const NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER: ::std::os::raw::c_uint = 2;
pub const NET_NETROM_NETWORK_TTL_INITIALISER: ::std::os::raw::c_uint = 3;
pub const NET_NETROM_TRANSPORT_TIMEOUT: ::std::os::raw::c_uint = 4;
pub const NET_NETROM_TRANSPORT_MAXIMUM_TRIES: ::std::os::raw::c_uint = 5;
pub const NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY: ::std::os::raw::c_uint = 6;
pub const NET_NETROM_TRANSPORT_BUSY_DELAY: ::std::os::raw::c_uint = 7;
pub const NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE: ::std::os::raw::c_uint = 8;
pub const NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT: ::std::os::raw::c_uint = 9;
pub const NET_NETROM_ROUTING_CONTROL: ::std::os::raw::c_uint = 10;
pub const NET_NETROM_LINK_FAILS_COUNT: ::std::os::raw::c_uint = 11;
pub const NET_NETROM_RESET: ::std::os::raw::c_uint = 12;
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
pub const NET_AX25_IP_DEFAULT_MODE: ::std::os::raw::c_uint = 1;
pub const NET_AX25_DEFAULT_MODE: ::std::os::raw::c_uint = 2;
pub const NET_AX25_BACKOFF_TYPE: ::std::os::raw::c_uint = 3;
pub const NET_AX25_CONNECT_MODE: ::std::os::raw::c_uint = 4;
pub const NET_AX25_STANDARD_WINDOW: ::std::os::raw::c_uint = 5;
pub const NET_AX25_EXTENDED_WINDOW: ::std::os::raw::c_uint = 6;
pub const NET_AX25_T1_TIMEOUT: ::std::os::raw::c_uint = 7;
pub const NET_AX25_T2_TIMEOUT: ::std::os::raw::c_uint = 8;
pub const NET_AX25_T3_TIMEOUT: ::std::os::raw::c_uint = 9;
pub const NET_AX25_IDLE_TIMEOUT: ::std::os::raw::c_uint = 10;
pub const NET_AX25_N2: ::std::os::raw::c_uint = 11;
pub const NET_AX25_PACLEN: ::std::os::raw::c_uint = 12;
pub const NET_AX25_PROTOCOL: ::std::os::raw::c_uint = 13;
pub const NET_AX25_DAMA_SLAVE_TIMEOUT: ::std::os::raw::c_uint = 14;
pub type _bindgen_ty_49 = ::std::os::raw::c_uint;
pub const NET_ROSE_RESTART_REQUEST_TIMEOUT: ::std::os::raw::c_uint = 1;
pub const NET_ROSE_CALL_REQUEST_TIMEOUT: ::std::os::raw::c_uint = 2;
pub const NET_ROSE_RESET_REQUEST_TIMEOUT: ::std::os::raw::c_uint = 3;
pub const NET_ROSE_CLEAR_REQUEST_TIMEOUT: ::std::os::raw::c_uint = 4;
pub const NET_ROSE_ACK_HOLD_BACK_TIMEOUT: ::std::os::raw::c_uint = 5;
pub const NET_ROSE_ROUTING_CONTROL: ::std::os::raw::c_uint = 6;
pub const NET_ROSE_LINK_FAIL_TIMEOUT: ::std::os::raw::c_uint = 7;
pub const NET_ROSE_MAX_VCS: ::std::os::raw::c_uint = 8;
pub const NET_ROSE_WINDOW_SIZE: ::std::os::raw::c_uint = 9;
pub const NET_ROSE_NO_ACTIVITY_TIMEOUT: ::std::os::raw::c_uint = 10;
pub type _bindgen_ty_50 = ::std::os::raw::c_uint;
pub const NET_X25_RESTART_REQUEST_TIMEOUT: ::std::os::raw::c_uint = 1;
pub const NET_X25_CALL_REQUEST_TIMEOUT: ::std::os::raw::c_uint = 2;
pub const NET_X25_RESET_REQUEST_TIMEOUT: ::std::os::raw::c_uint = 3;
pub const NET_X25_CLEAR_REQUEST_TIMEOUT: ::std::os::raw::c_uint = 4;
pub const NET_X25_ACK_HOLD_BACK_TIMEOUT: ::std::os::raw::c_uint = 5;
pub const NET_X25_FORWARD: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_51 = ::std::os::raw::c_uint;
pub const NET_TR_RIF_TIMEOUT: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_52 = ::std::os::raw::c_uint;
pub const NET_DECNET_NODE_TYPE: ::std::os::raw::c_uint = 1;
pub const NET_DECNET_NODE_ADDRESS: ::std::os::raw::c_uint = 2;
pub const NET_DECNET_NODE_NAME: ::std::os::raw::c_uint = 3;
pub const NET_DECNET_DEFAULT_DEVICE: ::std::os::raw::c_uint = 4;
pub const NET_DECNET_TIME_WAIT: ::std::os::raw::c_uint = 5;
pub const NET_DECNET_DN_COUNT: ::std::os::raw::c_uint = 6;
pub const NET_DECNET_DI_COUNT: ::std::os::raw::c_uint = 7;
pub const NET_DECNET_DR_COUNT: ::std::os::raw::c_uint = 8;
pub const NET_DECNET_DST_GC_INTERVAL: ::std::os::raw::c_uint = 9;
pub const NET_DECNET_CONF: ::std::os::raw::c_uint = 10;
pub const NET_DECNET_NO_FC_MAX_CWND: ::std::os::raw::c_uint = 11;
pub const NET_DECNET_MEM: ::std::os::raw::c_uint = 12;
pub const NET_DECNET_RMEM: ::std::os::raw::c_uint = 13;
pub const NET_DECNET_WMEM: ::std::os::raw::c_uint = 14;
pub const NET_DECNET_DEBUG_LEVEL: ::std::os::raw::c_uint = 255;
pub type _bindgen_ty_53 = ::std::os::raw::c_uint;
pub const NET_DECNET_CONF_LOOPBACK: ::std::os::raw::c_int = -2;
pub const NET_DECNET_CONF_DDCMP: ::std::os::raw::c_int = -3;
pub const NET_DECNET_CONF_PPP: ::std::os::raw::c_int = -4;
pub const NET_DECNET_CONF_X25: ::std::os::raw::c_int = -5;
pub const NET_DECNET_CONF_GRE: ::std::os::raw::c_int = -6;
pub const NET_DECNET_CONF_ETHER: ::std::os::raw::c_int = -7;
pub type _bindgen_ty_54 = ::std::os::raw::c_int;
pub const NET_DECNET_CONF_DEV_PRIORITY: ::std::os::raw::c_uint = 1;
pub const NET_DECNET_CONF_DEV_T1: ::std::os::raw::c_uint = 2;
pub const NET_DECNET_CONF_DEV_T2: ::std::os::raw::c_uint = 3;
pub const NET_DECNET_CONF_DEV_T3: ::std::os::raw::c_uint = 4;
pub const NET_DECNET_CONF_DEV_FORWARDING: ::std::os::raw::c_uint = 5;
pub const NET_DECNET_CONF_DEV_BLKSIZE: ::std::os::raw::c_uint = 6;
pub const NET_DECNET_CONF_DEV_STATE: ::std::os::raw::c_uint = 7;
pub type _bindgen_ty_55 = ::std::os::raw::c_uint;
pub const NET_SCTP_RTO_INITIAL: ::std::os::raw::c_uint = 1;
pub const NET_SCTP_RTO_MIN: ::std::os::raw::c_uint = 2;
pub const NET_SCTP_RTO_MAX: ::std::os::raw::c_uint = 3;
pub const NET_SCTP_RTO_ALPHA: ::std::os::raw::c_uint = 4;
pub const NET_SCTP_RTO_BETA: ::std::os::raw::c_uint = 5;
pub const NET_SCTP_VALID_COOKIE_LIFE: ::std::os::raw::c_uint = 6;
pub const NET_SCTP_ASSOCIATION_MAX_RETRANS: ::std::os::raw::c_uint = 7;
pub const NET_SCTP_PATH_MAX_RETRANS: ::std::os::raw::c_uint = 8;
pub const NET_SCTP_MAX_INIT_RETRANSMITS: ::std::os::raw::c_uint = 9;
pub const NET_SCTP_HB_INTERVAL: ::std::os::raw::c_uint = 10;
pub const NET_SCTP_PRESERVE_ENABLE: ::std::os::raw::c_uint = 11;
pub const NET_SCTP_MAX_BURST: ::std::os::raw::c_uint = 12;
pub const NET_SCTP_ADDIP_ENABLE: ::std::os::raw::c_uint = 13;
pub const NET_SCTP_PRSCTP_ENABLE: ::std::os::raw::c_uint = 14;
pub const NET_SCTP_SNDBUF_POLICY: ::std::os::raw::c_uint = 15;
pub const NET_SCTP_SACK_TIMEOUT: ::std::os::raw::c_uint = 16;
pub const NET_SCTP_RCVBUF_POLICY: ::std::os::raw::c_uint = 17;
pub type _bindgen_ty_56 = ::std::os::raw::c_uint;
pub const NET_BRIDGE_NF_CALL_ARPTABLES: ::std::os::raw::c_uint = 1;
pub const NET_BRIDGE_NF_CALL_IPTABLES: ::std::os::raw::c_uint = 2;
pub const NET_BRIDGE_NF_CALL_IP6TABLES: ::std::os::raw::c_uint = 3;
pub const NET_BRIDGE_NF_FILTER_VLAN_TAGGED: ::std::os::raw::c_uint = 4;
pub const NET_BRIDGE_NF_FILTER_PPPOE_TAGGED: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_57 = ::std::os::raw::c_uint;
pub const FS_NRINODE: ::std::os::raw::c_uint = 1;
pub const FS_STATINODE: ::std::os::raw::c_uint = 2;
pub const FS_MAXINODE: ::std::os::raw::c_uint = 3;
pub const FS_NRDQUOT: ::std::os::raw::c_uint = 4;
pub const FS_MAXDQUOT: ::std::os::raw::c_uint = 5;
pub const FS_NRFILE: ::std::os::raw::c_uint = 6;
pub const FS_MAXFILE: ::std::os::raw::c_uint = 7;
pub const FS_DENTRY: ::std::os::raw::c_uint = 8;
pub const FS_NRSUPER: ::std::os::raw::c_uint = 9;
pub const FS_MAXSUPER: ::std::os::raw::c_uint = 10;
pub const FS_OVERFLOWUID: ::std::os::raw::c_uint = 11;
pub const FS_OVERFLOWGID: ::std::os::raw::c_uint = 12;
pub const FS_LEASES: ::std::os::raw::c_uint = 13;
pub const FS_DIR_NOTIFY: ::std::os::raw::c_uint = 14;
pub const FS_LEASE_TIME: ::std::os::raw::c_uint = 15;
pub const FS_DQSTATS: ::std::os::raw::c_uint = 16;
pub const FS_XFS: ::std::os::raw::c_uint = 17;
pub const FS_AIO_NR: ::std::os::raw::c_uint = 18;
pub const FS_AIO_MAX_NR: ::std::os::raw::c_uint = 19;
pub const FS_INOTIFY: ::std::os::raw::c_uint = 20;
pub const FS_OCFS2: ::std::os::raw::c_uint = 988;
pub type _bindgen_ty_58 = ::std::os::raw::c_uint;
pub const FS_DQ_LOOKUPS: ::std::os::raw::c_uint = 1;
pub const FS_DQ_DROPS: ::std::os::raw::c_uint = 2;
pub const FS_DQ_READS: ::std::os::raw::c_uint = 3;
pub const FS_DQ_WRITES: ::std::os::raw::c_uint = 4;
pub const FS_DQ_CACHE_HITS: ::std::os::raw::c_uint = 5;
pub const FS_DQ_ALLOCATED: ::std::os::raw::c_uint = 6;
pub const FS_DQ_FREE: ::std::os::raw::c_uint = 7;
pub const FS_DQ_SYNCS: ::std::os::raw::c_uint = 8;
pub const FS_DQ_WARNINGS: ::std::os::raw::c_uint = 9;
pub type _bindgen_ty_59 = ::std::os::raw::c_uint;
pub const DEV_CDROM: ::std::os::raw::c_uint = 1;
pub const DEV_HWMON: ::std::os::raw::c_uint = 2;
pub const DEV_PARPORT: ::std::os::raw::c_uint = 3;
pub const DEV_RAID: ::std::os::raw::c_uint = 4;
pub const DEV_MAC_HID: ::std::os::raw::c_uint = 5;
pub const DEV_SCSI: ::std::os::raw::c_uint = 6;
pub const DEV_IPMI: ::std::os::raw::c_uint = 7;
pub type _bindgen_ty_60 = ::std::os::raw::c_uint;
pub const DEV_CDROM_INFO: ::std::os::raw::c_uint = 1;
pub const DEV_CDROM_AUTOCLOSE: ::std::os::raw::c_uint = 2;
pub const DEV_CDROM_AUTOEJECT: ::std::os::raw::c_uint = 3;
pub const DEV_CDROM_DEBUG: ::std::os::raw::c_uint = 4;
pub const DEV_CDROM_LOCK: ::std::os::raw::c_uint = 5;
pub const DEV_CDROM_CHECK_MEDIA: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_61 = ::std::os::raw::c_uint;
pub const DEV_PARPORT_DEFAULT: ::std::os::raw::c_int = -3;
pub type _bindgen_ty_62 = ::std::os::raw::c_int;
pub const DEV_RAID_SPEED_LIMIT_MIN: ::std::os::raw::c_uint = 1;
pub const DEV_RAID_SPEED_LIMIT_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_63 = ::std::os::raw::c_uint;
pub const DEV_PARPORT_DEFAULT_TIMESLICE: ::std::os::raw::c_uint = 1;
pub const DEV_PARPORT_DEFAULT_SPINTIME: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_64 = ::std::os::raw::c_uint;
pub const DEV_PARPORT_SPINTIME: ::std::os::raw::c_uint = 1;
pub const DEV_PARPORT_BASE_ADDR: ::std::os::raw::c_uint = 2;
pub const DEV_PARPORT_IRQ: ::std::os::raw::c_uint = 3;
pub const DEV_PARPORT_DMA: ::std::os::raw::c_uint = 4;
pub const DEV_PARPORT_MODES: ::std::os::raw::c_uint = 5;
pub const DEV_PARPORT_DEVICES: ::std::os::raw::c_uint = 6;
pub const DEV_PARPORT_AUTOPROBE: ::std::os::raw::c_uint = 16;
pub type _bindgen_ty_65 = ::std::os::raw::c_uint;
pub const DEV_PARPORT_DEVICES_ACTIVE: ::std::os::raw::c_int = -3;
pub type _bindgen_ty_66 = ::std::os::raw::c_int;
pub const DEV_PARPORT_DEVICE_TIMESLICE: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_67 = ::std::os::raw::c_uint;
pub const DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES: ::std::os::raw::c_uint = 1;
pub const DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES: ::std::os::raw::c_uint = 2;
pub const DEV_MAC_HID_MOUSE_BUTTON_EMULATION: ::std::os::raw::c_uint = 3;
pub const DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE: ::std::os::raw::c_uint = 4;
pub const DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE: ::std::os::raw::c_uint = 5;
pub const DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_68 = ::std::os::raw::c_uint;
pub const DEV_SCSI_LOGGING_LEVEL: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_69 = ::std::os::raw::c_uint;
pub const DEV_IPMI_POWEROFF_POWERCYCLE: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_70 = ::std::os::raw::c_uint;
pub const ABI_DEFHANDLER_COFF: ::std::os::raw::c_uint = 1;
pub const ABI_DEFHANDLER_ELF: ::std::os::raw::c_uint = 2;
pub const ABI_DEFHANDLER_LCALL7: ::std::os::raw::c_uint = 3;
pub const ABI_DEFHANDLER_LIBCSO: ::std::os::raw::c_uint = 4;
pub const ABI_TRACE: ::std::os::raw::c_uint = 5;
pub const ABI_FAKE_UTSNAME: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_71 = ::std::os::raw::c_uint;
extern "C" {
    pub static mut sysctl_vals: [::std::os::raw::c_int; 0usize];
}
extern "C" {
    pub static mut sysctl_long_vals: [::std::os::raw::c_ulong; 0usize];
}
pub type proc_handler = ::std::option::Option<
    unsafe extern "C" fn(
        ctl: *mut ctl_table,
        write: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        lenp: *mut size_t,
        ppos: *mut loff_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn proc_dostring(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_dobool(
        table: *mut ctl_table,
        write: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        lenp: *mut size_t,
        ppos: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_dointvec(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_douintvec(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_dointvec_minmax(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_douintvec_minmax(
        table: *mut ctl_table,
        write: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        lenp: *mut size_t,
        ppos: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_dou8vec_minmax(
        table: *mut ctl_table,
        write: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        lenp: *mut size_t,
        ppos: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_dointvec_jiffies(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_dointvec_ms_jiffies_minmax(
        table: *mut ctl_table,
        write: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        lenp: *mut size_t,
        ppos: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_dointvec_userhz_jiffies(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_dointvec_ms_jiffies(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_doulongvec_minmax(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_doulongvec_ms_jiffies_minmax(
        table: *mut ctl_table,
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut size_t,
        arg4: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_do_large_bitmap(
        arg1: *mut ctl_table,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_do_static_key(
        table: *mut ctl_table,
        write: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        lenp: *mut size_t,
        ppos: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_poll {
    pub event: atomic_t,
    pub wait: wait_queue_head_t,
}
#[test]
fn bindgen_test_layout_ctl_table_poll() {
    assert_eq!(
        ::std::mem::size_of::<ctl_table_poll>(),
        32usize,
        concat!("Size of: ", stringify!(ctl_table_poll))
    );
    assert_eq!(
        ::std::mem::align_of::<ctl_table_poll>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_poll))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table_poll>())).event as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_poll),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table_poll>())).wait as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_poll),
            "::",
            stringify!(wait)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_table {
    pub procname: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
    pub maxlen: ::std::os::raw::c_int,
    pub mode: umode_t,
    pub child: *mut ctl_table,
    pub proc_handler: proc_handler,
    pub poll: *mut ctl_table_poll,
    pub extra1: *mut ::std::os::raw::c_void,
    pub extra2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ctl_table() {
    assert_eq!(
        ::std::mem::size_of::<ctl_table>(),
        64usize,
        concat!("Size of: ", stringify!(ctl_table))
    );
    assert_eq!(
        ::std::mem::align_of::<ctl_table>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table>())).procname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(procname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table>())).maxlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(maxlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table>())).mode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table>())).child as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table>())).proc_handler as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(proc_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table>())).poll as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table>())).extra1 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(extra1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table>())).extra2 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table),
            "::",
            stringify!(extra2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_node {
    pub node: rb_node,
    pub header: *mut ctl_table_header,
}
#[test]
fn bindgen_test_layout_ctl_node() {
    assert_eq!(
        ::std::mem::size_of::<ctl_node>(),
        32usize,
        concat!("Size of: ", stringify!(ctl_node))
    );
    assert_eq!(
        ::std::mem::align_of::<ctl_node>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_node>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_node),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_node>())).header as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_node),
            "::",
            stringify!(header)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_header {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1,
    pub unregistering: *mut completion,
    pub ctl_table_arg: *mut ctl_table,
    pub root: *mut ctl_table_root,
    pub set: *mut ctl_table_set,
    pub parent: *mut ctl_dir,
    pub node: *mut ctl_node,
    pub inodes: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ctl_table_header__bindgen_ty_1 {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1__bindgen_ty_1,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    pub ctl_table: *mut ctl_table,
    pub used: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub nreg: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ctl_table_header__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).ctl_table
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ctl_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).used
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).count
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ctl_table_header__bindgen_ty_1__bindgen_ty_1>())).nreg
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(nreg)
        )
    );
}
#[test]
fn bindgen_test_layout_ctl_table_header__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ctl_table_header__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(ctl_table_header__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ctl_table_header__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_header__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ctl_table_header__bindgen_ty_1>())).rcu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header__bindgen_ty_1),
            "::",
            stringify!(rcu)
        )
    );
}
#[test]
fn bindgen_test_layout_ctl_table_header() {
    assert_eq!(
        ::std::mem::size_of::<ctl_table_header>(),
        80usize,
        concat!("Size of: ", stringify!(ctl_table_header))
    );
    assert_eq!(
        ::std::mem::align_of::<ctl_table_header>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table_header>())).unregistering as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(unregistering)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table_header>())).ctl_table_arg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(ctl_table_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table_header>())).root as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table_header>())).set as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table_header>())).parent as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table_header>())).node as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table_header>())).inodes as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_header),
            "::",
            stringify!(inodes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_dir {
    pub header: ctl_table_header,
    pub root: rb_root,
}
#[test]
fn bindgen_test_layout_ctl_dir() {
    assert_eq!(
        ::std::mem::size_of::<ctl_dir>(),
        88usize,
        concat!("Size of: ", stringify!(ctl_dir))
    );
    assert_eq!(
        ::std::mem::align_of::<ctl_dir>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_dir))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_dir>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_dir),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_dir>())).root as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_dir),
            "::",
            stringify!(root)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_set {
    pub is_seen: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ctl_table_set) -> ::std::os::raw::c_int,
    >,
    pub dir: ctl_dir,
}
#[test]
fn bindgen_test_layout_ctl_table_set() {
    assert_eq!(
        ::std::mem::size_of::<ctl_table_set>(),
        96usize,
        concat!("Size of: ", stringify!(ctl_table_set))
    );
    assert_eq!(
        ::std::mem::align_of::<ctl_table_set>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table_set>())).is_seen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_set),
            "::",
            stringify!(is_seen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table_set>())).dir as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_set),
            "::",
            stringify!(dir)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_root {
    pub default_set: ctl_table_set,
    pub lookup: ::std::option::Option<
        unsafe extern "C" fn(root: *mut ctl_table_root) -> *mut ctl_table_set,
    >,
    pub set_ownership: ::std::option::Option<
        unsafe extern "C" fn(
            head: *mut ctl_table_header,
            table: *mut ctl_table,
            uid: *mut kuid_t,
            gid: *mut kgid_t,
        ),
    >,
    pub permissions: ::std::option::Option<
        unsafe extern "C" fn(
            head: *mut ctl_table_header,
            table: *mut ctl_table,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_ctl_table_root() {
    assert_eq!(
        ::std::mem::size_of::<ctl_table_root>(),
        120usize,
        concat!("Size of: ", stringify!(ctl_table_root))
    );
    assert_eq!(
        ::std::mem::align_of::<ctl_table_root>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_table_root))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table_root>())).default_set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(default_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table_root>())).lookup as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table_root>())).set_ownership as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(set_ownership)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_table_root>())).permissions as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_table_root),
            "::",
            stringify!(permissions)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctl_path {
    pub procname: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ctl_path() {
    assert_eq!(
        ::std::mem::size_of::<ctl_path>(),
        8usize,
        concat!("Size of: ", stringify!(ctl_path))
    );
    assert_eq!(
        ::std::mem::align_of::<ctl_path>(),
        8usize,
        concat!("Alignment of ", stringify!(ctl_path))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ctl_path>())).procname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctl_path),
            "::",
            stringify!(procname)
        )
    );
}
extern "C" {
    pub fn __register_sysctl_base(base_table: *mut ctl_table) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proc_sys_poll_notify(poll: *mut ctl_table_poll);
}
extern "C" {
    pub fn setup_sysctl_set(
        p: *mut ctl_table_set,
        root: *mut ctl_table_root,
        is_seen: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ctl_table_set) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn retire_sysctl_set(set: *mut ctl_table_set);
}
extern "C" {
    pub fn __register_sysctl_table(
        set: *mut ctl_table_set,
        path: *const ::std::os::raw::c_char,
        table: *mut ctl_table,
    ) -> *mut ctl_table_header;
}
extern "C" {
    pub fn __register_sysctl_paths(
        set: *mut ctl_table_set,
        path: *const ctl_path,
        table: *mut ctl_table,
    ) -> *mut ctl_table_header;
}
extern "C" {
    pub fn register_sysctl(
        path: *const ::std::os::raw::c_char,
        table: *mut ctl_table,
    ) -> *mut ctl_table_header;
}
extern "C" {
    pub fn register_sysctl_table(table: *mut ctl_table) -> *mut ctl_table_header;
}
extern "C" {
    pub fn register_sysctl_paths(
        path: *const ctl_path,
        table: *mut ctl_table,
    ) -> *mut ctl_table_header;
}
extern "C" {
    pub fn unregister_sysctl_table(table: *mut ctl_table_header);
}
extern "C" {
    pub fn sysctl_init_bases() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __register_sysctl_init(
        path: *const ::std::os::raw::c_char,
        table: *mut ctl_table,
        table_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn register_sysctl_mount_point(
        path: *const ::std::os::raw::c_char,
    ) -> *mut ctl_table_header;
}
extern "C" {
    pub fn do_sysctl_args();
}
extern "C" {
    pub fn do_proc_douintvec(
        table: *mut ctl_table,
        write: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        lenp: *mut size_t,
        ppos: *mut loff_t,
        conv: ::std::option::Option<
            unsafe extern "C" fn(
                lvalp: *mut ::std::os::raw::c_ulong,
                valp: *mut ::std::os::raw::c_uint,
                write: ::std::os::raw::c_int,
                data: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut pwrsw_enabled: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut unaligned_enabled: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut unaligned_dump_stack: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut no_unaligned_warning: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sysctl_mount_point: [ctl_table; 0usize];
}
extern "C" {
    pub fn sysctl_max_threads(
        table: *mut ctl_table,
        write: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        lenp: *mut size_t,
        ppos: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct assoc_array {
    pub root: *mut assoc_array_ptr,
    pub nr_leaves_on_tree: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_assoc_array() {
    assert_eq!(
        ::std::mem::size_of::<assoc_array>(),
        16usize,
        concat!("Size of: ", stringify!(assoc_array))
    );
    assert_eq!(
        ::std::mem::align_of::<assoc_array>(),
        8usize,
        concat!("Alignment of ", stringify!(assoc_array))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<assoc_array>())).root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(assoc_array),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<assoc_array>())).nr_leaves_on_tree as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(assoc_array),
            "::",
            stringify!(nr_leaves_on_tree)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct assoc_array_ops {
    pub get_key_chunk: ::std::option::Option<
        unsafe extern "C" fn(
            index_key: *const ::std::os::raw::c_void,
            level: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulong,
    >,
    pub get_object_key_chunk: ::std::option::Option<
        unsafe extern "C" fn(
            object: *const ::std::os::raw::c_void,
            level: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_ulong,
    >,
    pub compare_object: ::std::option::Option<
        unsafe extern "C" fn(
            object: *const ::std::os::raw::c_void,
            index_key: *const ::std::os::raw::c_void,
        ) -> bool_,
    >,
    pub diff_objects: ::std::option::Option<
        unsafe extern "C" fn(
            object: *const ::std::os::raw::c_void,
            index_key: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub free_object:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_assoc_array_ops() {
    assert_eq!(
        ::std::mem::size_of::<assoc_array_ops>(),
        40usize,
        concat!("Size of: ", stringify!(assoc_array_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<assoc_array_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(assoc_array_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<assoc_array_ops>())).get_key_chunk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(assoc_array_ops),
            "::",
            stringify!(get_key_chunk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<assoc_array_ops>())).get_object_key_chunk as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(assoc_array_ops),
            "::",
            stringify!(get_object_key_chunk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<assoc_array_ops>())).compare_object as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(assoc_array_ops),
            "::",
            stringify!(compare_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<assoc_array_ops>())).diff_objects as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(assoc_array_ops),
            "::",
            stringify!(diff_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<assoc_array_ops>())).free_object as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(assoc_array_ops),
            "::",
            stringify!(free_object)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct assoc_array_edit {
    _unused: [u8; 0],
}
extern "C" {
    pub fn assoc_array_iterate(
        array: *const assoc_array,
        iterator: ::std::option::Option<
            unsafe extern "C" fn(
                object: *const ::std::os::raw::c_void,
                iterator_data: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        iterator_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn assoc_array_find(
        array: *const assoc_array,
        ops: *const assoc_array_ops,
        index_key: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn assoc_array_destroy(array: *mut assoc_array, ops: *const assoc_array_ops);
}
extern "C" {
    pub fn assoc_array_insert(
        array: *mut assoc_array,
        ops: *const assoc_array_ops,
        index_key: *const ::std::os::raw::c_void,
        object: *mut ::std::os::raw::c_void,
    ) -> *mut assoc_array_edit;
}
extern "C" {
    pub fn assoc_array_insert_set_object(
        edit: *mut assoc_array_edit,
        object: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn assoc_array_delete(
        array: *mut assoc_array,
        ops: *const assoc_array_ops,
        index_key: *const ::std::os::raw::c_void,
    ) -> *mut assoc_array_edit;
}
extern "C" {
    pub fn assoc_array_clear(
        array: *mut assoc_array,
        ops: *const assoc_array_ops,
    ) -> *mut assoc_array_edit;
}
extern "C" {
    pub fn assoc_array_apply_edit(edit: *mut assoc_array_edit);
}
extern "C" {
    pub fn assoc_array_cancel_edit(edit: *mut assoc_array_edit);
}
extern "C" {
    pub fn assoc_array_gc(
        array: *mut assoc_array,
        ops: *const assoc_array_ops,
        iterator: ::std::option::Option<
            unsafe extern "C" fn(
                object: *mut ::std::os::raw::c_void,
                iterator_data: *mut ::std::os::raw::c_void,
            ) -> bool_,
        >,
        iterator_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type key_serial_t = i32;
pub type key_perm_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net {
    _unused: [u8; 0],
}
pub const key_need_perm_KEY_NEED_UNSPECIFIED: key_need_perm = 0;
pub const key_need_perm_KEY_NEED_VIEW: key_need_perm = 1;
pub const key_need_perm_KEY_NEED_READ: key_need_perm = 2;
pub const key_need_perm_KEY_NEED_WRITE: key_need_perm = 3;
pub const key_need_perm_KEY_NEED_SEARCH: key_need_perm = 4;
pub const key_need_perm_KEY_NEED_LINK: key_need_perm = 5;
pub const key_need_perm_KEY_NEED_SETATTR: key_need_perm = 6;
pub const key_need_perm_KEY_NEED_UNLINK: key_need_perm = 7;
pub const key_need_perm_KEY_SYSADMIN_OVERRIDE: key_need_perm = 8;
pub const key_need_perm_KEY_AUTHTOKEN_OVERRIDE: key_need_perm = 9;
pub const key_need_perm_KEY_DEFER_PERM_CHECK: key_need_perm = 10;
pub type key_need_perm = ::std::os::raw::c_uint;
pub const key_lookup_flag_KEY_LOOKUP_CREATE: key_lookup_flag = 1;
pub const key_lookup_flag_KEY_LOOKUP_PARTIAL: key_lookup_flag = 2;
pub const key_lookup_flag_KEY_LOOKUP_ALL: key_lookup_flag = 3;
pub type key_lookup_flag = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_owner {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct keyring_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct keyring_name {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_tag {
    pub rcu: callback_head,
    pub usage: refcount_t,
    pub removed: bool_,
}
#[test]
fn bindgen_test_layout_key_tag() {
    assert_eq!(
        ::std::mem::size_of::<key_tag>(),
        24usize,
        concat!("Size of: ", stringify!(key_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<key_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(key_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key_tag>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key_tag),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key_tag>())).usage as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(key_tag),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key_tag>())).removed as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(key_tag),
            "::",
            stringify!(removed)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct keyring_index_key {
    pub hash: ::std::os::raw::c_ulong,
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union keyring_index_key__bindgen_ty_1 {
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1__bindgen_ty_1,
    pub x: ::std::os::raw::c_ulong,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct keyring_index_key__bindgen_ty_1__bindgen_ty_1 {
    pub desc_len: u16_,
    pub desc: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout_keyring_index_key__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<keyring_index_key__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(keyring_index_key__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<keyring_index_key__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(keyring_index_key__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<keyring_index_key__bindgen_ty_1__bindgen_ty_1>())).desc_len
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(desc_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<keyring_index_key__bindgen_ty_1__bindgen_ty_1>())).desc
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(desc)
        )
    );
}
#[test]
fn bindgen_test_layout_keyring_index_key__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<keyring_index_key__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(keyring_index_key__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<keyring_index_key__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(keyring_index_key__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<keyring_index_key__bindgen_ty_1>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
#[test]
fn bindgen_test_layout_keyring_index_key() {
    assert_eq!(
        ::std::mem::size_of::<keyring_index_key>(),
        40usize,
        concat!("Size of: ", stringify!(keyring_index_key))
    );
    assert_eq!(
        ::std::mem::align_of::<keyring_index_key>(),
        8usize,
        concat!("Alignment of ", stringify!(keyring_index_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<keyring_index_key>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<keyring_index_key>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<keyring_index_key>())).domain_tag as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key),
            "::",
            stringify!(domain_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<keyring_index_key>())).description as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(keyring_index_key),
            "::",
            stringify!(description)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key_payload {
    pub rcu_data0: *mut ::std::os::raw::c_void,
    pub data: [*mut ::std::os::raw::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_key_payload() {
    assert_eq!(
        ::std::mem::size_of::<key_payload>(),
        32usize,
        concat!("Size of: ", stringify!(key_payload))
    );
    assert_eq!(
        ::std::mem::align_of::<key_payload>(),
        8usize,
        concat!("Alignment of ", stringify!(key_payload))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key_payload>())).rcu_data0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key_payload),
            "::",
            stringify!(rcu_data0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key_payload>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key_payload),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __key_reference_with_attributes {
    _unused: [u8; 0],
}
pub type key_ref_t = *mut __key_reference_with_attributes;
pub type key_restrict_link_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        dest_keyring: *mut key,
        type_: *const key_type,
        payload: *const key_payload,
        restriction_key: *mut key,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_restriction {
    pub check: key_restrict_link_func_t,
    pub key: *mut key,
    pub keytype: *mut key_type,
}
#[test]
fn bindgen_test_layout_key_restriction() {
    assert_eq!(
        ::std::mem::size_of::<key_restriction>(),
        24usize,
        concat!("Size of: ", stringify!(key_restriction))
    );
    assert_eq!(
        ::std::mem::align_of::<key_restriction>(),
        8usize,
        concat!("Alignment of ", stringify!(key_restriction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key_restriction>())).check as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key_restriction),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key_restriction>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(key_restriction),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key_restriction>())).keytype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(key_restriction),
            "::",
            stringify!(keytype)
        )
    );
}
pub const key_state_KEY_IS_UNINSTANTIATED: key_state = 0;
pub const key_state_KEY_IS_POSITIVE: key_state = 1;
pub type key_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key {
    pub usage: refcount_t,
    pub serial: key_serial_t,
    pub __bindgen_anon_1: key__bindgen_ty_1,
    pub sem: rw_semaphore,
    pub user: *mut key_user,
    pub security: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_2: key__bindgen_ty_2,
    pub last_used_at: time64_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub perm: key_perm_t,
    pub quotalen: ::std::os::raw::c_ushort,
    pub datalen: ::std::os::raw::c_ushort,
    pub state: ::std::os::raw::c_short,
    pub flags: ::std::os::raw::c_ulong,
    pub __bindgen_anon_3: key__bindgen_ty_3,
    pub __bindgen_anon_4: key__bindgen_ty_4,
    pub restrict_link: *mut key_restriction,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_1 {
    pub graveyard_link: list_head,
    pub serial_node: rb_node,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<key__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<key__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<key__bindgen_ty_1>())).graveyard_link as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_1),
            "::",
            stringify!(graveyard_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key__bindgen_ty_1>())).serial_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_1),
            "::",
            stringify!(serial_node)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_2 {
    pub expiry: time64_t,
    pub revoked_at: time64_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<key__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<key__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key__bindgen_ty_2>())).expiry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_2),
            "::",
            stringify!(expiry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key__bindgen_ty_2>())).revoked_at as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_2),
            "::",
            stringify!(revoked_at)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_3 {
    pub index_key: keyring_index_key,
    pub __bindgen_anon_1: key__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key__bindgen_ty_3__bindgen_ty_1 {
    pub hash: ::std::os::raw::c_ulong,
    pub len_desc: ::std::os::raw::c_ulong,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<key__bindgen_ty_3__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_3__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<key__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_3__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).hash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).len_desc as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(len_desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).type_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).domain_tag as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(domain_tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<key__bindgen_ty_3__bindgen_ty_1>())).description as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(description)
        )
    );
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<key__bindgen_ty_3>(),
        40usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<key__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key__bindgen_ty_3>())).index_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_3),
            "::",
            stringify!(index_key)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_4 {
    pub payload: key_payload,
    pub __bindgen_anon_1: key__bindgen_ty_4__bindgen_ty_1,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key__bindgen_ty_4__bindgen_ty_1 {
    pub name_link: list_head,
    pub keys: assoc_array,
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<key__bindgen_ty_4__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_4__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<key__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_4__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<key__bindgen_ty_4__bindgen_ty_1>())).name_link as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(name_link)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<key__bindgen_ty_4__bindgen_ty_1>())).keys as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(keys)
        )
    );
}
#[test]
fn bindgen_test_layout_key__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<key__bindgen_ty_4>(),
        32usize,
        concat!("Size of: ", stringify!(key__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<key__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(key__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key__bindgen_ty_4>())).payload as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key__bindgen_ty_4),
            "::",
            stringify!(payload)
        )
    );
}
#[test]
fn bindgen_test_layout_key() {
    assert_eq!(
        ::std::mem::size_of::<key>(),
        216usize,
        concat!("Size of: ", stringify!(key))
    );
    assert_eq!(
        ::std::mem::align_of::<key>(),
        8usize,
        concat!("Alignment of ", stringify!(key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key>())).usage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key>())).serial as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key>())).sem as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(key), "::", stringify!(sem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key>())).user as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(key), "::", stringify!(user))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key>())).security as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key>())).last_used_at as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(last_used_at)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key>())).uid as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(key), "::", stringify!(uid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key>())).gid as *const _ as usize },
        108usize,
        concat!("Offset of field: ", stringify!(key), "::", stringify!(gid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key>())).perm as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(key), "::", stringify!(perm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key>())).quotalen as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(quotalen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key>())).datalen as *const _ as usize },
        118usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(datalen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key>())).state as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key>())).flags as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<key>())).restrict_link as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(key),
            "::",
            stringify!(restrict_link)
        )
    );
}
extern "C" {
    pub fn key_alloc(
        type_: *mut key_type,
        desc: *const ::std::os::raw::c_char,
        uid: kuid_t,
        gid: kgid_t,
        cred: *const cred,
        perm: key_perm_t,
        flags: ::std::os::raw::c_ulong,
        restrict_link: *mut key_restriction,
    ) -> *mut key;
}
extern "C" {
    pub fn key_revoke(key: *mut key);
}
extern "C" {
    pub fn key_invalidate(key: *mut key);
}
extern "C" {
    pub fn key_put(key: *mut key);
}
extern "C" {
    pub fn key_put_tag(tag: *mut key_tag) -> bool_;
}
extern "C" {
    pub fn key_remove_domain(domain_tag: *mut key_tag);
}
extern "C" {
    pub fn request_key_tag(
        type_: *mut key_type,
        description: *const ::std::os::raw::c_char,
        domain_tag: *mut key_tag,
        callout_info: *const ::std::os::raw::c_char,
    ) -> *mut key;
}
extern "C" {
    pub fn request_key_rcu(
        type_: *mut key_type,
        description: *const ::std::os::raw::c_char,
        domain_tag: *mut key_tag,
    ) -> *mut key;
}
extern "C" {
    pub fn request_key_with_auxdata(
        type_: *mut key_type,
        description: *const ::std::os::raw::c_char,
        domain_tag: *mut key_tag,
        callout_info: *const ::std::os::raw::c_void,
        callout_len: size_t,
        aux: *mut ::std::os::raw::c_void,
    ) -> *mut key;
}
extern "C" {
    pub fn wait_for_key_construction(key: *mut key, intr: bool_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn key_validate(key: *const key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn key_create_or_update(
        keyring: key_ref_t,
        type_: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        payload: *const ::std::os::raw::c_void,
        plen: size_t,
        perm: key_perm_t,
        flags: ::std::os::raw::c_ulong,
    ) -> key_ref_t;
}
extern "C" {
    pub fn key_update(
        key: key_ref_t,
        payload: *const ::std::os::raw::c_void,
        plen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn key_link(keyring: *mut key, key: *mut key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn key_move(
        key: *mut key,
        from_keyring: *mut key,
        to_keyring: *mut key,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn key_unlink(keyring: *mut key, key: *mut key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn keyring_alloc(
        description: *const ::std::os::raw::c_char,
        uid: kuid_t,
        gid: kgid_t,
        cred: *const cred,
        perm: key_perm_t,
        flags: ::std::os::raw::c_ulong,
        restrict_link: *mut key_restriction,
        dest: *mut key,
    ) -> *mut key;
}
extern "C" {
    pub fn restrict_link_reject(
        keyring: *mut key,
        type_: *const key_type,
        payload: *const key_payload,
        restriction_key: *mut key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn keyring_clear(keyring: *mut key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn keyring_search(
        keyring: key_ref_t,
        type_: *mut key_type,
        description: *const ::std::os::raw::c_char,
        recurse: bool_,
    ) -> key_ref_t;
}
extern "C" {
    pub fn keyring_add_key(keyring: *mut key, key: *mut key) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn keyring_restrict(
        keyring: key_ref_t,
        type_: *const ::std::os::raw::c_char,
        restriction: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn key_lookup(id: key_serial_t) -> *mut key;
}
extern "C" {
    pub fn key_set_timeout(arg1: *mut key, arg2: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn lookup_user_key(
        id: key_serial_t,
        flags: ::std::os::raw::c_ulong,
        need_perm: key_need_perm,
    ) -> key_ref_t;
}
extern "C" {
    pub fn key_free_user_ns(arg1: *mut user_namespace);
}
extern "C" {
    pub static mut key_sysctls: [ctl_table; 0usize];
}
extern "C" {
    pub fn install_thread_keyring_to_cred(cred: *mut cred) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn key_fsuid_changed(new_cred: *mut cred);
}
extern "C" {
    pub fn key_fsgid_changed(new_cred: *mut cred);
}
extern "C" {
    pub fn key_init();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_counter {
    pub lock: raw_spinlock_t,
    pub count: s64,
    pub list: list_head,
    pub counters: *mut s32,
}
#[test]
fn bindgen_test_layout_percpu_counter() {
    assert_eq!(
        ::std::mem::size_of::<percpu_counter>(),
        40usize,
        concat!("Size of: ", stringify!(percpu_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<percpu_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(percpu_counter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_counter>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_counter),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_counter>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_counter),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_counter>())).list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_counter),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_counter>())).counters as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_counter),
            "::",
            stringify!(counters)
        )
    );
}
extern "C" {
    pub static mut percpu_counter_batch: ::std::os::raw::c_int;
}
extern "C" {
    pub fn __percpu_counter_init(
        fbc: *mut percpu_counter,
        amount: s64,
        gfp: gfp_t,
        key: *mut lock_class_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn percpu_counter_destroy(fbc: *mut percpu_counter);
}
extern "C" {
    pub fn percpu_counter_set(fbc: *mut percpu_counter, amount: s64);
}
extern "C" {
    pub fn percpu_counter_add_batch(fbc: *mut percpu_counter, amount: s64, batch: s32);
}
extern "C" {
    pub fn __percpu_counter_sum(fbc: *mut percpu_counter) -> s64;
}
extern "C" {
    pub fn __percpu_counter_compare(
        fbc: *mut percpu_counter,
        rhs: s64,
        batch: s32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn percpu_counter_sync(fbc: *mut percpu_counter);
}
extern "C" {
    pub static mut printk_ratelimit_state: ratelimit_state;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_struct {
    pub __count: refcount_t,
    pub epoll_watches: percpu_counter,
    pub unix_inflight: ::std::os::raw::c_ulong,
    pub pipe_bufs: atomic_long_t,
    pub uidhash_node: hlist_node,
    pub uid: kuid_t,
    pub locked_vm: atomic_long_t,
    pub ratelimit: ratelimit_state,
}
#[test]
fn bindgen_test_layout_user_struct() {
    assert_eq!(
        ::std::mem::size_of::<user_struct>(),
        136usize,
        concat!("Size of: ", stringify!(user_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<user_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(user_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_struct>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_struct>())).epoll_watches as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(epoll_watches)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_struct>())).unix_inflight as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(unix_inflight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_struct>())).pipe_bufs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(pipe_bufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_struct>())).uidhash_node as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(uidhash_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_struct>())).uid as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_struct>())).locked_vm as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(locked_vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<user_struct>())).ratelimit as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(user_struct),
            "::",
            stringify!(ratelimit)
        )
    );
}
extern "C" {
    pub fn uids_sysfs_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn find_user(arg1: kuid_t) -> *mut user_struct;
}
extern "C" {
    pub static mut root_user: user_struct;
}
extern "C" {
    pub fn alloc_uid(arg1: kuid_t) -> *mut user_struct;
}
extern "C" {
    pub fn free_uid(arg1: *mut user_struct);
}
#[repr(C)]
#[derive(Debug)]
pub struct group_info {
    pub usage: atomic_t,
    pub ngroups: ::std::os::raw::c_int,
    pub gid: __IncompleteArrayField<kgid_t>,
}
#[test]
fn bindgen_test_layout_group_info() {
    assert_eq!(
        ::std::mem::size_of::<group_info>(),
        8usize,
        concat!("Size of: ", stringify!(group_info))
    );
    assert_eq!(
        ::std::mem::align_of::<group_info>(),
        4usize,
        concat!("Alignment of ", stringify!(group_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_info>())).usage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_info),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_info>())).ngroups as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_info),
            "::",
            stringify!(ngroups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_info>())).gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_info),
            "::",
            stringify!(gid)
        )
    );
}
extern "C" {
    pub fn groups_alloc(arg1: ::std::os::raw::c_int) -> *mut group_info;
}
extern "C" {
    pub fn groups_free(arg1: *mut group_info);
}
extern "C" {
    pub fn in_group_p(arg1: kgid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn in_egroup_p(arg1: kgid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn groups_search(arg1: *const group_info, arg2: kgid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_current_groups(arg1: *mut group_info) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_groups(arg1: *mut cred, arg2: *mut group_info);
}
extern "C" {
    pub fn may_setgroups() -> bool_;
}
extern "C" {
    pub fn groups_sort(arg1: *mut group_info);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cred {
    pub usage: atomic_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub suid: kuid_t,
    pub sgid: kgid_t,
    pub euid: kuid_t,
    pub egid: kgid_t,
    pub fsuid: kuid_t,
    pub fsgid: kgid_t,
    pub securebits: ::std::os::raw::c_uint,
    pub cap_inheritable: kernel_cap_t,
    pub cap_permitted: kernel_cap_t,
    pub cap_effective: kernel_cap_t,
    pub cap_bset: kernel_cap_t,
    pub cap_ambient: kernel_cap_t,
    pub jit_keyring: ::std::os::raw::c_uchar,
    pub session_keyring: *mut key,
    pub process_keyring: *mut key,
    pub thread_keyring: *mut key,
    pub request_key_auth: *mut key,
    pub security: *mut ::std::os::raw::c_void,
    pub user: *mut user_struct,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub group_info: *mut group_info,
    pub __bindgen_anon_1: cred__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cred__bindgen_ty_1 {
    pub non_rcu: ::std::os::raw::c_int,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_cred__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<cred__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(cred__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<cred__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cred__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred__bindgen_ty_1>())).non_rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cred__bindgen_ty_1),
            "::",
            stringify!(non_rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred__bindgen_ty_1>())).rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cred__bindgen_ty_1),
            "::",
            stringify!(rcu)
        )
    );
}
#[test]
fn bindgen_test_layout_cred() {
    assert_eq!(
        ::std::mem::size_of::<cred>(),
        176usize,
        concat!("Size of: ", stringify!(cred))
    );
    assert_eq!(
        ::std::mem::align_of::<cred>(),
        8usize,
        concat!("Alignment of ", stringify!(cred))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).usage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).uid as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(cred), "::", stringify!(uid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).gid as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cred), "::", stringify!(gid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).suid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(suid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).sgid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(sgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).euid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(euid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).egid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(egid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).fsuid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(fsuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).fsgid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(fsgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).securebits as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(securebits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).cap_inheritable as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(cap_inheritable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).cap_permitted as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(cap_permitted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).cap_effective as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(cap_effective)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).cap_bset as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(cap_bset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).cap_ambient as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(cap_ambient)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).jit_keyring as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(jit_keyring)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).session_keyring as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(session_keyring)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).process_keyring as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(process_keyring)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).thread_keyring as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(thread_keyring)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).request_key_auth as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(request_key_auth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).security as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(security)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).user as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).user_ns as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(user_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).ucounts as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(ucounts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cred>())).group_info as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cred),
            "::",
            stringify!(group_info)
        )
    );
}
extern "C" {
    pub fn __put_cred(arg1: *mut cred);
}
extern "C" {
    pub fn exit_creds(arg1: *mut task_struct);
}
extern "C" {
    pub fn copy_creds(
        arg1: *mut task_struct,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_task_cred(arg1: *mut task_struct) -> *const cred;
}
extern "C" {
    pub fn cred_alloc_blank() -> *mut cred;
}
extern "C" {
    pub fn prepare_creds() -> *mut cred;
}
extern "C" {
    pub fn prepare_exec_creds() -> *mut cred;
}
extern "C" {
    pub fn commit_creds(arg1: *mut cred) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort_creds(arg1: *mut cred);
}
extern "C" {
    pub fn override_creds(arg1: *const cred) -> *const cred;
}
extern "C" {
    pub fn revert_creds(arg1: *const cred);
}
extern "C" {
    pub fn prepare_kernel_cred(arg1: *mut task_struct) -> *mut cred;
}
extern "C" {
    pub fn change_create_files_as(arg1: *mut cred, arg2: *mut inode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_security_override(arg1: *mut cred, arg2: u32_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_security_override_from_ctx(
        arg1: *mut cred,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_create_files_as(arg1: *mut cred, arg2: *mut inode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cred_fscmp(arg1: *const cred, arg2: *const cred) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cred_init();
}
extern "C" {
    pub fn set_cred_ucounts(arg1: *mut cred) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sighand_struct {
    pub siglock: spinlock_t,
    pub count: refcount_t,
    pub signalfd_wqh: wait_queue_head_t,
    pub action: [k_sigaction; 64usize],
}
#[test]
fn bindgen_test_layout_sighand_struct() {
    assert_eq!(
        ::std::mem::size_of::<sighand_struct>(),
        2080usize,
        concat!("Size of: ", stringify!(sighand_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<sighand_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(sighand_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sighand_struct>())).siglock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sighand_struct),
            "::",
            stringify!(siglock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sighand_struct>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sighand_struct),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sighand_struct>())).signalfd_wqh as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sighand_struct),
            "::",
            stringify!(signalfd_wqh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sighand_struct>())).action as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sighand_struct),
            "::",
            stringify!(action)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pacct_struct {
    pub ac_flag: ::std::os::raw::c_int,
    pub ac_exitcode: ::std::os::raw::c_long,
    pub ac_mem: ::std::os::raw::c_ulong,
    pub ac_utime: u64_,
    pub ac_stime: u64_,
    pub ac_minflt: ::std::os::raw::c_ulong,
    pub ac_majflt: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_pacct_struct() {
    assert_eq!(
        ::std::mem::size_of::<pacct_struct>(),
        56usize,
        concat!("Size of: ", stringify!(pacct_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<pacct_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(pacct_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pacct_struct>())).ac_flag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pacct_struct),
            "::",
            stringify!(ac_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pacct_struct>())).ac_exitcode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pacct_struct),
            "::",
            stringify!(ac_exitcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pacct_struct>())).ac_mem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pacct_struct),
            "::",
            stringify!(ac_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pacct_struct>())).ac_utime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pacct_struct),
            "::",
            stringify!(ac_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pacct_struct>())).ac_stime as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pacct_struct),
            "::",
            stringify!(ac_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pacct_struct>())).ac_minflt as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pacct_struct),
            "::",
            stringify!(ac_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pacct_struct>())).ac_majflt as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pacct_struct),
            "::",
            stringify!(ac_majflt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_itimer {
    pub expires: u64_,
    pub incr: u64_,
}
#[test]
fn bindgen_test_layout_cpu_itimer() {
    assert_eq!(
        ::std::mem::size_of::<cpu_itimer>(),
        16usize,
        concat!("Size of: ", stringify!(cpu_itimer))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_itimer>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_itimer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_itimer>())).expires as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_itimer),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_itimer>())).incr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_itimer),
            "::",
            stringify!(incr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct task_cputime_atomic {
    pub utime: atomic64_t,
    pub stime: atomic64_t,
    pub sum_exec_runtime: atomic64_t,
}
#[test]
fn bindgen_test_layout_task_cputime_atomic() {
    assert_eq!(
        ::std::mem::size_of::<task_cputime_atomic>(),
        24usize,
        concat!("Size of: ", stringify!(task_cputime_atomic))
    );
    assert_eq!(
        ::std::mem::align_of::<task_cputime_atomic>(),
        8usize,
        concat!("Alignment of ", stringify!(task_cputime_atomic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_cputime_atomic>())).utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime_atomic),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<task_cputime_atomic>())).stime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime_atomic),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<task_cputime_atomic>())).sum_exec_runtime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(task_cputime_atomic),
            "::",
            stringify!(sum_exec_runtime)
        )
    );
}
#[doc = " struct thread_group_cputimer - thread group interval timer counts"]
#[doc = " @cputime_atomic:\tatomic thread group interval timers."]
#[doc = ""]
#[doc = " This structure contains the version of task_cputime, above, that is"]
#[doc = " used for thread group CPU timer calculations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread_group_cputimer {
    pub cputime_atomic: task_cputime_atomic,
}
#[test]
fn bindgen_test_layout_thread_group_cputimer() {
    assert_eq!(
        ::std::mem::size_of::<thread_group_cputimer>(),
        24usize,
        concat!("Size of: ", stringify!(thread_group_cputimer))
    );
    assert_eq!(
        ::std::mem::align_of::<thread_group_cputimer>(),
        8usize,
        concat!("Alignment of ", stringify!(thread_group_cputimer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<thread_group_cputimer>())).cputime_atomic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(thread_group_cputimer),
            "::",
            stringify!(cputime_atomic)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multiprocess_signals {
    pub signal: sigset_t,
    pub node: hlist_node,
}
#[test]
fn bindgen_test_layout_multiprocess_signals() {
    assert_eq!(
        ::std::mem::size_of::<multiprocess_signals>(),
        24usize,
        concat!("Size of: ", stringify!(multiprocess_signals))
    );
    assert_eq!(
        ::std::mem::align_of::<multiprocess_signals>(),
        8usize,
        concat!("Alignment of ", stringify!(multiprocess_signals))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<multiprocess_signals>())).signal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(multiprocess_signals),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<multiprocess_signals>())).node as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(multiprocess_signals),
            "::",
            stringify!(node)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct core_thread {
    pub task: *mut task_struct,
    pub next: *mut core_thread,
}
#[test]
fn bindgen_test_layout_core_thread() {
    assert_eq!(
        ::std::mem::size_of::<core_thread>(),
        16usize,
        concat!("Size of: ", stringify!(core_thread))
    );
    assert_eq!(
        ::std::mem::align_of::<core_thread>(),
        8usize,
        concat!("Alignment of ", stringify!(core_thread))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<core_thread>())).task as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(core_thread),
            "::",
            stringify!(task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<core_thread>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(core_thread),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct core_state {
    pub nr_threads: atomic_t,
    pub dumper: core_thread,
    pub startup: completion,
}
#[test]
fn bindgen_test_layout_core_state() {
    assert_eq!(
        ::std::mem::size_of::<core_state>(),
        56usize,
        concat!("Size of: ", stringify!(core_state))
    );
    assert_eq!(
        ::std::mem::align_of::<core_state>(),
        8usize,
        concat!("Alignment of ", stringify!(core_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<core_state>())).nr_threads as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(nr_threads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<core_state>())).dumper as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(dumper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<core_state>())).startup as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(core_state),
            "::",
            stringify!(startup)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct signal_struct {
    pub sigcnt: refcount_t,
    pub live: atomic_t,
    pub nr_threads: ::std::os::raw::c_int,
    pub quick_threads: ::std::os::raw::c_int,
    pub thread_head: list_head,
    pub wait_chldexit: wait_queue_head_t,
    pub curr_target: *mut task_struct,
    pub shared_pending: sigpending,
    pub multiprocess: hlist_head,
    pub group_exit_code: ::std::os::raw::c_int,
    pub notify_count: ::std::os::raw::c_int,
    pub group_exec_task: *mut task_struct,
    pub group_stop_count: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_uint,
    pub core_state: *mut core_state,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub posix_timer_id: ::std::os::raw::c_int,
    pub posix_timers: list_head,
    pub real_timer: hrtimer,
    pub it_real_incr: ktime_t,
    pub it: [cpu_itimer; 2usize],
    pub cputimer: thread_group_cputimer,
    pub posix_cputimers: posix_cputimers,
    pub pids: [*mut pid; 4usize],
    pub tty_old_pgrp: *mut pid,
    pub leader: ::std::os::raw::c_int,
    pub tty: *mut tty_struct,
    pub stats_lock: seqlock_t,
    pub utime: u64_,
    pub stime: u64_,
    pub cutime: u64_,
    pub cstime: u64_,
    pub gtime: u64_,
    pub cgtime: u64_,
    pub prev_cputime: prev_cputime,
    pub nvcsw: ::std::os::raw::c_ulong,
    pub nivcsw: ::std::os::raw::c_ulong,
    pub cnvcsw: ::std::os::raw::c_ulong,
    pub cnivcsw: ::std::os::raw::c_ulong,
    pub min_flt: ::std::os::raw::c_ulong,
    pub maj_flt: ::std::os::raw::c_ulong,
    pub cmin_flt: ::std::os::raw::c_ulong,
    pub cmaj_flt: ::std::os::raw::c_ulong,
    pub inblock: ::std::os::raw::c_ulong,
    pub oublock: ::std::os::raw::c_ulong,
    pub cinblock: ::std::os::raw::c_ulong,
    pub coublock: ::std::os::raw::c_ulong,
    pub maxrss: ::std::os::raw::c_ulong,
    pub cmaxrss: ::std::os::raw::c_ulong,
    pub ioac: task_io_accounting,
    pub sum_sched_runtime: ::std::os::raw::c_ulonglong,
    pub rlim: [rlimit; 16usize],
    pub pacct: pacct_struct,
    pub stats: *mut taskstats,
    pub audit_tty: ::std::os::raw::c_uint,
    pub tty_audit_buf: *mut tty_audit_buf,
    pub oom_flag_origin: bool_,
    pub oom_score_adj: ::std::os::raw::c_short,
    pub oom_score_adj_min: ::std::os::raw::c_short,
    pub oom_mm: *mut mm_struct,
    pub cred_guard_mutex: mutex,
    pub exec_update_lock: rw_semaphore,
}
#[test]
fn bindgen_test_layout_signal_struct() {
    assert_eq!(
        ::std::mem::size_of::<signal_struct>(),
        1096usize,
        concat!("Size of: ", stringify!(signal_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<signal_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(signal_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).sigcnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(sigcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).live as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(live)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).nr_threads as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(nr_threads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).quick_threads as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(quick_threads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).thread_head as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(thread_head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).wait_chldexit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(wait_chldexit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).curr_target as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(curr_target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).shared_pending as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(shared_pending)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).multiprocess as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(multiprocess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).group_exit_code as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(group_exit_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).notify_count as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(notify_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).group_exec_task as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(group_exec_task)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).group_stop_count as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(group_stop_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).flags as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).core_state as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(core_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).posix_timer_id as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(posix_timer_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).posix_timers as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(posix_timers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).real_timer as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(real_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).it_real_incr as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(it_real_incr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).it as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(it)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).cputimer as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cputimer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).posix_cputimers as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(posix_cputimers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).pids as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(pids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).tty_old_pgrp as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(tty_old_pgrp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).leader as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(leader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).tty as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(tty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).stats_lock as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(stats_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).utime as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).stime as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).cutime as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cutime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).cstime as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cstime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).gtime as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(gtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).cgtime as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cgtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).prev_cputime as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(prev_cputime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).nvcsw as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).nivcsw as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(nivcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).cnvcsw as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cnvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).cnivcsw as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cnivcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).min_flt as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(min_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).maj_flt as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(maj_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).cmin_flt as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cmin_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).cmaj_flt as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cmaj_flt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).inblock as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).oublock as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).cinblock as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cinblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).coublock as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(coublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).maxrss as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).cmaxrss as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cmaxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).ioac as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(ioac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).sum_sched_runtime as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(sum_sched_runtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).rlim as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(rlim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).pacct as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(pacct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).stats as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).audit_tty as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(audit_tty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).tty_audit_buf as *const _ as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(tty_audit_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).oom_flag_origin as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(oom_flag_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).oom_score_adj as *const _ as usize },
        1010usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(oom_score_adj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).oom_score_adj_min as *const _ as usize },
        1012usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(oom_score_adj_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).oom_mm as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(oom_mm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).cred_guard_mutex as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(cred_guard_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<signal_struct>())).exec_update_lock as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(signal_struct),
            "::",
            stringify!(exec_update_lock)
        )
    );
}
impl signal_struct {
    #[inline]
    pub fn is_child_subreaper(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_child_subreaper(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_child_subreaper(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_child_subreaper(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_child_subreaper: ::std::os::raw::c_uint,
        has_child_subreaper: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_child_subreaper: u32 = unsafe { ::std::mem::transmute(is_child_subreaper) };
            is_child_subreaper as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_child_subreaper: u32 = unsafe { ::std::mem::transmute(has_child_subreaper) };
            has_child_subreaper as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn flush_signals(arg1: *mut task_struct);
}
extern "C" {
    pub fn ignore_signals(arg1: *mut task_struct);
}
extern "C" {
    pub fn flush_signal_handlers(arg1: *mut task_struct, force_default: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dequeue_signal(
        task: *mut task_struct,
        mask: *mut sigset_t,
        info: *mut kernel_siginfo_t,
        type_: *mut pid_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn force_sig_fault_to_task(
        sig: ::std::os::raw::c_int,
        code: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_void,
        t: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn force_sig_fault(
        sig: ::std::os::raw::c_int,
        code: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send_sig_fault(
        sig: ::std::os::raw::c_int,
        code: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_void,
        t: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn force_sig_mceerr(
        code: ::std::os::raw::c_int,
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send_sig_mceerr(
        code: ::std::os::raw::c_int,
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_short,
        arg3: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn force_sig_bnderr(
        addr: *mut ::std::os::raw::c_void,
        lower: *mut ::std::os::raw::c_void,
        upper: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn force_sig_pkuerr(addr: *mut ::std::os::raw::c_void, pkey: u32_)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send_sig_perf(
        addr: *mut ::std::os::raw::c_void,
        type_: u32_,
        sig_data: u64_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn force_sig_ptrace_errno_trap(
        errno: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn force_sig_fault_trapno(
        sig: ::std::os::raw::c_int,
        code: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_void,
        trapno: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send_sig_fault_trapno(
        sig: ::std::os::raw::c_int,
        code: ::std::os::raw::c_int,
        addr: *mut ::std::os::raw::c_void,
        trapno: ::std::os::raw::c_int,
        t: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn force_sig_seccomp(
        syscall: ::std::os::raw::c_int,
        reason: ::std::os::raw::c_int,
        force_coredump: bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send_sig_info(
        arg1: ::std::os::raw::c_int,
        arg2: *mut kernel_siginfo,
        arg3: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn force_sigsegv(sig: ::std::os::raw::c_int);
}
extern "C" {
    pub fn force_sig_info(arg1: *mut kernel_siginfo) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __kill_pgrp_info(
        sig: ::std::os::raw::c_int,
        info: *mut kernel_siginfo,
        pgrp: *mut pid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kill_pid_info(
        sig: ::std::os::raw::c_int,
        info: *mut kernel_siginfo,
        pid: *mut pid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kill_pid_usb_asyncio(
        sig: ::std::os::raw::c_int,
        errno: ::std::os::raw::c_int,
        addr: sigval_t,
        arg1: *mut pid,
        arg2: *const cred,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kill_pgrp(
        pid: *mut pid,
        sig: ::std::os::raw::c_int,
        priv_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kill_pid(
        pid: *mut pid,
        sig: ::std::os::raw::c_int,
        priv_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_notify_parent(arg1: *mut task_struct, arg2: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn __wake_up_parent(p: *mut task_struct, parent: *mut task_struct);
}
extern "C" {
    pub fn force_sig(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn force_fatal_sig(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn force_exit_sig(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn send_sig(
        arg1: ::std::os::raw::c_int,
        arg2: *mut task_struct,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zap_other_threads(p: *mut task_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue_alloc() -> *mut sigqueue;
}
extern "C" {
    pub fn sigqueue_free(arg1: *mut sigqueue);
}
extern "C" {
    pub fn send_sigqueue(
        arg1: *mut sigqueue,
        arg2: *mut pid,
        arg3: pid_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_sigaction(
        arg1: ::std::os::raw::c_int,
        arg2: *mut k_sigaction,
        arg3: *mut k_sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recalc_sigpending_and_wake(t: *mut task_struct);
}
extern "C" {
    pub fn recalc_sigpending();
}
extern "C" {
    pub fn calculate_sigpending();
}
extern "C" {
    pub fn signal_wake_up_state(t: *mut task_struct, state: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn task_join_group_stop(task: *mut task_struct);
}
extern "C" {
    pub fn set_user_sigmask(umask: *const sigset_t, sigsetsize: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cleanup_sighand(arg1: *mut sighand_struct);
}
extern "C" {
    pub fn flush_itimer_signals();
}
extern "C" {
    pub fn current_is_single_threaded() -> bool_;
}
pub type proc_visitor = ::std::option::Option<
    unsafe extern "C" fn(
        p: *mut task_struct,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn walk_process_tree(
        top: *mut task_struct,
        arg1: proc_visitor,
        arg2: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn thread_group_exited(pid: *mut pid) -> bool_;
}
extern "C" {
    pub fn __lock_task_sighand(
        task: *mut task_struct,
        flags: *mut ::std::os::raw::c_ulong,
    ) -> *mut sighand_struct;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcuwait {
    pub task: *mut task_struct,
}
#[test]
fn bindgen_test_layout_rcuwait() {
    assert_eq!(
        ::std::mem::size_of::<rcuwait>(),
        8usize,
        concat!("Size of: ", stringify!(rcuwait))
    );
    assert_eq!(
        ::std::mem::align_of::<rcuwait>(),
        8usize,
        concat!("Alignment of ", stringify!(rcuwait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcuwait>())).task as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcuwait),
            "::",
            stringify!(task)
        )
    );
}
extern "C" {
    pub fn rcuwait_wake_up(w: *mut rcuwait) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finish_rcuwait(w: *mut rcuwait);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_sync {
    pub gp_state: ::std::os::raw::c_int,
    pub gp_count: ::std::os::raw::c_int,
    pub gp_wait: wait_queue_head_t,
    pub cb_head: callback_head,
}
#[test]
fn bindgen_test_layout_rcu_sync() {
    assert_eq!(
        ::std::mem::size_of::<rcu_sync>(),
        48usize,
        concat!("Size of: ", stringify!(rcu_sync))
    );
    assert_eq!(
        ::std::mem::align_of::<rcu_sync>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_sync))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_sync>())).gp_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(gp_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_sync>())).gp_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(gp_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_sync>())).gp_wait as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(gp_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rcu_sync>())).cb_head as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_sync),
            "::",
            stringify!(cb_head)
        )
    );
}
extern "C" {
    pub fn rcu_sync_init(arg1: *mut rcu_sync);
}
extern "C" {
    pub fn rcu_sync_enter_start(arg1: *mut rcu_sync);
}
extern "C" {
    pub fn rcu_sync_enter(arg1: *mut rcu_sync);
}
extern "C" {
    pub fn rcu_sync_exit(arg1: *mut rcu_sync);
}
extern "C" {
    pub fn rcu_sync_dtor(arg1: *mut rcu_sync);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_rw_semaphore {
    pub rss: rcu_sync,
    pub read_count: *mut ::std::os::raw::c_uint,
    pub writer: rcuwait,
    pub waiters: wait_queue_head_t,
    pub block: atomic_t,
}
#[test]
fn bindgen_test_layout_percpu_rw_semaphore() {
    assert_eq!(
        ::std::mem::size_of::<percpu_rw_semaphore>(),
        96usize,
        concat!("Size of: ", stringify!(percpu_rw_semaphore))
    );
    assert_eq!(
        ::std::mem::align_of::<percpu_rw_semaphore>(),
        8usize,
        concat!("Alignment of ", stringify!(percpu_rw_semaphore))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_rw_semaphore>())).rss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(rss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_rw_semaphore>())).read_count as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(read_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_rw_semaphore>())).writer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(writer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_rw_semaphore>())).waiters as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(waiters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_rw_semaphore>())).block as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_rw_semaphore),
            "::",
            stringify!(block)
        )
    );
}
extern "C" {
    pub fn __percpu_down_read(arg1: *mut percpu_rw_semaphore, arg2: bool_) -> bool_;
}
extern "C" {
    pub fn percpu_is_read_locked(arg1: *mut percpu_rw_semaphore) -> bool_;
}
extern "C" {
    pub fn percpu_down_write(arg1: *mut percpu_rw_semaphore);
}
extern "C" {
    pub fn percpu_up_write(arg1: *mut percpu_rw_semaphore);
}
extern "C" {
    pub fn __percpu_init_rwsem(
        arg1: *mut percpu_rw_semaphore,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut lock_class_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn percpu_free_rwsem(arg1: *mut percpu_rw_semaphore);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct delayed_call {
    pub fn_: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_delayed_call() {
    assert_eq!(
        ::std::mem::size_of::<delayed_call>(),
        16usize,
        concat!("Size of: ", stringify!(delayed_call))
    );
    assert_eq!(
        ::std::mem::align_of::<delayed_call>(),
        8usize,
        concat!("Alignment of ", stringify!(delayed_call))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<delayed_call>())).fn_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_call),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<delayed_call>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(delayed_call),
            "::",
            stringify!(arg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct guid_t {
    pub b: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_guid_t() {
    assert_eq!(
        ::std::mem::size_of::<guid_t>(),
        16usize,
        concat!("Size of: ", stringify!(guid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<guid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(guid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<guid_t>())).b as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(guid_t), "::", stringify!(b))
    );
}
pub type uuid_le = guid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uuid_t {
    pub b: [__u8; 16usize],
}
#[test]
fn bindgen_test_layout_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uuid_t>())).b as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uuid_t), "::", stringify!(b))
    );
}
extern "C" {
    pub static guid_null: guid_t;
}
extern "C" {
    pub static uuid_null: uuid_t;
}
extern "C" {
    pub fn generate_random_uuid(uuid: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn generate_random_guid(guid: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn guid_gen(u: *mut guid_t);
}
extern "C" {
    pub fn uuid_gen(u: *mut uuid_t);
}
extern "C" {
    pub fn uuid_is_valid(uuid: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub static guid_index: [u8_; 16usize];
}
extern "C" {
    pub static uuid_index: [u8_; 16usize];
}
extern "C" {
    pub fn guid_parse(uuid: *const ::std::os::raw::c_char, u: *mut guid_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uuid_parse(uuid: *const ::std::os::raw::c_char, u: *mut uuid_t)
        -> ::std::os::raw::c_int;
}
pub type errseq_t = u32_;
extern "C" {
    pub fn errseq_set(eseq: *mut errseq_t, err: ::std::os::raw::c_int) -> errseq_t;
}
extern "C" {
    pub fn errseq_sample(eseq: *mut errseq_t) -> errseq_t;
}
extern "C" {
    pub fn errseq_check(eseq: *mut errseq_t, since: errseq_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errseq_check_and_advance(
        eseq: *mut errseq_t,
        since: *mut errseq_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_mutex_setprio(p: *mut task_struct, pi_task: *mut task_struct);
}
extern "C" {
    pub fn rt_mutex_adjust_pi(p: *mut task_struct);
}
extern "C" {
    pub fn normalize_rt_tasks();
}
pub const ICQ_EXITED: ::std::os::raw::c_uint = 4;
pub const ICQ_DESTROYED: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_72 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_cq {
    pub q: *mut request_queue,
    pub ioc: *mut io_context,
    pub __bindgen_anon_1: io_cq__bindgen_ty_1,
    pub __bindgen_anon_2: io_cq__bindgen_ty_2,
    pub flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_1 {
    pub q_node: list_head,
    pub __rcu_icq_cache: *mut kmem_cache,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_io_cq__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<io_cq__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(io_cq__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<io_cq__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(io_cq__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_cq__bindgen_ty_1>())).q_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_1),
            "::",
            stringify!(q_node)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<io_cq__bindgen_ty_1>())).__rcu_icq_cache as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_1),
            "::",
            stringify!(__rcu_icq_cache)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_2 {
    pub ioc_node: hlist_node,
    pub __rcu_head: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_io_cq__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<io_cq__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(io_cq__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<io_cq__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(io_cq__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_cq__bindgen_ty_2>())).ioc_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_2),
            "::",
            stringify!(ioc_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_cq__bindgen_ty_2>())).__rcu_head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq__bindgen_ty_2),
            "::",
            stringify!(__rcu_head)
        )
    );
}
#[test]
fn bindgen_test_layout_io_cq() {
    assert_eq!(
        ::std::mem::size_of::<io_cq>(),
        56usize,
        concat!("Size of: ", stringify!(io_cq))
    );
    assert_eq!(
        ::std::mem::align_of::<io_cq>(),
        8usize,
        concat!("Alignment of ", stringify!(io_cq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_cq>())).q as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(io_cq), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_cq>())).ioc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq),
            "::",
            stringify!(ioc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_cq>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(io_cq),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_context {
    pub refcount: atomic_long_t,
    pub active_ref: atomic_t,
    pub ioprio: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_io_context() {
    assert_eq!(
        ::std::mem::size_of::<io_context>(),
        16usize,
        concat!("Size of: ", stringify!(io_context))
    );
    assert_eq!(
        ::std::mem::align_of::<io_context>(),
        8usize,
        concat!("Alignment of ", stringify!(io_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_context>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_context>())).active_ref as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(active_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<io_context>())).ioprio as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(io_context),
            "::",
            stringify!(ioprio)
        )
    );
}
extern "C" {
    pub fn put_io_context(ioc: *mut io_context);
}
extern "C" {
    pub fn exit_io_context(task: *mut task_struct);
}
extern "C" {
    pub fn __copy_io(
        clone_flags: ::std::os::raw::c_ulong,
        tsk: *mut task_struct,
    ) -> ::std::os::raw::c_int;
}
pub const IOPRIO_CLASS_NONE: ::std::os::raw::c_uint = 0;
pub const IOPRIO_CLASS_RT: ::std::os::raw::c_uint = 1;
pub const IOPRIO_CLASS_BE: ::std::os::raw::c_uint = 2;
pub const IOPRIO_CLASS_IDLE: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_73 = ::std::os::raw::c_uint;
pub const IOPRIO_WHO_PROCESS: ::std::os::raw::c_uint = 1;
pub const IOPRIO_WHO_PGRP: ::std::os::raw::c_uint = 2;
pub const IOPRIO_WHO_USER: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_74 = ::std::os::raw::c_uint;
extern "C" {
    pub fn __get_task_ioprio(p: *mut task_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_task_ioprio(
        task: *mut task_struct,
        ioprio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ioprio_check_cap(ioprio: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fs_ftype_to_dtype(filetype: ::std::os::raw::c_uint) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn fs_umode_to_ftype(mode: umode_t) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn fs_umode_to_dtype(mode: umode_t) -> ::std::os::raw::c_uchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfsmount {
    pub mnt_root: *mut dentry,
    pub mnt_sb: *mut super_block,
    pub mnt_flags: ::std::os::raw::c_int,
    pub mnt_userns: *mut user_namespace,
}
#[test]
fn bindgen_test_layout_vfsmount() {
    assert_eq!(
        ::std::mem::size_of::<vfsmount>(),
        32usize,
        concat!("Size of: ", stringify!(vfsmount))
    );
    assert_eq!(
        ::std::mem::align_of::<vfsmount>(),
        8usize,
        concat!("Alignment of ", stringify!(vfsmount))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfsmount>())).mnt_root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsmount),
            "::",
            stringify!(mnt_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfsmount>())).mnt_sb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsmount),
            "::",
            stringify!(mnt_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfsmount>())).mnt_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsmount),
            "::",
            stringify!(mnt_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfsmount>())).mnt_userns as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsmount),
            "::",
            stringify!(mnt_userns)
        )
    );
}
extern "C" {
    pub fn mnt_want_write(mnt: *mut vfsmount) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mnt_want_write_file(file: *mut file) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mnt_drop_write(mnt: *mut vfsmount);
}
extern "C" {
    pub fn mnt_drop_write_file(file: *mut file);
}
extern "C" {
    pub fn mntput(mnt: *mut vfsmount);
}
extern "C" {
    pub fn mntget(mnt: *mut vfsmount) -> *mut vfsmount;
}
extern "C" {
    pub fn mnt_clone_internal(path: *const path) -> *mut vfsmount;
}
extern "C" {
    pub fn __mnt_is_readonly(mnt: *mut vfsmount) -> bool_;
}
extern "C" {
    pub fn mnt_may_suid(mnt: *mut vfsmount) -> bool_;
}
extern "C" {
    pub fn clone_private_mount(path: *const path) -> *mut vfsmount;
}
extern "C" {
    pub fn __mnt_want_write(arg1: *mut vfsmount) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mnt_drop_write(arg1: *mut vfsmount);
}
extern "C" {
    pub fn fc_mount(fc: *mut fs_context) -> *mut vfsmount;
}
extern "C" {
    pub fn vfs_create_mount(fc: *mut fs_context) -> *mut vfsmount;
}
extern "C" {
    pub fn vfs_kern_mount(
        type_: *mut file_system_type,
        flags: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut vfsmount;
}
extern "C" {
    pub fn vfs_submount(
        mountpoint: *const dentry,
        type_: *mut file_system_type,
        name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut vfsmount;
}
extern "C" {
    pub fn mnt_set_expiry(mnt: *mut vfsmount, expiry_list: *mut list_head);
}
extern "C" {
    pub fn mark_mounts_for_expiry(mounts: *mut list_head);
}
extern "C" {
    pub fn name_to_dev_t(name: *const ::std::os::raw::c_char) -> dev_t;
}
extern "C" {
    pub fn path_is_mountpoint(path: *const path) -> bool_;
}
extern "C" {
    pub fn our_mnt(mnt: *mut vfsmount) -> bool_;
}
extern "C" {
    pub fn kern_mount(arg1: *mut file_system_type) -> *mut vfsmount;
}
extern "C" {
    pub fn kern_unmount(mnt: *mut vfsmount);
}
extern "C" {
    pub fn may_umount_tree(arg1: *mut vfsmount) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn may_umount(arg1: *mut vfsmount) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_mount(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_ulong,
        arg5: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn collect_mounts(arg1: *const path) -> *mut vfsmount;
}
extern "C" {
    pub fn drop_collected_mounts(arg1: *mut vfsmount);
}
extern "C" {
    pub fn iterate_mounts(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut vfsmount,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut vfsmount,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kern_unmount_array(mnt: *mut *mut vfsmount, num: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfsuid_t {
    pub val: uid_t,
}
#[test]
fn bindgen_test_layout_vfsuid_t() {
    assert_eq!(
        ::std::mem::size_of::<vfsuid_t>(),
        4usize,
        concat!("Size of: ", stringify!(vfsuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vfsuid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(vfsuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfsuid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsuid_t),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfsgid_t {
    pub val: gid_t,
}
#[test]
fn bindgen_test_layout_vfsgid_t() {
    assert_eq!(
        ::std::mem::size_of::<vfsgid_t>(),
        4usize,
        concat!("Size of: ", stringify!(vfsgid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vfsgid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(vfsgid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfsgid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfsgid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type percpu_ref_func_t = ::std::option::Option<unsafe extern "C" fn(arg1: *mut percpu_ref)>;
pub const __PERCPU_REF_ATOMIC: ::std::os::raw::c_uint = 1;
pub const __PERCPU_REF_DEAD: ::std::os::raw::c_uint = 2;
pub const __PERCPU_REF_ATOMIC_DEAD: ::std::os::raw::c_uint = 3;
pub const __PERCPU_REF_FLAG_BITS: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_75 = ::std::os::raw::c_uint;
pub const PERCPU_REF_INIT_ATOMIC: ::std::os::raw::c_uint = 1;
pub const PERCPU_REF_INIT_DEAD: ::std::os::raw::c_uint = 2;
pub const PERCPU_REF_ALLOW_REINIT: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_76 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct percpu_ref_data {
    pub count: atomic_long_t,
    pub release: percpu_ref_func_t,
    pub confirm_switch: percpu_ref_func_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub rcu: callback_head,
    pub ref_: *mut percpu_ref,
}
#[test]
fn bindgen_test_layout_percpu_ref_data() {
    assert_eq!(
        ::std::mem::size_of::<percpu_ref_data>(),
        56usize,
        concat!("Size of: ", stringify!(percpu_ref_data))
    );
    assert_eq!(
        ::std::mem::align_of::<percpu_ref_data>(),
        8usize,
        concat!("Alignment of ", stringify!(percpu_ref_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_ref_data>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref_data),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_ref_data>())).release as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref_data),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_ref_data>())).confirm_switch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref_data),
            "::",
            stringify!(confirm_switch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_ref_data>())).rcu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref_data),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_ref_data>())).ref_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref_data),
            "::",
            stringify!(ref_)
        )
    );
}
impl percpu_ref_data {
    #[inline]
    pub fn force_atomic(&self) -> bool_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_atomic(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_reinit(&self) -> bool_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_allow_reinit(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_atomic: bool_,
        allow_reinit: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_atomic: u8 = unsafe { ::std::mem::transmute(force_atomic) };
            force_atomic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let allow_reinit: u8 = unsafe { ::std::mem::transmute(allow_reinit) };
            allow_reinit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct percpu_ref {
    pub percpu_count_ptr: ::std::os::raw::c_ulong,
    pub data: *mut percpu_ref_data,
}
#[test]
fn bindgen_test_layout_percpu_ref() {
    assert_eq!(
        ::std::mem::size_of::<percpu_ref>(),
        16usize,
        concat!("Size of: ", stringify!(percpu_ref))
    );
    assert_eq!(
        ::std::mem::align_of::<percpu_ref>(),
        8usize,
        concat!("Alignment of ", stringify!(percpu_ref))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_ref>())).percpu_count_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref),
            "::",
            stringify!(percpu_count_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<percpu_ref>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(percpu_ref),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn percpu_ref_init(
        ref_: *mut percpu_ref,
        release: percpu_ref_func_t,
        flags: ::std::os::raw::c_uint,
        gfp: gfp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn percpu_ref_exit(ref_: *mut percpu_ref);
}
extern "C" {
    pub fn percpu_ref_switch_to_atomic(ref_: *mut percpu_ref, confirm_switch: percpu_ref_func_t);
}
extern "C" {
    pub fn percpu_ref_switch_to_atomic_sync(ref_: *mut percpu_ref);
}
extern "C" {
    pub fn percpu_ref_switch_to_percpu(ref_: *mut percpu_ref);
}
extern "C" {
    pub fn percpu_ref_kill_and_confirm(ref_: *mut percpu_ref, confirm_kill: percpu_ref_func_t);
}
extern "C" {
    pub fn percpu_ref_resurrect(ref_: *mut percpu_ref);
}
extern "C" {
    pub fn percpu_ref_reinit(ref_: *mut percpu_ref);
}
extern "C" {
    pub fn percpu_ref_is_zero(ref_: *mut percpu_ref) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slab {
    _unused: [u8; 0],
}
extern "C" {
    pub fn kasan_early_init();
}
extern "C" {
    pub fn kasan_init();
}
pub type kasan_vmalloc_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub static mut init_pkru_value: u32_;
}
extern "C" {
    pub fn kernel_fpu_begin_mask(kfpu_mask: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn kernel_fpu_end();
}
extern "C" {
    pub fn irq_fpu_usable() -> bool_;
}
extern "C" {
    pub fn fpregs_mark_activate();
}
extern "C" {
    pub fn fpregs_assert_state_consistent();
}
extern "C" {
    pub fn switch_fpu_return();
}
extern "C" {
    pub fn cpu_has_xfeatures(
        xfeatures_mask: u64_,
        feature_name: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fpu__exception_code(
        fpu: *mut fpu,
        trap_nr: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fpu_sync_fpstate(fpu: *mut fpu);
}
extern "C" {
    pub fn fpu_reset_from_exception_fixup();
}
extern "C" {
    pub fn fpu__init_cpu();
}
extern "C" {
    pub fn fpu__init_system(c: *mut cpuinfo_x86);
}
extern "C" {
    pub fn fpu__init_check_bugs();
}
extern "C" {
    pub fn fpu__resume_cpu();
}
extern "C" {
    pub static mut fpu_fpregs_owner_ctx: *mut fpu;
}
extern "C" {
    pub fn fpstate_free(fpu: *mut fpu);
}
extern "C" {
    pub fn fpstate_clear_xstate_component(fps: *mut fpstate, xfeature: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xstate_get_guest_group_perm() -> u64_;
}
extern "C" {
    pub fn fpu_alloc_guest_fpstate(gfpu: *mut fpu_guest) -> bool_;
}
extern "C" {
    pub fn fpu_free_guest_fpstate(gfpu: *mut fpu_guest);
}
extern "C" {
    pub fn fpu_swap_kvm_fpstate(gfpu: *mut fpu_guest, enter_guest: bool_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fpu_enable_guest_xfd_features(
        guest_fpu: *mut fpu_guest,
        xfeatures: u64_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fpu_update_guest_xfd(guest_fpu: *mut fpu_guest, xfd: u64_);
}
extern "C" {
    pub fn fpu_sync_guest_vmexit_xfd_state();
}
extern "C" {
    pub fn fpu_copy_guest_fpstate_to_uabi(
        gfpu: *mut fpu_guest,
        buf: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
        pkru: u32_,
    );
}
extern "C" {
    pub fn fpu_copy_uabi_to_guest_fpstate(
        gfpu: *mut fpu_guest,
        buf: *const ::std::os::raw::c_void,
        xcr0: u64_,
        vpkru: *mut u32_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fpu_xstate_prctl(
        option: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpu_idle_fpregs();
}
pub const cc_vendor_CC_VENDOR_NONE: cc_vendor = 0;
pub const cc_vendor_CC_VENDOR_AMD: cc_vendor = 1;
pub const cc_vendor_CC_VENDOR_HYPERV: cc_vendor = 2;
pub const cc_vendor_CC_VENDOR_INTEL: cc_vendor = 3;
pub type cc_vendor = ::std::os::raw::c_uint;
extern "C" {
    pub fn cc_set_vendor(v: cc_vendor);
}
extern "C" {
    pub fn cc_set_mask(mask: u64_);
}
extern "C" {
    pub static mut early_top_pgt: [pgd_t; 512usize];
}
extern "C" {
    pub fn __early_make_pgtable(address: ::std::os::raw::c_ulong, pmd: pmdval_t) -> bool_;
}
extern "C" {
    pub fn ptdump_walk_pgd_level(m: *mut seq_file, mm: *mut mm_struct);
}
extern "C" {
    pub fn ptdump_walk_pgd_level_debugfs(m: *mut seq_file, mm: *mut mm_struct, user: bool_);
}
extern "C" {
    pub fn ptdump_walk_pgd_level_checkwx();
}
extern "C" {
    pub fn ptdump_walk_user_pgd_level_checkwx();
}
extern "C" {
    pub static mut empty_zero_page: [::std::os::raw::c_ulong; 512usize];
}
extern "C" {
    pub static mut pgd_lock: spinlock_t;
}
extern "C" {
    pub static mut pgd_list: list_head;
}
extern "C" {
    pub fn pgd_page_get_mm(page: *mut page) -> *mut mm_struct;
}
extern "C" {
    pub static mut early_pmd_flags: pmdval_t;
}
extern "C" {
    pub fn populate_extra_pmd(vaddr: ::std::os::raw::c_ulong) -> *mut pmd_t;
}
extern "C" {
    pub fn populate_extra_pte(vaddr: ::std::os::raw::c_ulong) -> *mut pte_t;
}
extern "C" {
    pub fn __pti_set_user_pgtbl(pgdp: *mut pgd_t, pgd: pgd_t) -> pgd_t;
}
pub const vsyscall_num___NR_vgettimeofday: vsyscall_num = 0;
pub const vsyscall_num___NR_vtime: vsyscall_num = 1;
pub const vsyscall_num___NR_vgetcpu: vsyscall_num = 2;
pub type vsyscall_num = ::std::os::raw::c_uint;
pub const fixed_addresses_VSYSCALL_PAGE: fixed_addresses = 511;
pub const fixed_addresses_FIX_DBGP_BASE: fixed_addresses = 512;
pub const fixed_addresses_FIX_EARLYCON_MEM_BASE: fixed_addresses = 513;
pub const fixed_addresses_FIX_OHCI1394_BASE: fixed_addresses = 514;
pub const fixed_addresses_FIX_APIC_BASE: fixed_addresses = 515;
pub const fixed_addresses_FIX_IO_APIC_BASE_0: fixed_addresses = 516;
pub const fixed_addresses_FIX_IO_APIC_BASE_END: fixed_addresses = 643;
pub const fixed_addresses___end_of_permanent_fixed_addresses: fixed_addresses = 644;
pub const fixed_addresses_FIX_BTMAP_END: fixed_addresses = 1024;
pub const fixed_addresses_FIX_BTMAP_BEGIN: fixed_addresses = 1535;
pub const fixed_addresses___end_of_fixed_addresses: fixed_addresses = 1536;
pub type fixed_addresses = ::std::os::raw::c_uint;
extern "C" {
    pub fn reserve_top_address(reserve: ::std::os::raw::c_ulong);
}
extern "C" {
    pub static mut fixmaps_set: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut pkmap_page_table: *mut pte_t;
}
extern "C" {
    pub fn __native_set_fixmap(idx: fixed_addresses, pte: pte_t);
}
extern "C" {
    pub fn native_set_fixmap(idx: ::std::os::raw::c_uint, phys: phys_addr_t, flags: pgprot_t);
}
extern "C" {
    pub fn early_memremap_encrypted(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_memremap_encrypted_wp(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_memremap_decrypted(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn early_memremap_decrypted_wp(
        phys_addr: resource_size_t,
        size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __early_set_fixmap(idx: fixed_addresses, phys: phys_addr_t, flags: pgprot_t);
}
extern "C" {
    pub static mut level4_kernel_pgt: [p4d_t; 512usize];
}
extern "C" {
    pub static mut level4_ident_pgt: [p4d_t; 512usize];
}
extern "C" {
    pub static mut level3_kernel_pgt: [pud_t; 512usize];
}
extern "C" {
    pub static mut level3_ident_pgt: [pud_t; 512usize];
}
extern "C" {
    pub static mut level2_kernel_pgt: [pmd_t; 512usize];
}
extern "C" {
    pub static mut level2_fixmap_pgt: [pmd_t; 512usize];
}
extern "C" {
    pub static mut level2_ident_pgt: [pmd_t; 512usize];
}
extern "C" {
    pub static mut level1_fixmap_pgt: [pte_t; 1024usize];
}
extern "C" {
    pub static mut init_top_pgt: [pgd_t; 0usize];
}
extern "C" {
    pub fn paging_init();
}
extern "C" {
    pub fn set_pte_vaddr_p4d(p4d_page: *mut p4d_t, vaddr: ::std::os::raw::c_ulong, new_pte: pte_t);
}
extern "C" {
    pub fn set_pte_vaddr_pud(pud_page: *mut pud_t, vaddr: ::std::os::raw::c_ulong, new_pte: pte_t);
}
extern "C" {
    pub fn kern_addr_valid(addr: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cleanup_highmap();
}
extern "C" {
    pub fn init_extra_mapping_uc(phys: ::std::os::raw::c_ulong, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn init_extra_mapping_wb(phys: ::std::os::raw::c_ulong, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub static mut direct_gbpages: ::std::os::raw::c_int;
}
extern "C" {
    pub fn init_mem_mapping();
}
extern "C" {
    pub fn early_alloc_pgt_buf();
}
extern "C" {
    pub fn memblock_find_dma_reserve();
}
extern "C" {
    pub fn poking_init();
}
extern "C" {
    pub fn init_memory_mapping(
        start: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
        prot: pgprot_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut trampoline_pgd_entry: pgd_t;
}
extern "C" {
    pub fn ptep_set_access_flags(
        vma: *mut vm_area_struct,
        address: ::std::os::raw::c_ulong,
        ptep: *mut pte_t,
        entry: pte_t,
        dirty: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptep_test_and_clear_young(
        vma: *mut vm_area_struct,
        addr: ::std::os::raw::c_ulong,
        ptep: *mut pte_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptep_clear_flush_young(
        vma: *mut vm_area_struct,
        address: ::std::os::raw::c_ulong,
        ptep: *mut pte_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pmdp_set_access_flags(
        vma: *mut vm_area_struct,
        address: ::std::os::raw::c_ulong,
        pmdp: *mut pmd_t,
        entry: pmd_t,
        dirty: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pudp_set_access_flags(
        vma: *mut vm_area_struct,
        address: ::std::os::raw::c_ulong,
        pudp: *mut pud_t,
        entry: pud_t,
        dirty: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pmdp_test_and_clear_young(
        vma: *mut vm_area_struct,
        addr: ::std::os::raw::c_ulong,
        pmdp: *mut pmd_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pudp_test_and_clear_young(
        vma: *mut vm_area_struct,
        addr: ::std::os::raw::c_ulong,
        pudp: *mut pud_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pmdp_clear_flush_young(
        vma: *mut vm_area_struct,
        address: ::std::os::raw::c_ulong,
        pmdp: *mut pmd_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pmdp_invalidate_ad(
        vma: *mut vm_area_struct,
        address: ::std::os::raw::c_ulong,
        pmdp: *mut pmd_t,
    ) -> pmd_t;
}
extern "C" {
    pub fn pfn_modify_allowed(pfn: ::std::os::raw::c_ulong, prot: pgprot_t) -> bool_;
}
extern "C" {
    pub fn ptep_clear_flush(
        vma: *mut vm_area_struct,
        address: ::std::os::raw::c_ulong,
        ptep: *mut pte_t,
    ) -> pte_t;
}
extern "C" {
    pub fn pmdp_huge_clear_flush(
        vma: *mut vm_area_struct,
        address: ::std::os::raw::c_ulong,
        pmdp: *mut pmd_t,
    ) -> pmd_t;
}
extern "C" {
    pub fn pudp_huge_clear_flush(
        vma: *mut vm_area_struct,
        address: ::std::os::raw::c_ulong,
        pudp: *mut pud_t,
    ) -> pud_t;
}
extern "C" {
    pub fn pgtable_trans_huge_deposit(mm: *mut mm_struct, pmdp: *mut pmd_t, pgtable: pgtable_t);
}
extern "C" {
    pub fn pgtable_trans_huge_withdraw(mm: *mut mm_struct, pmdp: *mut pmd_t) -> pgtable_t;
}
extern "C" {
    pub fn pmdp_invalidate(
        vma: *mut vm_area_struct,
        address: ::std::os::raw::c_ulong,
        pmdp: *mut pmd_t,
    ) -> pmd_t;
}
extern "C" {
    pub fn pgd_clear_bad(arg1: *mut pgd_t);
}
extern "C" {
    pub fn p4d_clear_bad(arg1: *mut p4d_t);
}
extern "C" {
    pub fn pud_clear_bad(arg1: *mut pud_t);
}
extern "C" {
    pub fn pmd_clear_bad(arg1: *mut pmd_t);
}
extern "C" {
    pub fn track_pfn_remap(
        vma: *mut vm_area_struct,
        prot: *mut pgprot_t,
        pfn: ::std::os::raw::c_ulong,
        addr: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn track_pfn_insert(vma: *mut vm_area_struct, prot: *mut pgprot_t, pfn: pfn_t);
}
extern "C" {
    pub fn track_pfn_copy(vma: *mut vm_area_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn untrack_pfn(
        vma: *mut vm_area_struct,
        pfn: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn untrack_pfn_moved(vma: *mut vm_area_struct);
}
extern "C" {
    pub fn p4d_set_huge(
        p4d: *mut p4d_t,
        addr: phys_addr_t,
        prot: pgprot_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn p4d_clear_huge(p4d: *mut p4d_t);
}
extern "C" {
    pub fn pud_set_huge(
        pud: *mut pud_t,
        addr: phys_addr_t,
        prot: pgprot_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pmd_set_huge(
        pmd: *mut pmd_t,
        addr: phys_addr_t,
        prot: pgprot_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pud_clear_huge(pud: *mut pud_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pmd_clear_huge(pmd: *mut pmd_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn p4d_free_pud_page(
        p4d: *mut p4d_t,
        addr: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pud_free_pmd_page(
        pud: *mut pud_t,
        addr: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pmd_free_pte_page(
        pmd: *mut pmd_t,
        addr: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn phys_mem_access_prot_allowed(
        file: *mut file,
        pfn: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
        vma_prot: *mut pgprot_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pgtable_cache_init();
}
pub type pgtbl_mod_mask = ::std::os::raw::c_uint;
extern "C" {
    pub static mut kasan_early_shadow_page: [::std::os::raw::c_uchar; 4096usize];
}
extern "C" {
    pub static mut kasan_early_shadow_pte: [pte_t; 512usize];
}
extern "C" {
    pub static mut kasan_early_shadow_pmd: [pmd_t; 512usize];
}
extern "C" {
    pub static mut kasan_early_shadow_pud: [pud_t; 512usize];
}
extern "C" {
    pub static mut kasan_early_shadow_p4d: [p4d_t; 512usize];
}
extern "C" {
    pub fn kasan_populate_early_shadow(
        shadow_start: *const ::std::os::raw::c_void,
        shadow_end: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kasan_add_zero_shadow(
        start: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kasan_remove_zero_shadow(
        start: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn kasan_enable_current();
}
extern "C" {
    pub fn kasan_disable_current();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kasan_cache {
    pub alloc_meta_offset: ::std::os::raw::c_int,
    pub free_meta_offset: ::std::os::raw::c_int,
    pub is_kmalloc: bool_,
}
#[test]
fn bindgen_test_layout_kasan_cache() {
    assert_eq!(
        ::std::mem::size_of::<kasan_cache>(),
        12usize,
        concat!("Size of: ", stringify!(kasan_cache))
    );
    assert_eq!(
        ::std::mem::align_of::<kasan_cache>(),
        4usize,
        concat!("Alignment of ", stringify!(kasan_cache))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kasan_cache>())).alloc_meta_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kasan_cache),
            "::",
            stringify!(alloc_meta_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kasan_cache>())).free_meta_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kasan_cache),
            "::",
            stringify!(free_meta_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kasan_cache>())).is_kmalloc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kasan_cache),
            "::",
            stringify!(is_kmalloc)
        )
    );
}
extern "C" {
    pub fn __kasan_unpoison_range(addr: *const ::std::os::raw::c_void, size: size_t);
}
extern "C" {
    pub fn __kasan_poison_pages(page: *mut page, order: ::std::os::raw::c_uint, init: bool_);
}
extern "C" {
    pub fn __kasan_unpoison_pages(page: *mut page, order: ::std::os::raw::c_uint, init: bool_);
}
extern "C" {
    pub fn __kasan_cache_create_kmalloc(cache: *mut kmem_cache);
}
extern "C" {
    pub fn __kasan_poison_slab(slab: *mut slab);
}
extern "C" {
    pub fn __kasan_unpoison_object_data(
        cache: *mut kmem_cache,
        object: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __kasan_poison_object_data(cache: *mut kmem_cache, object: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __kasan_init_slab_obj(
        cache: *mut kmem_cache,
        object: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __kasan_slab_free(
        s: *mut kmem_cache,
        object: *mut ::std::os::raw::c_void,
        ip: ::std::os::raw::c_ulong,
        init: bool_,
    ) -> bool_;
}
extern "C" {
    pub fn __kasan_kfree_large(ptr: *mut ::std::os::raw::c_void, ip: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __kasan_slab_free_mempool(ptr: *mut ::std::os::raw::c_void, ip: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __kasan_slab_alloc(
        s: *mut kmem_cache,
        object: *mut ::std::os::raw::c_void,
        flags: gfp_t,
        init: bool_,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __kasan_kmalloc(
        s: *mut kmem_cache,
        object: *const ::std::os::raw::c_void,
        size: size_t,
        flags: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __kasan_kmalloc_large(
        ptr: *const ::std::os::raw::c_void,
        size: size_t,
        flags: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __kasan_krealloc(
        object: *const ::std::os::raw::c_void,
        new_size: size_t,
        flags: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __kasan_check_byte(
        addr: *const ::std::os::raw::c_void,
        ip: ::std::os::raw::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn kasan_unpoison_task_stack(task: *mut task_struct);
}
extern "C" {
    pub fn kasan_metadata_size(cache: *mut kmem_cache) -> size_t;
}
extern "C" {
    pub fn kasan_never_merge() -> slab_flags_t;
}
extern "C" {
    pub fn kasan_cache_create(
        cache: *mut kmem_cache,
        size: *mut ::std::os::raw::c_uint,
        flags: *mut slab_flags_t,
    );
}
extern "C" {
    pub fn kasan_cache_shrink(cache: *mut kmem_cache);
}
extern "C" {
    pub fn kasan_cache_shutdown(cache: *mut kmem_cache);
}
extern "C" {
    pub fn kasan_record_aux_stack(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn kasan_record_aux_stack_noalloc(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn kasan_alloc_module_shadow(
        addr: *mut ::std::os::raw::c_void,
        size: size_t,
        gfp_mask: gfp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kasan_free_module_shadow(vm: *const vm_struct);
}
extern "C" {
    pub fn kmem_cache_init();
}
extern "C" {
    pub fn slab_is_available() -> bool_;
}
extern "C" {
    pub fn kmem_cache_create(
        name: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
        flags: slab_flags_t,
        ctor: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> *mut kmem_cache;
}
extern "C" {
    pub fn kmem_cache_create_usercopy(
        name: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
        flags: slab_flags_t,
        useroffset: ::std::os::raw::c_uint,
        usersize: ::std::os::raw::c_uint,
        ctor: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> *mut kmem_cache;
}
extern "C" {
    pub fn kmem_cache_destroy(s: *mut kmem_cache);
}
extern "C" {
    pub fn kmem_cache_shrink(s: *mut kmem_cache) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn krealloc(
        objp: *const ::std::os::raw::c_void,
        new_size: size_t,
        flags: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kfree(objp: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn kfree_sensitive(objp: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn __ksize(objp: *const ::std::os::raw::c_void) -> size_t;
}
extern "C" {
    #[doc = " ksize - Report actual allocation size of associated object"]
    #[doc = ""]
    #[doc = " @objp: Pointer returned from a prior kmalloc()-family allocation."]
    #[doc = ""]
    #[doc = " This should not be used for writing beyond the originally requested"]
    #[doc = " allocation size. Either use krealloc() or round up the allocation size"]
    #[doc = " with kmalloc_size_roundup() prior to allocation. If this is used to"]
    #[doc = " access beyond the originally requested allocation size, UBSAN_BOUNDS"]
    #[doc = " and/or FORTIFY_SOURCE may trip, since they only know about the"]
    #[doc = " originally allocated size via the __alloc_size attribute."]
    pub fn ksize(objp: *const ::std::os::raw::c_void) -> size_t;
}
extern "C" {
    pub fn kmem_valid_obj(object: *mut ::std::os::raw::c_void) -> bool_;
}
extern "C" {
    pub fn kmem_dump_obj(object: *mut ::std::os::raw::c_void);
}
pub const kmalloc_cache_type_KMALLOC_NORMAL: kmalloc_cache_type = 0;
pub const kmalloc_cache_type_KMALLOC_CGROUP: kmalloc_cache_type = 0;
pub const kmalloc_cache_type_KMALLOC_RECLAIM: kmalloc_cache_type = 1;
pub const kmalloc_cache_type_KMALLOC_DMA: kmalloc_cache_type = 2;
pub const kmalloc_cache_type_NR_KMALLOC_TYPES: kmalloc_cache_type = 3;
pub type kmalloc_cache_type = ::std::os::raw::c_uint;
extern "C" {
    pub static mut kmalloc_caches: [[*mut kmem_cache; 14usize]; 3usize];
}
extern "C" {
    pub fn __kmalloc(size: size_t, flags: gfp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc(s: *mut kmem_cache, flags: gfp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc_lru(
        s: *mut kmem_cache,
        lru: *mut list_lru,
        gfpflags: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_free(s: *mut kmem_cache, objp: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn kmem_cache_free_bulk(
        s: *mut kmem_cache,
        size: size_t,
        p: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn kmem_cache_alloc_bulk(
        s: *mut kmem_cache,
        flags: gfp_t,
        size: size_t,
        p: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __kmalloc_node(
        size: size_t,
        flags: gfp_t,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc_node(
        s: *mut kmem_cache,
        flags: gfp_t,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmalloc_trace(
        s: *mut kmem_cache,
        flags: gfp_t,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmalloc_node_trace(
        s: *mut kmem_cache,
        gfpflags: gfp_t,
        node: ::std::os::raw::c_int,
        size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmalloc_large(size: size_t, flags: gfp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kmalloc_large_node(
        size: size_t,
        flags: gfp_t,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __kmalloc_node_track_caller(
        size: size_t,
        flags: gfp_t,
        node: ::std::os::raw::c_int,
        caller: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kvmalloc_node(
        size: size_t,
        flags: gfp_t,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kvrealloc(
        p: *const ::std::os::raw::c_void,
        oldsize: size_t,
        newsize: size_t,
        flags: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn kvfree(addr: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn kvfree_sensitive(addr: *const ::std::os::raw::c_void, len: size_t);
}
extern "C" {
    pub fn kmem_cache_size(s: *mut kmem_cache) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " kmalloc_size_roundup - Report allocation bucket size for the given size"]
    #[doc = ""]
    #[doc = " @size: Number of bytes to round up from."]
    #[doc = ""]
    #[doc = " This returns the number of bytes that would be available in a kmalloc()"]
    #[doc = " allocation of @size bytes. For example, a 126 byte request would be"]
    #[doc = " rounded up to the next sized kmalloc bucket, 128 bytes. (This is strictly"]
    #[doc = " for the general-purpose kmalloc()-based allocations, and is not for the"]
    #[doc = " pre-sized kmem_cache_alloc()-based allocations.)"]
    #[doc = ""]
    #[doc = " Use this to kmalloc() the full bucket size ahead of time instead of using"]
    #[doc = " ksize() to query the size after an allocation."]
    pub fn kmalloc_size_roundup(size: size_t) -> size_t;
}
extern "C" {
    pub fn kmem_cache_init_late();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_clone_range {
    pub src_fd: __s64,
    pub src_offset: __u64,
    pub src_length: __u64,
    pub dest_offset: __u64,
}
#[test]
fn bindgen_test_layout_file_clone_range() {
    assert_eq!(
        ::std::mem::size_of::<file_clone_range>(),
        32usize,
        concat!("Size of: ", stringify!(file_clone_range))
    );
    assert_eq!(
        ::std::mem::align_of::<file_clone_range>(),
        8usize,
        concat!("Alignment of ", stringify!(file_clone_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_clone_range>())).src_fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_clone_range),
            "::",
            stringify!(src_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_clone_range>())).src_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_clone_range),
            "::",
            stringify!(src_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_clone_range>())).src_length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_clone_range),
            "::",
            stringify!(src_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_clone_range>())).dest_offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_clone_range),
            "::",
            stringify!(dest_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fstrim_range {
    pub start: __u64,
    pub len: __u64,
    pub minlen: __u64,
}
#[test]
fn bindgen_test_layout_fstrim_range() {
    assert_eq!(
        ::std::mem::size_of::<fstrim_range>(),
        24usize,
        concat!("Size of: ", stringify!(fstrim_range))
    );
    assert_eq!(
        ::std::mem::align_of::<fstrim_range>(),
        8usize,
        concat!("Alignment of ", stringify!(fstrim_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstrim_range>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fstrim_range),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstrim_range>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fstrim_range),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fstrim_range>())).minlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fstrim_range),
            "::",
            stringify!(minlen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_dedupe_range_info {
    pub dest_fd: __s64,
    pub dest_offset: __u64,
    pub bytes_deduped: __u64,
    pub status: __s32,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_file_dedupe_range_info() {
    assert_eq!(
        ::std::mem::size_of::<file_dedupe_range_info>(),
        32usize,
        concat!("Size of: ", stringify!(file_dedupe_range_info))
    );
    assert_eq!(
        ::std::mem::align_of::<file_dedupe_range_info>(),
        8usize,
        concat!("Alignment of ", stringify!(file_dedupe_range_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range_info>())).dest_fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range_info),
            "::",
            stringify!(dest_fd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_dedupe_range_info>())).dest_offset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range_info),
            "::",
            stringify!(dest_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_dedupe_range_info>())).bytes_deduped as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range_info),
            "::",
            stringify!(bytes_deduped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range_info>())).status as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range_info),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range_info>())).reserved as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range_info),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct file_dedupe_range {
    pub src_offset: __u64,
    pub src_length: __u64,
    pub dest_count: __u16,
    pub reserved1: __u16,
    pub reserved2: __u32,
    pub info: __IncompleteArrayField<file_dedupe_range_info>,
}
#[test]
fn bindgen_test_layout_file_dedupe_range() {
    assert_eq!(
        ::std::mem::size_of::<file_dedupe_range>(),
        24usize,
        concat!("Size of: ", stringify!(file_dedupe_range))
    );
    assert_eq!(
        ::std::mem::align_of::<file_dedupe_range>(),
        8usize,
        concat!("Alignment of ", stringify!(file_dedupe_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range>())).src_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range),
            "::",
            stringify!(src_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range>())).src_length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range),
            "::",
            stringify!(src_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range>())).dest_count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range),
            "::",
            stringify!(dest_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range>())).reserved1 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range>())).reserved2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_dedupe_range>())).info as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_dedupe_range),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct files_stat_struct {
    pub nr_files: ::std::os::raw::c_ulong,
    pub nr_free_files: ::std::os::raw::c_ulong,
    pub max_files: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_files_stat_struct() {
    assert_eq!(
        ::std::mem::size_of::<files_stat_struct>(),
        24usize,
        concat!("Size of: ", stringify!(files_stat_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<files_stat_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(files_stat_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<files_stat_struct>())).nr_files as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(files_stat_struct),
            "::",
            stringify!(nr_files)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<files_stat_struct>())).nr_free_files as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(files_stat_struct),
            "::",
            stringify!(nr_free_files)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<files_stat_struct>())).max_files as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(files_stat_struct),
            "::",
            stringify!(max_files)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inodes_stat_t {
    pub nr_inodes: ::std::os::raw::c_long,
    pub nr_unused: ::std::os::raw::c_long,
    pub dummy: [::std::os::raw::c_long; 5usize],
}
#[test]
fn bindgen_test_layout_inodes_stat_t() {
    assert_eq!(
        ::std::mem::size_of::<inodes_stat_t>(),
        56usize,
        concat!("Size of: ", stringify!(inodes_stat_t))
    );
    assert_eq!(
        ::std::mem::align_of::<inodes_stat_t>(),
        8usize,
        concat!("Alignment of ", stringify!(inodes_stat_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inodes_stat_t>())).nr_inodes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inodes_stat_t),
            "::",
            stringify!(nr_inodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inodes_stat_t>())).nr_unused as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(inodes_stat_t),
            "::",
            stringify!(nr_unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inodes_stat_t>())).dummy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(inodes_stat_t),
            "::",
            stringify!(dummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsxattr {
    pub fsx_xflags: __u32,
    pub fsx_extsize: __u32,
    pub fsx_nextents: __u32,
    pub fsx_projid: __u32,
    pub fsx_cowextsize: __u32,
    pub fsx_pad: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_fsxattr() {
    assert_eq!(
        ::std::mem::size_of::<fsxattr>(),
        28usize,
        concat!("Size of: ", stringify!(fsxattr))
    );
    assert_eq!(
        ::std::mem::align_of::<fsxattr>(),
        4usize,
        concat!("Alignment of ", stringify!(fsxattr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsxattr>())).fsx_xflags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fsxattr),
            "::",
            stringify!(fsx_xflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsxattr>())).fsx_extsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fsxattr),
            "::",
            stringify!(fsx_extsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsxattr>())).fsx_nextents as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fsxattr),
            "::",
            stringify!(fsx_nextents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsxattr>())).fsx_projid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fsxattr),
            "::",
            stringify!(fsx_projid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsxattr>())).fsx_cowextsize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fsxattr),
            "::",
            stringify!(fsx_cowextsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fsxattr>())).fsx_pad as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fsxattr),
            "::",
            stringify!(fsx_pad)
        )
    );
}
pub type __kernel_rwf_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bdi_writeback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_comp_batch {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct export_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fiemap_extent_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hd_geometry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kobject {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct poll_table_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kstatfs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swap_info_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iov_iter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fscrypt_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsverity_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsverity_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_parameter_spec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fileattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iomap_ops {
    _unused: [u8; 0],
}
extern "C" {
    pub fn inode_init();
}
extern "C" {
    pub fn inode_init_early();
}
extern "C" {
    pub fn files_init();
}
extern "C" {
    pub fn files_maxfiles_init();
}
extern "C" {
    pub fn get_max_files() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub static mut sysctl_nr_open: ::std::os::raw::c_uint;
}
pub type rwf_t = __kernel_rwf_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buffer_head {
    _unused: [u8; 0],
}
pub type get_block_t = ::std::option::Option<
    unsafe extern "C" fn(
        inode: *mut inode,
        iblock: sector_t,
        bh_result: *mut buffer_head,
        create: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type dio_iodone_t = ::std::option::Option<
    unsafe extern "C" fn(
        iocb: *mut kiocb,
        offset: loff_t,
        bytes: ssize_t,
        private: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iattr {
    pub ia_valid: ::std::os::raw::c_uint,
    pub ia_mode: umode_t,
    pub __bindgen_anon_1: iattr__bindgen_ty_1,
    pub __bindgen_anon_2: iattr__bindgen_ty_2,
    pub ia_size: loff_t,
    pub ia_atime: timespec64,
    pub ia_mtime: timespec64,
    pub ia_ctime: timespec64,
    pub ia_file: *mut file,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iattr__bindgen_ty_1 {
    pub ia_uid: kuid_t,
    pub ia_vfsuid: vfsuid_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_iattr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<iattr__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(iattr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<iattr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(iattr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iattr__bindgen_ty_1>())).ia_uid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr__bindgen_ty_1),
            "::",
            stringify!(ia_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iattr__bindgen_ty_1>())).ia_vfsuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr__bindgen_ty_1),
            "::",
            stringify!(ia_vfsuid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iattr__bindgen_ty_2 {
    pub ia_gid: kgid_t,
    pub ia_vfsgid: vfsgid_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_iattr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<iattr__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(iattr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<iattr__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(iattr__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iattr__bindgen_ty_2>())).ia_gid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr__bindgen_ty_2),
            "::",
            stringify!(ia_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iattr__bindgen_ty_2>())).ia_vfsgid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr__bindgen_ty_2),
            "::",
            stringify!(ia_vfsgid)
        )
    );
}
#[test]
fn bindgen_test_layout_iattr() {
    assert_eq!(
        ::std::mem::size_of::<iattr>(),
        80usize,
        concat!("Size of: ", stringify!(iattr))
    );
    assert_eq!(
        ::std::mem::align_of::<iattr>(),
        8usize,
        concat!("Alignment of ", stringify!(iattr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iattr>())).ia_valid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iattr>())).ia_mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iattr>())).ia_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iattr>())).ia_atime as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iattr>())).ia_mtime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iattr>())).ia_ctime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iattr>())).ia_file as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(iattr),
            "::",
            stringify!(ia_file)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_disk_quota {
    pub d_version: __s8,
    pub d_flags: __s8,
    pub d_fieldmask: __u16,
    pub d_id: __u32,
    pub d_blk_hardlimit: __u64,
    pub d_blk_softlimit: __u64,
    pub d_ino_hardlimit: __u64,
    pub d_ino_softlimit: __u64,
    pub d_bcount: __u64,
    pub d_icount: __u64,
    pub d_itimer: __s32,
    pub d_btimer: __s32,
    pub d_iwarns: __u16,
    pub d_bwarns: __u16,
    pub d_itimer_hi: __s8,
    pub d_btimer_hi: __s8,
    pub d_rtbtimer_hi: __s8,
    pub d_padding2: __s8,
    pub d_rtb_hardlimit: __u64,
    pub d_rtb_softlimit: __u64,
    pub d_rtbcount: __u64,
    pub d_rtbtimer: __s32,
    pub d_rtbwarns: __u16,
    pub d_padding3: __s16,
    pub d_padding4: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_fs_disk_quota() {
    assert_eq!(
        ::std::mem::size_of::<fs_disk_quota>(),
        112usize,
        concat!("Size of: ", stringify!(fs_disk_quota))
    );
    assert_eq!(
        ::std::mem::align_of::<fs_disk_quota>(),
        8usize,
        concat!("Alignment of ", stringify!(fs_disk_quota))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_flags as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_fieldmask as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_fieldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_blk_hardlimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_blk_hardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_blk_softlimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_blk_softlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_ino_hardlimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_ino_hardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_ino_softlimit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_ino_softlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_bcount as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_bcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_icount as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_icount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_itimer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_itimer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_btimer as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_btimer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_iwarns as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_iwarns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_bwarns as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_bwarns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_itimer_hi as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_itimer_hi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_btimer_hi as *const _ as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_btimer_hi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_rtbtimer_hi as *const _ as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_rtbtimer_hi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_padding2 as *const _ as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_padding2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_rtb_hardlimit as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_rtb_hardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_rtb_softlimit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_rtb_softlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_rtbcount as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_rtbcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_rtbtimer as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_rtbtimer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_rtbwarns as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_rtbwarns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_padding3 as *const _ as usize },
        102usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_padding3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_disk_quota>())).d_padding4 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_disk_quota),
            "::",
            stringify!(d_padding4)
        )
    );
}
pub type fs_disk_quota_t = fs_disk_quota;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_qfilestat {
    pub qfs_ino: __u64,
    pub qfs_nblks: __u64,
    pub qfs_nextents: __u32,
}
#[test]
fn bindgen_test_layout_fs_qfilestat() {
    assert_eq!(
        ::std::mem::size_of::<fs_qfilestat>(),
        24usize,
        concat!("Size of: ", stringify!(fs_qfilestat))
    );
    assert_eq!(
        ::std::mem::align_of::<fs_qfilestat>(),
        8usize,
        concat!("Alignment of ", stringify!(fs_qfilestat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_qfilestat>())).qfs_ino as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_qfilestat),
            "::",
            stringify!(qfs_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_qfilestat>())).qfs_nblks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_qfilestat),
            "::",
            stringify!(qfs_nblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_qfilestat>())).qfs_nextents as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_qfilestat),
            "::",
            stringify!(qfs_nextents)
        )
    );
}
pub type fs_qfilestat_t = fs_qfilestat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_quota_stat {
    pub qs_version: __s8,
    pub qs_flags: __u16,
    pub qs_pad: __s8,
    pub qs_uquota: fs_qfilestat_t,
    pub qs_gquota: fs_qfilestat_t,
    pub qs_incoredqs: __u32,
    pub qs_btimelimit: __s32,
    pub qs_itimelimit: __s32,
    pub qs_rtbtimelimit: __s32,
    pub qs_bwarnlimit: __u16,
    pub qs_iwarnlimit: __u16,
}
#[test]
fn bindgen_test_layout_fs_quota_stat() {
    assert_eq!(
        ::std::mem::size_of::<fs_quota_stat>(),
        80usize,
        concat!("Size of: ", stringify!(fs_quota_stat))
    );
    assert_eq!(
        ::std::mem::align_of::<fs_quota_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(fs_quota_stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_stat>())).qs_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_stat),
            "::",
            stringify!(qs_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_stat>())).qs_flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_stat),
            "::",
            stringify!(qs_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_stat>())).qs_pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_stat),
            "::",
            stringify!(qs_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_stat>())).qs_uquota as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_stat),
            "::",
            stringify!(qs_uquota)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_stat>())).qs_gquota as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_stat),
            "::",
            stringify!(qs_gquota)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_stat>())).qs_incoredqs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_stat),
            "::",
            stringify!(qs_incoredqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_stat>())).qs_btimelimit as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_stat),
            "::",
            stringify!(qs_btimelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_stat>())).qs_itimelimit as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_stat),
            "::",
            stringify!(qs_itimelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_stat>())).qs_rtbtimelimit as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_stat),
            "::",
            stringify!(qs_rtbtimelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_stat>())).qs_bwarnlimit as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_stat),
            "::",
            stringify!(qs_bwarnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_stat>())).qs_iwarnlimit as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_stat),
            "::",
            stringify!(qs_iwarnlimit)
        )
    );
}
pub type fs_quota_stat_t = fs_quota_stat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_qfilestatv {
    pub qfs_ino: __u64,
    pub qfs_nblks: __u64,
    pub qfs_nextents: __u32,
    pub qfs_pad: __u32,
}
#[test]
fn bindgen_test_layout_fs_qfilestatv() {
    assert_eq!(
        ::std::mem::size_of::<fs_qfilestatv>(),
        24usize,
        concat!("Size of: ", stringify!(fs_qfilestatv))
    );
    assert_eq!(
        ::std::mem::align_of::<fs_qfilestatv>(),
        8usize,
        concat!("Alignment of ", stringify!(fs_qfilestatv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_qfilestatv>())).qfs_ino as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_qfilestatv),
            "::",
            stringify!(qfs_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_qfilestatv>())).qfs_nblks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_qfilestatv),
            "::",
            stringify!(qfs_nblks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_qfilestatv>())).qfs_nextents as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_qfilestatv),
            "::",
            stringify!(qfs_nextents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_qfilestatv>())).qfs_pad as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_qfilestatv),
            "::",
            stringify!(qfs_pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fs_quota_statv {
    pub qs_version: __s8,
    pub qs_pad1: __u8,
    pub qs_flags: __u16,
    pub qs_incoredqs: __u32,
    pub qs_uquota: fs_qfilestatv,
    pub qs_gquota: fs_qfilestatv,
    pub qs_pquota: fs_qfilestatv,
    pub qs_btimelimit: __s32,
    pub qs_itimelimit: __s32,
    pub qs_rtbtimelimit: __s32,
    pub qs_bwarnlimit: __u16,
    pub qs_iwarnlimit: __u16,
    pub qs_rtbwarnlimit: __u16,
    pub qs_pad3: __u16,
    pub qs_pad4: __u32,
    pub qs_pad2: [__u64; 7usize],
}
#[test]
fn bindgen_test_layout_fs_quota_statv() {
    assert_eq!(
        ::std::mem::size_of::<fs_quota_statv>(),
        160usize,
        concat!("Size of: ", stringify!(fs_quota_statv))
    );
    assert_eq!(
        ::std::mem::align_of::<fs_quota_statv>(),
        8usize,
        concat!("Alignment of ", stringify!(fs_quota_statv))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_pad1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_incoredqs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_incoredqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_uquota as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_uquota)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_gquota as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_gquota)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_pquota as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_pquota)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_btimelimit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_btimelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_itimelimit as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_itimelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_rtbtimelimit as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_rtbtimelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_bwarnlimit as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_bwarnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_iwarnlimit as *const _ as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_iwarnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_rtbwarnlimit as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_rtbwarnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_pad3 as *const _ as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_pad4 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fs_quota_statv>())).qs_pad2 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(fs_quota_statv),
            "::",
            stringify!(qs_pad2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qtree_fmt_operations {
    pub mem2disk_dqblk: ::std::option::Option<
        unsafe extern "C" fn(disk: *mut ::std::os::raw::c_void, dquot: *mut dquot),
    >,
    pub disk2mem_dqblk: ::std::option::Option<
        unsafe extern "C" fn(dquot: *mut dquot, disk: *mut ::std::os::raw::c_void),
    >,
    pub is_id: ::std::option::Option<
        unsafe extern "C" fn(
            disk: *mut ::std::os::raw::c_void,
            dquot: *mut dquot,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_qtree_fmt_operations() {
    assert_eq!(
        ::std::mem::size_of::<qtree_fmt_operations>(),
        24usize,
        concat!("Size of: ", stringify!(qtree_fmt_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<qtree_fmt_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(qtree_fmt_operations))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qtree_fmt_operations>())).mem2disk_dqblk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qtree_fmt_operations),
            "::",
            stringify!(mem2disk_dqblk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qtree_fmt_operations>())).disk2mem_dqblk as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qtree_fmt_operations),
            "::",
            stringify!(disk2mem_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qtree_fmt_operations>())).is_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qtree_fmt_operations),
            "::",
            stringify!(is_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qtree_mem_dqinfo {
    pub dqi_sb: *mut super_block,
    pub dqi_type: ::std::os::raw::c_int,
    pub dqi_blocks: ::std::os::raw::c_uint,
    pub dqi_free_blk: ::std::os::raw::c_uint,
    pub dqi_free_entry: ::std::os::raw::c_uint,
    pub dqi_blocksize_bits: ::std::os::raw::c_uint,
    pub dqi_entry_size: ::std::os::raw::c_uint,
    pub dqi_usable_bs: ::std::os::raw::c_uint,
    pub dqi_qtree_depth: ::std::os::raw::c_uint,
    pub dqi_ops: *const qtree_fmt_operations,
}
#[test]
fn bindgen_test_layout_qtree_mem_dqinfo() {
    assert_eq!(
        ::std::mem::size_of::<qtree_mem_dqinfo>(),
        48usize,
        concat!("Size of: ", stringify!(qtree_mem_dqinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<qtree_mem_dqinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(qtree_mem_dqinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qtree_mem_dqinfo>())).dqi_sb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qtree_mem_dqinfo),
            "::",
            stringify!(dqi_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qtree_mem_dqinfo>())).dqi_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qtree_mem_dqinfo),
            "::",
            stringify!(dqi_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qtree_mem_dqinfo>())).dqi_blocks as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(qtree_mem_dqinfo),
            "::",
            stringify!(dqi_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qtree_mem_dqinfo>())).dqi_free_blk as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qtree_mem_dqinfo),
            "::",
            stringify!(dqi_free_blk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qtree_mem_dqinfo>())).dqi_free_entry as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(qtree_mem_dqinfo),
            "::",
            stringify!(dqi_free_entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qtree_mem_dqinfo>())).dqi_blocksize_bits as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qtree_mem_dqinfo),
            "::",
            stringify!(dqi_blocksize_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qtree_mem_dqinfo>())).dqi_entry_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(qtree_mem_dqinfo),
            "::",
            stringify!(dqi_entry_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qtree_mem_dqinfo>())).dqi_usable_bs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qtree_mem_dqinfo),
            "::",
            stringify!(dqi_usable_bs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<qtree_mem_dqinfo>())).dqi_qtree_depth as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(qtree_mem_dqinfo),
            "::",
            stringify!(dqi_qtree_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qtree_mem_dqinfo>())).dqi_ops as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qtree_mem_dqinfo),
            "::",
            stringify!(dqi_ops)
        )
    );
}
extern "C" {
    pub fn qtree_write_dquot(
        info: *mut qtree_mem_dqinfo,
        dquot: *mut dquot,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qtree_read_dquot(
        info: *mut qtree_mem_dqinfo,
        dquot: *mut dquot,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qtree_delete_dquot(
        info: *mut qtree_mem_dqinfo,
        dquot: *mut dquot,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qtree_release_dquot(
        info: *mut qtree_mem_dqinfo,
        dquot: *mut dquot,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qtree_entry_unused(
        info: *mut qtree_mem_dqinfo,
        disk: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qtree_get_next_id(info: *mut qtree_mem_dqinfo, qid: *mut kqid) -> ::std::os::raw::c_int;
}
pub type projid_t = __kernel_uid32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kprojid_t {
    pub val: projid_t,
}
#[test]
fn bindgen_test_layout_kprojid_t() {
    assert_eq!(
        ::std::mem::size_of::<kprojid_t>(),
        4usize,
        concat!("Size of: ", stringify!(kprojid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<kprojid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(kprojid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kprojid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kprojid_t),
            "::",
            stringify!(val)
        )
    );
}
pub const QIF_BLIMITS_B: ::std::os::raw::c_uint = 0;
pub const QIF_SPACE_B: ::std::os::raw::c_uint = 1;
pub const QIF_ILIMITS_B: ::std::os::raw::c_uint = 2;
pub const QIF_INODES_B: ::std::os::raw::c_uint = 3;
pub const QIF_BTIME_B: ::std::os::raw::c_uint = 4;
pub const QIF_ITIME_B: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_77 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_dqblk {
    pub dqb_bhardlimit: __u64,
    pub dqb_bsoftlimit: __u64,
    pub dqb_curspace: __u64,
    pub dqb_ihardlimit: __u64,
    pub dqb_isoftlimit: __u64,
    pub dqb_curinodes: __u64,
    pub dqb_btime: __u64,
    pub dqb_itime: __u64,
    pub dqb_valid: __u32,
}
#[test]
fn bindgen_test_layout_if_dqblk() {
    assert_eq!(
        ::std::mem::size_of::<if_dqblk>(),
        72usize,
        concat!("Size of: ", stringify!(if_dqblk))
    );
    assert_eq!(
        ::std::mem::align_of::<if_dqblk>(),
        8usize,
        concat!("Alignment of ", stringify!(if_dqblk))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_dqblk>())).dqb_bhardlimit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_dqblk),
            "::",
            stringify!(dqb_bhardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_dqblk>())).dqb_bsoftlimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(if_dqblk),
            "::",
            stringify!(dqb_bsoftlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_dqblk>())).dqb_curspace as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(if_dqblk),
            "::",
            stringify!(dqb_curspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_dqblk>())).dqb_ihardlimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(if_dqblk),
            "::",
            stringify!(dqb_ihardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_dqblk>())).dqb_isoftlimit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(if_dqblk),
            "::",
            stringify!(dqb_isoftlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_dqblk>())).dqb_curinodes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(if_dqblk),
            "::",
            stringify!(dqb_curinodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_dqblk>())).dqb_btime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(if_dqblk),
            "::",
            stringify!(dqb_btime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_dqblk>())).dqb_itime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(if_dqblk),
            "::",
            stringify!(dqb_itime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_dqblk>())).dqb_valid as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(if_dqblk),
            "::",
            stringify!(dqb_valid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_nextdqblk {
    pub dqb_bhardlimit: __u64,
    pub dqb_bsoftlimit: __u64,
    pub dqb_curspace: __u64,
    pub dqb_ihardlimit: __u64,
    pub dqb_isoftlimit: __u64,
    pub dqb_curinodes: __u64,
    pub dqb_btime: __u64,
    pub dqb_itime: __u64,
    pub dqb_valid: __u32,
    pub dqb_id: __u32,
}
#[test]
fn bindgen_test_layout_if_nextdqblk() {
    assert_eq!(
        ::std::mem::size_of::<if_nextdqblk>(),
        72usize,
        concat!("Size of: ", stringify!(if_nextdqblk))
    );
    assert_eq!(
        ::std::mem::align_of::<if_nextdqblk>(),
        8usize,
        concat!("Alignment of ", stringify!(if_nextdqblk))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_nextdqblk>())).dqb_bhardlimit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_nextdqblk),
            "::",
            stringify!(dqb_bhardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_nextdqblk>())).dqb_bsoftlimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(if_nextdqblk),
            "::",
            stringify!(dqb_bsoftlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_nextdqblk>())).dqb_curspace as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(if_nextdqblk),
            "::",
            stringify!(dqb_curspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_nextdqblk>())).dqb_ihardlimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(if_nextdqblk),
            "::",
            stringify!(dqb_ihardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_nextdqblk>())).dqb_isoftlimit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(if_nextdqblk),
            "::",
            stringify!(dqb_isoftlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_nextdqblk>())).dqb_curinodes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(if_nextdqblk),
            "::",
            stringify!(dqb_curinodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_nextdqblk>())).dqb_btime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(if_nextdqblk),
            "::",
            stringify!(dqb_btime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_nextdqblk>())).dqb_itime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(if_nextdqblk),
            "::",
            stringify!(dqb_itime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_nextdqblk>())).dqb_valid as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(if_nextdqblk),
            "::",
            stringify!(dqb_valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_nextdqblk>())).dqb_id as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(if_nextdqblk),
            "::",
            stringify!(dqb_id)
        )
    );
}
pub const DQF_ROOT_SQUASH_B: ::std::os::raw::c_uint = 0;
pub const DQF_SYS_FILE_B: ::std::os::raw::c_uint = 16;
pub const DQF_PRIVATE: ::std::os::raw::c_uint = 17;
pub type _bindgen_ty_78 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_dqinfo {
    pub dqi_bgrace: __u64,
    pub dqi_igrace: __u64,
    pub dqi_flags: __u32,
    pub dqi_valid: __u32,
}
#[test]
fn bindgen_test_layout_if_dqinfo() {
    assert_eq!(
        ::std::mem::size_of::<if_dqinfo>(),
        24usize,
        concat!("Size of: ", stringify!(if_dqinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<if_dqinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(if_dqinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_dqinfo>())).dqi_bgrace as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(if_dqinfo),
            "::",
            stringify!(dqi_bgrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_dqinfo>())).dqi_igrace as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(if_dqinfo),
            "::",
            stringify!(dqi_igrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_dqinfo>())).dqi_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(if_dqinfo),
            "::",
            stringify!(dqi_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<if_dqinfo>())).dqi_valid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(if_dqinfo),
            "::",
            stringify!(dqi_valid)
        )
    );
}
pub const QUOTA_NL_C_UNSPEC: ::std::os::raw::c_uint = 0;
pub const QUOTA_NL_C_WARNING: ::std::os::raw::c_uint = 1;
pub const __QUOTA_NL_C_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_79 = ::std::os::raw::c_uint;
pub const QUOTA_NL_A_UNSPEC: ::std::os::raw::c_uint = 0;
pub const QUOTA_NL_A_QTYPE: ::std::os::raw::c_uint = 1;
pub const QUOTA_NL_A_EXCESS_ID: ::std::os::raw::c_uint = 2;
pub const QUOTA_NL_A_WARNING: ::std::os::raw::c_uint = 3;
pub const QUOTA_NL_A_DEV_MAJOR: ::std::os::raw::c_uint = 4;
pub const QUOTA_NL_A_DEV_MINOR: ::std::os::raw::c_uint = 5;
pub const QUOTA_NL_A_CAUSED_ID: ::std::os::raw::c_uint = 6;
pub const QUOTA_NL_A_PAD: ::std::os::raw::c_uint = 7;
pub const __QUOTA_NL_A_MAX: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_80 = ::std::os::raw::c_uint;
pub const quota_type_USRQUOTA: quota_type = 0;
pub const quota_type_GRPQUOTA: quota_type = 1;
pub const quota_type_PRJQUOTA: quota_type = 2;
pub type quota_type = ::std::os::raw::c_uint;
pub type qid_t = __kernel_uid32_t;
pub type qsize_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kqid {
    pub __bindgen_anon_1: kqid__bindgen_ty_1,
    pub type_: quota_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kqid__bindgen_ty_1 {
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub projid: kprojid_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_kqid__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<kqid__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(kqid__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<kqid__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(kqid__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kqid__bindgen_ty_1>())).uid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid__bindgen_ty_1),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kqid__bindgen_ty_1>())).gid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid__bindgen_ty_1),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kqid__bindgen_ty_1>())).projid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid__bindgen_ty_1),
            "::",
            stringify!(projid)
        )
    );
}
#[test]
fn bindgen_test_layout_kqid() {
    assert_eq!(
        ::std::mem::size_of::<kqid>(),
        8usize,
        concat!("Size of: ", stringify!(kqid))
    );
    assert_eq!(
        ::std::mem::align_of::<kqid>(),
        4usize,
        concat!("Alignment of ", stringify!(kqid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kqid>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(kqid),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    pub fn qid_eq(left: kqid, right: kqid) -> bool_;
}
extern "C" {
    pub fn qid_lt(left: kqid, right: kqid) -> bool_;
}
extern "C" {
    pub fn from_kqid(to: *mut user_namespace, qid: kqid) -> qid_t;
}
extern "C" {
    pub fn from_kqid_munged(to: *mut user_namespace, qid: kqid) -> qid_t;
}
extern "C" {
    pub fn qid_valid(qid: kqid) -> bool_;
}
extern "C" {
    pub static mut dq_data_lock: spinlock_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_dqblk {
    pub dqb_bhardlimit: qsize_t,
    pub dqb_bsoftlimit: qsize_t,
    pub dqb_curspace: qsize_t,
    pub dqb_rsvspace: qsize_t,
    pub dqb_ihardlimit: qsize_t,
    pub dqb_isoftlimit: qsize_t,
    pub dqb_curinodes: qsize_t,
    pub dqb_btime: time64_t,
    pub dqb_itime: time64_t,
}
#[test]
fn bindgen_test_layout_mem_dqblk() {
    assert_eq!(
        ::std::mem::size_of::<mem_dqblk>(),
        72usize,
        concat!("Size of: ", stringify!(mem_dqblk))
    );
    assert_eq!(
        ::std::mem::align_of::<mem_dqblk>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_dqblk))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqblk>())).dqb_bhardlimit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_bhardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqblk>())).dqb_bsoftlimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_bsoftlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqblk>())).dqb_curspace as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_curspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqblk>())).dqb_rsvspace as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_rsvspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqblk>())).dqb_ihardlimit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_ihardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqblk>())).dqb_isoftlimit as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_isoftlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqblk>())).dqb_curinodes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_curinodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqblk>())).dqb_btime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_btime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqblk>())).dqb_itime as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqblk),
            "::",
            stringify!(dqb_itime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mem_dqinfo {
    pub dqi_format: *mut quota_format_type,
    pub dqi_fmt_id: ::std::os::raw::c_int,
    pub dqi_dirty_list: list_head,
    pub dqi_flags: ::std::os::raw::c_ulong,
    pub dqi_bgrace: ::std::os::raw::c_uint,
    pub dqi_igrace: ::std::os::raw::c_uint,
    pub dqi_max_spc_limit: qsize_t,
    pub dqi_max_ino_limit: qsize_t,
    pub dqi_priv: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_mem_dqinfo() {
    assert_eq!(
        ::std::mem::size_of::<mem_dqinfo>(),
        72usize,
        concat!("Size of: ", stringify!(mem_dqinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<mem_dqinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(mem_dqinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqinfo>())).dqi_format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqinfo>())).dqi_fmt_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_fmt_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqinfo>())).dqi_dirty_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_dirty_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqinfo>())).dqi_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqinfo>())).dqi_bgrace as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_bgrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqinfo>())).dqi_igrace as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_igrace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqinfo>())).dqi_max_spc_limit as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_max_spc_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqinfo>())).dqi_max_ino_limit as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_max_ino_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mem_dqinfo>())).dqi_priv as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mem_dqinfo),
            "::",
            stringify!(dqi_priv)
        )
    );
}
pub const DQF_INFO_DIRTY_B: ::std::os::raw::c_uint = 17;
pub type _bindgen_ty_81 = ::std::os::raw::c_uint;
extern "C" {
    pub fn mark_info_dirty(sb: *mut super_block, type_: ::std::os::raw::c_int);
}
pub const DQST_LOOKUPS: ::std::os::raw::c_uint = 0;
pub const DQST_DROPS: ::std::os::raw::c_uint = 1;
pub const DQST_READS: ::std::os::raw::c_uint = 2;
pub const DQST_WRITES: ::std::os::raw::c_uint = 3;
pub const DQST_CACHE_HITS: ::std::os::raw::c_uint = 4;
pub const DQST_ALLOC_DQUOTS: ::std::os::raw::c_uint = 5;
pub const DQST_FREE_DQUOTS: ::std::os::raw::c_uint = 6;
pub const DQST_SYNCS: ::std::os::raw::c_uint = 7;
pub const _DQST_DQSTAT_LAST: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_82 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dqstats {
    pub stat: [::std::os::raw::c_ulong; 8usize],
    pub counter: [percpu_counter; 8usize],
}
#[test]
fn bindgen_test_layout_dqstats() {
    assert_eq!(
        ::std::mem::size_of::<dqstats>(),
        384usize,
        concat!("Size of: ", stringify!(dqstats))
    );
    assert_eq!(
        ::std::mem::align_of::<dqstats>(),
        8usize,
        concat!("Alignment of ", stringify!(dqstats))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dqstats>())).stat as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dqstats),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dqstats>())).counter as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dqstats),
            "::",
            stringify!(counter)
        )
    );
}
extern "C" {
    pub static mut dqstats: dqstats;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dquot {
    pub dq_hash: hlist_node,
    pub dq_inuse: list_head,
    pub dq_free: list_head,
    pub dq_dirty: list_head,
    pub dq_lock: mutex,
    pub dq_dqb_lock: spinlock_t,
    pub dq_count: atomic_t,
    pub dq_sb: *mut super_block,
    pub dq_id: kqid,
    pub dq_off: loff_t,
    pub dq_flags: ::std::os::raw::c_ulong,
    pub dq_dqb: mem_dqblk,
}
#[test]
fn bindgen_test_layout_dquot() {
    assert_eq!(
        ::std::mem::size_of::<dquot>(),
        208usize,
        concat!("Size of: ", stringify!(dquot))
    );
    assert_eq!(
        ::std::mem::align_of::<dquot>(),
        8usize,
        concat!("Alignment of ", stringify!(dquot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot>())).dq_hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot>())).dq_inuse as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_inuse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot>())).dq_free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot>())).dq_dirty as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_dirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot>())).dq_lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot>())).dq_dqb_lock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_dqb_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot>())).dq_count as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot>())).dq_sb as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot>())).dq_id as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot>())).dq_off as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot>())).dq_flags as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot>())).dq_dqb as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot),
            "::",
            stringify!(dq_dqb)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quota_format_ops {
    pub check_quota_file: ::std::option::Option<
        unsafe extern "C" fn(
            sb: *mut super_block,
            type_: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_file_info: ::std::option::Option<
        unsafe extern "C" fn(
            sb: *mut super_block,
            type_: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub write_file_info: ::std::option::Option<
        unsafe extern "C" fn(
            sb: *mut super_block,
            type_: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub free_file_info: ::std::option::Option<
        unsafe extern "C" fn(
            sb: *mut super_block,
            type_: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_dqblk:
        ::std::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> ::std::os::raw::c_int>,
    pub commit_dqblk:
        ::std::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> ::std::os::raw::c_int>,
    pub release_dqblk:
        ::std::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> ::std::os::raw::c_int>,
    pub get_next_id: ::std::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_quota_format_ops() {
    assert_eq!(
        ::std::mem::size_of::<quota_format_ops>(),
        64usize,
        concat!("Size of: ", stringify!(quota_format_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<quota_format_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(quota_format_ops))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<quota_format_ops>())).check_quota_file as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(check_quota_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_format_ops>())).read_file_info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(read_file_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<quota_format_ops>())).write_file_info as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(write_file_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_format_ops>())).free_file_info as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(free_file_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_format_ops>())).read_dqblk as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(read_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_format_ops>())).commit_dqblk as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(commit_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_format_ops>())).release_dqblk as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(release_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_format_ops>())).get_next_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_ops),
            "::",
            stringify!(get_next_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dquot_operations {
    pub write_dquot:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::std::os::raw::c_int>,
    pub alloc_dquot: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: ::std::os::raw::c_int) -> *mut dquot,
    >,
    pub destroy_dquot: ::std::option::Option<unsafe extern "C" fn(arg1: *mut dquot)>,
    pub acquire_dquot:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::std::os::raw::c_int>,
    pub release_dquot:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::std::os::raw::c_int>,
    pub mark_dirty:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> ::std::os::raw::c_int>,
    pub write_info: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_reserved_space:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut qsize_t>,
    pub get_projid: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut kprojid_t) -> ::std::os::raw::c_int,
    >,
    pub get_inode_usage: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut qsize_t) -> ::std::os::raw::c_int,
    >,
    pub get_next_id: ::std::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_dquot_operations() {
    assert_eq!(
        ::std::mem::size_of::<dquot_operations>(),
        88usize,
        concat!("Size of: ", stringify!(dquot_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<dquot_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(dquot_operations))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot_operations>())).write_dquot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(write_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot_operations>())).alloc_dquot as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(alloc_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot_operations>())).destroy_dquot as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(destroy_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot_operations>())).acquire_dquot as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(acquire_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot_operations>())).release_dquot as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(release_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot_operations>())).mark_dirty as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(mark_dirty)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot_operations>())).write_info as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(write_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dquot_operations>())).get_reserved_space as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_reserved_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot_operations>())).get_projid as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_projid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<dquot_operations>())).get_inode_usage as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_inode_usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dquot_operations>())).get_next_id as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dquot_operations),
            "::",
            stringify!(get_next_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qc_dqblk {
    pub d_fieldmask: ::std::os::raw::c_int,
    pub d_spc_hardlimit: u64_,
    pub d_spc_softlimit: u64_,
    pub d_ino_hardlimit: u64_,
    pub d_ino_softlimit: u64_,
    pub d_space: u64_,
    pub d_ino_count: u64_,
    pub d_ino_timer: s64,
    pub d_spc_timer: s64,
    pub d_ino_warns: ::std::os::raw::c_int,
    pub d_spc_warns: ::std::os::raw::c_int,
    pub d_rt_spc_hardlimit: u64_,
    pub d_rt_spc_softlimit: u64_,
    pub d_rt_space: u64_,
    pub d_rt_spc_timer: s64,
    pub d_rt_spc_warns: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_qc_dqblk() {
    assert_eq!(
        ::std::mem::size_of::<qc_dqblk>(),
        120usize,
        concat!("Size of: ", stringify!(qc_dqblk))
    );
    assert_eq!(
        ::std::mem::align_of::<qc_dqblk>(),
        8usize,
        concat!("Alignment of ", stringify!(qc_dqblk))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_fieldmask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_fieldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_spc_hardlimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_hardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_spc_softlimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_softlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_ino_hardlimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_hardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_ino_softlimit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_softlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_space as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_ino_count as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_ino_timer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_spc_timer as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_ino_warns as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_ino_warns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_spc_warns as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_spc_warns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_rt_spc_hardlimit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_hardlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_rt_spc_softlimit as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_softlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_rt_space as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_rt_spc_timer as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_dqblk>())).d_rt_spc_warns as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_dqblk),
            "::",
            stringify!(d_rt_spc_warns)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qc_type_state {
    pub flags: ::std::os::raw::c_uint,
    pub spc_timelimit: ::std::os::raw::c_uint,
    pub ino_timelimit: ::std::os::raw::c_uint,
    pub rt_spc_timelimit: ::std::os::raw::c_uint,
    pub spc_warnlimit: ::std::os::raw::c_uint,
    pub ino_warnlimit: ::std::os::raw::c_uint,
    pub rt_spc_warnlimit: ::std::os::raw::c_uint,
    pub ino: ::std::os::raw::c_ulonglong,
    pub blocks: blkcnt_t,
    pub nextents: blkcnt_t,
}
#[test]
fn bindgen_test_layout_qc_type_state() {
    assert_eq!(
        ::std::mem::size_of::<qc_type_state>(),
        56usize,
        concat!("Size of: ", stringify!(qc_type_state))
    );
    assert_eq!(
        ::std::mem::align_of::<qc_type_state>(),
        8usize,
        concat!("Alignment of ", stringify!(qc_type_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_type_state>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_type_state>())).spc_timelimit as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_type_state>())).ino_timelimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(ino_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_type_state>())).rt_spc_timelimit as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(rt_spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_type_state>())).spc_warnlimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(spc_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_type_state>())).ino_warnlimit as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(ino_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_type_state>())).rt_spc_warnlimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(rt_spc_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_type_state>())).ino as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_type_state>())).blocks as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_type_state>())).nextents as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_type_state),
            "::",
            stringify!(nextents)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qc_state {
    pub s_incoredqs: ::std::os::raw::c_uint,
    pub s_state: [qc_type_state; 3usize],
}
#[test]
fn bindgen_test_layout_qc_state() {
    assert_eq!(
        ::std::mem::size_of::<qc_state>(),
        176usize,
        concat!("Size of: ", stringify!(qc_state))
    );
    assert_eq!(
        ::std::mem::align_of::<qc_state>(),
        8usize,
        concat!("Alignment of ", stringify!(qc_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_state>())).s_incoredqs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_state),
            "::",
            stringify!(s_incoredqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_state>())).s_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_state),
            "::",
            stringify!(s_state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qc_info {
    pub i_fieldmask: ::std::os::raw::c_int,
    pub i_flags: ::std::os::raw::c_uint,
    pub i_spc_timelimit: ::std::os::raw::c_uint,
    pub i_ino_timelimit: ::std::os::raw::c_uint,
    pub i_rt_spc_timelimit: ::std::os::raw::c_uint,
    pub i_spc_warnlimit: ::std::os::raw::c_uint,
    pub i_ino_warnlimit: ::std::os::raw::c_uint,
    pub i_rt_spc_warnlimit: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_qc_info() {
    assert_eq!(
        ::std::mem::size_of::<qc_info>(),
        32usize,
        concat!("Size of: ", stringify!(qc_info))
    );
    assert_eq!(
        ::std::mem::align_of::<qc_info>(),
        4usize,
        concat!("Alignment of ", stringify!(qc_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_info>())).i_fieldmask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_fieldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_info>())).i_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_info>())).i_spc_timelimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_info>())).i_ino_timelimit as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_ino_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_info>())).i_rt_spc_timelimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_rt_spc_timelimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_info>())).i_spc_warnlimit as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_spc_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_info>())).i_ino_warnlimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_ino_warnlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<qc_info>())).i_rt_spc_warnlimit as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(qc_info),
            "::",
            stringify!(i_rt_spc_warnlimit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quotactl_ops {
    pub quota_on: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *const path,
        ) -> ::std::os::raw::c_int,
    >,
    pub quota_off: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub quota_enable: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub quota_disable: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub quota_sync: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_info: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::std::os::raw::c_int,
            arg3: *mut qc_info,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_dqblk: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_nextdqblk: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut kqid,
            arg3: *mut qc_dqblk,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_dqblk: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_state: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut qc_state) -> ::std::os::raw::c_int,
    >,
    pub rm_xquota: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_quotactl_ops() {
    assert_eq!(
        ::std::mem::size_of::<quotactl_ops>(),
        88usize,
        concat!("Size of: ", stringify!(quotactl_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<quotactl_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(quotactl_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quotactl_ops>())).quota_on as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_on)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quotactl_ops>())).quota_off as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quotactl_ops>())).quota_enable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quotactl_ops>())).quota_disable as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_disable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quotactl_ops>())).quota_sync as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(quota_sync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quotactl_ops>())).set_info as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(set_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quotactl_ops>())).get_dqblk as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(get_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quotactl_ops>())).get_nextdqblk as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(get_nextdqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quotactl_ops>())).set_dqblk as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(set_dqblk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quotactl_ops>())).get_state as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(get_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quotactl_ops>())).rm_xquota as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(quotactl_ops),
            "::",
            stringify!(rm_xquota)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quota_format_type {
    pub qf_fmt_id: ::std::os::raw::c_int,
    pub qf_ops: *const quota_format_ops,
    pub qf_owner: *mut module,
    pub qf_next: *mut quota_format_type,
}
#[test]
fn bindgen_test_layout_quota_format_type() {
    assert_eq!(
        ::std::mem::size_of::<quota_format_type>(),
        32usize,
        concat!("Size of: ", stringify!(quota_format_type))
    );
    assert_eq!(
        ::std::mem::align_of::<quota_format_type>(),
        8usize,
        concat!("Alignment of ", stringify!(quota_format_type))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_format_type>())).qf_fmt_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_fmt_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_format_type>())).qf_ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_format_type>())).qf_owner as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_format_type>())).qf_next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_format_type),
            "::",
            stringify!(qf_next)
        )
    );
}
pub const _DQUOT_USAGE_ENABLED: ::std::os::raw::c_uint = 0;
pub const _DQUOT_LIMITS_ENABLED: ::std::os::raw::c_uint = 1;
pub const _DQUOT_SUSPENDED: ::std::os::raw::c_uint = 2;
pub const _DQUOT_STATE_FLAGS: ::std::os::raw::c_uint = 3;
#[doc = " Quota state flags - they come in three flavors - for users, groups and projects."]
#[doc = ""]
#[doc = " Actual typed flags layout:"]
#[doc = "\t\t\t\tUSRQUOTA\tGRPQUOTA\tPRJQUOTA"]
#[doc = "  DQUOT_USAGE_ENABLED\t\t0x0001\t\t0x0002\t\t0x0004"]
#[doc = "  DQUOT_LIMITS_ENABLED\t0x0008\t\t0x0010\t\t0x0020"]
#[doc = "  DQUOT_SUSPENDED\t\t0x0040\t\t0x0080\t\t0x0100"]
#[doc = ""]
#[doc = " Following bits are used for non-typed flags:"]
#[doc = "  DQUOT_QUOTA_SYS_FILE\t0x0200"]
#[doc = "  DQUOT_NEGATIVE_USAGE\t0x0400"]
#[doc = "  DQUOT_NOLIST_DIRTY\t\t0x0800"]
pub type _bindgen_ty_83 = ::std::os::raw::c_uint;
extern "C" {
    pub fn quota_send_warning(qid: kqid, dev: dev_t, warntype: ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_info {
    pub flags: ::std::os::raw::c_uint,
    pub dqio_sem: rw_semaphore,
    pub files: [*mut inode; 3usize],
    pub info: [mem_dqinfo; 3usize],
    pub ops: [*const quota_format_ops; 3usize],
}
#[test]
fn bindgen_test_layout_quota_info() {
    assert_eq!(
        ::std::mem::size_of::<quota_info>(),
        312usize,
        concat!("Size of: ", stringify!(quota_info))
    );
    assert_eq!(
        ::std::mem::align_of::<quota_info>(),
        8usize,
        concat!("Alignment of ", stringify!(quota_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_info>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_info>())).dqio_sem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(dqio_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_info>())).files as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(files)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_info>())).info as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_info>())).ops as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_info),
            "::",
            stringify!(ops)
        )
    );
}
extern "C" {
    pub fn register_quota_format(fmt: *mut quota_format_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unregister_quota_format(fmt: *mut quota_format_type);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct quota_module_name {
    pub qm_fmt_id: ::std::os::raw::c_int,
    pub qm_mod_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_quota_module_name() {
    assert_eq!(
        ::std::mem::size_of::<quota_module_name>(),
        16usize,
        concat!("Size of: ", stringify!(quota_module_name))
    );
    assert_eq!(
        ::std::mem::align_of::<quota_module_name>(),
        8usize,
        concat!("Alignment of ", stringify!(quota_module_name))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_module_name>())).qm_fmt_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_module_name),
            "::",
            stringify!(qm_fmt_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<quota_module_name>())).qm_mod_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(quota_module_name),
            "::",
            stringify!(qm_mod_name)
        )
    );
}
pub const positive_aop_returns_AOP_WRITEPAGE_ACTIVATE: positive_aop_returns = 524288;
pub const positive_aop_returns_AOP_TRUNCATED_PAGE: positive_aop_returns = 524289;
#[doc = " enum positive_aop_returns - aop return codes with specific semantics"]
#[doc = ""]
#[doc = " @AOP_WRITEPAGE_ACTIVATE: Informs the caller that page writeback has"]
#[doc = " \t\t\t    completed, that the page is still locked, and"]
#[doc = " \t\t\t    should be considered active.  The VM uses this hint"]
#[doc = " \t\t\t    to return the page to the active list -- it won't"]
#[doc = " \t\t\t    be a candidate for writeback again in the near"]
#[doc = " \t\t\t    future.  Other callers must be careful to unlock"]
#[doc = " \t\t\t    the page if they get this return.  Returned by"]
#[doc = " \t\t\t    writepage();"]
#[doc = ""]
#[doc = " @AOP_TRUNCATED_PAGE: The AOP method that was handed a locked page has"]
#[doc = "  \t\t\tunlocked it and the page might have been truncated."]
#[doc = "  \t\t\tThe caller should back up to acquiring a new page and"]
#[doc = "  \t\t\ttrying again.  The aop will be taking reasonable"]
#[doc = "  \t\t\tprecautions not to livelock.  If the caller held a page"]
#[doc = "  \t\t\treference, it should drop it before retrying.  Returned"]
#[doc = "  \t\t\tby read_folio()."]
#[doc = ""]
#[doc = " address_space_operation functions return these large constants to indicate"]
#[doc = " special semantics to the caller.  These are much larger than the bytes in a"]
#[doc = " page to allow for functions that return the number of bytes operated on in a"]
#[doc = " given page."]
pub type positive_aop_returns = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct writeback_control {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct readahead_control {
    _unused: [u8; 0],
}
pub const rw_hint_WRITE_LIFE_NOT_SET: rw_hint = 0;
pub const rw_hint_WRITE_LIFE_NONE: rw_hint = 1;
pub const rw_hint_WRITE_LIFE_SHORT: rw_hint = 2;
pub const rw_hint_WRITE_LIFE_MEDIUM: rw_hint = 3;
pub const rw_hint_WRITE_LIFE_LONG: rw_hint = 4;
pub const rw_hint_WRITE_LIFE_EXTREME: rw_hint = 5;
pub type rw_hint = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kiocb {
    pub ki_filp: *mut file,
    pub ki_pos: loff_t,
    pub ki_complete:
        ::std::option::Option<unsafe extern "C" fn(iocb: *mut kiocb, ret: ::std::os::raw::c_long)>,
    pub private: *mut ::std::os::raw::c_void,
    pub ki_flags: ::std::os::raw::c_int,
    pub ki_ioprio: u16_,
    pub ki_waitq: *mut wait_page_queue,
}
#[test]
fn bindgen_test_layout_kiocb() {
    assert_eq!(
        ::std::mem::size_of::<kiocb>(),
        48usize,
        concat!("Size of: ", stringify!(kiocb))
    );
    assert_eq!(
        ::std::mem::align_of::<kiocb>(),
        8usize,
        concat!("Alignment of ", stringify!(kiocb))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kiocb>())).ki_filp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_filp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kiocb>())).ki_pos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kiocb>())).ki_complete as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_complete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kiocb>())).private as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(private)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kiocb>())).ki_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kiocb>())).ki_ioprio as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_ioprio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<kiocb>())).ki_waitq as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(kiocb),
            "::",
            stringify!(ki_waitq)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct address_space_operations {
    pub writepage: ::std::option::Option<
        unsafe extern "C" fn(page: *mut page, wbc: *mut writeback_control) -> ::std::os::raw::c_int,
    >,
    pub read_folio: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut folio) -> ::std::os::raw::c_int,
    >,
    pub writepages: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            arg2: *mut writeback_control,
        ) -> ::std::os::raw::c_int,
    >,
    pub dirty_folio: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut folio) -> bool_,
    >,
    pub readahead: ::std::option::Option<unsafe extern "C" fn(arg1: *mut readahead_control)>,
    pub write_begin: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            mapping: *mut address_space,
            pos: loff_t,
            len: ::std::os::raw::c_uint,
            pagep: *mut *mut page,
            fsdata: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub write_end: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            mapping: *mut address_space,
            pos: loff_t,
            len: ::std::os::raw::c_uint,
            copied: ::std::os::raw::c_uint,
            page: *mut page,
            fsdata: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub bmap: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: sector_t) -> sector_t,
    >,
    pub invalidate_folio:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut folio, offset: size_t, len: size_t)>,
    pub release_folio:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut folio, arg2: gfp_t) -> bool_>,
    pub free_folio: ::std::option::Option<unsafe extern "C" fn(folio: *mut folio)>,
    pub direct_IO: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, iter: *mut iov_iter) -> ssize_t,
    >,
    pub migrate_folio: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            dst: *mut folio,
            src: *mut folio,
            arg2: migrate_mode,
        ) -> ::std::os::raw::c_int,
    >,
    pub launder_folio:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut folio) -> ::std::os::raw::c_int>,
    pub is_partially_uptodate: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut folio, from: size_t, count: size_t) -> bool_,
    >,
    pub is_dirty_writeback: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut folio, dirty: *mut bool_, wb: *mut bool_),
    >,
    pub error_remove_page: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut page) -> ::std::os::raw::c_int,
    >,
    pub swap_activate: ::std::option::Option<
        unsafe extern "C" fn(
            sis: *mut swap_info_struct,
            file: *mut file,
            span: *mut sector_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub swap_deactivate: ::std::option::Option<unsafe extern "C" fn(file: *mut file)>,
    pub swap_rw: ::std::option::Option<
        unsafe extern "C" fn(iocb: *mut kiocb, iter: *mut iov_iter) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_address_space_operations() {
    assert_eq!(
        ::std::mem::size_of::<address_space_operations>(),
        160usize,
        concat!("Size of: ", stringify!(address_space_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<address_space_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(address_space_operations))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).writepage as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(writepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).read_folio as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(read_folio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).writepages as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(writepages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).dirty_folio as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(dirty_folio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).readahead as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(readahead)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).write_begin as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(write_begin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).write_end as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space_operations>())).bmap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(bmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).invalidate_folio as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(invalidate_folio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).release_folio as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(release_folio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).free_folio as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(free_folio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).direct_IO as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(direct_IO)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).migrate_folio as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(migrate_folio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).launder_folio as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(launder_folio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).is_partially_uptodate as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(is_partially_uptodate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).is_dirty_writeback as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(is_dirty_writeback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).error_remove_page as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(error_remove_page)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).swap_activate as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(swap_activate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).swap_deactivate as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(swap_deactivate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<address_space_operations>())).swap_rw as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space_operations),
            "::",
            stringify!(swap_rw)
        )
    );
}
extern "C" {
    pub static empty_aops: address_space_operations;
}
#[doc = " struct address_space - Contents of a cacheable, mappable object."]
#[doc = " @host: Owner, either the inode or the block_device."]
#[doc = " @i_pages: Cached pages."]
#[doc = " @invalidate_lock: Guards coherency between page cache contents and"]
#[doc = "   file offset->disk block mappings in the filesystem during invalidates."]
#[doc = "   It is also used to block modification of page cache contents through"]
#[doc = "   memory mappings."]
#[doc = " @gfp_mask: Memory allocation flags to use for allocating pages."]
#[doc = " @i_mmap_writable: Number of VM_SHARED mappings."]
#[doc = " @nr_thps: Number of THPs in the pagecache (non-shmem only)."]
#[doc = " @i_mmap: Tree of private and shared mappings."]
#[doc = " @i_mmap_rwsem: Protects @i_mmap and @i_mmap_writable."]
#[doc = " @nrpages: Number of page entries, protected by the i_pages lock."]
#[doc = " @writeback_index: Writeback starts here."]
#[doc = " @a_ops: Methods."]
#[doc = " @flags: Error bits and flags (AS_*)."]
#[doc = " @wb_err: The most recent error which has occurred."]
#[doc = " @private_lock: For use by the owner of the address_space."]
#[doc = " @private_list: For use by the owner of the address_space."]
#[doc = " @private_data: For use by the owner of the address_space."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct address_space {
    pub host: *mut inode,
    pub i_pages: xarray,
    pub invalidate_lock: rw_semaphore,
    pub gfp_mask: gfp_t,
    pub i_mmap_writable: atomic_t,
    pub i_mmap: rb_root_cached,
    pub i_mmap_rwsem: rw_semaphore,
    pub nrpages: ::std::os::raw::c_ulong,
    pub writeback_index: ::std::os::raw::c_ulong,
    pub a_ops: *const address_space_operations,
    pub flags: ::std::os::raw::c_ulong,
    pub wb_err: errseq_t,
    pub private_lock: spinlock_t,
    pub private_list: list_head,
    pub private_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_address_space() {
    assert_eq!(
        ::std::mem::size_of::<address_space>(),
        192usize,
        concat!("Size of: ", stringify!(address_space))
    );
    assert_eq!(
        ::std::mem::align_of::<address_space>(),
        8usize,
        concat!("Alignment of ", stringify!(address_space))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space>())).host as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space>())).i_pages as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(i_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space>())).invalidate_lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(invalidate_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space>())).gfp_mask as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(gfp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space>())).i_mmap_writable as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(i_mmap_writable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space>())).i_mmap as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(i_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space>())).i_mmap_rwsem as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(i_mmap_rwsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space>())).nrpages as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(nrpages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space>())).writeback_index as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(writeback_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space>())).a_ops as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(a_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space>())).flags as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space>())).wb_err as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(wb_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space>())).private_lock as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(private_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space>())).private_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(private_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<address_space>())).private_data as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(address_space),
            "::",
            stringify!(private_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_acl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsnotify_mark_connector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inode {
    pub i_mode: umode_t,
    pub i_opflags: ::std::os::raw::c_ushort,
    pub i_uid: kuid_t,
    pub i_gid: kgid_t,
    pub i_flags: ::std::os::raw::c_uint,
    pub i_acl: *mut posix_acl,
    pub i_default_acl: *mut posix_acl,
    pub i_op: *const inode_operations,
    pub i_sb: *mut super_block,
    pub i_mapping: *mut address_space,
    pub i_security: *mut ::std::os::raw::c_void,
    pub i_ino: ::std::os::raw::c_ulong,
    pub __bindgen_anon_1: inode__bindgen_ty_1,
    pub i_rdev: dev_t,
    pub i_size: loff_t,
    pub i_atime: timespec64,
    pub i_mtime: timespec64,
    pub i_ctime: timespec64,
    pub i_lock: spinlock_t,
    pub i_bytes: ::std::os::raw::c_ushort,
    pub i_blkbits: u8_,
    pub i_write_hint: u8_,
    pub i_blocks: blkcnt_t,
    pub i_state: ::std::os::raw::c_ulong,
    pub i_rwsem: rw_semaphore,
    pub dirtied_when: ::std::os::raw::c_ulong,
    pub dirtied_time_when: ::std::os::raw::c_ulong,
    pub i_hash: hlist_node,
    pub i_io_list: list_head,
    pub i_lru: list_head,
    pub i_sb_list: list_head,
    pub i_wb_list: list_head,
    pub __bindgen_anon_2: inode__bindgen_ty_2,
    pub i_version: atomic64_t,
    pub i_sequence: atomic64_t,
    pub i_count: atomic_t,
    pub i_dio_count: atomic_t,
    pub i_writecount: atomic_t,
    pub i_readcount: atomic_t,
    pub __bindgen_anon_3: inode__bindgen_ty_3,
    pub i_flctx: *mut file_lock_context,
    pub i_data: address_space,
    pub i_devices: list_head,
    pub __bindgen_anon_4: inode__bindgen_ty_4,
    pub i_generation: __u32,
    pub i_fsnotify_mask: __u32,
    pub i_fsnotify_marks: *mut fsnotify_mark_connector,
    pub i_private: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_1 {
    pub i_nlink: ::std::os::raw::c_uint,
    pub __i_nlink: ::std::os::raw::c_uint,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_inode__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<inode__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(inode__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<inode__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(inode__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode__bindgen_ty_1>())).i_nlink as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_1),
            "::",
            stringify!(i_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode__bindgen_ty_1>())).__i_nlink as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_1),
            "::",
            stringify!(__i_nlink)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_2 {
    pub i_dentry: hlist_head,
    pub i_rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_inode__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<inode__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(inode__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<inode__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(inode__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode__bindgen_ty_2>())).i_dentry as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_2),
            "::",
            stringify!(i_dentry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode__bindgen_ty_2>())).i_rcu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_2),
            "::",
            stringify!(i_rcu)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_3 {
    pub i_fop: *const file_operations,
    pub free_inode: ::std::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_inode__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<inode__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(inode__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<inode__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(inode__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode__bindgen_ty_3>())).i_fop as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_3),
            "::",
            stringify!(i_fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode__bindgen_ty_3>())).free_inode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_3),
            "::",
            stringify!(free_inode)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_4 {
    pub i_pipe: *mut pipe_inode_info,
    pub i_cdev: *mut cdev,
    pub i_link: *mut ::std::os::raw::c_char,
    pub i_dir_seq: ::std::os::raw::c_uint,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_inode__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<inode__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(inode__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<inode__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(inode__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode__bindgen_ty_4>())).i_pipe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_4),
            "::",
            stringify!(i_pipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode__bindgen_ty_4>())).i_cdev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_4),
            "::",
            stringify!(i_cdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode__bindgen_ty_4>())).i_link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_4),
            "::",
            stringify!(i_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode__bindgen_ty_4>())).i_dir_seq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode__bindgen_ty_4),
            "::",
            stringify!(i_dir_seq)
        )
    );
}
#[test]
fn bindgen_test_layout_inode() {
    assert_eq!(
        ::std::mem::size_of::<inode>(),
        600usize,
        concat!("Size of: ", stringify!(inode))
    );
    assert_eq!(
        ::std::mem::align_of::<inode>(),
        8usize,
        concat!("Alignment of ", stringify!(inode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_opflags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_opflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_acl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_acl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_default_acl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_default_acl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_op as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_sb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_sb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_mapping as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_security as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_ino as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_rdev as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_atime as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_mtime as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_ctime as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_bytes as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_blkbits as *const _ as usize },
        142usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_blkbits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_write_hint as *const _ as usize },
        143usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_write_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_blocks as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_state as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_rwsem as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_rwsem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).dirtied_when as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(dirtied_when)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).dirtied_time_when as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(dirtied_time_when)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_hash as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_io_list as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_io_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_lru as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_sb_list as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_sb_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_wb_list as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_wb_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_version as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_sequence as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_count as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_dio_count as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_dio_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_writecount as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_writecount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_readcount as *const _ as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_readcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_flctx as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_flctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_data as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_devices as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_devices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_generation as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_generation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_fsnotify_mask as *const _ as usize },
        580usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_fsnotify_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_fsnotify_marks as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_fsnotify_marks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode>())).i_private as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(inode),
            "::",
            stringify!(i_private)
        )
    );
}
extern "C" {
    pub fn timestamp_truncate(t: timespec64, inode: *mut inode) -> timespec64;
}
pub const inode_i_mutex_lock_class_I_MUTEX_NORMAL: inode_i_mutex_lock_class = 0;
pub const inode_i_mutex_lock_class_I_MUTEX_PARENT: inode_i_mutex_lock_class = 1;
pub const inode_i_mutex_lock_class_I_MUTEX_CHILD: inode_i_mutex_lock_class = 2;
pub const inode_i_mutex_lock_class_I_MUTEX_XATTR: inode_i_mutex_lock_class = 3;
pub const inode_i_mutex_lock_class_I_MUTEX_NONDIR2: inode_i_mutex_lock_class = 4;
pub const inode_i_mutex_lock_class_I_MUTEX_PARENT2: inode_i_mutex_lock_class = 5;
pub type inode_i_mutex_lock_class = ::std::os::raw::c_uint;
extern "C" {
    pub fn lock_two_nondirectories(arg1: *mut inode, arg2: *mut inode);
}
extern "C" {
    pub fn unlock_two_nondirectories(arg1: *mut inode, arg2: *mut inode);
}
extern "C" {
    pub fn filemap_invalidate_lock_two(mapping1: *mut address_space, mapping2: *mut address_space);
}
extern "C" {
    pub fn filemap_invalidate_unlock_two(
        mapping1: *mut address_space,
        mapping2: *mut address_space,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fown_struct {
    pub lock: rwlock_t,
    pub pid: *mut pid,
    pub pid_type: pid_type,
    pub uid: kuid_t,
    pub euid: kuid_t,
    pub signum: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fown_struct() {
    assert_eq!(
        ::std::mem::size_of::<fown_struct>(),
        32usize,
        concat!("Size of: ", stringify!(fown_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<fown_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(fown_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fown_struct>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fown_struct>())).pid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fown_struct>())).pid_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(pid_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fown_struct>())).uid as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fown_struct>())).euid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(euid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fown_struct>())).signum as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(fown_struct),
            "::",
            stringify!(signum)
        )
    );
}
#[doc = " struct file_ra_state - Track a file's readahead state."]
#[doc = " @start: Where the most recent readahead started."]
#[doc = " @size: Number of pages read in the most recent readahead."]
#[doc = " @async_size: Numer of pages that were/are not needed immediately"]
#[doc = "      and so were/are genuinely \"ahead\".  Start next readahead when"]
#[doc = "      the first of these pages is accessed."]
#[doc = " @ra_pages: Maximum size of a readahead request, copied from the bdi."]
#[doc = " @mmap_miss: How many mmap accesses missed in the page cache."]
#[doc = " @prev_pos: The last byte in the most recent read request."]
#[doc = ""]
#[doc = " When this structure is passed to ->readahead(), the \"most recent\""]
#[doc = " readahead means the current readahead."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_ra_state {
    pub start: ::std::os::raw::c_ulong,
    pub size: ::std::os::raw::c_uint,
    pub async_size: ::std::os::raw::c_uint,
    pub ra_pages: ::std::os::raw::c_uint,
    pub mmap_miss: ::std::os::raw::c_uint,
    pub prev_pos: loff_t,
}
#[test]
fn bindgen_test_layout_file_ra_state() {
    assert_eq!(
        ::std::mem::size_of::<file_ra_state>(),
        32usize,
        concat!("Size of: ", stringify!(file_ra_state))
    );
    assert_eq!(
        ::std::mem::align_of::<file_ra_state>(),
        8usize,
        concat!("Alignment of ", stringify!(file_ra_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_ra_state>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_ra_state>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_ra_state>())).async_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(async_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_ra_state>())).ra_pages as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(ra_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_ra_state>())).mmap_miss as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(mmap_miss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_ra_state>())).prev_pos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_ra_state),
            "::",
            stringify!(prev_pos)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file {
    pub __bindgen_anon_1: file__bindgen_ty_1,
    pub f_path: path,
    pub f_inode: *mut inode,
    pub f_op: *const file_operations,
    pub f_lock: spinlock_t,
    pub f_count: atomic_long_t,
    pub f_flags: ::std::os::raw::c_uint,
    pub f_mode: fmode_t,
    pub f_pos_lock: mutex,
    pub f_pos: loff_t,
    pub f_owner: fown_struct,
    pub f_cred: *const cred,
    pub f_ra: file_ra_state,
    pub f_version: u64_,
    pub f_security: *mut ::std::os::raw::c_void,
    pub private_data: *mut ::std::os::raw::c_void,
    pub f_ep: *mut hlist_head,
    pub f_mapping: *mut address_space,
    pub f_wb_err: errseq_t,
    pub f_sb_err: errseq_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file__bindgen_ty_1 {
    pub f_llist: llist_node,
    pub f_rcuhead: callback_head,
    pub f_iocb_flags: ::std::os::raw::c_uint,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_file__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<file__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(file__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<file__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(file__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file__bindgen_ty_1>())).f_llist as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file__bindgen_ty_1),
            "::",
            stringify!(f_llist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file__bindgen_ty_1>())).f_rcuhead as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file__bindgen_ty_1),
            "::",
            stringify!(f_rcuhead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file__bindgen_ty_1>())).f_iocb_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file__bindgen_ty_1),
            "::",
            stringify!(f_iocb_flags)
        )
    );
}
#[test]
fn bindgen_test_layout_file() {
    assert_eq!(
        ::std::mem::size_of::<file>(),
        232usize,
        concat!("Size of: ", stringify!(file))
    );
    assert_eq!(
        ::std::mem::align_of::<file>(),
        8usize,
        concat!("Alignment of ", stringify!(file))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_path as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_inode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_op as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_lock as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_flags as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_mode as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_pos_lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_pos_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_pos as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_owner as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_cred as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_ra as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_ra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_version as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_security as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).private_data as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_ep as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_ep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_mapping as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_wb_err as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_wb_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file>())).f_sb_err as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(file),
            "::",
            stringify!(f_sb_err)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct file_handle {
    pub handle_bytes: __u32,
    pub handle_type: ::std::os::raw::c_int,
    pub f_handle: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_file_handle() {
    assert_eq!(
        ::std::mem::size_of::<file_handle>(),
        8usize,
        concat!("Size of: ", stringify!(file_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<file_handle>(),
        4usize,
        concat!("Alignment of ", stringify!(file_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_handle>())).handle_bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_handle),
            "::",
            stringify!(handle_bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_handle>())).handle_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(file_handle),
            "::",
            stringify!(handle_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_handle>())).f_handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_handle),
            "::",
            stringify!(f_handle)
        )
    );
}
pub type fl_owner_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_lock_operations {
    pub fl_copy_lock:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut file_lock)>,
    pub fl_release_private: ::std::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>,
}
#[test]
fn bindgen_test_layout_file_lock_operations() {
    assert_eq!(
        ::std::mem::size_of::<file_lock_operations>(),
        16usize,
        concat!("Size of: ", stringify!(file_lock_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<file_lock_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock_operations))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_lock_operations>())).fl_copy_lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_operations),
            "::",
            stringify!(fl_copy_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_lock_operations>())).fl_release_private as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_operations),
            "::",
            stringify!(fl_release_private)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_manager_operations {
    pub lm_mod_owner: *mut ::std::os::raw::c_void,
    pub lm_get_owner: ::std::option::Option<unsafe extern "C" fn(arg1: fl_owner_t) -> fl_owner_t>,
    pub lm_put_owner: ::std::option::Option<unsafe extern "C" fn(arg1: fl_owner_t)>,
    pub lm_notify: ::std::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>,
    pub lm_grant: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_lock,
            arg2: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub lm_break: ::std::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> bool_>,
    pub lm_change: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_lock,
            arg2: ::std::os::raw::c_int,
            arg3: *mut list_head,
        ) -> ::std::os::raw::c_int,
    >,
    pub lm_setup: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut *mut ::std::os::raw::c_void),
    >,
    pub lm_breaker_owns_lease:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> bool_>,
    pub lm_lock_expirable:
        ::std::option::Option<unsafe extern "C" fn(cfl: *mut file_lock) -> bool_>,
    pub lm_expire_lock: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_lock_manager_operations() {
    assert_eq!(
        ::std::mem::size_of::<lock_manager_operations>(),
        88usize,
        concat!("Size of: ", stringify!(lock_manager_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<lock_manager_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(lock_manager_operations))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lock_manager_operations>())).lm_mod_owner as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_mod_owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lock_manager_operations>())).lm_get_owner as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_get_owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lock_manager_operations>())).lm_put_owner as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_put_owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lock_manager_operations>())).lm_notify as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_notify)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lock_manager_operations>())).lm_grant as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_grant)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lock_manager_operations>())).lm_break as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_break)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lock_manager_operations>())).lm_change as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lock_manager_operations>())).lm_setup as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_setup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lock_manager_operations>())).lm_breaker_owns_lease as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_breaker_owns_lease)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lock_manager_operations>())).lm_lock_expirable as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_lock_expirable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lock_manager_operations>())).lm_expire_lock as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager_operations),
            "::",
            stringify!(lm_expire_lock)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_manager {
    pub list: list_head,
    pub block_opens: bool_,
}
#[test]
fn bindgen_test_layout_lock_manager() {
    assert_eq!(
        ::std::mem::size_of::<lock_manager>(),
        24usize,
        concat!("Size of: ", stringify!(lock_manager))
    );
    assert_eq!(
        ::std::mem::align_of::<lock_manager>(),
        8usize,
        concat!("Alignment of ", stringify!(lock_manager))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lock_manager>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lock_manager>())).block_opens as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_manager),
            "::",
            stringify!(block_opens)
        )
    );
}
extern "C" {
    pub fn locks_start_grace(arg1: *mut net, arg2: *mut lock_manager);
}
extern "C" {
    pub fn locks_end_grace(arg1: *mut lock_manager);
}
extern "C" {
    pub fn locks_in_grace(arg1: *mut net) -> bool_;
}
extern "C" {
    pub fn opens_in_grace(arg1: *mut net) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlm_lockowner {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs_lock_info {
    pub state: u32_,
    pub owner: *mut nlm_lockowner,
    pub list: list_head,
}
#[test]
fn bindgen_test_layout_nfs_lock_info() {
    assert_eq!(
        ::std::mem::size_of::<nfs_lock_info>(),
        32usize,
        concat!("Size of: ", stringify!(nfs_lock_info))
    );
    assert_eq!(
        ::std::mem::align_of::<nfs_lock_info>(),
        8usize,
        concat!("Alignment of ", stringify!(nfs_lock_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfs_lock_info>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs_lock_info),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfs_lock_info>())).owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs_lock_info),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfs_lock_info>())).list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs_lock_info),
            "::",
            stringify!(list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_lock_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nfs4_lock_info {
    pub owner: *mut nfs4_lock_state,
}
#[test]
fn bindgen_test_layout_nfs4_lock_info() {
    assert_eq!(
        ::std::mem::size_of::<nfs4_lock_info>(),
        8usize,
        concat!("Size of: ", stringify!(nfs4_lock_info))
    );
    assert_eq!(
        ::std::mem::align_of::<nfs4_lock_info>(),
        8usize,
        concat!("Alignment of ", stringify!(nfs4_lock_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nfs4_lock_info>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nfs4_lock_info),
            "::",
            stringify!(owner)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock {
    pub fl_blocker: *mut file_lock,
    pub fl_list: list_head,
    pub fl_link: hlist_node,
    pub fl_blocked_requests: list_head,
    pub fl_blocked_member: list_head,
    pub fl_owner: fl_owner_t,
    pub fl_flags: ::std::os::raw::c_uint,
    pub fl_type: ::std::os::raw::c_uchar,
    pub fl_pid: ::std::os::raw::c_uint,
    pub fl_link_cpu: ::std::os::raw::c_int,
    pub fl_wait: wait_queue_head_t,
    pub fl_file: *mut file,
    pub fl_start: loff_t,
    pub fl_end: loff_t,
    pub fl_fasync: *mut fasync_struct,
    pub fl_break_time: ::std::os::raw::c_ulong,
    pub fl_downgrade_time: ::std::os::raw::c_ulong,
    pub fl_ops: *const file_lock_operations,
    pub fl_lmops: *const lock_manager_operations,
    pub fl_u: file_lock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file_lock__bindgen_ty_1 {
    pub nfs_fl: nfs_lock_info,
    pub nfs4_fl: nfs4_lock_info,
    pub afs: file_lock__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_lock__bindgen_ty_1__bindgen_ty_1 {
    pub link: list_head,
    pub state: ::std::os::raw::c_int,
    pub debug_id: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_file_lock__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<file_lock__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<file_lock__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_lock__bindgen_ty_1__bindgen_ty_1>())).link as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_lock__bindgen_ty_1__bindgen_ty_1>())).state as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<file_lock__bindgen_ty_1__bindgen_ty_1>())).debug_id as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(debug_id)
        )
    );
}
#[test]
fn bindgen_test_layout_file_lock__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<file_lock__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(file_lock__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<file_lock__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock__bindgen_ty_1>())).nfs_fl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1),
            "::",
            stringify!(nfs_fl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock__bindgen_ty_1>())).nfs4_fl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1),
            "::",
            stringify!(nfs4_fl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock__bindgen_ty_1>())).afs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock__bindgen_ty_1),
            "::",
            stringify!(afs)
        )
    );
}
#[test]
fn bindgen_test_layout_file_lock() {
    assert_eq!(
        ::std::mem::size_of::<file_lock>(),
        216usize,
        concat!("Size of: ", stringify!(file_lock))
    );
    assert_eq!(
        ::std::mem::align_of::<file_lock>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_blocker as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_blocker)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_link as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_blocked_requests as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_blocked_requests)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_blocked_member as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_blocked_member)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_owner as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_type as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_pid as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_link_cpu as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_link_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_wait as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_file as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_start as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_end as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_fasync as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_fasync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_break_time as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_break_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_downgrade_time as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_downgrade_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_ops as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_lmops as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_lmops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock>())).fl_u as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock),
            "::",
            stringify!(fl_u)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock_context {
    pub flc_lock: spinlock_t,
    pub flc_flock: list_head,
    pub flc_posix: list_head,
    pub flc_lease: list_head,
}
#[test]
fn bindgen_test_layout_file_lock_context() {
    assert_eq!(
        ::std::mem::size_of::<file_lock_context>(),
        56usize,
        concat!("Size of: ", stringify!(file_lock_context))
    );
    assert_eq!(
        ::std::mem::align_of::<file_lock_context>(),
        8usize,
        concat!("Alignment of ", stringify!(file_lock_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock_context>())).flc_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock_context>())).flc_flock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_flock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock_context>())).flc_posix as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_posix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<file_lock_context>())).flc_lease as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(file_lock_context),
            "::",
            stringify!(flc_lease)
        )
    );
}
extern "C" {
    pub fn send_sigio(
        fown: *mut fown_struct,
        fd: ::std::os::raw::c_int,
        band: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn fcntl_getlk(
        arg1: *mut file,
        arg2: ::std::os::raw::c_uint,
        arg3: *mut flock,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcntl_setlk(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut file,
        arg3: ::std::os::raw::c_uint,
        arg4: *mut flock,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcntl_setlease(
        fd: ::std::os::raw::c_uint,
        filp: *mut file,
        arg: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcntl_getlease(filp: *mut file) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn locks_free_lock_context(inode: *mut inode);
}
extern "C" {
    pub fn locks_free_lock(fl: *mut file_lock);
}
extern "C" {
    pub fn locks_init_lock(arg1: *mut file_lock);
}
extern "C" {
    pub fn locks_alloc_lock() -> *mut file_lock;
}
extern "C" {
    pub fn locks_copy_lock(arg1: *mut file_lock, arg2: *mut file_lock);
}
extern "C" {
    pub fn locks_copy_conflock(arg1: *mut file_lock, arg2: *mut file_lock);
}
extern "C" {
    pub fn locks_remove_posix(arg1: *mut file, arg2: fl_owner_t);
}
extern "C" {
    pub fn locks_remove_file(arg1: *mut file);
}
extern "C" {
    pub fn locks_release_private(arg1: *mut file_lock);
}
extern "C" {
    pub fn posix_test_lock(arg1: *mut file, arg2: *mut file_lock);
}
extern "C" {
    pub fn posix_lock_file(
        arg1: *mut file,
        arg2: *mut file_lock,
        arg3: *mut file_lock,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn locks_delete_block(arg1: *mut file_lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_test_lock(arg1: *mut file, arg2: *mut file_lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_lock_file(
        arg1: *mut file,
        arg2: ::std::os::raw::c_uint,
        arg3: *mut file_lock,
        arg4: *mut file_lock,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_cancel_lock(filp: *mut file, fl: *mut file_lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn locks_lock_inode_wait(inode: *mut inode, fl: *mut file_lock) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __break_lease(
        inode: *mut inode,
        flags: ::std::os::raw::c_uint,
        type_: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lease_get_mtime(arg1: *mut inode, time: *mut timespec64);
}
extern "C" {
    pub fn generic_setlease(
        arg1: *mut file,
        arg2: ::std::os::raw::c_long,
        arg3: *mut *mut file_lock,
        priv_: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_setlease(
        arg1: *mut file,
        arg2: ::std::os::raw::c_long,
        arg3: *mut *mut file_lock,
        arg4: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lease_modify(
        arg1: *mut file_lock,
        arg2: ::std::os::raw::c_int,
        arg3: *mut list_head,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lease_register_notifier(arg1: *mut notifier_block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lease_unregister_notifier(arg1: *mut notifier_block);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct files_struct {
    _unused: [u8; 0],
}
extern "C" {
    pub fn show_fd_locks(f: *mut seq_file, filp: *mut file, files: *mut files_struct);
}
extern "C" {
    pub fn locks_owner_has_blockers(flctx: *mut file_lock_context, owner: fl_owner_t) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fasync_struct {
    pub fa_lock: rwlock_t,
    pub magic: ::std::os::raw::c_int,
    pub fa_fd: ::std::os::raw::c_int,
    pub fa_next: *mut fasync_struct,
    pub fa_file: *mut file,
    pub fa_rcu: callback_head,
}
#[test]
fn bindgen_test_layout_fasync_struct() {
    assert_eq!(
        ::std::mem::size_of::<fasync_struct>(),
        48usize,
        concat!("Size of: ", stringify!(fasync_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<fasync_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(fasync_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fasync_struct>())).fa_lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fasync_struct>())).magic as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fasync_struct>())).fa_fd as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fasync_struct>())).fa_next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fasync_struct>())).fa_file as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fasync_struct>())).fa_rcu as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fasync_struct),
            "::",
            stringify!(fa_rcu)
        )
    );
}
extern "C" {
    pub fn fasync_helper(
        arg1: ::std::os::raw::c_int,
        arg2: *mut file,
        arg3: ::std::os::raw::c_int,
        arg4: *mut *mut fasync_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fasync_insert_entry(
        arg1: ::std::os::raw::c_int,
        arg2: *mut file,
        arg3: *mut *mut fasync_struct,
        arg4: *mut fasync_struct,
    ) -> *mut fasync_struct;
}
extern "C" {
    pub fn fasync_remove_entry(
        arg1: *mut file,
        arg2: *mut *mut fasync_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fasync_alloc() -> *mut fasync_struct;
}
extern "C" {
    pub fn fasync_free(arg1: *mut fasync_struct);
}
extern "C" {
    pub fn kill_fasync(
        arg1: *mut *mut fasync_struct,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn __f_setown(
        filp: *mut file,
        arg1: *mut pid,
        arg2: pid_type,
        force: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn f_setown(
        filp: *mut file,
        arg: ::std::os::raw::c_ulong,
        force: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn f_delown(filp: *mut file);
}
extern "C" {
    pub fn f_getown(filp: *mut file) -> pid_t;
}
extern "C" {
    pub fn send_sigurg(fown: *mut fown_struct) -> ::std::os::raw::c_int;
}
pub const SB_UNFROZEN: ::std::os::raw::c_uint = 0;
pub const SB_FREEZE_WRITE: ::std::os::raw::c_uint = 1;
pub const SB_FREEZE_PAGEFAULT: ::std::os::raw::c_uint = 2;
pub const SB_FREEZE_FS: ::std::os::raw::c_uint = 3;
pub const SB_FREEZE_COMPLETE: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_84 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sb_writers {
    pub frozen: ::std::os::raw::c_int,
    pub wait_unfrozen: wait_queue_head_t,
    pub rw_sem: [percpu_rw_semaphore; 3usize],
}
#[test]
fn bindgen_test_layout_sb_writers() {
    assert_eq!(
        ::std::mem::size_of::<sb_writers>(),
        320usize,
        concat!("Size of: ", stringify!(sb_writers))
    );
    assert_eq!(
        ::std::mem::align_of::<sb_writers>(),
        8usize,
        concat!("Alignment of ", stringify!(sb_writers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sb_writers>())).frozen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sb_writers),
            "::",
            stringify!(frozen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sb_writers>())).wait_unfrozen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sb_writers),
            "::",
            stringify!(wait_unfrozen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sb_writers>())).rw_sem as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sb_writers),
            "::",
            stringify!(rw_sem)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct super_block {
    pub s_list: list_head,
    pub s_dev: dev_t,
    pub s_blocksize_bits: ::std::os::raw::c_uchar,
    pub s_blocksize: ::std::os::raw::c_ulong,
    pub s_maxbytes: loff_t,
    pub s_type: *mut file_system_type,
    pub s_op: *const super_operations,
    pub dq_op: *const dquot_operations,
    pub s_qcop: *const quotactl_ops,
    pub s_export_op: *const export_operations,
    pub s_flags: ::std::os::raw::c_ulong,
    pub s_iflags: ::std::os::raw::c_ulong,
    pub s_magic: ::std::os::raw::c_ulong,
    pub s_root: *mut dentry,
    pub s_umount: rw_semaphore,
    pub s_count: ::std::os::raw::c_int,
    pub s_active: atomic_t,
    pub s_security: *mut ::std::os::raw::c_void,
    pub s_xattr: *mut *mut xattr_handler,
    pub s_roots: hlist_bl_head,
    pub s_mounts: list_head,
    pub s_bdev: *mut block_device,
    pub s_bdi: *mut backing_dev_info,
    pub s_mtd: *mut mtd_info,
    pub s_instances: hlist_node,
    pub s_quota_types: ::std::os::raw::c_uint,
    pub s_dquot: quota_info,
    pub s_writers: sb_writers,
    pub s_fs_info: *mut ::std::os::raw::c_void,
    pub s_time_gran: u32_,
    pub s_time_min: time64_t,
    pub s_time_max: time64_t,
    pub s_fsnotify_mask: __u32,
    pub s_fsnotify_marks: *mut fsnotify_mark_connector,
    pub s_id: [::std::os::raw::c_char; 32usize],
    pub s_uuid: uuid_t,
    pub s_max_links: ::std::os::raw::c_uint,
    pub s_mode: fmode_t,
    pub s_vfs_rename_mutex: mutex,
    pub s_subtype: *const ::std::os::raw::c_char,
    pub s_d_op: *const dentry_operations,
    pub s_shrink: shrinker,
    pub s_remove_count: atomic_long_t,
    pub s_fsnotify_connectors: atomic_long_t,
    pub s_readonly_remount: ::std::os::raw::c_int,
    pub s_wb_err: errseq_t,
    pub s_dio_done_wq: *mut workqueue_struct,
    pub s_pins: hlist_head,
    pub s_user_ns: *mut user_namespace,
    pub s_dentry_lru: list_lru,
    pub s_inode_lru: list_lru,
    pub rcu: callback_head,
    pub destroy_work: work_struct,
    pub s_sync_lock: mutex,
    pub s_stack_depth: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u32; 11usize],
    pub s_inode_list_lock: spinlock_t,
    pub s_inodes: list_head,
    pub s_inode_wblist_lock: spinlock_t,
    pub s_inodes_wb: list_head,
}
#[test]
fn bindgen_test_layout_super_block() {
    assert_eq!(
        ::std::mem::size_of::<super_block>(),
        1344usize,
        concat!("Size of: ", stringify!(super_block))
    );
    assert_eq!(
        ::std::mem::align_of::<super_block>(),
        64usize,
        concat!("Alignment of ", stringify!(super_block))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_dev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_blocksize_bits as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_blocksize_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_blocksize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_blocksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_maxbytes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_maxbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_type as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_op as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).dq_op as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(dq_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_qcop as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_qcop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_export_op as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_export_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_iflags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_iflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_magic as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_root as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_umount as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_umount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_count as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_active as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_security as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_security)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_xattr as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_xattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_roots as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_roots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_mounts as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_mounts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_bdev as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_bdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_bdi as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_bdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_mtd as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_mtd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_instances as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_instances)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_quota_types as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_quota_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_dquot as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dquot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_writers as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_writers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_fs_info as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_fs_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_time_gran as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_time_gran)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_time_min as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_time_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_time_max as *const _ as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_time_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_fsnotify_mask as *const _ as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_fsnotify_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_fsnotify_marks as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_fsnotify_marks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_id as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_uuid as *const _ as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_max_links as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_max_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_mode as *const _ as usize },
        980usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_vfs_rename_mutex as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_vfs_rename_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_subtype as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_subtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_d_op as *const _ as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_d_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_shrink as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_shrink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_remove_count as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_remove_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<super_block>())).s_fsnotify_connectors as *const _ as usize
        },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_fsnotify_connectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_readonly_remount as *const _ as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_readonly_remount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_wb_err as *const _ as usize },
        1108usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_wb_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_dio_done_wq as *const _ as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dio_done_wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_pins as *const _ as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_pins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_user_ns as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_user_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_dentry_lru as *const _ as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_dentry_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_inode_lru as *const _ as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inode_lru)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).rcu as *const _ as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).destroy_work as *const _ as usize },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(destroy_work)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_sync_lock as *const _ as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_sync_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_stack_depth as *const _ as usize },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_stack_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_inode_list_lock as *const _ as usize },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inode_list_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_inodes as *const _ as usize },
        1288usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_inode_wblist_lock as *const _ as usize },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inode_wblist_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_block>())).s_inodes_wb as *const _ as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(super_block),
            "::",
            stringify!(s_inodes_wb)
        )
    );
}
extern "C" {
    pub fn current_time(inode: *mut inode) -> timespec64;
}
extern "C" {
    pub fn inode_owner_or_capable(mnt_userns: *mut user_namespace, inode: *const inode) -> bool_;
}
extern "C" {
    pub fn vfs_create(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: umode_t,
        arg5: bool_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_mkdir(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: umode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_mknod(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: umode_t,
        arg5: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_symlink(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_link(
        arg1: *mut dentry,
        arg2: *mut user_namespace,
        arg3: *mut inode,
        arg4: *mut dentry,
        arg5: *mut *mut inode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_rmdir(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: *mut dentry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_unlink(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: *mut *mut inode,
    ) -> ::std::os::raw::c_int;
}
#[doc = " struct renamedata - contains all information required for renaming"]
#[doc = " @old_mnt_userns:    old user namespace of the mount the inode was found from"]
#[doc = " @old_dir:           parent of source"]
#[doc = " @old_dentry:                source"]
#[doc = " @new_mnt_userns:    new user namespace of the mount the inode was found from"]
#[doc = " @new_dir:           parent of destination"]
#[doc = " @new_dentry:                destination"]
#[doc = " @delegated_inode:   returns an inode needing a delegation break"]
#[doc = " @flags:             rename flags"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct renamedata {
    pub old_mnt_userns: *mut user_namespace,
    pub old_dir: *mut inode,
    pub old_dentry: *mut dentry,
    pub new_mnt_userns: *mut user_namespace,
    pub new_dir: *mut inode,
    pub new_dentry: *mut dentry,
    pub delegated_inode: *mut *mut inode,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_renamedata() {
    assert_eq!(
        ::std::mem::size_of::<renamedata>(),
        64usize,
        concat!("Size of: ", stringify!(renamedata))
    );
    assert_eq!(
        ::std::mem::align_of::<renamedata>(),
        8usize,
        concat!("Alignment of ", stringify!(renamedata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<renamedata>())).old_mnt_userns as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(renamedata),
            "::",
            stringify!(old_mnt_userns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<renamedata>())).old_dir as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(renamedata),
            "::",
            stringify!(old_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<renamedata>())).old_dentry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(renamedata),
            "::",
            stringify!(old_dentry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<renamedata>())).new_mnt_userns as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(renamedata),
            "::",
            stringify!(new_mnt_userns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<renamedata>())).new_dir as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(renamedata),
            "::",
            stringify!(new_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<renamedata>())).new_dentry as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(renamedata),
            "::",
            stringify!(new_dentry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<renamedata>())).delegated_inode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(renamedata),
            "::",
            stringify!(delegated_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<renamedata>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(renamedata),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn vfs_rename(arg1: *mut renamedata) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_tmpfile_open(
        mnt_userns: *mut user_namespace,
        parentpath: *const path,
        mode: umode_t,
        open_flag: ::std::os::raw::c_int,
        cred: *const cred,
    ) -> *mut file;
}
extern "C" {
    pub fn vfs_mkobj(
        arg1: *mut dentry,
        arg2: umode_t,
        f: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: umode_t,
                arg3: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_fchown(file: *mut file, user: uid_t, group: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_fchmod(file: *mut file, mode: umode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_utimes(path: *const path, times: *mut timespec64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_ioctl(
        file: *mut file,
        cmd: ::std::os::raw::c_uint,
        arg: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn compat_ptr_ioctl(
        file: *mut file,
        cmd: ::std::os::raw::c_uint,
        arg: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn inode_init_owner(
        mnt_userns: *mut user_namespace,
        inode: *mut inode,
        dir: *const inode,
        mode: umode_t,
    );
}
extern "C" {
    pub fn may_open_dev(path: *const path) -> bool_;
}
extern "C" {
    pub fn mode_strip_sgid(
        mnt_userns: *mut user_namespace,
        dir: *const inode,
        mode: umode_t,
    ) -> umode_t;
}
pub type filldir_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut dir_context,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: loff_t,
        arg5: u64_,
        arg6: ::std::os::raw::c_uint,
    ) -> bool_,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dir_context {
    pub actor: filldir_t,
    pub pos: loff_t,
}
#[test]
fn bindgen_test_layout_dir_context() {
    assert_eq!(
        ::std::mem::size_of::<dir_context>(),
        16usize,
        concat!("Size of: ", stringify!(dir_context))
    );
    assert_eq!(
        ::std::mem::align_of::<dir_context>(),
        8usize,
        concat!("Alignment of ", stringify!(dir_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dir_context>())).actor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dir_context),
            "::",
            stringify!(actor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dir_context>())).pos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dir_context),
            "::",
            stringify!(pos)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_uring_cmd {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct inode_operations {
    pub lookup: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: ::std::os::raw::c_uint,
        ) -> *mut dentry,
    >,
    pub get_link: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut delayed_call,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub permission: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_acl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: ::std::os::raw::c_int,
            arg3: bool_,
        ) -> *mut posix_acl,
    >,
    pub readlink: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
            arg5: bool_,
        ) -> ::std::os::raw::c_int,
    >,
    pub link: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut dentry,
        ) -> ::std::os::raw::c_int,
    >,
    pub unlink: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> ::std::os::raw::c_int,
    >,
    pub symlink: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub mkdir: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub rmdir: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> ::std::os::raw::c_int,
    >,
    pub mknod: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
            arg5: dev_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub rename: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: *mut inode,
            arg5: *mut dentry,
            arg6: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub setattr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut dentry,
            arg3: *mut iattr,
        ) -> ::std::os::raw::c_int,
    >,
    pub getattr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *const path,
            arg3: *mut kstat,
            arg4: u32_,
            arg5: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub listxattr: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut ::std::os::raw::c_char,
            arg3: size_t,
        ) -> ssize_t,
    >,
    pub fiemap: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut fiemap_extent_info,
            start: u64_,
            len: u64_,
        ) -> ::std::os::raw::c_int,
    >,
    pub update_time: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut timespec64,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub atomic_open: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut file,
            open_flag: ::std::os::raw::c_uint,
            create_mode: umode_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub tmpfile: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut file,
            arg4: umode_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub set_acl: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut posix_acl,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub fileattr_set: ::std::option::Option<
        unsafe extern "C" fn(
            mnt_userns: *mut user_namespace,
            dentry: *mut dentry,
            fa: *mut fileattr,
        ) -> ::std::os::raw::c_int,
    >,
    pub fileattr_get: ::std::option::Option<
        unsafe extern "C" fn(dentry: *mut dentry, fa: *mut fileattr) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_inode_operations() {
    assert_eq!(
        ::std::mem::size_of::<inode_operations>(),
        192usize,
        concat!("Size of: ", stringify!(inode_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<inode_operations>(),
        64usize,
        concat!("Alignment of ", stringify!(inode_operations))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).lookup as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).get_link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(get_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).permission as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(permission)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).get_acl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(get_acl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).readlink as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(readlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).create as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).link as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).unlink as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(unlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).symlink as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(symlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).mkdir as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(mkdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).rmdir as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(rmdir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).mknod as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(mknod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).rename as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(rename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).setattr as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(setattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).getattr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(getattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).listxattr as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(listxattr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).fiemap as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(fiemap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).update_time as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(update_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).atomic_open as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(atomic_open)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).tmpfile as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(tmpfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).set_acl as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(set_acl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).fileattr_set as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(fileattr_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<inode_operations>())).fileattr_get as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(inode_operations),
            "::",
            stringify!(fileattr_get)
        )
    );
}
extern "C" {
    pub fn vfs_read(
        arg1: *mut file,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *mut loff_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn vfs_write(
        arg1: *mut file,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *mut loff_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn vfs_copy_file_range(
        arg1: *mut file,
        arg2: loff_t,
        arg3: *mut file,
        arg4: loff_t,
        arg5: size_t,
        arg6: ::std::os::raw::c_uint,
    ) -> ssize_t;
}
extern "C" {
    pub fn generic_copy_file_range(
        file_in: *mut file,
        pos_in: loff_t,
        file_out: *mut file,
        pos_out: loff_t,
        len: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> ssize_t;
}
extern "C" {
    pub fn __generic_remap_file_range_prep(
        file_in: *mut file,
        pos_in: loff_t,
        file_out: *mut file,
        pos_out: loff_t,
        len: *mut loff_t,
        remap_flags: ::std::os::raw::c_uint,
        dax_read_ops: *const iomap_ops,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_remap_file_range_prep(
        file_in: *mut file,
        pos_in: loff_t,
        file_out: *mut file,
        pos_out: loff_t,
        count: *mut loff_t,
        remap_flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_clone_file_range(
        file_in: *mut file,
        pos_in: loff_t,
        file_out: *mut file,
        pos_out: loff_t,
        len: loff_t,
        remap_flags: ::std::os::raw::c_uint,
    ) -> loff_t;
}
extern "C" {
    pub fn vfs_clone_file_range(
        file_in: *mut file,
        pos_in: loff_t,
        file_out: *mut file,
        pos_out: loff_t,
        len: loff_t,
        remap_flags: ::std::os::raw::c_uint,
    ) -> loff_t;
}
extern "C" {
    pub fn vfs_dedupe_file_range(
        file: *mut file,
        same: *mut file_dedupe_range,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_dedupe_file_range_one(
        src_file: *mut file,
        src_pos: loff_t,
        dst_file: *mut file,
        dst_pos: loff_t,
        len: loff_t,
        remap_flags: ::std::os::raw::c_uint,
    ) -> loff_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct super_operations {
    pub alloc_inode:
        ::std::option::Option<unsafe extern "C" fn(sb: *mut super_block) -> *mut inode>,
    pub destroy_inode: ::std::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub free_inode: ::std::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub dirty_inode:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut inode, flags: ::std::os::raw::c_int)>,
    pub write_inode: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            wbc: *mut writeback_control,
        ) -> ::std::os::raw::c_int,
    >,
    pub drop_inode:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> ::std::os::raw::c_int>,
    pub evict_inode: ::std::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub put_super: ::std::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub sync_fs: ::std::option::Option<
        unsafe extern "C" fn(
            sb: *mut super_block,
            wait: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub freeze_super: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block) -> ::std::os::raw::c_int,
    >,
    pub freeze_fs: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block) -> ::std::os::raw::c_int,
    >,
    pub thaw_super: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block) -> ::std::os::raw::c_int,
    >,
    pub unfreeze_fs: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block) -> ::std::os::raw::c_int,
    >,
    pub statfs: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut kstatfs) -> ::std::os::raw::c_int,
    >,
    pub remount_fs: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub umount_begin: ::std::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub show_options: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::std::os::raw::c_int,
    >,
    pub show_devname: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::std::os::raw::c_int,
    >,
    pub show_path: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::std::os::raw::c_int,
    >,
    pub show_stats: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> ::std::os::raw::c_int,
    >,
    pub quota_read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::std::os::raw::c_int,
            arg3: *mut ::std::os::raw::c_char,
            arg4: size_t,
            arg5: loff_t,
        ) -> ssize_t,
    >,
    pub quota_write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_char,
            arg4: size_t,
            arg5: loff_t,
        ) -> ssize_t,
    >,
    pub get_dquots:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut *mut dquot>,
    pub nr_cached_objects: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut shrink_control,
        ) -> ::std::os::raw::c_long,
    >,
    pub free_cached_objects: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut shrink_control,
        ) -> ::std::os::raw::c_long,
    >,
}
#[test]
fn bindgen_test_layout_super_operations() {
    assert_eq!(
        ::std::mem::size_of::<super_operations>(),
        200usize,
        concat!("Size of: ", stringify!(super_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<super_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(super_operations))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).alloc_inode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(alloc_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).destroy_inode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(destroy_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).free_inode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(free_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).dirty_inode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(dirty_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).write_inode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(write_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).drop_inode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(drop_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).evict_inode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(evict_inode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).put_super as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(put_super)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).sync_fs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(sync_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).freeze_super as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(freeze_super)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).freeze_fs as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(freeze_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).thaw_super as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(thaw_super)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).unfreeze_fs as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(unfreeze_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).statfs as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(statfs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).remount_fs as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(remount_fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).umount_begin as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(umount_begin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).show_options as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).show_devname as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_devname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).show_path as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).show_stats as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(show_stats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).quota_read as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(quota_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).quota_write as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(quota_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<super_operations>())).get_dquots as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(get_dquots)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<super_operations>())).nr_cached_objects as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(nr_cached_objects)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<super_operations>())).free_cached_objects as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(super_operations),
            "::",
            stringify!(free_cached_objects)
        )
    );
}
extern "C" {
    pub fn __mark_inode_dirty(arg1: *mut inode, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn inc_nlink(inode: *mut inode);
}
extern "C" {
    pub fn drop_nlink(inode: *mut inode);
}
extern "C" {
    pub fn clear_nlink(inode: *mut inode);
}
extern "C" {
    pub fn set_nlink(inode: *mut inode, nlink: ::std::os::raw::c_uint);
}
pub const file_time_flags_S_ATIME: file_time_flags = 1;
pub const file_time_flags_S_MTIME: file_time_flags = 2;
pub const file_time_flags_S_CTIME: file_time_flags = 4;
pub const file_time_flags_S_VERSION: file_time_flags = 8;
pub type file_time_flags = ::std::os::raw::c_uint;
extern "C" {
    pub fn atime_needs_update(arg1: *const path, arg2: *mut inode) -> bool_;
}
extern "C" {
    pub fn touch_atime(arg1: *const path);
}
extern "C" {
    pub fn inode_update_time(
        inode: *mut inode,
        time: *mut timespec64,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn file_modified(file: *mut file) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kiocb_modified(iocb: *mut kiocb) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync_inode_metadata(
        inode: *mut inode,
        wait: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mount_bdev(
        fs_type: *mut file_system_type,
        flags: ::std::os::raw::c_int,
        dev_name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
        fill_super: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut ::std::os::raw::c_void,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut dentry;
}
extern "C" {
    pub fn mount_single(
        fs_type: *mut file_system_type,
        flags: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        fill_super: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut ::std::os::raw::c_void,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut dentry;
}
extern "C" {
    pub fn mount_nodev(
        fs_type: *mut file_system_type,
        flags: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        fill_super: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut ::std::os::raw::c_void,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut dentry;
}
extern "C" {
    pub fn mount_subtree(mnt: *mut vfsmount, path: *const ::std::os::raw::c_char) -> *mut dentry;
}
extern "C" {
    pub fn retire_super(sb: *mut super_block);
}
extern "C" {
    pub fn generic_shutdown_super(sb: *mut super_block);
}
extern "C" {
    pub fn kill_block_super(sb: *mut super_block);
}
extern "C" {
    pub fn kill_anon_super(sb: *mut super_block);
}
extern "C" {
    pub fn kill_litter_super(sb: *mut super_block);
}
extern "C" {
    pub fn deactivate_super(sb: *mut super_block);
}
extern "C" {
    pub fn deactivate_locked_super(sb: *mut super_block);
}
extern "C" {
    pub fn set_anon_super(
        s: *mut super_block,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_anon_super_fc(s: *mut super_block, fc: *mut fs_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_anon_bdev(arg1: *mut dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn free_anon_bdev(arg1: dev_t);
}
extern "C" {
    pub fn sget_fc(
        fc: *mut fs_context,
        test: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut fs_context,
            ) -> ::std::os::raw::c_int,
        >,
        set: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut fs_context,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut super_block;
}
extern "C" {
    pub fn sget(
        type_: *mut file_system_type,
        test: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        set: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        flags: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut super_block;
}
extern "C" {
    pub fn register_filesystem(arg1: *mut file_system_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unregister_filesystem(arg1: *mut file_system_type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_statfs(arg1: *const path, arg2: *mut kstatfs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn user_statfs(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut kstatfs,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fd_statfs(arg1: ::std::os::raw::c_int, arg2: *mut kstatfs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freeze_super(super_: *mut super_block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn thaw_super(super_: *mut super_block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn super_setup_bdi_name(
        sb: *mut super_block,
        fmt: *mut ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn super_setup_bdi(sb: *mut super_block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn current_umask() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ihold(inode: *mut inode);
}
extern "C" {
    pub fn iput(arg1: *mut inode);
}
extern "C" {
    pub fn generic_update_time(
        arg1: *mut inode,
        arg2: *mut timespec64,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut fs_kobj: *mut kobject;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_names {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct filename {
    pub name: *const ::std::os::raw::c_char,
    pub uptr: *const ::std::os::raw::c_char,
    pub refcnt: ::std::os::raw::c_int,
    pub aname: *mut audit_names,
    pub iname: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_filename() {
    assert_eq!(
        ::std::mem::size_of::<filename>(),
        32usize,
        concat!("Size of: ", stringify!(filename))
    );
    assert_eq!(
        ::std::mem::align_of::<filename>(),
        8usize,
        concat!("Alignment of ", stringify!(filename))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<filename>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(filename),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<filename>())).uptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(filename),
            "::",
            stringify!(uptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<filename>())).refcnt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(filename),
            "::",
            stringify!(refcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<filename>())).aname as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(filename),
            "::",
            stringify!(aname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<filename>())).iname as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(filename),
            "::",
            stringify!(iname)
        )
    );
}
extern "C" {
    pub fn vfs_truncate(arg1: *const path, arg2: loff_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn do_truncate(
        arg1: *mut user_namespace,
        arg2: *mut dentry,
        start: loff_t,
        time_attrs: ::std::os::raw::c_uint,
        filp: *mut file,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_fallocate(
        file: *mut file,
        mode: ::std::os::raw::c_int,
        offset: loff_t,
        len: loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_sys_open(
        dfd: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        mode: umode_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn file_open_name(
        arg1: *mut filename,
        arg2: ::std::os::raw::c_int,
        arg3: umode_t,
    ) -> *mut file;
}
extern "C" {
    pub fn filp_open(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: umode_t,
    ) -> *mut file;
}
extern "C" {
    pub fn file_open_root(
        arg1: *const path,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: umode_t,
    ) -> *mut file;
}
extern "C" {
    pub fn dentry_open(
        arg1: *const path,
        arg2: ::std::os::raw::c_int,
        arg3: *const cred,
    ) -> *mut file;
}
extern "C" {
    pub fn dentry_create(
        path: *const path,
        flags: ::std::os::raw::c_int,
        mode: umode_t,
        cred: *const cred,
    ) -> *mut file;
}
extern "C" {
    pub fn open_with_fake_path(
        arg1: *const path,
        arg2: ::std::os::raw::c_int,
        arg3: *mut inode,
        arg4: *const cred,
    ) -> *mut file;
}
extern "C" {
    pub fn filp_close(arg1: *mut file, id: fl_owner_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getname_flags(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> *mut filename;
}
extern "C" {
    pub fn getname_uflags(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut filename;
}
extern "C" {
    pub fn getname(arg1: *const ::std::os::raw::c_char) -> *mut filename;
}
extern "C" {
    pub fn getname_kernel(arg1: *const ::std::os::raw::c_char) -> *mut filename;
}
extern "C" {
    pub fn putname(name: *mut filename);
}
extern "C" {
    pub fn finish_open(
        file: *mut file,
        dentry: *mut dentry,
        open: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finish_no_open(file: *mut file, dentry: *mut dentry) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_caches_init_early();
}
extern "C" {
    pub fn vfs_caches_init();
}
extern "C" {
    pub static mut names_cachep: *mut kmem_cache;
}
extern "C" {
    pub static mut blockdev_superblock: *mut super_block;
}
extern "C" {
    pub fn emergency_thaw_all();
}
extern "C" {
    pub fn sync_filesystem(arg1: *mut super_block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static def_blk_fops: file_operations;
}
extern "C" {
    pub static def_chr_fops: file_operations;
}
extern "C" {
    pub fn alloc_chrdev_region(
        arg1: *mut dev_t,
        arg2: ::std::os::raw::c_uint,
        arg3: ::std::os::raw::c_uint,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn register_chrdev_region(
        arg1: dev_t,
        arg2: ::std::os::raw::c_uint,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __register_chrdev(
        major: ::std::os::raw::c_uint,
        baseminor: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
        fops: *const file_operations,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __unregister_chrdev(
        major: ::std::os::raw::c_uint,
        baseminor: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn unregister_chrdev_region(arg1: dev_t, arg2: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn chrdev_show(arg1: *mut seq_file, arg2: off_t);
}
extern "C" {
    pub fn init_special_inode(arg1: *mut inode, arg2: umode_t, arg3: dev_t);
}
extern "C" {
    pub fn make_bad_inode(arg1: *mut inode);
}
extern "C" {
    pub fn is_bad_inode(arg1: *mut inode) -> bool_;
}
extern "C" {
    pub fn file_fdatawait_range(
        file: *mut file,
        lstart: loff_t,
        lend: loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn file_check_and_advance_wb_err(file: *mut file) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn file_write_and_wait_range(
        file: *mut file,
        start: loff_t,
        end: loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_fsync_range(
        file: *mut file,
        start: loff_t,
        end: loff_t,
        datasync: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_fsync(file: *mut file, datasync: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync_file_range(
        file: *mut file,
        offset: loff_t,
        nbytes: loff_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn emergency_sync();
}
extern "C" {
    pub fn emergency_remount();
}
extern "C" {
    pub fn bmap(inode: *mut inode, block: *mut sector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn notify_change(
        arg1: *mut user_namespace,
        arg2: *mut dentry,
        arg3: *mut iattr,
        arg4: *mut *mut inode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inode_permission(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_permission(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __check_sticky(
        mnt_userns: *mut user_namespace,
        dir: *mut inode,
        inode: *mut inode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn do_pipe_flags(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kernel_read(
        arg1: *mut file,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
        arg4: *mut loff_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn __kernel_read(
        file: *mut file,
        buf: *mut ::std::os::raw::c_void,
        count: size_t,
        pos: *mut loff_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn kernel_write(
        arg1: *mut file,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
        arg4: *mut loff_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn __kernel_write(
        arg1: *mut file,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
        arg4: *mut loff_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn open_exec(arg1: *const ::std::os::raw::c_char) -> *mut file;
}
extern "C" {
    pub fn is_subdir(arg1: *mut dentry, arg2: *mut dentry) -> bool_;
}
extern "C" {
    pub fn path_is_under(arg1: *const path, arg2: *const path) -> bool_;
}
extern "C" {
    pub fn file_path(
        arg1: *mut file,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn default_llseek(file: *mut file, offset: loff_t, whence: ::std::os::raw::c_int)
        -> loff_t;
}
extern "C" {
    pub fn vfs_llseek(file: *mut file, offset: loff_t, whence: ::std::os::raw::c_int) -> loff_t;
}
extern "C" {
    pub fn inode_init_always(arg1: *mut super_block, arg2: *mut inode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inode_init_once(arg1: *mut inode);
}
extern "C" {
    pub fn address_space_init_once(mapping: *mut address_space);
}
extern "C" {
    pub fn igrab(arg1: *mut inode) -> *mut inode;
}
extern "C" {
    pub fn iunique(arg1: *mut super_block, arg2: ino_t) -> ino_t;
}
extern "C" {
    pub fn inode_needs_sync(inode: *mut inode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_delete_inode(inode: *mut inode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn d_mark_dontcache(inode: *mut inode);
}
extern "C" {
    pub fn ilookup5_nowait(
        sb: *mut super_block,
        hashval: ::std::os::raw::c_ulong,
        test: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn ilookup5(
        sb: *mut super_block,
        hashval: ::std::os::raw::c_ulong,
        test: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn ilookup(sb: *mut super_block, ino: ::std::os::raw::c_ulong) -> *mut inode;
}
extern "C" {
    pub fn inode_insert5(
        inode: *mut inode,
        hashval: ::std::os::raw::c_ulong,
        test: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        set: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn iget5_locked(
        arg1: *mut super_block,
        arg2: ::std::os::raw::c_ulong,
        test: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        set: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn iget_locked(arg1: *mut super_block, arg2: ::std::os::raw::c_ulong) -> *mut inode;
}
extern "C" {
    pub fn find_inode_nowait(
        arg1: *mut super_block,
        arg2: ::std::os::raw::c_ulong,
        match_: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: ::std::os::raw::c_ulong,
                arg3: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn find_inode_rcu(
        arg1: *mut super_block,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn find_inode_by_ino_rcu(
        arg1: *mut super_block,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut inode;
}
extern "C" {
    pub fn insert_inode_locked4(
        arg1: *mut inode,
        arg2: ::std::os::raw::c_ulong,
        test: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn insert_inode_locked(arg1: *mut inode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlock_new_inode(arg1: *mut inode);
}
extern "C" {
    pub fn discard_new_inode(arg1: *mut inode);
}
extern "C" {
    pub fn get_next_ino() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn evict_inodes(sb: *mut super_block);
}
extern "C" {
    pub fn dump_mapping(arg1: *const address_space);
}
extern "C" {
    pub fn __iget(inode: *mut inode);
}
extern "C" {
    pub fn iget_failed(arg1: *mut inode);
}
extern "C" {
    pub fn clear_inode(arg1: *mut inode);
}
extern "C" {
    pub fn __destroy_inode(arg1: *mut inode);
}
extern "C" {
    pub fn new_inode_pseudo(sb: *mut super_block) -> *mut inode;
}
extern "C" {
    pub fn new_inode(sb: *mut super_block) -> *mut inode;
}
extern "C" {
    pub fn free_inode_nonrcu(inode: *mut inode);
}
extern "C" {
    pub fn should_remove_suid(arg1: *mut dentry) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn file_remove_privs(arg1: *mut file) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __insert_inode_hash(arg1: *mut inode, hashval: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __remove_inode_hash(arg1: *mut inode);
}
extern "C" {
    pub fn inode_sb_list_add(inode: *mut inode);
}
extern "C" {
    pub fn inode_add_lru(inode: *mut inode);
}
extern "C" {
    pub fn sb_set_blocksize(
        arg1: *mut super_block,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sb_min_blocksize(
        arg1: *mut super_block,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_file_mmap(arg1: *mut file, arg2: *mut vm_area_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_file_readonly_mmap(
        arg1: *mut file,
        arg2: *mut vm_area_struct,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_write_checks(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t;
}
extern "C" {
    pub fn generic_write_checks_count(
        iocb: *mut kiocb,
        count: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_write_check_limits(
        file: *mut file,
        pos: loff_t,
        count: *mut loff_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_file_rw_checks(file_in: *mut file, file_out: *mut file)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filemap_read(iocb: *mut kiocb, to: *mut iov_iter, already_read: ssize_t) -> ssize_t;
}
extern "C" {
    pub fn generic_file_read_iter(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t;
}
extern "C" {
    pub fn __generic_file_write_iter(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t;
}
extern "C" {
    pub fn generic_file_write_iter(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t;
}
extern "C" {
    pub fn generic_file_direct_write(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t;
}
extern "C" {
    pub fn generic_perform_write(arg1: *mut kiocb, arg2: *mut iov_iter) -> ssize_t;
}
extern "C" {
    pub fn vfs_iter_read(
        file: *mut file,
        iter: *mut iov_iter,
        ppos: *mut loff_t,
        flags: rwf_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn vfs_iter_write(
        file: *mut file,
        iter: *mut iov_iter,
        ppos: *mut loff_t,
        flags: rwf_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn vfs_iocb_iter_read(file: *mut file, iocb: *mut kiocb, iter: *mut iov_iter) -> ssize_t;
}
extern "C" {
    pub fn vfs_iocb_iter_write(file: *mut file, iocb: *mut kiocb, iter: *mut iov_iter) -> ssize_t;
}
extern "C" {
    pub fn generic_file_splice_read(
        arg1: *mut file,
        arg2: *mut loff_t,
        arg3: *mut pipe_inode_info,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ssize_t;
}
extern "C" {
    pub fn iter_file_splice_write(
        arg1: *mut pipe_inode_info,
        arg2: *mut file,
        arg3: *mut loff_t,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ssize_t;
}
extern "C" {
    pub fn generic_splice_sendpage(
        pipe: *mut pipe_inode_info,
        out: *mut file,
        arg1: *mut loff_t,
        len: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> ssize_t;
}
extern "C" {
    pub fn do_splice_direct(
        in_: *mut file,
        ppos: *mut loff_t,
        out: *mut file,
        opos: *mut loff_t,
        len: size_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn file_ra_state_init(ra: *mut file_ra_state, mapping: *mut address_space);
}
extern "C" {
    pub fn noop_llseek(file: *mut file, offset: loff_t, whence: ::std::os::raw::c_int) -> loff_t;
}
extern "C" {
    pub fn vfs_setpos(file: *mut file, offset: loff_t, maxsize: loff_t) -> loff_t;
}
extern "C" {
    pub fn generic_file_llseek(
        file: *mut file,
        offset: loff_t,
        whence: ::std::os::raw::c_int,
    ) -> loff_t;
}
extern "C" {
    pub fn generic_file_llseek_size(
        file: *mut file,
        offset: loff_t,
        whence: ::std::os::raw::c_int,
        maxsize: loff_t,
        eof: loff_t,
    ) -> loff_t;
}
extern "C" {
    pub fn fixed_size_llseek(
        file: *mut file,
        offset: loff_t,
        whence: ::std::os::raw::c_int,
        size: loff_t,
    ) -> loff_t;
}
extern "C" {
    pub fn no_seek_end_llseek_size(
        arg1: *mut file,
        arg2: loff_t,
        arg3: ::std::os::raw::c_int,
        arg4: loff_t,
    ) -> loff_t;
}
extern "C" {
    pub fn no_seek_end_llseek(arg1: *mut file, arg2: loff_t, arg3: ::std::os::raw::c_int)
        -> loff_t;
}
extern "C" {
    pub fn rw_verify_area(
        arg1: ::std::os::raw::c_int,
        arg2: *mut file,
        arg3: *const loff_t,
        arg4: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_file_open(inode: *mut inode, filp: *mut file) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nonseekable_open(inode: *mut inode, filp: *mut file) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stream_open(inode: *mut inode, filp: *mut file) -> ::std::os::raw::c_int;
}
pub type dio_submit_t = ::std::option::Option<
    unsafe extern "C" fn(bio: *mut bio, inode: *mut inode, file_offset: loff_t),
>;
pub const DIO_LOCKING: ::std::os::raw::c_uint = 1;
pub const DIO_SKIP_HOLES: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_85 = ::std::os::raw::c_uint;
extern "C" {
    pub fn __blockdev_direct_IO(
        iocb: *mut kiocb,
        inode: *mut inode,
        bdev: *mut block_device,
        iter: *mut iov_iter,
        get_block: get_block_t,
        end_io: dio_iodone_t,
        submit_io: dio_submit_t,
        flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn inode_dio_wait(inode: *mut inode);
}
extern "C" {
    pub fn dio_warn_stale_pagecache(filp: *mut file);
}
extern "C" {
    pub fn inode_set_flags(
        inode: *mut inode,
        flags: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub static generic_ro_fops: file_operations;
}
extern "C" {
    pub fn readlink_copy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn page_readlink(
        arg1: *mut dentry,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn page_get_link(
        arg1: *mut dentry,
        arg2: *mut inode,
        arg3: *mut delayed_call,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn page_put_link(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn page_symlink(
        inode: *mut inode,
        symname: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static page_symlink_inode_operations: inode_operations;
}
extern "C" {
    pub fn kfree_link(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn generic_fillattr(arg1: *mut user_namespace, arg2: *mut inode, arg3: *mut kstat);
}
extern "C" {
    pub fn generic_fill_statx_attr(inode: *mut inode, stat: *mut kstat);
}
extern "C" {
    pub fn vfs_getattr_nosec(
        arg1: *const path,
        arg2: *mut kstat,
        arg3: u32_,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_getattr(
        arg1: *const path,
        arg2: *mut kstat,
        arg3: u32_,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __inode_add_bytes(inode: *mut inode, bytes: loff_t);
}
extern "C" {
    pub fn inode_add_bytes(inode: *mut inode, bytes: loff_t);
}
extern "C" {
    pub fn __inode_sub_bytes(inode: *mut inode, bytes: loff_t);
}
extern "C" {
    pub fn inode_sub_bytes(inode: *mut inode, bytes: loff_t);
}
extern "C" {
    pub fn inode_get_bytes(inode: *mut inode) -> loff_t;
}
extern "C" {
    pub fn inode_set_bytes(inode: *mut inode, bytes: loff_t);
}
extern "C" {
    pub fn simple_get_link(
        arg1: *mut dentry,
        arg2: *mut inode,
        arg3: *mut delayed_call,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub static simple_symlink_inode_operations: inode_operations;
}
extern "C" {
    pub fn iterate_dir(arg1: *mut file, arg2: *mut dir_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_fstatat(
        dfd: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        stat: *mut kstat,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_fstat(fd: ::std::os::raw::c_int, stat: *mut kstat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfs_get_link(
        arg1: *mut dentry,
        arg2: *mut delayed_call,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vfs_readlink(
        arg1: *mut dentry,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_filesystem(fs: *mut file_system_type) -> *mut file_system_type;
}
extern "C" {
    pub fn put_filesystem(fs: *mut file_system_type);
}
extern "C" {
    pub fn get_fs_type(name: *const ::std::os::raw::c_char) -> *mut file_system_type;
}
extern "C" {
    pub fn get_super(arg1: *mut block_device) -> *mut super_block;
}
extern "C" {
    pub fn get_active_super(bdev: *mut block_device) -> *mut super_block;
}
extern "C" {
    pub fn drop_super(sb: *mut super_block);
}
extern "C" {
    pub fn drop_super_exclusive(sb: *mut super_block);
}
extern "C" {
    pub fn iterate_supers(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut ::std::os::raw::c_void),
        >,
        arg2: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn iterate_supers_type(
        arg1: *mut file_system_type,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut ::std::os::raw::c_void),
        >,
        arg3: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn dcache_dir_open(arg1: *mut inode, arg2: *mut file) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dcache_dir_close(arg1: *mut inode, arg2: *mut file) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dcache_dir_lseek(arg1: *mut file, arg2: loff_t, arg3: ::std::os::raw::c_int) -> loff_t;
}
extern "C" {
    pub fn dcache_readdir(arg1: *mut file, arg2: *mut dir_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_setattr(
        arg1: *mut user_namespace,
        arg2: *mut dentry,
        arg3: *mut iattr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_getattr(
        arg1: *mut user_namespace,
        arg2: *const path,
        arg3: *mut kstat,
        arg4: u32_,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_statfs(arg1: *mut dentry, arg2: *mut kstatfs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_open(inode: *mut inode, file: *mut file) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_link(
        arg1: *mut dentry,
        arg2: *mut inode,
        arg3: *mut dentry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_unlink(arg1: *mut inode, arg2: *mut dentry) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_rmdir(arg1: *mut inode, arg2: *mut dentry) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_rename_exchange(
        old_dir: *mut inode,
        old_dentry: *mut dentry,
        new_dir: *mut inode,
        new_dentry: *mut dentry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_rename(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: *mut inode,
        arg5: *mut dentry,
        arg6: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_recursive_removal(
        arg1: *mut dentry,
        callback: ::std::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    );
}
extern "C" {
    pub fn noop_fsync(
        arg1: *mut file,
        arg2: loff_t,
        arg3: loff_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn noop_direct_IO(iocb: *mut kiocb, iter: *mut iov_iter) -> ssize_t;
}
extern "C" {
    pub fn simple_empty(arg1: *mut dentry) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_write_begin(
        file: *mut file,
        mapping: *mut address_space,
        pos: loff_t,
        len: ::std::os::raw::c_uint,
        pagep: *mut *mut page,
        fsdata: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static ram_aops: address_space_operations;
}
extern "C" {
    pub fn always_delete_dentry(arg1: *const dentry) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alloc_anon_inode(arg1: *mut super_block) -> *mut inode;
}
extern "C" {
    pub fn simple_nosetlease(
        arg1: *mut file,
        arg2: ::std::os::raw::c_long,
        arg3: *mut *mut file_lock,
        arg4: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static simple_dentry_operations: dentry_operations;
}
extern "C" {
    pub fn simple_lookup(
        arg1: *mut inode,
        arg2: *mut dentry,
        flags: ::std::os::raw::c_uint,
    ) -> *mut dentry;
}
extern "C" {
    pub fn generic_read_dir(
        arg1: *mut file,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *mut loff_t,
    ) -> ssize_t;
}
extern "C" {
    pub static simple_dir_operations: file_operations;
}
extern "C" {
    pub static simple_dir_inode_operations: inode_operations;
}
extern "C" {
    pub fn make_empty_dir_inode(inode: *mut inode);
}
extern "C" {
    pub fn is_empty_dir_inode(inode: *mut inode) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tree_descr {
    pub name: *const ::std::os::raw::c_char,
    pub ops: *const file_operations,
    pub mode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tree_descr() {
    assert_eq!(
        ::std::mem::size_of::<tree_descr>(),
        24usize,
        concat!("Size of: ", stringify!(tree_descr))
    );
    assert_eq!(
        ::std::mem::align_of::<tree_descr>(),
        8usize,
        concat!("Alignment of ", stringify!(tree_descr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tree_descr>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tree_descr),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tree_descr>())).ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tree_descr),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tree_descr>())).mode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tree_descr),
            "::",
            stringify!(mode)
        )
    );
}
extern "C" {
    pub fn d_alloc_name(arg1: *mut dentry, arg2: *const ::std::os::raw::c_char) -> *mut dentry;
}
extern "C" {
    pub fn simple_fill_super(
        arg1: *mut super_block,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const tree_descr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_pin_fs(
        arg1: *mut file_system_type,
        mount: *mut *mut vfsmount,
        count: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_release_fs(mount: *mut *mut vfsmount, count: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn simple_read_from_buffer(
        to: *mut ::std::os::raw::c_void,
        count: size_t,
        ppos: *mut loff_t,
        from: *const ::std::os::raw::c_void,
        available: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn simple_write_to_buffer(
        to: *mut ::std::os::raw::c_void,
        available: size_t,
        ppos: *mut loff_t,
        from: *const ::std::os::raw::c_void,
        count: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn __generic_file_fsync(
        arg1: *mut file,
        arg2: loff_t,
        arg3: loff_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_file_fsync(
        arg1: *mut file,
        arg2: loff_t,
        arg3: loff_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_check_addressable(
        arg1: ::std::os::raw::c_uint,
        arg2: u64_,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_set_encrypted_ci_d_ops(dentry: *mut dentry);
}
extern "C" {
    pub fn may_setattr(
        mnt_userns: *mut user_namespace,
        inode: *mut inode,
        ia_valid: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattr_prepare(
        arg1: *mut user_namespace,
        arg2: *mut dentry,
        arg3: *mut iattr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inode_newsize_ok(arg1: *const inode, offset: loff_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattr_copy(arg1: *mut user_namespace, inode: *mut inode, attr: *const iattr);
}
extern "C" {
    pub fn file_update_time(file: *mut file) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug)]
pub struct simple_transaction_argresp {
    pub size: ssize_t,
    pub data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_simple_transaction_argresp() {
    assert_eq!(
        ::std::mem::size_of::<simple_transaction_argresp>(),
        8usize,
        concat!("Size of: ", stringify!(simple_transaction_argresp))
    );
    assert_eq!(
        ::std::mem::align_of::<simple_transaction_argresp>(),
        8usize,
        concat!("Alignment of ", stringify!(simple_transaction_argresp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<simple_transaction_argresp>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(simple_transaction_argresp),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<simple_transaction_argresp>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(simple_transaction_argresp),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn simple_transaction_get(
        file: *mut file,
        buf: *const ::std::os::raw::c_char,
        size: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn simple_transaction_read(
        file: *mut file,
        buf: *mut ::std::os::raw::c_char,
        size: size_t,
        pos: *mut loff_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn simple_transaction_release(inode: *mut inode, file: *mut file) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_transaction_set(file: *mut file, n: size_t);
}
extern "C" {
    pub fn simple_attr_open(
        inode: *mut inode,
        file: *mut file,
        get: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut u64_,
            ) -> ::std::os::raw::c_int,
        >,
        set: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: u64_,
            ) -> ::std::os::raw::c_int,
        >,
        fmt: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_attr_release(inode: *mut inode, file: *mut file) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn simple_attr_read(
        file: *mut file,
        buf: *mut ::std::os::raw::c_char,
        len: size_t,
        ppos: *mut loff_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn simple_attr_write(
        file: *mut file,
        buf: *const ::std::os::raw::c_char,
        len: size_t,
        ppos: *mut loff_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn list_bdev_fs_names(
        buf: *mut ::std::os::raw::c_char,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn path_noexec(path: *const path) -> bool_;
}
extern "C" {
    pub fn inode_nohighmem(inode: *mut inode);
}
extern "C" {
    pub fn vfs_fadvise(
        file: *mut file,
        offset: loff_t,
        len: loff_t,
        advice: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn generic_fadvise(
        file: *mut file,
        offset: loff_t,
        len: loff_t,
        advice: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_struct {
    pub next: *mut vm_struct,
    pub addr: *mut ::std::os::raw::c_void,
    pub size: ::std::os::raw::c_ulong,
    pub flags: ::std::os::raw::c_ulong,
    pub pages: *mut *mut page,
    pub page_order: ::std::os::raw::c_uint,
    pub nr_pages: ::std::os::raw::c_uint,
    pub phys_addr: phys_addr_t,
    pub caller: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vm_struct() {
    assert_eq!(
        ::std::mem::size_of::<vm_struct>(),
        64usize,
        concat!("Size of: ", stringify!(vm_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<vm_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).pages as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).page_order as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(page_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).nr_pages as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(nr_pages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).phys_addr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vm_struct>())).caller as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vm_struct),
            "::",
            stringify!(caller)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vmap_area {
    pub va_start: ::std::os::raw::c_ulong,
    pub va_end: ::std::os::raw::c_ulong,
    pub rb_node: rb_node,
    pub list: list_head,
    pub __bindgen_anon_1: vmap_area__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vmap_area__bindgen_ty_1 {
    pub subtree_max_size: ::std::os::raw::c_ulong,
    pub vm: *mut vm_struct,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_vmap_area__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vmap_area__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(vmap_area__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vmap_area__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vmap_area__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vmap_area__bindgen_ty_1>())).subtree_max_size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area__bindgen_ty_1),
            "::",
            stringify!(subtree_max_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area__bindgen_ty_1>())).vm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area__bindgen_ty_1),
            "::",
            stringify!(vm)
        )
    );
}
#[test]
fn bindgen_test_layout_vmap_area() {
    assert_eq!(
        ::std::mem::size_of::<vmap_area>(),
        64usize,
        concat!("Size of: ", stringify!(vmap_area))
    );
    assert_eq!(
        ::std::mem::align_of::<vmap_area>(),
        8usize,
        concat!("Alignment of ", stringify!(vmap_area))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).va_start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(va_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).va_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(va_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).rb_node as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(rb_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vmap_area>())).list as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vmap_area),
            "::",
            stringify!(list)
        )
    );
}
extern "C" {
    pub fn vm_unmap_ram(mem: *const ::std::os::raw::c_void, count: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn vm_map_ram(
        pages: *mut *mut page,
        count: ::std::os::raw::c_uint,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vm_unmap_aliases();
}
extern "C" {
    pub fn vmalloc_init();
}
extern "C" {
    pub fn vmalloc_nr_pages() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn vmalloc(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vzalloc(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_user(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_node(
        size: ::std::os::raw::c_ulong,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vzalloc_node(
        size: ::std::os::raw::c_ulong,
        node: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_32(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_32_user(size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __vmalloc(size: ::std::os::raw::c_ulong, gfp_mask: gfp_t)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __vmalloc_node_range(
        size: ::std::os::raw::c_ulong,
        align: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
        gfp_mask: gfp_t,
        prot: pgprot_t,
        vm_flags: ::std::os::raw::c_ulong,
        node: ::std::os::raw::c_int,
        caller: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __vmalloc_node(
        size: ::std::os::raw::c_ulong,
        align: ::std::os::raw::c_ulong,
        gfp_mask: gfp_t,
        node: ::std::os::raw::c_int,
        caller: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_huge(
        size: ::std::os::raw::c_ulong,
        gfp_mask: gfp_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __vmalloc_array(n: size_t, size: size_t, flags: gfp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmalloc_array(n: size_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __vcalloc(n: size_t, size: size_t, flags: gfp_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vcalloc(n: size_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vfree(addr: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn vfree_atomic(addr: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn vmap(
        pages: *mut *mut page,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_ulong,
        prot: pgprot_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vmap_pfn(
        pfns: *mut ::std::os::raw::c_ulong,
        count: ::std::os::raw::c_uint,
        prot: pgprot_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn vunmap(addr: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn remap_vmalloc_range_partial(
        vma: *mut vm_area_struct,
        uaddr: ::std::os::raw::c_ulong,
        kaddr: *mut ::std::os::raw::c_void,
        pgoff: ::std::os::raw::c_ulong,
        size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remap_vmalloc_range(
        vma: *mut vm_area_struct,
        addr: *mut ::std::os::raw::c_void,
        pgoff: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arch_sync_kernel_mappings(start: ::std::os::raw::c_ulong, end: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn get_vm_area(
        size: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> *mut vm_struct;
}
extern "C" {
    pub fn get_vm_area_caller(
        size: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
        caller: *const ::std::os::raw::c_void,
    ) -> *mut vm_struct;
}
extern "C" {
    pub fn __get_vm_area_caller(
        size: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
        start: ::std::os::raw::c_ulong,
        end: ::std::os::raw::c_ulong,
        caller: *const ::std::os::raw::c_void,
    ) -> *mut vm_struct;
}
extern "C" {
    pub fn free_vm_area(area: *mut vm_struct);
}
extern "C" {
    pub fn remove_vm_area(addr: *const ::std::os::raw::c_void) -> *mut vm_struct;
}
extern "C" {
    pub fn find_vm_area(addr: *const ::std::os::raw::c_void) -> *mut vm_struct;
}
extern "C" {
    pub fn find_vmap_area(addr: ::std::os::raw::c_ulong) -> *mut vmap_area;
}
extern "C" {
    pub fn vunmap_range(addr: ::std::os::raw::c_ulong, end: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn vread(
        buf: *mut ::std::os::raw::c_char,
        addr: *mut ::std::os::raw::c_char,
        count: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub static mut vmap_area_list: list_head;
}
extern "C" {
    pub fn vm_area_add_early(vm: *mut vm_struct);
}
extern "C" {
    pub fn vm_area_register_early(vm: *mut vm_struct, align: size_t);
}
extern "C" {
    pub fn pcpu_get_vm_areas(
        offsets: *const ::std::os::raw::c_ulong,
        sizes: *const size_t,
        nr_vms: ::std::os::raw::c_int,
        align: size_t,
    ) -> *mut *mut vm_struct;
}
extern "C" {
    pub fn pcpu_free_vm_areas(vms: *mut *mut vm_struct, nr_vms: ::std::os::raw::c_int);
}
extern "C" {
    pub fn register_vmap_purge_notifier(nb: *mut notifier_block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unregister_vmap_purge_notifier(nb: *mut notifier_block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vmalloc_dump_obj(object: *mut ::std::os::raw::c_void) -> bool_;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct __una_u16 {
    pub x: u16_,
}
#[test]
fn bindgen_test_layout___una_u16() {
    assert_eq!(
        ::std::mem::size_of::<__una_u16>(),
        2usize,
        concat!("Size of: ", stringify!(__una_u16))
    );
    assert_eq!(
        ::std::mem::align_of::<__una_u16>(),
        1usize,
        concat!("Alignment of ", stringify!(__una_u16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__una_u16>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__una_u16),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct __una_u32 {
    pub x: u32_,
}
#[test]
fn bindgen_test_layout___una_u32() {
    assert_eq!(
        ::std::mem::size_of::<__una_u32>(),
        4usize,
        concat!("Size of: ", stringify!(__una_u32))
    );
    assert_eq!(
        ::std::mem::align_of::<__una_u32>(),
        1usize,
        concat!("Alignment of ", stringify!(__una_u32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__una_u32>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__una_u32),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct __una_u64 {
    pub x: u64_,
}
#[test]
fn bindgen_test_layout___una_u64() {
    assert_eq!(
        ::std::mem::size_of::<__una_u64>(),
        8usize,
        concat!("Size of: ", stringify!(__una_u64))
    );
    assert_eq!(
        ::std::mem::align_of::<__una_u64>(),
        1usize,
        concat!("Alignment of ", stringify!(__una_u64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__una_u64>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__una_u64),
            "::",
            stringify!(x)
        )
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct static_key_mod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct static_call_mod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct maple_pnode {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct maple_enode {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clocksource {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uprobe {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldt_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vdso_image {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct page_pool {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct anon_vma {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_operations_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linux_binfmt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmu_notifier_subscriptions {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memory_tier {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msgbuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sem {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sem_queue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sem_undo {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_clock {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mutex_waiter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct compat_robust_list_head {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request_queue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cgroup {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct assoc_array_ptr {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct key_user {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct taskstats {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty_audit_buf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait_page_queue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdev {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xattr_handler {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct block_device {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtd_info {
    pub _address: u8,
}
